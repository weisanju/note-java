<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">我的笔记库</a></li><li class="chapter-item expanded affix "><li class="part-title">java基础</li><li class="chapter-item expanded "><a href="1.java基础_代理/index.html"><strong aria-hidden="true">1.</strong> 代理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.java基础_代理/CGLIB.html"><strong aria-hidden="true">1.1.</strong> CGLIB</a></li><li class="chapter-item expanded "><a href="1.java基础_代理/cglib的几种Callback.html"><strong aria-hidden="true">1.2.</strong> cglib的几种Callback</a></li><li class="chapter-item expanded "><a href="1.java基础_代理/jdk动态代理.html"><strong aria-hidden="true">1.3.</strong> jdk动态代理</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 对象拷贝</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.java基础_对象拷贝/mapstruct.html"><strong aria-hidden="true">2.1.</strong> mapstruct</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 函数式编程</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.java基础_函数式编程/anyMatchAllMatch.html"><strong aria-hidden="true">3.1.</strong> anyMatchAllMatch</a></li><li class="chapter-item expanded "><a href="3.java基础_函数式编程/java函数式编程.html"><strong aria-hidden="true">3.2.</strong> java函数式编程</a></li><li class="chapter-item expanded "><a href="3.java基础_函数式编程/lamba表达式原理.html"><strong aria-hidden="true">3.3.</strong> lamba表达式原理</a></li><li class="chapter-item expanded "><a href="3.java基础_函数式编程/方法引用.html"><strong aria-hidden="true">3.4.</strong> 方法引用</a></li><li class="chapter-item expanded "><a href="3.java基础_函数式编程/流操作.html"><strong aria-hidden="true">3.5.</strong> 流操作</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Bean校验</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.java基础_Bean校验/javaValidated.html"><strong aria-hidden="true">4.1.</strong> javaValidated</a></li></ol></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/index.html"><strong aria-hidden="true">5.</strong> 多线程与锁</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/JUC线程同步工具.html"><strong aria-hidden="true">5.1.</strong> JUC线程同步工具</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/LockSupport.html"><strong aria-hidden="true">5.2.</strong> LockSupport</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/java内存模型.html"><strong aria-hidden="true">5.3.</strong> java内存模型</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/java线程状态.html"><strong aria-hidden="true">5.4.</strong> java线程状态</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/java锁.html"><strong aria-hidden="true">5.5.</strong> java锁</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/jvm线程模型.html"><strong aria-hidden="true">5.6.</strong> jvm线程模型</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/关于多线程与并发编码的心得.html"><strong aria-hidden="true">5.7.</strong> 关于多线程与并发编码的心得</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/线程操作.html"><strong aria-hidden="true">5.8.</strong> 线程操作</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/线程池.html"><strong aria-hidden="true">5.9.</strong> 线程池</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.10.</strong> 基于AQS的同步工具</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/基于AQS的同步工具/AQS.html"><strong aria-hidden="true">5.10.1.</strong> AQS</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/基于AQS的同步工具/Condition条件等待.html"><strong aria-hidden="true">5.10.2.</strong> Condition条件等待</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/基于AQS的同步工具/CountDownLatch.html"><strong aria-hidden="true">5.10.3.</strong> CountDownLatch</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/基于AQS的同步工具/CyclicBarrier.html"><strong aria-hidden="true">5.10.4.</strong> CyclicBarrier</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/基于AQS的同步工具/Lock锁接口.html"><strong aria-hidden="true">5.10.5.</strong> Lock锁接口</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/基于AQS的同步工具/ReentrantLock.html"><strong aria-hidden="true">5.10.6.</strong> ReentrantLock</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/基于AQS的同步工具/ReentrantReadWriteLock.html"><strong aria-hidden="true">5.10.7.</strong> ReentrantReadWriteLock</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/基于AQS的同步工具/Semaphore.html"><strong aria-hidden="true">5.10.8.</strong> Semaphore</a></li><li class="chapter-item expanded "><a href="5.java基础_多线程与锁/基于AQS的同步工具/StampedLock.html"><strong aria-hidden="true">5.10.9.</strong> StampedLock</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="6.java基础_集合框架/index.html"><strong aria-hidden="true">6.</strong> 集合框架</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6.java基础_集合框架/ArrayBlockingQueue.html"><strong aria-hidden="true">6.1.</strong> ArrayBlockingQueue</a></li><li class="chapter-item expanded "><a href="6.java基础_集合框架/ArrayList.html"><strong aria-hidden="true">6.2.</strong> ArrayList</a></li><li class="chapter-item expanded "><a href="6.java基础_集合框架/Collections工具类.html"><strong aria-hidden="true">6.3.</strong> Collections工具类</a></li><li class="chapter-item expanded "><a href="6.java基础_集合框架/ConcurrentHashMap.html"><strong aria-hidden="true">6.4.</strong> ConcurrentHashMap</a></li><li class="chapter-item expanded "><a href="6.java基础_集合框架/LinkedList与双向队列.html"><strong aria-hidden="true">6.5.</strong> LinkedList与双向队列</a></li><li class="chapter-item expanded "><a href="6.java基础_集合框架/List.html"><strong aria-hidden="true">6.6.</strong> List</a></li><li class="chapter-item expanded "><a href="6.java基础_集合框架/Map接口.html"><strong aria-hidden="true">6.7.</strong> Map接口</a></li><li class="chapter-item expanded "><a href="6.java基础_集合框架/Queue与Deque.html"><strong aria-hidden="true">6.8.</strong> Queue与Deque</a></li><li class="chapter-item expanded "><a href="6.java基础_集合框架/Set与LinkedHashMap.html"><strong aria-hidden="true">6.9.</strong> Set与LinkedHashMap</a></li><li class="chapter-item expanded "><a href="6.java基础_集合框架/SynchronousQueue.html"><strong aria-hidden="true">6.10.</strong> SynchronousQueue</a></li><li class="chapter-item expanded "><a href="6.java基础_集合框架/arraylist和linkedlist.html"><strong aria-hidden="true">6.11.</strong> arraylist和linkedlist</a></li><li class="chapter-item expanded "><a href="6.java基础_集合框架/hashMap.html"><strong aria-hidden="true">6.12.</strong> hashMap</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">jvm</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> jvm基础</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="7.jvm_jvm基础/GC后对象地址变化了HashCode如何保持不变.html"><strong aria-hidden="true">7.1.</strong> GC后对象地址变化了HashCode如何保持不变</a></li><li class="chapter-item expanded "><a href="7.jvm_jvm基础/JMM与volatile关键字.html"><strong aria-hidden="true">7.2.</strong> JMM与volatile关键字</a></li><li class="chapter-item expanded "><a href="7.jvm_jvm基础/JVMGC.html"><strong aria-hidden="true">7.3.</strong> JVMGC</a></li><li class="chapter-item expanded "><a href="7.jvm_jvm基础/JVM内存模型.html"><strong aria-hidden="true">7.4.</strong> JVM内存模型</a></li><li class="chapter-item expanded "><a href="7.jvm_jvm基础/JVM参数.html"><strong aria-hidden="true">7.5.</strong> JVM参数</a></li><li class="chapter-item expanded "><a href="7.jvm_jvm基础/JVM复制算法.html"><strong aria-hidden="true">7.6.</strong> JVM复制算法</a></li><li class="chapter-item expanded "><a href="7.jvm_jvm基础/javaUnsafe工具类与CAS.html"><strong aria-hidden="true">7.7.</strong> javaUnsafe工具类与CAS</a></li><li class="chapter-item expanded "><a href="7.jvm_jvm基础/java内存泄露与OOM.html"><strong aria-hidden="true">7.8.</strong> java内存泄露与OOM</a></li><li class="chapter-item expanded "><a href="7.jvm_jvm基础/java对象分析.html"><strong aria-hidden="true">7.9.</strong> java对象分析</a></li><li class="chapter-item expanded "><a href="7.jvm_jvm基础/java引用类型.html"><strong aria-hidden="true">7.10.</strong> java引用类型</a></li><li class="chapter-item expanded "><a href="7.jvm_jvm基础/类加载/index.html"><strong aria-hidden="true">7.11.</strong> 类加载</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="7.jvm_jvm基础/类加载/类加载器.html"><strong aria-hidden="true">7.11.1.</strong> 类加载器</a></li><li class="chapter-item expanded "><a href="7.jvm_jvm基础/类加载/类加载过程.html"><strong aria-hidden="true">7.11.2.</strong> 类加载过程</a></li><li class="chapter-item expanded "><a href="7.jvm_jvm基础/类加载/线程上下文加载器.html"><strong aria-hidden="true">7.11.3.</strong> 线程上下文加载器</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> jvm问题诊断与性能分析</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="8.jvm_jvm问题诊断与性能分析/MAT.html"><strong aria-hidden="true">8.1.</strong> MAT</a></li><li class="chapter-item expanded "><a href="8.jvm_jvm问题诊断与性能分析/arthas.html"><strong aria-hidden="true">8.2.</strong> arthas</a></li><li class="chapter-item expanded "><a href="8.jvm_jvm问题诊断与性能分析/javaCPU占用高的问题.html"><strong aria-hidden="true">8.3.</strong> javaCPU占用高的问题</a></li><li class="chapter-item expanded "><a href="8.jvm_jvm问题诊断与性能分析/java远程调试.html"><strong aria-hidden="true">8.4.</strong> java远程调试</a></li><li class="chapter-item expanded "><a href="8.jvm_jvm问题诊断与性能分析/优雅停服.html"><strong aria-hidden="true">8.5.</strong> 优雅停服</a></li><li class="chapter-item expanded "><a href="8.jvm_jvm问题诊断与性能分析/排查内存溢出.html"><strong aria-hidden="true">8.6.</strong> 排查内存溢出</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Arthas</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="9.jvm_Arthas/1.安装.html"><strong aria-hidden="true">9.1.</strong> 安装</a></li><li class="chapter-item expanded "><a href="9.jvm_Arthas/2.快速入门.html"><strong aria-hidden="true">9.2.</strong> 快速入门</a></li><li class="chapter-item expanded "><a href="9.jvm_Arthas/3.命令.html"><strong aria-hidden="true">9.3.</strong> 命令</a></li><li class="chapter-item expanded "><a href="9.jvm_Arthas/4.ArthasTunnel.html"><strong aria-hidden="true">9.4.</strong> ArthasTunnel</a></li><li class="chapter-item expanded "><a href="9.jvm_Arthas/5.Idea插件.html"><strong aria-hidden="true">9.5.</strong> Idea插件</a></li><li class="chapter-item expanded "><a href="9.jvm_Arthas/6.JavaAgent启动.html"><strong aria-hidden="true">9.6.</strong> JavaAgent启动</a></li><li class="chapter-item expanded "><a href="9.jvm_Arthas/7.火焰图.html"><strong aria-hidden="true">9.7.</strong> 火焰图</a></li><li class="chapter-item expanded "><a href="9.jvm_Arthas/8.thread命令.html"><strong aria-hidden="true">9.8.</strong> thread命令</a></li><li class="chapter-item expanded "><a href="9.jvm_Arthas/9.trace.html"><strong aria-hidden="true">9.9.</strong> trace</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">spring</li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> SpringFramework</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="10.spring_SpringFramework/0.spring容器启动总览.html"><strong aria-hidden="true">10.1.</strong> spring容器启动总览</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/1.spring容器启动-bean实例化流程.html"><strong aria-hidden="true">10.2.</strong> spring容器启动-bean实例化流程</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/2.SpringBean实例化过程.html"><strong aria-hidden="true">10.3.</strong> SpringBean实例化过程</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/3.Spring依赖注入与初始化.html"><strong aria-hidden="true">10.4.</strong> Spring依赖注入与初始化</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/4.SpringBean的生命周期.html"><strong aria-hidden="true">10.5.</strong> SpringBean的生命周期</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/5.SpringSchedule.html"><strong aria-hidden="true">10.6.</strong> SpringSchedule</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/ClassPathScanningCandidateComponentProvider.html"><strong aria-hidden="true">10.7.</strong> ClassPathScanningCandidateComponentProvider</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/PropertySource.html"><strong aria-hidden="true">10.8.</strong> PropertySource</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/Spring总结.html"><strong aria-hidden="true">10.9.</strong> Spring总结</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/applicationContext与BeanFactory的区别.html"><strong aria-hidden="true">10.10.</strong> applicationContext与BeanFactory的区别</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring杂项.html"><strong aria-hidden="true">10.11.</strong> spring杂项</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring组合注解.html"><strong aria-hidden="true">10.12.</strong> spring组合注解</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring解决循环依赖问题.html"><strong aria-hidden="true">10.13.</strong> spring解决循环依赖问题</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/postprocessor/index.html"><strong aria-hidden="true">10.14.</strong> postprocessor</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring-aop/index.html"><strong aria-hidden="true">10.15.</strong> spring-aop</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring-aop/SpringAop-cglib动态代理.html"><strong aria-hidden="true">10.15.1.</strong> SpringAop-cglib动态代理</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring-aop/SpringAop-jdk动态代理.html"><strong aria-hidden="true">10.15.2.</strong> SpringAop-jdk动态代理</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring-aop/SpringAop-涉及到的类.html"><strong aria-hidden="true">10.15.3.</strong> SpringAop-涉及到的类</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring-aop/SpringAop-编程式代理.html"><strong aria-hidden="true">10.15.4.</strong> SpringAop-编程式代理</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring-aop/SpringAop-自动代理.html"><strong aria-hidden="true">10.15.5.</strong> SpringAop-自动代理</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring-aop/SpringAop总结.html"><strong aria-hidden="true">10.15.6.</strong> SpringAop总结</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring-aop/aop包解析.html"><strong aria-hidden="true">10.15.7.</strong> aop包解析</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring-aop/taskList.html"><strong aria-hidden="true">10.15.8.</strong> taskList</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.15.9.</strong> AOP应用解析</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring-aop/AOP应用解析/Async异步.html"><strong aria-hidden="true">10.15.9.1.</strong> Async异步</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring-aop/AOP应用解析/依赖懒加载.html"><strong aria-hidden="true">10.15.9.2.</strong> 依赖懒加载</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring-aop/AOP应用解析/缓存.html"><strong aria-hidden="true">10.15.9.3.</strong> 缓存</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring-bean定义/index.html"><strong aria-hidden="true">10.16.</strong> spring-bean定义</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="10.spring_SpringFramework/spring-bean定义/Bean定义.html"><strong aria-hidden="true">10.16.1.</strong> Bean定义</a></li></ol></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/springBeanScope/index.html"><strong aria-hidden="true">10.17.</strong> springBeanScope</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="10.spring_SpringFramework/springBeanScope/spring自定义可刷新的上下文.html"><strong aria-hidden="true">10.17.1.</strong> spring自定义可刷新的上下文</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.18.</strong> springframework</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="10.spring_SpringFramework/springframework/MessageSource.html"><strong aria-hidden="true">10.18.1.</strong> MessageSource</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/springframework/spring-ioc.html"><strong aria-hidden="true">10.18.2.</strong> spring-ioc</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/springframework/springEL.html"><strong aria-hidden="true">10.18.3.</strong> springEL</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/springframework/spring代理.html"><strong aria-hidden="true">10.18.4.</strong> spring代理</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/springframework/基于Ant的路径匹配.html"><strong aria-hidden="true">10.18.5.</strong> 基于Ant的路径匹配</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/springframework/字段格式化.html"><strong aria-hidden="true">10.18.6.</strong> 字段格式化</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/springframework/属性源抽象.html"><strong aria-hidden="true">10.18.7.</strong> 属性源抽象</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/springframework/类型转换.html"><strong aria-hidden="true">10.18.8.</strong> 类型转换</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/springframework/资源抽象.html"><strong aria-hidden="true">10.18.9.</strong> 资源抽象</a></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/springframework/配置全局日期格式化.html"><strong aria-hidden="true">10.18.10.</strong> 配置全局日期格式化</a></li></ol></li><li class="chapter-item expanded "><a href="10.spring_SpringFramework/编程式注入类/index.html"><strong aria-hidden="true">10.19.</strong> 编程式注入类</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="10.spring_SpringFramework/编程式注入类/AOP代理相关.html"><strong aria-hidden="true">10.19.1.</strong> AOP代理相关</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="11.spring_SpringWebMvc/index.html"><strong aria-hidden="true">11.</strong> SpringWebMvc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="11.spring_SpringWebMvc/URI_Links.html"><strong aria-hidden="true">11.1.</strong> URI_Links</a></li><li class="chapter-item expanded "><a href="11.spring_SpringWebMvc/functional_endpoints.html"><strong aria-hidden="true">11.2.</strong> functional_endpoints</a></li><li class="chapter-item expanded "><a href="11.spring_SpringWebMvc/mvcannotation-driven注解的作用.html"><strong aria-hidden="true">11.3.</strong> mvcannotation-driven注解的作用</a></li><li class="chapter-item expanded "><a href="11.spring_SpringWebMvc/spring-mvc.html"><strong aria-hidden="true">11.4.</strong> spring-mvc</a></li><li class="chapter-item expanded "><a href="11.spring_SpringWebMvc/springMVC自定义参数解析注解.html"><strong aria-hidden="true">11.5.</strong> springMVC自定义参数解析注解</a></li><li class="chapter-item expanded "><a href="11.spring_SpringWebMvc/springMVC路径映射.html"><strong aria-hidden="true">11.6.</strong> springMVC路径映射</a></li><li class="chapter-item expanded "><a href="11.spring_SpringWebMvc/springMVC返回后.html"><strong aria-hidden="true">11.7.</strong> springMVC返回后</a></li><li class="chapter-item expanded "><a href="11.spring_SpringWebMvc/springMvcController配置.html"><strong aria-hidden="true">11.8.</strong> springMvcController配置</a></li><li class="chapter-item expanded "><a href="11.spring_SpringWebMvc/内置四种filters.html"><strong aria-hidden="true">11.9.</strong> 内置四种filters</a></li><li class="chapter-item expanded "><a href="11.spring_SpringWebMvc/基于注解的控制器.html"><strong aria-hidden="true">11.10.</strong> 基于注解的控制器</a></li></ol></li><li class="chapter-item expanded "><a href="12.spring_SpringBoot/index.html"><strong aria-hidden="true">12.</strong> SpringBoot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="12.spring_SpringBoot/springBoot资源处理.html"><strong aria-hidden="true">12.1.</strong> springBoot资源处理</a></li><li class="chapter-item expanded "><a href="12.spring_SpringBoot/springboot-HiKariCP连接池动态数据源配置.html"><strong aria-hidden="true">12.2.</strong> springboot-HiKariCP连接池动态数据源配置</a></li><li class="chapter-item expanded "><a href="12.spring_SpringBoot/springboot-devtools.html"><strong aria-hidden="true">12.3.</strong> springboot-devtools</a></li><li class="chapter-item expanded "><a href="12.spring_SpringBoot/springboot-元数据.html"><strong aria-hidden="true">12.4.</strong> springboot-元数据</a></li><li class="chapter-item expanded "><a href="12.spring_SpringBoot/springboot-多模块.html"><strong aria-hidden="true">12.5.</strong> springboot-多模块</a></li><li class="chapter-item expanded "><a href="12.spring_SpringBoot/springboot-日志.html"><strong aria-hidden="true">12.6.</strong> springboot-日志</a></li><li class="chapter-item expanded "><a href="12.spring_SpringBoot/springboot-自动配置原理.html"><strong aria-hidden="true">12.7.</strong> springboot-自动配置原理</a></li><li class="chapter-item expanded "><a href="12.spring_SpringBoot/springboot-过滤器.html"><strong aria-hidden="true">12.8.</strong> springboot-过滤器</a></li><li class="chapter-item expanded "><a href="12.spring_SpringBoot/springboot-配置文件与jar分离.html"><strong aria-hidden="true">12.9.</strong> springboot-配置文件与jar分离</a></li><li class="chapter-item expanded "><a href="12.spring_SpringBoot/快速入门.html"><strong aria-hidden="true">12.10.</strong> 快速入门</a></li><li class="chapter-item expanded "><a href="12.spring_SpringBoot/自定义springBootStarter.html"><strong aria-hidden="true">12.11.</strong> 自定义springBootStarter</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.12.</strong> springboot配置文件加载</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="12.spring_SpringBoot/springboot配置文件加载/propertySource原理.html"><strong aria-hidden="true">12.12.1.</strong> propertySource原理</a></li><li class="chapter-item expanded "><a href="12.spring_SpringBoot/springboot配置文件加载/默认加载原则.html"><strong aria-hidden="true">12.12.2.</strong> 默认加载原则</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.13.</strong> 官方文档</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="12.spring_SpringBoot/官方文档/SpringApplication.html"><strong aria-hidden="true">12.13.1.</strong> SpringApplication</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="13.spring_SpringSecurity/index.html"><strong aria-hidden="true">13.</strong> SpringSecurity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="13.spring_SpringSecurity/spring核心逻辑.html"><strong aria-hidden="true">13.1.</strong> spring核心逻辑</a></li></ol></li><li class="chapter-item expanded "><a href="14.spring_SpringWebFlux/index.html"><strong aria-hidden="true">14.</strong> SpringWebFlux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="14.spring_SpringWebFlux/CoreFeatures.html"><strong aria-hidden="true">14.1.</strong> CoreFeatures</a></li><li class="chapter-item expanded "><a href="14.spring_SpringWebFlux/DispatcherHandler.html"><strong aria-hidden="true">14.2.</strong> DispatcherHandler</a></li><li class="chapter-item expanded "><a href="14.spring_SpringWebFlux/FunctionEndpoint.html"><strong aria-hidden="true">14.3.</strong> FunctionEndpoint</a></li><li class="chapter-item expanded "><a href="14.spring_SpringWebFlux/URILinks.html"><strong aria-hidden="true">14.4.</strong> URILinks</a></li><li class="chapter-item expanded "><a href="14.spring_SpringWebFlux/WebFluxConfig.html"><strong aria-hidden="true">14.5.</strong> WebFluxConfig</a></li><li class="chapter-item expanded "><a href="14.spring_SpringWebFlux/taskList.html"><strong aria-hidden="true">14.6.</strong> taskList</a></li><li class="chapter-item expanded "><a href="14.spring_SpringWebFlux/基于注解的控制器/index.html"><strong aria-hidden="true">14.7.</strong> 基于注解的控制器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="14.spring_SpringWebFlux/基于注解的控制器/HandlerMethod.html"><strong aria-hidden="true">14.7.1.</strong> HandlerMethod</a></li><li class="chapter-item expanded "><a href="14.spring_SpringWebFlux/基于注解的控制器/RequestMapping.html"><strong aria-hidden="true">14.7.2.</strong> RequestMapping</a></li></ol></li><li class="chapter-item expanded "><a href="14.spring_SpringWebFlux/源码分析/index.html"><strong aria-hidden="true">14.8.</strong> 源码分析</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="14.spring_SpringWebFlux/源码分析/springBoot创建WebFlux分析.html"><strong aria-hidden="true">14.8.1.</strong> springBoot创建WebFlux分析</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="15.spring_SpringCloud/index.html"><strong aria-hidden="true">15.</strong> SpringCloud</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="15.spring_SpringCloud/Ribbon与Feign/index.html"><strong aria-hidden="true">15.1.</strong> Ribbon与Feign</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.2.</strong> 服务注册与发现</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="15.spring_SpringCloud/服务注册与发现/nacos/index.html"><strong aria-hidden="true">15.2.1.</strong> nacos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="15.spring_SpringCloud/服务注册与发现/nacos/nacos-with-spring.html"><strong aria-hidden="true">15.2.1.1.</strong> nacos-with-spring</a></li><li class="chapter-item expanded "><a href="15.spring_SpringCloud/服务注册与发现/nacos/nacos-with-spring-clound.html"><strong aria-hidden="true">15.2.1.2.</strong> nacos-with-spring-clound</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.3.</strong> 网关</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="15.spring_SpringCloud/网关/springCloudGateway/index.html"><strong aria-hidden="true">15.3.1.</strong> springCloudGateway</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="15.spring_SpringCloud/网关/springCloudGateway/springCloud中的构造者模式.html"><strong aria-hidden="true">15.3.1.1.</strong> springCloud中的构造者模式</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="16.spring_SpringCache/index.html"><strong aria-hidden="true">16.</strong> SpringCache</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="16.spring_SpringCache/1.基于申明式缓存.html"><strong aria-hidden="true">16.1.</strong> 基于申明式缓存</a></li><li class="chapter-item expanded "><a href="16.spring_SpringCache/2.JCacheAnnotations.html"><strong aria-hidden="true">16.2.</strong> JCacheAnnotations</a></li><li class="chapter-item expanded "><a href="16.spring_SpringCache/3.XML的申明式缓存.html"><strong aria-hidden="true">16.3.</strong> XML的申明式缓存</a></li><li class="chapter-item expanded "><a href="16.spring_SpringCache/4.配置缓存库.html"><strong aria-hidden="true">16.4.</strong> 配置缓存库</a></li></ol></li><li class="chapter-item expanded "><a href="17.spring_SpringDataRedis/index.html"><strong aria-hidden="true">17.</strong> SpringDataRedis</a></li><li class="chapter-item expanded affix "><li class="part-title"></li><li class="chapter-item expanded "><a href="18.响应式编程/index.html"><strong aria-hidden="true">18.</strong> 响应式编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="18.响应式编程/ProjectReactor/index.html"><strong aria-hidden="true">18.1.</strong> ProjectReactor</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="18.响应式编程/ProjectReactor/创建发布者.html"><strong aria-hidden="true">18.1.1.</strong> 创建发布者</a></li><li class="chapter-item expanded "><a href="18.响应式编程/ProjectReactor/创建订阅.html"><strong aria-hidden="true">18.1.2.</strong> 创建订阅</a></li><li class="chapter-item expanded "><a href="18.响应式编程/ProjectReactor/响应式流的动作.html"><strong aria-hidden="true">18.1.3.</strong> 响应式流的动作</a></li><li class="chapter-item expanded "><a href="18.响应式编程/ProjectReactor/选择合适的操作符.html"><strong aria-hidden="true">18.1.4.</strong> 选择合适的操作符</a></li><li class="chapter-item expanded "><a href="18.响应式编程/ProjectReactor/core-features/index.html"><strong aria-hidden="true">18.1.5.</strong> core-features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="18.响应式编程/ProjectReactor/core-features/FluxAndMono.html"><strong aria-hidden="true">18.1.5.1.</strong> FluxAndMono</a></li><li class="chapter-item expanded "><a href="18.响应式编程/ProjectReactor/core-features/ProcessorOrSinks.html"><strong aria-hidden="true">18.1.5.2.</strong> ProcessorOrSinks</a></li><li class="chapter-item expanded "><a href="18.响应式编程/ProjectReactor/core-features/线程和调度.html"><strong aria-hidden="true">18.1.5.3.</strong> 线程和调度</a></li><li class="chapter-item expanded "><a href="18.响应式编程/ProjectReactor/core-features/编程式创建序列.html"><strong aria-hidden="true">18.1.5.4.</strong> 编程式创建序列</a></li><li class="chapter-item expanded "><a href="18.响应式编程/ProjectReactor/core-features/错误处理.html"><strong aria-hidden="true">18.1.5.5.</strong> 错误处理</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="19.日志/index.html"><strong aria-hidden="true">19.</strong> 日志</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="19.日志/JUL.html"><strong aria-hidden="true">19.1.</strong> JUL</a></li><li class="chapter-item expanded "><a href="19.日志/SL4j.html"><strong aria-hidden="true">19.2.</strong> SL4j</a></li><li class="chapter-item expanded "><a href="19.日志/日志处理进化史.html"><strong aria-hidden="true">19.3.</strong> 日志处理进化史</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/index.html"><strong aria-hidden="true">19.4.</strong> log4j2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="19.日志/log4j2/Log4j2API.html"><strong aria-hidden="true">19.4.1.</strong> Log4j2API</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/log4j2-web.html"><strong aria-hidden="true">19.4.2.</strong> log4j2-web</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/lookups.html"><strong aria-hidden="true">19.4.3.</strong> lookups</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/依赖管理.html"><strong aria-hidden="true">19.4.4.</strong> 依赖管理</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/appenders/index.html"><strong aria-hidden="true">19.4.5.</strong> appenders</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="19.日志/log4j2/appenders/AsyncAppender.html"><strong aria-hidden="true">19.4.5.1.</strong> AsyncAppender</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/appenders/CassandraAppender.html"><strong aria-hidden="true">19.4.5.2.</strong> CassandraAppender</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/appenders/ConsoleAppender.html"><strong aria-hidden="true">19.4.5.3.</strong> ConsoleAppender</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/appenders/FailoverAppender.html"><strong aria-hidden="true">19.4.5.4.</strong> FailoverAppender</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/appenders/FileAppender.html"><strong aria-hidden="true">19.4.5.5.</strong> FileAppender</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/appenders/JDBCAppender.html"><strong aria-hidden="true">19.4.5.6.</strong> JDBCAppender</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/appenders/OutputStreamAppender.html"><strong aria-hidden="true">19.4.5.7.</strong> OutputStreamAppender</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/appenders/RandomAccessFileAppender.html"><strong aria-hidden="true">19.4.5.8.</strong> RandomAccessFileAppender</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/appenders/RewriteAppender.html"><strong aria-hidden="true">19.4.5.9.</strong> RewriteAppender</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/appenders/RollingFileAppender.html"><strong aria-hidden="true">19.4.5.10.</strong> RollingFileAppender</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/appenders/RollingRandomAccessFileAppender.html"><strong aria-hidden="true">19.4.5.11.</strong> RollingRandomAccessFileAppender</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/appenders/RoutingAppender.html"><strong aria-hidden="true">19.4.5.12.</strong> RoutingAppender</a></li></ol></li><li class="chapter-item expanded "><a href="19.日志/log4j2/layouts/index.html"><strong aria-hidden="true">19.4.6.</strong> layouts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="19.日志/log4j2/layouts/CSVLayouts.html"><strong aria-hidden="true">19.4.6.1.</strong> CSVLayouts</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/layouts/HTMLayouts.html"><strong aria-hidden="true">19.4.6.2.</strong> HTMLayouts</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/layouts/JSONLayout.html"><strong aria-hidden="true">19.4.6.3.</strong> JSONLayout</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/layouts/JSONTemplateLayouts.html"><strong aria-hidden="true">19.4.6.4.</strong> JSONTemplateLayouts</a></li><li class="chapter-item expanded "><a href="19.日志/log4j2/layouts/PatternLayout.html"><strong aria-hidden="true">19.4.6.5.</strong> PatternLayout</a></li></ol></li><li class="chapter-item expanded "><a href="19.日志/log4j2/log4j2配置/index.html"><strong aria-hidden="true">19.4.7.</strong> log4j2配置</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="19.日志/log4j2/log4j2配置/高级配置.html"><strong aria-hidden="true">19.4.7.1.</strong> 高级配置</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> 设计模式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="20.设计模式/PipeLine.html"><strong aria-hidden="true">20.1.</strong> PipeLine</a></li></ol></li><li class="chapter-item expanded "><a href="22.Maven/index.html"><strong aria-hidden="true">21.</strong> Maven</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="22.Maven/AutoConfig插件.html"><strong aria-hidden="true">21.1.</strong> AutoConfig插件</a></li><li class="chapter-item expanded "><a href="22.Maven/MavenArcheType.html"><strong aria-hidden="true">21.2.</strong> MavenArcheType</a></li><li class="chapter-item expanded "><a href="22.Maven/maven.html"><strong aria-hidden="true">21.3.</strong> maven</a></li><li class="chapter-item expanded "><a href="22.Maven/maven-Maven_Resources_Plugin.html"><strong aria-hidden="true">21.4.</strong> maven-Maven_Resources_Plugin</a></li><li class="chapter-item expanded "><a href="22.Maven/maven-archiver.html"><strong aria-hidden="true">21.5.</strong> maven-archiver</a></li><li class="chapter-item expanded "><a href="22.Maven/maven-assembly-plugin.html"><strong aria-hidden="true">21.6.</strong> maven-assembly-plugin</a></li><li class="chapter-item expanded "><a href="22.Maven/maven-bom.html"><strong aria-hidden="true">21.7.</strong> maven-bom</a></li><li class="chapter-item expanded "><a href="22.Maven/maven-profile.html"><strong aria-hidden="true">21.8.</strong> maven-profile</a></li><li class="chapter-item expanded "><a href="22.Maven/maven-依赖管理.html"><strong aria-hidden="true">21.9.</strong> maven-依赖管理</a></li><li class="chapter-item expanded "><a href="22.Maven/maven-编译源码.html"><strong aria-hidden="true">21.10.</strong> maven-编译源码</a></li><li class="chapter-item expanded "><a href="22.Maven/maven中的生命周期、插件、目标.html"><strong aria-hidden="true">21.11.</strong> maven中的生命周期、插件、目标</a></li><li class="chapter-item expanded "><a href="22.Maven/maven打包方式.html"><strong aria-hidden="true">21.12.</strong> maven打包方式</a></li><li class="chapter-item expanded "><a href="22.Maven/maven聚合项目版本管理实践.html"><strong aria-hidden="true">21.13.</strong> maven聚合项目版本管理实践</a></li></ol></li><li class="chapter-item expanded "><a href="23.IO/index.html"><strong aria-hidden="true">22.</strong> IO</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="23.IO/Buffer.html"><strong aria-hidden="true">22.1.</strong> Buffer</a></li><li class="chapter-item expanded "><a href="23.IO/Channel.html"><strong aria-hidden="true">22.2.</strong> Channel</a></li><li class="chapter-item expanded "><a href="23.IO/LinuxIO模型演变.html"><strong aria-hidden="true">22.3.</strong> LinuxIO模型演变</a></li><li class="chapter-item expanded "><a href="23.IO/Selector（选择器）.html"><strong aria-hidden="true">22.4.</strong> Selector（选择器）</a></li><li class="chapter-item expanded "><a href="23.IO/主流IO模型.html"><strong aria-hidden="true">22.5.</strong> 主流IO模型</a></li><li class="chapter-item expanded "><a href="23.IO/从IO到NIO个人理解.html"><strong aria-hidden="true">22.6.</strong> 从IO到NIO个人理解</a></li><li class="chapter-item expanded "><a href="23.IO/字符集.html"><strong aria-hidden="true">22.7.</strong> 字符集</a></li><li class="chapter-item expanded "><a href="23.IO/FileIO(NIO-2.0)/index.html"><strong aria-hidden="true">22.8.</strong> FileIO(NIO-2.0)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="23.IO/FileIO(NIO-2.0)/LinksSymbolicOtherwise.html"><strong aria-hidden="true">22.8.1.</strong> LinksSymbolicOtherwise</a></li><li class="chapter-item expanded "><a href="23.IO/FileIO(NIO-2.0)/RandomAccessFiles.html"><strong aria-hidden="true">22.8.2.</strong> RandomAccessFiles</a></li><li class="chapter-item expanded "><a href="23.IO/FileIO(NIO-2.0)/传统IO与NIO的API迁移.html"><strong aria-hidden="true">22.8.3.</strong> 传统IO与NIO的API迁移</a></li><li class="chapter-item expanded "><a href="23.IO/FileIO(NIO-2.0)/元数据管理.html"><strong aria-hidden="true">22.8.4.</strong> 元数据管理</a></li><li class="chapter-item expanded "><a href="23.IO/FileIO(NIO-2.0)/其他有用方法.html"><strong aria-hidden="true">22.8.5.</strong> 其他有用方法</a></li><li class="chapter-item expanded "><a href="23.IO/FileIO(NIO-2.0)/开发自定义文件系统.html"><strong aria-hidden="true">22.8.6.</strong> 开发自定义文件系统</a></li><li class="chapter-item expanded "><a href="23.IO/FileIO(NIO-2.0)/文件查找.html"><strong aria-hidden="true">22.8.7.</strong> 文件查找</a></li><li class="chapter-item expanded "><a href="23.IO/FileIO(NIO-2.0)/文件管理.html"><strong aria-hidden="true">22.8.8.</strong> 文件管理</a></li><li class="chapter-item expanded "><a href="23.IO/FileIO(NIO-2.0)/文件读写.html"><strong aria-hidden="true">22.8.9.</strong> 文件读写</a></li><li class="chapter-item expanded "><a href="23.IO/FileIO(NIO-2.0)/监控目录变化.html"><strong aria-hidden="true">22.8.10.</strong> 监控目录变化</a></li><li class="chapter-item expanded "><a href="23.IO/FileIO(NIO-2.0)/目录管理.html"><strong aria-hidden="true">22.8.11.</strong> 目录管理</a></li><li class="chapter-item expanded "><a href="23.IO/FileIO(NIO-2.0)/路径操作.html"><strong aria-hidden="true">22.8.12.</strong> 路径操作</a></li><li class="chapter-item expanded "><a href="23.IO/FileIO(NIO-2.0)/遍历目录树.html"><strong aria-hidden="true">22.8.13.</strong> 遍历目录树</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="24.Servlet规范/index.html"><strong aria-hidden="true">23.</strong> Servlet规范</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="24.Servlet规范/fitler.html"><strong aria-hidden="true">23.1.</strong> fitler</a></li><li class="chapter-item expanded "><a href="24.Servlet规范/httpServlet接口.html"><strong aria-hidden="true">23.2.</strong> httpServlet接口</a></li><li class="chapter-item expanded "><a href="24.Servlet规范/request.html"><strong aria-hidden="true">23.3.</strong> request</a></li><li class="chapter-item expanded "><a href="24.Servlet规范/response.html"><strong aria-hidden="true">23.4.</strong> response</a></li><li class="chapter-item expanded "><a href="24.Servlet规范/servletContext.html"><strong aria-hidden="true">23.5.</strong> servletContext</a></li><li class="chapter-item expanded "><a href="24.Servlet规范/servlet初始化.html"><strong aria-hidden="true">23.6.</strong> servlet初始化</a></li><li class="chapter-item expanded "><a href="24.Servlet规范/session.html"><strong aria-hidden="true">23.7.</strong> session</a></li><li class="chapter-item expanded "><a href="24.Servlet规范/入门.html"><strong aria-hidden="true">23.8.</strong> 入门</a></li><li class="chapter-item expanded "><a href="24.Servlet规范/注解与可插拔.html"><strong aria-hidden="true">23.9.</strong> 注解与可插拔</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">单元测试</li><li class="chapter-item expanded "><a href="21.单元测试_JUNIT5/index.html"><strong aria-hidden="true">24.</strong> JUNIT5</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="21.单元测试_JUNIT5/ConsoleLaunch.html"><strong aria-hidden="true">24.1.</strong> ConsoleLaunch</a></li><li class="chapter-item expanded "><a href="21.单元测试_JUNIT5/DependencyMetadata.html"><strong aria-hidden="true">24.2.</strong> DependencyMetadata</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.3.</strong> writtingTest</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="21.单元测试_JUNIT5/writtingTest/Annotations.html"><strong aria-hidden="true">24.3.1.</strong> Annotations</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">ORM</li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> MyBatis</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="25.ORM_MyBatis/mybatis.html"><strong aria-hidden="true">25.1.</strong> mybatis</a></li><li class="chapter-item expanded "><a href="25.ORM_MyBatis/mybatis-插件开发.html"><strong aria-hidden="true">25.2.</strong> mybatis-插件开发</a></li><li class="chapter-item expanded "><a href="25.ORM_MyBatis/mybatis标签.html"><strong aria-hidden="true">25.3.</strong> mybatis标签</a></li><li class="chapter-item expanded "><a href="25.ORM_MyBatis/resultHandler.html"><strong aria-hidden="true">25.4.</strong> resultHandler</a></li><li class="chapter-item expanded "><a href="25.ORM_MyBatis/多结果集分页.html"><strong aria-hidden="true">25.5.</strong> 多结果集分页</a></li></ol></li><li class="chapter-item expanded "><a href="26.ORM_JPA/index.html"><strong aria-hidden="true">26.</strong> JPA</a></li><li class="chapter-item expanded affix "><li class="part-title">鉴权</li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Shiro</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="27.鉴权_Shiro/shiro频繁访问redis.html"><strong aria-hidden="true">27.1.</strong> shiro频繁访问redis</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">其他</li><li class="chapter-item expanded "><a href="28.其他_Security/index.html"><strong aria-hidden="true">28.</strong> Security</a></li><li class="chapter-item expanded "><a href="29.其他_JSR/index.html"><strong aria-hidden="true">29.</strong> JSR</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="29.其他_JSR/jar包规范.html"><strong aria-hidden="true">29.1.</strong> jar包规范</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">30.</strong> JMH</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="30.其他_JMH/java基准测试.html"><strong aria-hidden="true">30.1.</strong> java基准测试</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">31.</strong> JavaCommandLine</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="31.其他_JavaCommandLine/JAVA命令行工具.html"><strong aria-hidden="true">31.1.</strong> JAVA命令行工具</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">32.</strong> 分布式与微服务</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="32.其他_分布式与微服务/JWT无状态Session.html"><strong aria-hidden="true">32.1.</strong> JWT无状态Session</a></li><li class="chapter-item expanded "><a href="32.其他_分布式与微服务/一致性Hash.html"><strong aria-hidden="true">32.2.</strong> 一致性Hash</a></li><li class="chapter-item expanded "><a href="32.其他_分布式与微服务/分布式ID.html"><strong aria-hidden="true">32.3.</strong> 分布式ID</a></li><li class="chapter-item expanded "><a href="32.其他_分布式与微服务/分布式Session案.html"><strong aria-hidden="true">32.4.</strong> 分布式Session案</a></li><li class="chapter-item expanded "><a href="32.其他_分布式与微服务/分布式事务.html"><strong aria-hidden="true">32.5.</strong> 分布式事务</a></li><li class="chapter-item expanded "><a href="32.其他_分布式与微服务/分布式协调器-Zookeeper.html"><strong aria-hidden="true">32.6.</strong> 分布式协调器-Zookeeper</a></li><li class="chapter-item expanded "><a href="32.其他_分布式与微服务/分布式锁.html"><strong aria-hidden="true">32.7.</strong> 分布式锁</a></li><li class="chapter-item expanded "><a href="32.其他_分布式与微服务/接口幂等性.html"><strong aria-hidden="true">32.8.</strong> 接口幂等性</a></li><li class="chapter-item expanded "><a href="32.其他_分布式与微服务/负载均衡.html"><strong aria-hidden="true">32.9.</strong> 负载均衡</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">33.</strong> 未分类</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="50.其他_未分类/EasyRules.html"><strong aria-hidden="true">33.1.</strong> EasyRules</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/JavaLocalDate.html"><strong aria-hidden="true">33.2.</strong> JavaLocalDate</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/JavaSPI.html"><strong aria-hidden="true">33.3.</strong> JavaSPI</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/JavaUnsafe类.html"><strong aria-hidden="true">33.4.</strong> JavaUnsafe类</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/Java异常.html"><strong aria-hidden="true">33.5.</strong> Java异常</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/Java泛型的协变与逆变.html"><strong aria-hidden="true">33.6.</strong> Java泛型的协变与逆变</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/PO、VO、BO.html"><strong aria-hidden="true">33.7.</strong> PO、VO、BO</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/WeakCache.html"><strong aria-hidden="true">33.8.</strong> WeakCache</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/apacheUtils类.html"><strong aria-hidden="true">33.9.</strong> apacheUtils类</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/foreach语法糖.html"><strong aria-hidden="true">33.10.</strong> foreach语法糖</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/formatter.html"><strong aria-hidden="true">33.11.</strong> formatter</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/integer的比较问题.html"><strong aria-hidden="true">33.12.</strong> integer的比较问题</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/javaIdea调试.html"><strong aria-hidden="true">33.13.</strong> javaIdea调试</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/javaPererences工具.html"><strong aria-hidden="true">33.14.</strong> javaPererences工具</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/java中常见的语法糖.html"><strong aria-hidden="true">33.15.</strong> java中常见的语法糖</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/java优化指南.html"><strong aria-hidden="true">33.16.</strong> java优化指南</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/java各版本新特性.html"><strong aria-hidden="true">33.17.</strong> java各版本新特性</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/java序列化接口.html"><strong aria-hidden="true">33.18.</strong> java序列化接口</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/java模块化.html"><strong aria-hidden="true">33.19.</strong> java模块化</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/jdk1.8新特性.html"><strong aria-hidden="true">33.20.</strong> jdk1.8新特性</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/jdk与jre.html"><strong aria-hidden="true">33.21.</strong> jdk与jre</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/string常量池.html"><strong aria-hidden="true">33.22.</strong> string常量池</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/threadLocal.html"><strong aria-hidden="true">33.23.</strong> threadLocal</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/代码异味.html"><strong aria-hidden="true">33.24.</strong> 代码异味</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/基于jdk1.8的Arrays.sort.html"><strong aria-hidden="true">33.25.</strong> 基于jdk1.8的Arrays.sort</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/枚举.html"><strong aria-hidden="true">33.26.</strong> 枚举</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/注解.html"><strong aria-hidden="true">33.27.</strong> 注解</a></li><li class="chapter-item expanded "><a href="50.其他_未分类/类的关系.html"><strong aria-hidden="true">33.28.</strong> 类的关系</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="我的笔记库"><a class="header" href="#我的笔记库">我的笔记库</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代理"><a class="header" href="#代理">代理</a></h1>
<h2 id="优势"><a class="header" href="#优势">优势</a></h2>
<p>使用代理有 2 个优势：</p>
<ul>
<li>可以隐藏委托类的实现</li>
<li>可以实现客户与委托类之间的解耦, 在不修改委托类代码的情况下能够做一些额外的处理</li>
</ul>
<h2 id="场景"><a class="header" href="#场景">场景</a></h2>
<ul>
<li>在 Java 中我们有很多场景需要使用代理类, 比如远程 RPC 调用的时候我们就是通过代理类去实现的, 还有 Spring 的 AOP 切面中我们也是为切面生成了一个代理类等等。 </li>
<li>代理类主要分为静态代理、JDK 动态代理和 CGLIB 动态代理，它们各有优缺点，没有最好的, 存在就是有意义的，在不同的场景下它们会有不同的用武之地。</li>
</ul>
<h1 id="java-静态代理"><a class="header" href="#java-静态代理">Java 静态代理</a></h1>
<ul>
<li>首先, 定义接口和接口的实现类, 然后定义接口的代理对象, 将接口的实例注入到代理对象中, 然后通过代理对象去调用真正的实现类，实现过程非常简单也比较</li>
<li>静态代理的代理关系在编译期间就已经确定了的。它适合于代理类较少且确定的情况。它可实现在怒修改委托类代码的情况下做一些额外的处理，比如包装礼盒，实现客户类与委托类的解耦。缺点是只适用委托方法少的情况下, 试想一下如果委托类有几百上千个方法, 岂不是很难受, 要在代理类中写一堆的代理方法。这个需求动态代理可以搞定</li>
</ul>
<pre><code class="language-java">// 委托接口
public interface IHelloService {

    /**
     * 定义接口方法
     * @param userName
     * @return
     */
    String sayHello(String userName);

}
// 委托类实现
public class HelloService implements IHelloService {

    @Override
    public String sayHello(String userName) {
        System.out.println(&quot;helloService&quot; + userName);
        return &quot;HelloService&quot; + userName;
    }
}

// 代理类
public class StaticProxyHello implements IHelloService {

    private IHelloService helloService = new HelloService();

    @Override
    public String sayHello(String userName) {
        /** 代理对象可以在此处包装一下*/
        System.out.println(&quot;代理对象包装礼盒...&quot;);
        return helloService.sayHello(userName);
    }
}
// 测试静态代理类
public class MainStatic {
    public static void main(String[] args) {
        StaticProxyHello staticProxyHello = new StaticProxyHello();
        staticProxyHello.sayHello(&quot;isole&quot;);
    }
}
</code></pre>
<h1 id="动态代理"><a class="header" href="#动态代理">动态代理</a></h1>
<p>代理类在程序运行时创建的代理方式被成为 <code>动态代理</code>。在了解动态代理之前, 我们先简回顾一下 JVM 的类加载机制中的加载阶段要做的三件事情 ( 附 Java 中的类加载器 )</p>
<ol>
<li>通过一个类的全名或其它途径来获取这个类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 Class 对象, 作为方法区中对这个类访问的入口</li>
</ol>
<p>而我们要说的动态代理，主要就发生在第一个阶段, 这个阶段类的二进制字节流的来源可以有很多, 比如 zip 包、网络、<code>运行时计算生成</code>、其它文件生成 (JSP)、数据库获取。其中运行时计算生成就是我们所说的动态代理技术，在 Proxy 类中, 就是运用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 <code>*$Proxy</code> 的代理类的二进制字节流。所谓的动态代理就是想办法根据接口或者目标对象计算出<code>代理类</code>的字节码然后加载进 JVM 中。实际计算的情况会很复杂，我们借助一些诸如 JDK 动态代理实现、CGLIB 第三方库来完成的</p>
<p>另一方面为了让生成的代理类与目标对象 (就是委托类) 保持一致, 我们有 2 种做法：通过接口的 JDK 动态代理 和通过继承类的 CGLIB 动态代理。</p>
<h2 id="jdk动态代理"><a class="header" href="#jdk动态代理">JDK动态代理</a></h2>
<pre><code class="language-java">public interface InvocationHandler {
    /**
     * 调用处理
     * @param proxy 代理类对象
     * @param methon 标识具体调用的是代理类的哪个方法
     * @param args 代理类方法的参数
     */
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
</code></pre>
<pre><code class="language-java">// 委托类接口
public interface IHelloService {

    /**
     * 方法1
     * @param userName
     * @return
     */
    String sayHello(String userName);

    /**
     * 方法2
     * @param userName
     * @return
     */
    String sayByeBye(String userName);

}
// 委托类
public class HelloService implements IHelloService {

    @Override
    public String sayHello(String userName) {
        System.out.println(userName + &quot; hello&quot;);
        return userName + &quot; hello&quot;;
    }

    @Override
    public String sayByeBye(String userName) {
        System.out.println(userName + &quot; ByeBye&quot;);
        return userName + &quot; ByeBye&quot;;
    }
}
// 中间类
public class JavaProxyInvocationHandler implements InvocationHandler {

    /**
     * 中间类持有委托类对象的引用,这里会构成一种静态代理关系
     */
    private Object obj ;

    /**
     * 有参构造器,传入委托类的对象
     * @param obj 委托类的对象
     */
    public JavaProxyInvocationHandler(Object obj){
        this.obj = obj;

    }

    /**
     * 动态生成代理类对象,Proxy.newProxyInstance
     * @return 返回代理类的实例
     */
    public Object newProxyInstance() {
        return Proxy.newProxyInstance(
                //指定代理对象的类加载器
                obj.getClass().getClassLoader(),
                //代理对象需要实现的接口，可以同时指定多个接口
                obj.getClass().getInterfaces(),
                //方法调用的实际处理者，代理对象的方法调用都会转发到这里
                this);
    }


    /**
     *
     * @param proxy 代理对象
     * @param method 代理方法
     * @param args 方法的参数
     * @return
     * @throws Throwable
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;invoke before&quot;);
        Object result = method.invoke(obj, args);
        System.out.println(&quot;invoke after&quot;);
        return result;
    }
}
// 测试动态代理类
public class MainJavaProxy {
    public static void main(String[] args) {
        JavaProxyInvocationHandler proxyInvocationHandler = new JavaProxyInvocationHandler(new HelloService());
        IHelloService helloService = (IHelloService) proxyInvocationHandler.newProxyInstance();
        helloService.sayByeBye(&quot;paopao&quot;);
        helloService.sayHello(&quot;yupao&quot;);
    }

}
</code></pre>
<h2 id="cglib动态代理"><a class="header" href="#cglib动态代理">CGLIB动态代理</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;cglib&lt;/groupId&gt;
    &lt;artifactId&gt;cglib&lt;/artifactId&gt;
    &lt;version&gt;3.3.0s&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>CGLIB 创建动态代理类的模式是:</p>
<ol>
<li>查找目标类上的所有非 final 的 public 类型的方法 (final 的不能被重写)</li>
<li>将这些方法的定义转成字节码</li>
<li>将组成的字节码转换成相应的代理的 Class 对象然后通过反射获得代理类的实例对象</li>
<li>实现 MethodInterceptor 接口, 用来处理对代理类上所有方法的请求</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<h2 id="cglib是什么"><a class="header" href="#cglib是什么"><strong>Cglib是什么</strong></a></h2>
<p>Cglib是一个强大的、高性能的<strong>代码生成包</strong>，它广泛被许多AOP框架使用，为他们<strong>提供方法的拦截</strong>。下图是我网上找到的一张Cglib与一些框架和语言的关系：</p>
<p><img src="1.java%E5%9F%BA%E7%A1%80_%E4%BB%A3%E7%90%86/../images/cglib-structure.gif" alt="cglib-structure" /></p>
<ul>
<li>最底层的是字节码Bytecode，字节码是Java为了保证“一次编译、到处运行”而产生的一种虚拟指令格式，例如iload_0、iconst_1、if_icmpne、dup等</li>
<li>位于字节码之上的是ASM，这是一种直接操作字节码的框架，应用ASM需要对Java字节码、Class结构比较熟悉</li>
<li>位于ASM之上的是CGLIB、Groovy、BeanShell，后两种并不是Java体系中的内容而是脚本语言，它们通过ASM框架生成字节码变相执行Java代码，这说明<strong>在JVM中执行程序并不一定非要写Java代码----只要你能生成Java字节码，JVM并不关心字节码的来源</strong>，当然通过Java代码生成的JVM字节码是通过编译器直接生成的，算是最“正统”的JVM字节码</li>
<li>位于CGLIB、Groovy、BeanShell之上的就是Hibernate、Spring AOP这些框架了，这一层大家都比较熟悉</li>
<li>最上层的是Applications，即具体应用，一般都是一个Web项目或者本地跑一个程序</li>
</ul>
<h1 id="cglib类库结构"><a class="header" href="#cglib类库结构">CGLIB类库结构</a></h1>
<h2 id="使用cglib代码对类做代理"><a class="header" href="#使用cglib代码对类做代理"><strong>使用Cglib代码对类做代理</strong></a></h2>
<p>下面演示一下Cglib代码示例----对类做代理。首先定义一个Dao类，里面有一个select()方法和一个update()方法：</p>
<p><strong>源方法</strong></p>
<pre><code class="language-java">public class Dao {
  
    public void update() {
        System.out.println(&quot;PeopleDao.update()&quot;);
    }
  
    public void select() {
        System.out.println(&quot;PeopleDao.select()&quot;);
    }
}
</code></pre>
<p><strong>拦截代理类</strong></p>
<pre><code class="language-java">public class DaoProxy implements MethodInterceptor {

    @Override
    public Object intercept(Object object, Method method, Object[] objects, MethodProxy proxy) throws Throwable {
        System.out.println(&quot;Before Method Invoke&quot;);
        proxy.invokeSuper(object, objects);
        System.out.println(&quot;After Method Invoke&quot;);
      
        return object;
    }
  
}
</code></pre>
<p>intercept方法的参数的含义为：</p>
<ul>
<li>Object表示要进行增强的对象</li>
<li>Method表示拦截的方法</li>
<li>Object[]数组表示参数列表，基本数据类型需要传入其包装类型</li>
<li>MethodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用</li>
</ul>
<p><strong>返回值</strong></p>
<p><em>any value compatible with the signature of the proxied method. Method returning void will ignore this value</em></p>
<p><strong>增强类</strong></p>
<pre><code class="language-java">public class CglibTest {

    @Test
    public void testCglib() {
        DaoProxy daoProxy = new DaoProxy();
      
        Enhancer enhancer = new Enhancer();
        //设置要代理的类
        enhancer.setSuperclass(Dao.class);
        //表示设置回调即MethodInterceptor的实现类
        enhancer.setCallback(daoProxy);
        //使用create()方法生成一个代理对象
        Dao dao = (Dao)enhancer.create();
        dao.update();
        dao.select();
    }
  
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callbacks简介"><a class="header" href="#callbacks简介">callbacks简介</a></h1>
<p>这里的callback可以认为是cglib用于生成字节码的实现手段，cglib一共实现了6种callback，用于对代理类目标进行不同手段的代理</p>
<p>分别为：</p>
<ul>
<li>FixedValue</li>
<li>InvocationHandler</li>
<li>LazyLoader</li>
<li>MethodInterceptor</li>
<li>Dispatcher</li>
<li>NoOp</li>
<li>ProxyRefDispatcher</li>
</ul>
<h1 id="dispatcher"><a class="header" href="#dispatcher">Dispatcher</a></h1>
<p>实现Dispatcher接口，要求实现loadObject方法，返回期望的代理类。</p>
<p>值的一提的是，loadobject方法在每次调用被拦截方法的时候都会被调用一次</p>
<p>手动返回指定的被代理类的，每次调用都会返回一个新的</p>
<pre><code class="language-java">public final void methodForDispatcher() {
    Dispatcher var10000 = this.CGLIB$CALLBACK_3;
    if (var10000 == null) {
        CGLIB$BIND_CALLBACKS(this);
        var10000 = this.CGLIB$CALLBACK_3;
    }
	//每次都调用一次loadObject，获取对象，并调用对象的相应方法
    //这样的实现，相当于loadObject可以很灵活的返回相应的实现类或者子类
    ((CallbackBean)var10000.loadObject()).methodForDispatcher();
}
</code></pre>
<h1 id="lazyloader"><a class="header" href="#lazyloader">LazyLoader</a></h1>
<ol>
<li>与Dispatcher 类似，但是只会返回一次代理类实例</li>
<li>懒加载 </li>
</ol>
<pre><code class="language-java">public final void select_with_lazyLoader() {
    ((MyDao)this.CGLIB$LOAD_PRIVATE_6()).select_with_lazyLoader();
}
private final synchronized Object CGLIB$LOAD_PRIVATE_6() {
    Object var10000 = this.CGLIB$LAZY_LOADER_6;
    if (var10000 == null) {
        LazyLoader var10001 = this.CGLIB$CALLBACK_6;
        if (var10001 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10001 = this.CGLIB$CALLBACK_6;
        }
		//如果为空才调用代理类
        var10000 = this.CGLIB$LAZY_LOADER_6 = var10001.loadObject();
    }

    return var10000;
}
</code></pre>
<h1 id="proxyrefdispatcher"><a class="header" href="#proxyrefdispatcher">ProxyRefDispatcher</a></h1>
<p>与Dispatcher 类似，每次调用都会传入代理类的引用进来</p>
<pre><code class="language-java">public final void select_with_proxyRef() {
    ProxyRefDispatcher var10000 = this.CGLIB$CALLBACK_7;
    if (var10000 == null) {
        CGLIB$BIND_CALLBACKS(this);
        var10000 = this.CGLIB$CALLBACK_7;
    }

    ((MyDao)var10000.loadObject(this)).select_with_proxyRef();
}
</code></pre>
<h1 id="fixedvalue"><a class="header" href="#fixedvalue">FixedValue</a></h1>
<ol>
<li>该callback同样要求实现一个loadobject方法</li>
<li>每次调用方法时直接返回该值，并强制转换</li>
</ol>
<pre><code class="language-java">public final String select_with_fixedValue() {
    FixedValue var10000 = this.CGLIB$CALLBACK_3;
    if (var10000 == null) {
        CGLIB$BIND_CALLBACKS(this);
        var10000 = this.CGLIB$CALLBACK_3;
    }

    return (String)var10000.loadObject();
}
</code></pre>
<h1 id="noop"><a class="header" href="#noop">Noop</a></h1>
<ol>
<li>没有重写方法</li>
<li>直接调用父类的方法</li>
</ol>
<h1 id="invocationhandler"><a class="header" href="#invocationhandler">InvocationHandler</a></h1>
<ol>
<li>直接调用 InvocationHandler</li>
</ol>
<pre><code class="language-java">    public final Object select_with_invocationHandler(String var1) {
        try {
            InvocationHandler var10000 = this.CGLIB$CALLBACK_5;
            if (var10000 == null) {
                CGLIB$BIND_CALLBACKS(this);
                var10000 = this.CGLIB$CALLBACK_5;
            }

            return var10000.invoke(this, CGLIB$select_with_invocationHandler$5, new Object[]{var1});
        } catch (Error | RuntimeException var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }
</code></pre>
<h1 id="methodinterceptor"><a class="header" href="#methodinterceptor">MethodInterceptor</a></h1>
<p>使用 <em>fastclass</em> 机制 调用父类方法</p>
<ol>
<li>var1是 代理对象引用</li>
<li>var2是 调用方法</li>
<li>var3是 参数对象</li>
<li>var4是 fastClass机制的类调用</li>
</ol>
<pre><code class="language-java">    public final void select() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (var10000 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            var10000.intercept(this, CGLIB$select$1$Method, CGLIB$emptyArgs, CGLIB$select$1$Proxy);
        } else {
            super.select();
        }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是java动态代理"><a class="header" href="#什么是java动态代理">什么是JAVA动态代理？</a></h1>
<p>JAVA动态代理与静态代理相对，静态代理是在编译期就已经确定代理类和真实类的关系，并且生成代理类的。而动态代理是在运行期利用JVM的反射机制生成代理类</p>
<p>这里是直接生成类的字节码，然后通过类加载器载入JAVA虚拟机执行</p>
<p>现在主流的JAVA动态代理技术的实现有两种：</p>
<p>一种是JDK自带的，就是我们所说的JDK动态代理，</p>
<p>另一种是开源社区的一个开源项目CGLIB</p>
<h1 id="什么是jdk动态代理"><a class="header" href="#什么是jdk动态代理">什么是JDK动态代理？</a></h1>
<p>JDK动态代理的实现是在运行时，根据一组接口定义，使用Proxy、InvocationHandler等工具类去生成一个代理类和代理类实例。</p>
<p><img src="1.java%E5%9F%BA%E7%A1%80_%E4%BB%A3%E7%90%86/../../images/jdkproxy.webp" alt="" /></p>
<ol>
<li>类名的生成规则是前缀&quot;$Proxy&quot;加上一个序列数</li>
<li>这个类继承Proxy，实现一系列的接口Intf1,Intf2...IntfN</li>
<li>既然要实现接口，那么就要实现接口的各个方法,JDK动态代理类是如何实现这些接口方法的具体逻辑,答案就在InvocationHandler上</li>
<li>$Proxy0对外只提供一个构造函数，这个构造函数接受一个InvocationHandler实例h，这个构造函数的逻辑非常简单，就是调用父类的构造函数</li>
<li>将参数h赋值给对象字段h。最终就是把所有的方法实现都分派到InvocationHandler实例h的invoke方法上。</li>
<li>所以JDK动态代理的接口方法实现逻辑是完全由InvocationHandler实例的invoke方法决定的。</li>
</ol>
<h1 id="保存jdk动态代理字节码的两种方式"><a class="header" href="#保存jdk动态代理字节码的两种方式">保存JDK动态代理字节码的两种方式</a></h1>
<h2 id="设置系统属性"><a class="header" href="#设置系统属性">设置系统属性</a></h2>
<pre><code class="language-java">public Object getProxy() {
	System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;); //设置系统属性
	return Proxy.newProxyInstance(target.getClass().getClassLoader(),
			target.getClass().getInterfaces(), this); 
}
</code></pre>
<p>会 自动将 proxy 写入 <code>${workplace}/com/sun/proxy</code> 路径下</p>
<h2 id="保存proxygenerator生成的字节流数组"><a class="header" href="#保存proxygenerator生成的字节流数组">保存ProxyGenerator生成的字节流数组</a></h2>
<pre><code class="language-java">byte[] bytes = ProxyGenerator.generateProxyClass(&quot;MyClass.class&quot;, Dog.class.getInterfaces());
Path path = Paths.get(Dog.class.getResource(&quot;&quot;).toURI());

FileChannel open = FileChannel.open(path.resolve(&quot;MyClass.class&quot;), StandardOpenOption.WRITE,StandardOpenOption.CREATE);
        open.write(ByteBuffer.wrap(bytes));

</code></pre>
<h1 id="字节码分析"><a class="header" href="#字节码分析">字节码分析</a></h1>
<ol>
<li>m0是 <em>hashCode</em>、m1是 <em>equals</em>、m2是 <em>toString</em> 方法</li>
<li>其余 m* 是接口的方法</li>
<li>所有接口方法都交由 InvocationHandler处理</li>
</ol>
<pre><code class="language-java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package com.sun.proxy;

import com.weisanju.ioStudy.proxy.Animal;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;

public final class $Proxy0 extends Proxy implements Animal {
    private static Method m1;
    private static Method m2;
    private static Method m4;
    private static Method m3;
    private static Method m0;

    public $Proxy0(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void eat(String var1) throws  {
        try {
            super.h.invoke(this, m4, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final void say() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));
            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);
            m4 = Class.forName(&quot;com.weisanju.ioStudy.proxy.Animal&quot;).getMethod(&quot;eat&quot;, Class.forName(&quot;java.lang.String&quot;));
            m3 = Class.forName(&quot;com.weisanju.ioStudy.proxy.Animal&quot;).getMethod(&quot;say&quot;);
            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
</code></pre>
<h1 id="源码解析"><a class="header" href="#源码解析">源码解析</a></h1>
<h2 id="newproxyinstance"><a class="header" href="#newproxyinstance">newProxyInstance</a></h2>
<blockquote>
<p>该代码段主要是 获取代理类，并根据代理类 使用 InvocationHandler  实例化</p>
</blockquote>
<ol>
<li>根据 接口获取 代理类 （如果有缓存则使用缓存，如果没有缓存则 生成）</li>
<li>获取代理类的 构造函数：<em>invocationHandler</em> 的那个</li>
<li>使用 InvocationHandler 根据构造函数实例化 对象</li>
</ol>
<pre><code class="language-java">    public static Object newProxyInstance(ClassLoader loader,
                                          Class&lt;?&gt;[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        //检验h不为空，h为空抛异常
        Objects.requireNonNull(h);
        //接口的类对象拷贝一份
        final Class&lt;?&gt;[] intfs = interfaces.clone();
        //进行一些安全性检查
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }

        /*
         * Look up or generate the designated proxy class.
         *  查询（在缓存中已经有）或生成指定的代理类的class对象。
         * 根据接口生成生成指定代理类
         */
        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);

        /*
         * Invoke its constructor with the designated invocation handler.
         */
        try {
            //权限检查
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }
            //得到代理类对象的构造函数，这个构造函数的参数由constructorParams指定
            //参数constructorParames为常量值：private static final Class&lt;?&gt;[] constructorParams = { InvocationHandler.class };
            //获取构造函数
            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            //实例化
            //这里生成代理对象，传入的参数new Object[]{h}后面讲
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }
</code></pre>
<h2 id="getproxyclass0"><a class="header" href="#getproxyclass0">getProxyClass0</a></h2>
<p>这里使用的 <em>WeakCache</em> 二级弱缓存</p>
<ol>
<li>key是 classLoader：使用的是 弱引用队列</li>
<li>二级key是 代理的接口们 强引用</li>
<li>value 弱引用</li>
</ol>
<p><strong>value计算逻辑</strong></p>
<ol>
<li>负责校验接口 是否存在 可加载、是否是接口、是否重复</li>
<li>维护 proxy的类名</li>
<li>使用接口 调用 生成字节码的类</li>
</ol>
<pre><code class="language-java">public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {

    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);
    for (Class&lt;?&gt; intf : interfaces) {
        /*
         * Verify that the class loader resolves the name of this
         * interface to the same Class object.
         */
        Class&lt;?&gt; interfaceClass = null;
        try {
            interfaceClass = Class.forName(intf.getName(), false, loader);
        } catch (ClassNotFoundException e) {
        }
        if (interfaceClass != intf) {
            throw new IllegalArgumentException(
                intf + &quot; is not visible from class loader&quot;);
        }
        /*
         * Verify that the Class object actually represents an
         * interface.
         */
        if (!interfaceClass.isInterface()) {
            throw new IllegalArgumentException(
                interfaceClass.getName() + &quot; is not an interface&quot;);
        }
        /*
         * Verify that this interface is not a duplicate.
         */
        if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
            throw new IllegalArgumentException(
                &quot;repeated interface: &quot; + interfaceClass.getName());
        }
    }

    String proxyPkg = null;     // package to define proxy class in
    int accessFlags = Modifier.PUBLIC | Modifier.FINAL;

    /*
     * Record the package of a non-public proxy interface so that the
     * proxy class will be defined in the same package.  Verify that
     * all non-public proxy interfaces are in the same package.
     */
    for (Class&lt;?&gt; intf : interfaces) {
        int flags = intf.getModifiers();
        if (!Modifier.isPublic(flags)) {
            accessFlags = Modifier.FINAL;
            String name = intf.getName();
            int n = name.lastIndexOf('.');
            String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));
            if (proxyPkg == null) {
                proxyPkg = pkg;
            } else if (!pkg.equals(proxyPkg)) {
                throw new IllegalArgumentException(
                    &quot;non-public interfaces from different packages&quot;);
            }
        }
    }

    if (proxyPkg == null) {
        // if no non-public proxy interfaces, use com.sun.proxy package
        proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;
    }

    /*
     * Choose a name for the proxy class to generate.
     */
    long num = nextUniqueNumber.getAndIncrement();
    String proxyName = proxyPkg + proxyClassNamePrefix + num;

    /*
     * Generate the specified proxy class.
     */
    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
        proxyName, interfaces, accessFlags);
    try {
        return defineClass0(loader, proxyName,
                            proxyClassFile, 0, proxyClassFile.length);
    } catch (ClassFormatError e) {
        /*
         * A ClassFormatError here means that (barring bugs in the
         * proxy class generation code) there was some other
         * invalid aspect of the arguments supplied to the proxy
         * class creation (such as virtual machine limitations
         * exceeded).
         */
        throw new IllegalArgumentException(e.toString());
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapstruct介绍"><a class="header" href="#mapstruct介绍">MapStruct介绍</a></h1>
<ul>
<li>
<p>mapStructut是一个基于注解的,用来生成类型安全的bean映射类</p>
</li>
<li>
<p>在编译时期Mapstruct会生成接口的实现,基于普通的方法调用,没有反射</p>
</li>
<li>
<p>主要包含了两个组件</p>
<ul>
<li><em>org.mapstruct:mapstruct</em>: 注解</li>
<li><em>org.mapstruct:mapstruct-processor</em>: 生成实现类的处理器</li>
</ul>
</li>
</ul>
<h1 id="使用方式"><a class="header" href="#使用方式">使用方式</a></h1>
<h2 id="maven-configuration"><a class="header" href="#maven-configuration"><em>Maven configuration</em></a></h2>
<pre><code>&lt;properties&gt;
    &lt;org.mapstruct.version&gt;1.3.1.Final&lt;/org.mapstruct.version&gt;
&lt;/properties&gt;
...
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;
        &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;
        &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.8.1&lt;/version&gt;
&lt;configuration&gt;
        &lt;source&gt;1.8&lt;/source&gt;
        &lt;target&gt;1.8&lt;/target&gt;
        &lt;annotationProcessorPaths&gt;
            &lt;path&gt;
                &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;
                &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;
                &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;
            &lt;/path&gt;
        &lt;/annotationProcessorPaths&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<h1 id="入门"><a class="header" href="#入门">入门</a></h1>
<h2 id="案例"><a class="header" href="#案例">案例</a></h2>
<p><strong>源类型</strong></p>
<ul>
<li>转换的类要符合JavaBean定义</li>
<li>同名会自动转换</li>
<li>@BeanMapping(ignoreByDefault = true) 不会自动匹配,只能显示指定名字字段的对应关系</li>
</ul>
<pre><code class="language-java">public class Car {
 
    private String make;
    private int numberOfSeats;
    private CarType type;
}
public enum  CarType {
    BAIDU,
    ALI,
    TENXUN
}
</code></pre>
<p><strong>目标类型</strong></p>
<pre><code class="language-java">public class CarDto {
 
    private String make;
    private int seatCount;
    private String type;
 }
</code></pre>
<p><strong>中间转换类</strong></p>
<pre><code class="language-java">@Mapper
public interface CarMapper {
 
    CarMapper INSTANCE = Mappers.getMapper( CarMapper.class );
 
    @Mapping(source = &quot;numberOfSeats&quot;, target = &quot;seatCount&quot;) // 可以有多个 @Repeatable(Mappings.class)
    @Mapping(source = &quot;numberOfSeats&quot;, target = &quot;seatCount&quot;)
    CarDto carToCarDto(Car car);
}
</code></pre>
<p><strong>测试类</strong></p>
<pre><code class="language-java">{
    //given
    Car car = new Car( &quot;Morris&quot;, 5, CarType.ALI );

    //when
    CarDto carDto = CarMapper.INSTANCE.carToCarDto( car );

    //then
    assertThat(carDto, notNullValue());
    assertThat(carDto.getSeatCount(),is(5));
    assertThat(carDto.getType(),is(&quot;ALI&quot;));
}
</code></pre>
<h1 id="类型转换"><a class="header" href="#类型转换"><a href="https://mapstruct.org/documentation/stable/reference/html/#implicit-type-conversions">类型转换</a></a></h1>
<h2 id="基本数据类型转换"><a class="header" href="#基本数据类型转换">基本数据类型转换</a></h2>
<p>如果源类型与 目标类型 不同,会进行隐式转换,或者调用或者创建另一个映射方法</p>
<h3 id="包装类型转基本类型"><a class="header" href="#包装类型转基本类型">包装类型转基本类型</a></h3>
<ul>
<li>所有Java的数值类型会自动转换</li>
<li>long 转 int会造成精度丢失,<em>MapperConfig</em> 注解 的 typeConversionPolicy 方法控制 警告与错误由于向后兼容,默认<code>ReportingPolicy.IGNORE</code></li>
</ul>
<h3 id="所有基本数据类型-转string"><a class="header" href="#所有基本数据类型-转string">所有基本数据类型 转string</a></h3>
<ul>
<li>自动调用相应包装类型的 parse与valueOf</li>
</ul>
<pre><code>int to  string string to int
会自动调用 如下方法
String#valueOf(int) and Integer#parseInt(String)
</code></pre>
<ul>
<li>
<p>可以识别 java.text.DecimalFormat 的</p>
<pre><code class="language-vue">@Mapper
public interface CarMapper {

    @Mapping(source = &quot;price&quot;, numberFormat = &quot;$#.00&quot;)
    CarDto carToCarDto(Car car);

    @IterableMapping(numberFormat = &quot;$#.00&quot;)
    List&lt;String&gt; prices(List&lt;Integer&gt; prices);
}
</code></pre>
</li>
</ul>
<h3 id="枚举转string"><a class="header" href="#枚举转string">枚举转string</a></h3>
<p>默认取 枚举方法名</p>
<h3 id="日期类型转换"><a class="header" href="#日期类型转换">日期类型转换</a></h3>
<p>各种日期之间的转换</p>
<pre><code>@Mapper
public interface CarMapper {

    @Mapping(source = &quot;manufacturingDate&quot;, dateFormat = &quot;dd.MM.yyyy&quot;)
    CarDto carToCarDto(Car car);

    @IterableMapping(dateFormat = &quot;dd.MM.yyyy&quot;)
    List&lt;String&gt; stringListToDateList(List&lt;Date&gt; dates);
}
</code></pre>
<h3 id="货币与string"><a class="header" href="#货币与string">货币与string</a></h3>
<p><code>java.util.Currency</code> and <code>String</code>.</p>
<h2 id="引用数据类型转换"><a class="header" href="#引用数据类型转换">引用数据类型转换</a></h2>
<pre><code class="language-java">@Mapper
public interface CarMapper {

    CarDto carToCarDto(Car car);

    PersonDto personToPersonDto(Person person);
}
</code></pre>
<p><strong>遵循原则</strong></p>
<ul>
<li>如果源和目标 有同样的类型, 值只会简单的从源copy到目的</li>
<li>如果类型不一致,查看是否还有另一个映射方法, <strong>参数与源类型相同,返回值与目标类型相同</strong>,则会自动调用这个方法</li>
<li>如果没有上述类型方法,则查找内置的转换器,如果有则应用</li>
<li>如果没有则 尝试自动生成 转换器</li>
<li>如果无法生成转换器 则编译时报错</li>
</ul>
<p><strong>扩展</strong></p>
<p><code>@Mapper( disableSubMappingMethodsGeneration = true )</code>. 禁止自动生成 子映射</p>
<h2 id="嵌套bean的映射"><a class="header" href="#嵌套bean的映射">嵌套bean的映射</a></h2>
<pre><code class="language-java">//使用 . 可以指定嵌套的映射
@Mapper
public interface FishTankMapper {

    @Mapping(target = &quot;fish.kind&quot;, source = &quot;fish.type&quot;)
    @Mapping(target = &quot;fish.name&quot;, ignore = true) //忽略
    @Mapping(target = &quot;ornament&quot;, source = &quot;interior.ornament&quot;)
    @Mapping(target = &quot;material.materialType&quot;, source = &quot;material&quot;)
    @Mapping(target = &quot;quality.report.organisation.name&quot;, source = &quot;quality.report.organisationName&quot;)
    FishTankDto map( FishTank source );
}
</code></pre>
<pre><code class="language-java">@Mapper
public interface FishTankMapperWithDocument {

    @Mapping(target = &quot;fish.kind&quot;, source = &quot;fish.type&quot;)
    @Mapping(target = &quot;fish.name&quot;, expression = &quot;java(\&quot;Jaws\&quot;)&quot;)
    @Mapping(target = &quot;plant&quot;, ignore = true )
    @Mapping(target = &quot;ornament&quot;, ignore = true )
    @Mapping(target = &quot;material&quot;, ignore = true)
    @Mapping(target = &quot;quality.document&quot;, source = &quot;quality.report&quot;)
    @Mapping(target = &quot;quality.document.organisation.name&quot;, constant = &quot;NoIdeaInc&quot; )
    FishTankWithNestedDocumentDto map( FishTank source );

}
</code></pre>
<h2 id="mapping-composition-experimental"><a class="header" href="#mapping-composition-experimental">Mapping Composition (experimental)</a></h2>
<p>组合注解:用来处理 多个不同种类的bean可能存在 相同的字段</p>
<pre><code>定义在注解上
@Retention(RetentionPolicy.CLASS)
@Mapping(target = &quot;id&quot;, ignore = true)
@Mapping(target = &quot;creationDate&quot;, expression = &quot;java(new java.util.Date())&quot;)
@Mapping(target = &quot;name&quot;, source = &quot;groupName&quot;)
public @interface ToEntity { }

使用定义的注解
@Mapper
public interface StorageMapper {

    StorageMapper INSTANCE = Mappers.getMapper( StorageMapper.class );

    @ToEntity
    @Mapping( target = &quot;weightLimit&quot;, source = &quot;maxWeight&quot;)
    ShelveEntity map(ShelveDto source);

    @ToEntity
    @Mapping( target = &quot;label&quot;, source = &quot;designation&quot;)
    BoxEntity map(BoxDto source);
}

</code></pre>
<h2 id="增加自定义方法"><a class="header" href="#增加自定义方法">增加自定义方法</a></h2>
<h3 id="使用接口默认方法"><a class="header" href="#使用接口默认方法">使用接口默认方法</a></h3>
<pre><code>@Mapper
public interface CarMapper {

    @Mapping(...)
    ...
    CarDto carToCarDto(Car car);

    default PersonDto personToPersonDto(Person person) {
        //hand-written mapping logic
    }
}
</code></pre>
<h3 id="使用抽象类继承"><a class="header" href="#使用抽象类继承">使用抽象类继承</a></h3>
<pre><code>@Mapper
public abstract class CarMapper {

    @Mapping(...)
    ...
    public abstract CarDto carToCarDto(Car car);

    public PersonDto personToPersonDto(Person person) {
        //hand-written mapping logic
    }
}
</code></pre>
<h2 id="来自多源"><a class="header" href="#来自多源">来自多源</a></h2>
<p>如果多源中字段名有歧义就会报错</p>
<pre><code>@Mapper
public interface AddressMapper {

    @Mapping(source = &quot;person.description&quot;, target = &quot;description&quot;)
    @Mapping(source = &quot;address.houseNo&quot;, target = &quot;houseNumber&quot;)
    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Address address);
}
</code></pre>
<h2 id="嵌套的bean属性处理"><a class="header" href="#嵌套的bean属性处理">嵌套的bean属性处理</a></h2>
<p>使用. 表明 将 record对象中所有的属性映射到target</p>
<pre><code>@Mapper
 public interface CustomerMapper {

     @Mapping( target = &quot;name&quot;, source = &quot;record.name&quot; )
     @Mapping( target = &quot;.&quot;, source = &quot;record&quot; )
     @Mapping( target = &quot;.&quot;, source = &quot;account&quot; )
     Customer customerDtoToCustomer(CustomerDto customerDto);
 }
</code></pre>
<h2 id="更新使用-源类型-更新目标类型"><a class="header" href="#更新使用-源类型-更新目标类型">更新使用 源类型 更新目标类型</a></h2>
<pre><code>@Mapper
public interface CarMapper {

    void updateCarFromDto(CarDto carDto, @MappingTarget Car car);
}
</code></pre>
<h2 id="直接字段访问映射"><a class="header" href="#直接字段访问映射">直接字段访问映射</a></h2>
<p>支持 public的 字段,没有getter,setter</p>
<pre><code>    @InheritInverseConfiguration
    CustomerDto fromCustomer(Customer customer);
</code></pre>
<h2 id="使用构建器"><a class="header" href="#使用构建器">使用构建器</a></h2>
<div style="break-before: page; page-break-before: always;"></div><p>Stream中 <em>anyMatch</em> 跟 <em>allMatch</em> 对于空集合的 作用</p>
<p>anyMatch：只要有一个满足即可退出</p>
<p><strong>等价代码</strong></p>
<pre><code class="language-java">    public static &lt;T&gt;boolean anyMatch(List&lt;T&gt; target, Predicate&lt;T&gt; predicate){
        for (T t : target) {
            if(predicate.test(t)){
                return true;
            }
        }
        return false;
    }
</code></pre>
<p><em>allMatch</em>: 只要有一个不满足条件，则返回false</p>
<p><strong>等价代码</strong></p>
<pre><code class="language-java">    public static &lt;T&gt;boolean allMatch(List&lt;T&gt; target, Predicate&lt;T&gt; predicate){
        for (T t : target) {
            if(!predicate.test(t)){
                return false;
            }
        }
        return true;
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数式接口"><a class="header" href="#函数式接口">函数式接口</a></h1>
<ul>
<li>只有一个抽象方法的接口</li>
<li>可以通过 <em>@FunctionalInterface</em> 来注明这是一个函数式接口</li>
</ul>
<h1 id="lambda-表达式"><a class="header" href="#lambda-表达式">lambda 表达式</a></h1>
<p>lambda 表达式的语法由参数列表、箭头符号 <code>-&gt;</code> 和函数体组成</p>
<h1 id="目标类型"><a class="header" href="#目标类型">目标类型</a></h1>
<p>lambda表达式的类型是由其上下文推导而来</p>
<h3 id="目标类型的上下文"><a class="header" href="#目标类型的上下文">目标类型的上下文</a></h3>
<ul>
<li>
<p>变量声明</p>
</li>
<li>
<p>赋值</p>
</li>
<li>
<p>返回语句</p>
</li>
<li>
<p>数组初始化器</p>
<pre><code>new FileFilter[] {
    f -&gt; f.exists(), f -&gt; f.canRead(), f -&gt; f.getName().startsWith(&quot;q&quot;)
  });
</code></pre>
</li>
<li>
<p>方法和构造方法的参数</p>
</li>
<li>
<p>lambda 表达式函数体</p>
</li>
<li>
<p>条件表达式（<code>? :</code>）</p>
</li>
<li>
<p>转型（Cast）表达式</p>
</li>
</ul>
<h1 id="词法作用域"><a class="header" href="#词法作用域">词法作用域</a></h1>
<ul>
<li>
<p>内部类与 lambda表达式作用域</p>
<p>内部类的作用域在 类内部</p>
<p>lambda表达式的作用域是在 类外部,类似于代码块的作用域</p>
</li>
</ul>
<h1 id="变量捕获"><a class="header" href="#变量捕获">变量捕获</a></h1>
<p>lambda 表达式对 <em>值</em> 封闭，对 <em>变量</em> 开放</p>
<p>lambda表达式 对局部变量 引用的原则是 <em>effective final</em></p>
<p>lambda不支持 捕获变量的修改,因为容易在多线程环境下引起竞争</p>
<pre><code>int sum = 0;
list.forEach(e -&gt; { sum += e.size(); }); // Illegal, close over values

List&lt;Integer&gt; aList = new List&lt;&gt;();
list.forEach(e -&gt; { aList.add(e); }); // Legal, open over variables
</code></pre>
<h1 id="方法引用"><a class="header" href="#方法引用">方法引用</a></h1>
<ul>
<li>方法引用时 lambda表达式的缩写</li>
<li><em>Person::getName</em> 等价于 <em>p -&gt; p.getName()</em></li>
</ul>
<h2 id="方法引用的种类"><a class="header" href="#方法引用的种类">方法引用的种类</a></h2>
<ul>
<li>静态方法引用：<code>ClassName::methodName</code></li>
<li>实例上的实例方法引用：<code>instanceReference::methodName</code></li>
<li>超类上的实例方法引用：<code>super::methodName</code></li>
<li>类型上的实例方法引用：<code>ClassName::methodName</code></li>
<li>构造方法引用：<code>Class::new</code></li>
<li>数组构造方法引用：<code>TypeName[]::new</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="一创建测试样例"><a class="header" href="#一创建测试样例">一、创建测试样例</a></h2>
<pre><code class="language-java">public class App {
    public static void main(String[] args) {
        Lam lam = (msg) -&gt; &quot;log:&quot; + msg;
        String result = lam.print(&quot;Test&quot;);
        System.out.println(result);
    }
}
interface Lam {
    String print(String msg);
}
</code></pre>
<h2 id="利用java命令编译分析"><a class="header" href="#利用java命令编译分析">利用Java命令编译分析</a></h2>
<pre><code class="language-java">javap -p Lam.class
// 从返回值我们可以看到，因为Lam.class是App.class的内部类，所以提示我们它是App.java编译过来的，并且其内部只有一个abstract方法print()。
  Compiled from &quot;App.java&quot;
interface Lam {
  public abstract java.lang.String print(java.lang.String);
}


javap -p App.class
//在APP中生成了一个静态方法：lambda$main$0
Compiled from &quot;App.java&quot;
public class App {
  public App();
  public static void main(java.lang.String[]);
  private static java.lang.String lambda$main$0(java.lang.String);
}


</code></pre>
<h2 id="静态方法如何实现的"><a class="header" href="#静态方法如何实现的">静态方法如何实现的</a></h2>
<pre><code class="language-java">//查看详细实现过程，这里只关注 lambda$main$0 方法
➜  classes javap -c -p  App.class    
Compiled from &quot;App.java&quot;
public class App {
  public App();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: invokedynamic #2,  0              // InvokeDynamic #0:print:()LLam;
       5: astore_1
       6: aload_1
       7: ldc           #3                  // String Test
       9: invokeinterface #4,  2            // InterfaceMethod Lam.print:(Ljava/lang/String;)Ljava/lang/String;
      14: astore_2
      15: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
      18: aload_2
      19: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      22: return

  private static java.lang.String lambda$main$0(java.lang.String);
    Code:
       0: new           #7                  // class java/lang/StringBuilder
       3: dup
       4: invokespecial #8                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V
       7: ldc           #9                  // String log:
       9: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      12: aload_0
      13: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      16: invokevirtual #11                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      19: areturn
}
</code></pre>
<h2 id="如何调用生成的静态方法"><a class="header" href="#如何调用生成的静态方法">如何调用生成的静态方法</a></h2>
<p>这个*lambda$main$0(String)*方法是怎么被调用的呢？我们通过对java命令指定选项查看底层详细的编译过程：</p>
<p><strong>调用 AppMain方法、并导出中途生成的代理类</strong></p>
<pre><code class="language-shell">java -Djdk.internal.lambda.dumpProxyClasses App
</code></pre>
<p>我们能够看到多出来一个<em>App$$Lambda$1.class</em>文件，打开文件：</p>
<pre><code>javap -p App$$Lambda$1.class
</code></pre>
<p>我们再通过javap -c查看一下它内部详细信息：</p>
<pre><code class="language-java">javap -c App$$Lambda$1.class
</code></pre>
<pre><code class="language-java">final class App$$Lambda$1 implements Lam {
  public java.lang.String print(java.lang.String);
    Code:
       0: aload_1
       1: invokestatic  #18                 // Method App.lambda$main$0:(Ljava/lang/String;)Ljava/lang/String;
       4: areturn
}
</code></pre>
<p>由此我们可以看出，App$$Lambda$1.class的print()方法执行了App.lambda$main$0()，因此，我们就可以得出结论：</p>
<ol>
<li>Java在编译时，首先，在App内将Lambda表达式抽取出来作为一个static方法<em>lambda$main$0(String)</em>；</li>
<li>然后，对Lam.class做了默认实现<em>App$$Lambda$1.class</em>，并在内部<em>print</em>()方法中调用了App内的static方法：<em>lambda$main$0()</em>；</li>
<li>接下来，执行App的<em>main</em>()方法时，就会对lambda表达式利用实现类的<em>print</em>()方法运行；</li>
<li>最后，将结果返回，并打印。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方法引用-1"><a class="header" href="#方法引用-1">方法引用</a></h1>
<p>方法引用 可以看作是 一个匿名内部类的实现,实质上是一个 匿名内部类的对象</p>
<h1 id="方法引用有四种"><a class="header" href="#方法引用有四种">方法引用有四种</a></h1>
<p><strong>指向静态方法的引用</strong></p>
<p><strong>指向某个对象的实例方法的引用</strong></p>
<p><strong>指向某个类型的实例方法的引用</strong></p>
<p><strong>指向构造方法的引用</strong></p>
<table><thead><tr><th>方法 引用</th><th>lambada表达式</th></tr></thead><tbody>
<tr><td><em>String::valueof</em>  (静态方法)</td><td><em>x-&gt;String.valueof(x)</em></td></tr>
<tr><td><em>Object::toString()</em> (对象的实例方法的引用)</td><td><em>x-&gt;x.toString();</em></td></tr>
<tr><td><em>x::toString()</em> (类型的实例方法的引用)</td><td><em>x-&gt;x.toString();</em></td></tr>
<tr><td><em>ArrayList::new</em> (构造方法的引用)</td><td><em>()-&gt;new ArrayList()</em></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="知识准备"><a class="header" href="#知识准备">知识准备</a></h1>
<h2 id="命令式编程与声明式编程"><a class="header" href="#命令式编程与声明式编程">命令式编程与声明式编程</a></h2>
<p>在命令式编程中 不仅控制要做什么，还要如何做</p>
<p>声明式编程只需要告诉该做什么 而怎么做 可以交给 jdk接口中的默认方法</p>
<h2 id="流支持两种类型的操作"><a class="header" href="#流支持两种类型的操作">流支持两种类型的操作</a></h2>
<ul>
<li>中间操作与终端操作</li>
<li>中间操作称为惰性操作</li>
<li>终端操作也称为急切操作</li>
<li>惰性操作不处理元素,直到流上调用急切操作</li>
</ul>
<h2 id="java可选类-optional"><a class="header" href="#java可选类-optional">java可选类 <em>Optional</em></a></h2>
<ul>
<li>获取值
<ul>
<li><em>get</em>:可以获取 获取为空抛异常</li>
<li><em>orElse</em>:获取不到返回其他值</li>
<li><em>orElseGet</em> 获取不到返回 <em>supplier</em>提供器提供的值</li>
<li><em>orElseThrow</em>:获取不到抛出 <em>supplier</em>提供的异常</li>
</ul>
</li>
<li>比较
<ul>
<li><em>equals</em>:调用其他对象的 equals方法</li>
</ul>
</li>
<li>操作
<ul>
<li><em>ifpresent</em> 如果存在则执行操作</li>
<li><em>ispresent</em> 判断是否存在</li>
<li><em>filter</em> 判断成功则返回 非空, 否则为空</li>
<li><em>map</em>: 通过 <em>Function&lt;? super T,? extends U&gt;</em> 将 <code>Option&lt;T&gt;</code> 转化为 <code>Optional&lt;U&gt;</code></li>
<li><em>flatmap</em> : <em>Function&lt;? super T, Optional<U>&gt; mapper</em> </li>
</ul>
</li>
</ul>
<h2 id="流操作必备概念"><a class="header" href="#流操作必备概念">流操作必备概念</a></h2>
<h3 id="functiontr--一元函数"><a class="header" href="#functiontr--一元函数"><em>Function&lt;T,R&gt;</em>  一元函数</a></h3>
<ul>
<li>
<p><em>R apply(T t);</em> 输入一个参数,返回一个结果</p>
</li>
<li>
<p><code>&lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before)</code> </p>
<p>​	前一个函数的 输出 作为当前函数的 输入</p>
</li>
<li>
<p><code>&lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after)</code></p>
<p>当前函数的 输出 作为 下一个函数的 输入</p>
</li>
<li>
<p><em>identity</em> 返回值本身</p>
</li>
</ul>
<h3 id="bifunctiont-u-r-二元函数"><a class="header" href="#bifunctiont-u-r-二元函数"><em>BiFunction&lt;T, U, R&gt;</em> 二元函数</a></h3>
<ul>
<li><em>R apply(T t, U u);</em> 比较</li>
<li>子类 <em>BinaryOperator</em> 二元比较操作
<ul>
<li><em>minBy</em></li>
<li><em>maxBy</em></li>
</ul>
</li>
</ul>
<h3 id="comparator-比较器"><a class="header" href="#comparator-比较器"><em>Comparator</em> 比较器</a></h3>
<ul>
<li>
<p><em>Comparator<T> thenComparing(Comparator&lt;? super T&gt; other)</em></p>
</li>
<li>
<p>如果比较相等 继续用下一个比较器比较</p>
</li>
<li>
<pre><code>&lt;U&gt; Comparator&lt;T&gt; thenComparing(
        Function&lt;? super T, ? extends U&gt; keyExtractor,
        Comparator&lt;? super U&gt; keyComparator)
</code></pre>
<ul>
<li>如果比较相等 , 继续用指定提取 后 的可比较的key</li>
</ul>
</li>
<li>
<p><em>thenComparingInt</em> <em>|long</em> | <em>double</em></p>
<ul>
<li>如果比较相等 , 继续用  指定提取后的 int类型比较</li>
</ul>
</li>
<li>
<p><em>reversed</em> 获得一个方向比较的 比较器</p>
</li>
<li>
<p><em>comparing</em> 返回 指定 keyextractor 和 keyComparator的 比较器</p>
</li>
<li>
<p><em>comparingInt</em>...</p>
</li>
</ul>
<h3 id="谓词判断"><a class="header" href="#谓词判断">谓词判断</a></h3>
<ul>
<li><em>test(T t)</em> 判断</li>
<li><em>and(Predicate&lt;? super T&gt; other)</em></li>
<li><em>negate()</em> 取反</li>
<li><em>or()</em> </li>
<li><em>Predicate<T> isEqual(Object targetRef)</em> 返回与目标引用相等的 谓词判断</li>
</ul>
<h3 id="提供器supplier"><a class="header" href="#提供器supplier">提供器<em>Supplier</em></a></h3>
<ul>
<li><em>T get()</em></li>
</ul>
<h3 id="一元操作"><a class="header" href="#一元操作">一元操作</a></h3>
<p><em>UnaryOperator extends Function&lt;T,T&gt;</em> </p>
<p>永远返回它本身</p>
<h3 id="消费者"><a class="header" href="#消费者">消费者</a></h3>
<p><em>void accept(T t);</em></p>
<p><code>Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after)</code> 在当前消费完之后,接着消费</p>
<h1 id="流的创建"><a class="header" href="#流的创建">流的创建</a></h1>
<h2 id="从值创建流"><a class="header" href="#从值创建流">从值创建流</a></h2>
<pre><code>1.值或者数组
&lt;T&gt; Stream&lt;T&gt; of(T...values)
2.流构建器
Stream&lt;String&gt; stream  = Stream.&lt;String&gt;builder()
        .add(&quot;XML&quot;)
        .add(&quot;Java&quot;)
        .add(&quot;CSS&quot;)
        .add(&quot;SQL&quot;)
        .build();
stream.forEach(System.out::println);
3.IntStream范围
IntStream oneToFive  = IntStream.range(1, 6);
IntStream oneToFive  = IntStream.rangeClosed(1, 5);
</code></pre>
<h2 id="从空流创建流"><a class="header" href="#从空流创建流">从空流创建流</a></h2>
<pre><code>Stream&lt;String&gt; stream  = Stream.empty();
</code></pre>
<h2 id="从函数创建流"><a class="header" href="#从函数创建流">从函数创建流</a></h2>
<pre><code>1.顺序创建有序流
&lt;T&gt; Stream&lt;T&gt; iterate(T  seed, UnaryOperator&lt;T&gt;  f)
2.生成重复值的无限流
&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)
3.随机流
java.util.Random类提供ints()，longs()和doubles()分别返回无限IntStream，LongStream和DoubleStream
 new Random().ints().limit(5).forEach(System.out::println);
</code></pre>
<ul>
<li>
<p>从其他<em>API</em>创建流</p>
<ul>
<li>
<p>可以从 各种集合创建流  <em>集合.stream()</em></p>
</li>
<li>
<p>可以从<em>CharSequence</em> 创建流</p>
</li>
<li>
<p>从正则创建流</p>
<pre><code>Pattern.compile(&quot;,&quot;)
    .splitAsStream(str)
    .forEach(System.out::println);
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="从文件创建流"><a class="header" href="#从文件创建流">从文件创建流</a></h2>
<ul>
<li>
<p>使用流从<em>JarFile</em>读取<em>JarEntry</em></p>
<pre><code>1.读取文件
Path path = Paths.get(&quot;D:\\smb.conf&quot;);
    try (Stream&lt;String&gt; lines = Files.lines(path)) {
      lines.forEach(System.out::println);
    } catch (IOException e) {
      e.printStackTrace();
    }
2.读取目录
public class Main {
  public static void main(String[] args) {
    Path dir = Paths.get(&quot;.&quot;);
    System.out.printf(&quot;%nThe file tree for %s%n&quot;, 
        dir.toAbsolutePath());
    try (Stream&lt;Path&gt; fileTree = Files.walk(dir)) {
      fileTree.forEach(System.out::println);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}
</code></pre>
</li>
</ul>
<h1 id="中间操作"><a class="header" href="#中间操作">中间操作</a></h1>
<h2 id="查找与匹配"><a class="header" href="#查找与匹配">查找与匹配</a></h2>
<p><em>allMatch</em></p>
<p><em>findAny</em></p>
<p><em>findFirst</em></p>
<p><em>noneMatch</em></p>
<h2 id="过滤"><a class="header" href="#过滤">过滤</a></h2>
<p><em>filter</em> </p>
<p>使用谓词过滤</p>
<h2 id="映射"><a class="header" href="#映射">映射</a></h2>
<ul>
<li><em>flatMap</em> 支持一对多映射</li>
<li><em>map</em> 支持一对一映射</li>
</ul>
<h2 id="截取与跳过"><a class="header" href="#截取与跳过">截取与跳过</a></h2>
<p><em>limit</em></p>
<p><em>skip</em></p>
<h2 id="排序与去重"><a class="header" href="#排序与去重">排序与去重</a></h2>
<p><em>distinct</em></p>
<ul>
<li>对流中的每个元素去重</li>
</ul>
<p><em>sorted</em></p>
<ul>
<li>对流中的每个元素排序</li>
</ul>
<h1 id="终止操作"><a class="header" href="#终止操作">终止操作</a></h1>
<h2 id="遍历与查看"><a class="header" href="#遍历与查看">遍历与查看</a></h2>
<p><em>forEach</em></p>
<ul>
<li>遍历流中的每个元素</li>
</ul>
<p><em>peek</em></p>
<h2 id="组合"><a class="header" href="#组合">组合</a></h2>
<p><em>reduce</em></p>
<ul>
<li>
<p>需要一个种子与累加器</p>
</li>
<li>
<p><em>sum()，max()，min()，count()</em> 这些适合于数值流</p>
</li>
</ul>
<h2 id="聚合"><a class="header" href="#聚合">聚合</a></h2>
<p>类似于组合,专门用于数值的聚合</p>
<p>sum</p>
<p>max</p>
<p>min</p>
<p>count</p>
<h2 id="流收集-通用"><a class="header" href="#流收集-通用">流收集-通用</a></h2>
<p>提供要如何收集的收集器</p>
<p>collect</p>
<pre><code>针对提供自定义容器
&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)

Supplier&lt;ArrayList&lt;String&gt;&gt; supplier = () -&gt; new ArrayList&lt;&gt;();
Supplier&lt;ArrayList&lt;String&gt;&gt; supplier = ArrayList::new;

提供容器收集的累加器
BiConsumer&lt;ArrayList&lt;String&gt;, String&gt;  accumulator = ArrayList::add;

组合器仅用于并行流。
List&lt;String&gt; names = Employee.persons()
        .stream()
        .map(Employee::getName)
        .collect(ArrayList::new,  ArrayList::add, ArrayList::addAll);
    System.out.println(names);
</code></pre>
<p>collector</p>
<ul>
<li>常见的 <em>toList()</em>，<em>toSet()<em>和</em>toCollection()</em></li>
</ul>
<h2 id="流收集-摘要"><a class="header" href="#流收集-摘要">流收集-摘要</a></h2>
<p>类别</p>
<ul>
<li>
<p><em>DoubleSummaryStatistics</em></p>
</li>
<li>
<p><em>LongSummaryStatistics</em></p>
</li>
<li>
<p><em>IntSummaryStatistics</em></p>
</li>
<li>
<p>Collectors.summarizingDouble()返回DoubleSummaryStatistics。</p>
</li>
<li>
<p>Collectors.summarizingLong()返回一个LongSummaryStatistics。</p>
</li>
<li>
<p>Collectors.summarizingInt()返回一个IntSummaryStatistics。</p>
</li>
</ul>
<p>案例</p>
<pre><code class="language-java">    DoubleSummaryStatistics incomeStats = Employee.persons()
        .stream()
        .map(Employee::getIncome)
        .collect(DoubleSummaryStatistics::new, 
                 DoubleSummaryStatistics::accept, 
                 DoubleSummaryStatistics::combine);
     System.out.println(incomeStats);
</code></pre>
<h2 id="流收集-映射"><a class="header" href="#流收集-映射">流收集-映射</a></h2>
<pre><code>toMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper)


toMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction)


toMap(Function&lt;? super T,? extends K&gt; keyMapper, Function&lt;? super T,? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt;  mapSupplier)
</code></pre>
<pre><code>System.out.println(
        Stream.of(&quot;aac&quot;, &quot;bbb&quot;, &quot;ccc&quot;).
        map(a -&gt; a.split(&quot;&quot;)).
        flatMap(Arrays::stream).
        collect(
                Collectors.toMap(k-&gt;k, v -&gt; 1, (k1, k2) -&gt; k1 + 1)
        )
  );
</code></pre>
<h2 id="流收集-连接"><a class="header" href="#流收集-连接">流收集-连接</a></h2>
<pre><code>joining()
joining(CharSequence delimiter)
joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)
适用于string流
     String  prefixedNames = persons.stream()
        .map(Employee::getName)
        .collect(Collectors.joining(&quot;, &quot;, &quot;Hello &quot;,  &quot;.  Goodbye.&quot;));
</code></pre>
<h2 id="流收集-分组"><a class="header" href="#流收集-分组">流收集-分组</a></h2>
<p>给定 分组器 和 分组后的 子组收集器</p>
<pre><code class="language-java">groupingBy(Function&lt;? super  T,?  extends K&gt;  classifier)

groupingBy(Function&lt;? super  T,?  extends K&gt;  classifier,  Collector&lt;? super T,A,D&gt; downstream)

groupingBy(Function&lt;? super  T,?  extends K&gt;  classifier, Supplier&lt;M&gt;  mapFactory, Collector&lt;? super T,A,D&gt; downstream)
</code></pre>
<p><strong>示例</strong>1</p>
<pre><code class="language-java"> Comparator&lt;Person&gt; byHeight = Comparator.comparing(Person::getHeight);
   Map&lt;String, Optional&lt;Person&gt;&gt; tallestByCity = people.stream()
             .collect(Collectors.groupingBy(Person::getCity, Collectors.reducing(BinaryOperator.maxBy(byHeight))));
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>Map&lt;Employee.Gender, String&gt;  namesByGender = Employee.persons()
    .stream()
    .collect(Collectors.groupingBy(Employee::getGender, 
                                   Collectors.mapping(Employee::getName, Collectors.joining(&quot;, &quot;))));
</code></pre>
<h2 id="流收集-分区"><a class="header" href="#流收集-分区">流收集-分区</a></h2>
<p>只能分两个区,通过谓词划分</p>
<pre><code>partitioningBy(Predicate&lt;? super T&gt; predicate)

partitioningBy(Predicate&lt;? super T&gt; predicate,  Collector&lt;? super T,A,D&gt; downstream)

Map&lt;Boolean,  List&lt;Employee&gt;&gt;  partionedByMaleGender = 
    Employee.persons()
            .stream()
            .collect(Collectors.partitioningBy(Employee::isMale)); 
    System.out.println(partionedByMaleGender);
 
</code></pre>
<h2 id="流收集-转换"><a class="header" href="#流收集-转换">流收集-转换</a></h2>
<p>第一个参数是收集数据的收集器。 第二个参数是转换结果的转换器。</p>
<p>A是累积的元素类型</p>
<p>T是输入的类型</p>
<p>R是 累积的结果</p>
<p>RR是转换的结果</p>
<pre><code>collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt;  finisher)

    List&lt;String&gt; names = Employee.persons()
        .stream()
        .map(Employee::getName)
        .collect(Collectors.collectingAndThen(Collectors.toList(),
             result -&gt;  Collections.unmodifiableList(result)));  
</code></pre>
<h1 id="并行流"><a class="header" href="#并行流">并行流</a></h1>
<p>顺序流上的操作由一个线程串行处理。</p>
<p>使用多个线程并行处理并行流上的操作。</p>
<pre><code>Stream.iterate(1L,i-&gt;i+1).limit(n).parllel().reduce(0L,Long::sum)
</code></pre>
<h1 id="collector接口"><a class="header" href="#collector接口">Collector接口</a></h1>
<pre><code> Supplier&lt;A&gt; supplier();
 BiConsumer&lt;A, T&gt; accumulator();
 BinaryOperator&lt;A&gt; combiner();
 Function&lt;A, R&gt; finisher();
 Set&lt;Characteristics&gt; characteristics();
</code></pre>
<pre><code class="language-java">package com.weisanju.stream;

import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;

class GroupingWithKeys&lt;T, K&gt; implements Collector&lt;T, Map&lt;K, List&lt;T&gt;&gt;, Map&lt;K, List&lt;T&gt;&gt;&gt; {

    private List&lt;K&gt; possibleKeys = Collections.emptyList();
    private final Function&lt;T, K&gt; keyGenerator;

    @SafeVarargs
    public GroupingWithKeys(Function&lt;T, K&gt; keyGenerator, K... possibleKeys) {  //构造时传入 Key 生成器和可能的 Keys
        if (possibleKeys != null) {
            this.possibleKeys = Arrays.asList(possibleKeys);
        }
        this.keyGenerator = keyGenerator;
    }

    @Override
    public Supplier&lt;Map&lt;K, List&lt;T&gt;&gt;&gt; supplier() {
        return () -&gt; {
            Map&lt;K, List&lt;T&gt;&gt; map = new LinkedHashMap&lt;&gt;();
            possibleKeys.forEach(s -&gt; map.put(s, new ArrayList&lt;T&gt;())); //按 possibleKeys 依次用空列表填充 Map
            return map;
        };
    }

    @Override
    public BiConsumer&lt;Map&lt;K, List&lt;T&gt;&gt;, T&gt; accumulator() {
        return (map, t) -&gt; {
          List&lt;T&gt; ts = map.computeIfAbsent(keyGenerator.apply(t), (e) -&gt; new ArrayList&lt;&gt;());
          ts.add(t);
        };
    }

    @Override
    public BinaryOperator&lt;Map&lt;K, List&lt;T&gt;&gt;&gt; combiner() {
        return (map1, map2) -&gt; {
            map1.putAll(map2);
            return map1;
        };
    }

    @Override
    public Function&lt;Map&lt;K, List&lt;T&gt;&gt;, Map&lt;K, List&lt;T&gt;&gt;&gt; finisher() {
        return Function.identity();
    }

    @Override
    public Set&lt;Characteristics&gt; characteristics() {
        return Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH, Characteristics.CONCURRENT));
    }
}
</code></pre>
<h1 id="spliterator接口"><a class="header" href="#spliterator接口">Spliterator接口</a></h1>
<h2 id="接口方法"><a class="header" href="#接口方法">接口方法</a></h2>
<table><thead><tr><th>方法名</th><th>解析</th></tr></thead><tbody>
<tr><td>boolean tryAdvance(Consumer&lt;? super T&gt; action)</td><td>如果元素存在，则对它进行处理，并返回true，否则返回false。<br />如果我们不想处理stream后续的元素，则在tryAdvance中返回false即可，利用这个特征，可以中断stream的处理。</td></tr>
<tr><td>Spliterator<T> trySplit()</td><td>trySplit尝试对现有的stream进行分拆，一般用在parallelStream的情况，因为在并发stream下，我们需要用多线程去处理stream的不同元素，trySplit就是对stream中元素进行分拆处理的方法。<br />理想情况下trySplit应该将stream拆分成数目相同的两部分才能最大提升性能。</td></tr>
<tr><td>long estimateSize();</td><td>表示Spliterator中待处理的元素</td></tr>
<tr><td>characteristics</td><td>Spliterator的特征<br />ORDERED    = 0x00000010;//表示元素是有序的（每一次遍历结果相同） <br />DISTINCT   = 0x00000001;//表示元素不重复 <br />SORTED     = 0x00000004;//表示元素是按一定规律进行排列（有指定比较器） <br />SIZED      = 0x00000040;// 表示大小是固定的 <br />NONNULL    = 0x00000100;//表示没有null元素 <br />IMMUTABLE  = 0x00000400;//表示元素不可变 <br /> CONCURRENT = 0x00001000;//表示迭代器可以多线程操作 <br /> SUBSIZED   = 0x00004000;//表示子Spliterators都具有SIZED特性<br />一个Spliterator可以有多个特征，多个特征进行or运算，最后得到最终的characteristics。</td></tr>
</tbody></table>
<p>​	</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="校验框架介绍"><a class="header" href="#校验框架介绍">校验框架介绍</a></h1>
<p>JSR303 是一套JavaBean参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们JavaBean的属性上面，就可以在需要校验的时候进行校验了。注解如下：</p>
<h2 id="jsr303注解"><a class="header" href="#jsr303注解">JSR303注解</a></h2>
<h2 id="空检查"><a class="header" href="#空检查">空检查</a></h2>
<table><thead><tr><th>注解名</th><th>验证对象</th><th>说明</th></tr></thead><tbody>
<tr><td><strong>@NotEmpty</strong></td><td>集合类</td><td>；不能为null，而且长度必须大于0</td></tr>
<tr><td><strong>@NotBlank</strong></td><td>String</td><td>只能作用在String上，不能为null，而且调用trim()后，长度必须大于0</td></tr>
<tr><td><strong>@NotNull</strong></td><td>用在基本类型上</td><td>不能为null，但可以为empty。</td></tr>
<tr><td><strong>@Null</strong></td><td>用在基本类型上</td><td>被注释的元素必须为null</td></tr>
</tbody></table>
<h2 id="长度检查"><a class="header" href="#长度检查"><strong>长度检查</strong></a></h2>
<table><thead><tr><th>注解名</th><th>验证对象</th><th>说明</th></tr></thead><tbody>
<tr><td><strong>@Size(min=,max=)</strong></td><td>Array,Collection,Map,String</td><td>长度是否在给定的范围之内</td></tr>
<tr><td><strong>@Length(min=, max=)</strong></td><td>String 类型</td><td>长度是否在给定的范围之内</td></tr>
</tbody></table>
<h2 id="booelan检查"><a class="header" href="#booelan检查">Booelan检查</a></h2>
<table><thead><tr><th>注解名</th><th>验证对象</th><th>说明</th></tr></thead><tbody>
<tr><td><strong>@AssertTrue</strong></td><td>bool</td><td>验证 Boolean 对象是否为 true</td></tr>
<tr><td><strong>@AssertFalse</strong></td><td>bool</td><td>验证 Boolean 对象是否为 false</td></tr>
</tbody></table>
<h2 id="日期检查"><a class="header" href="#日期检查">日期检查</a></h2>
<table><thead><tr><th>注解名</th><th>验证对象</th><th>说明</th></tr></thead><tbody>
<tr><td><strong>@Past</strong></td><td>date,Calendar</td><td>验证是否在当前时间之前</td></tr>
<tr><td><strong>@Future</strong></td><td>date,Calendar</td><td>验证 String 对象是否符合正则表达式的规则</td></tr>
<tr><td><strong>@Pattern</strong></td><td>String 对象</td><td>是否符合正则表达式的规则</td></tr>
</tbody></table>
<h2 id="数值检查"><a class="header" href="#数值检查">数值检查</a></h2>
<table><thead><tr><th>注解名</th><th>验证对象</th><th>说明</th></tr></thead><tbody>
<tr><td><strong>@Min</strong>,<strong>@Max</strong></td><td>Number 和 String 对象</td><td>是否大等于指定的值</td></tr>
<tr><td><strong>@DecimalMax</strong>,<strong>@DecimalMin</strong></td><td>BigDecimal,数值类型</td><td></td></tr>
<tr><td><strong>@Digits</strong></td><td>Number 和 String</td><td>验证 Number 和 String 的构成是否合法</td></tr>
<tr><td><strong>@Digits(integer=,fraction=)</strong></td><td>字符串</td><td>验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。</td></tr>
</tbody></table>
<p>Hibernate validator 在JSR303的基础上对校验注解进行了扩展，扩展注解如下：</p>
<h2 id="hibernate扩展注解"><a class="header" href="#hibernate扩展注解">Hibernate扩展注解</a></h2>
<table><thead><tr><th>注解名</th><th>说明</th></tr></thead><tbody>
<tr><td>@Email</td><td>被注释的元素必须是电子邮箱</td></tr>
<tr><td>@Length</td><td>字符串的长度</td></tr>
<tr><td>@NotEmpty</td><td>字符串非空</td></tr>
<tr><td>@Range</td><td>指定范围</td></tr>
</tbody></table>
<p>Spring validtor 同样扩展了jsr303,并实现了方法参数和返回值的校验</p>
<p>Spring 提供了MethodValidationPostProcessor类，用于对方法的校验</p>
<h1 id="声明-java-bean-约束"><a class="header" href="#声明-java-bean-约束">声明 Java Bean 约束</a></h1>
<h2 id="字段级别约束"><a class="header" href="#字段级别约束">字段级别约束</a></h2>
<pre><code class="language-java">@NotNull
private String manufacturer;
</code></pre>
<h2 id="属性级别约束"><a class="header" href="#属性级别约束">属性级别约束</a></h2>
<pre><code class="language-java">@NotNull
public String getManufacturer(){
  return manufacturer;
}
</code></pre>
<h2 id="容器级别约束"><a class="header" href="#容器级别约束">容器级别约束</a></h2>
<pre><code class="language-java">private Map&lt;@NotNull FuelConsumption, @MaxAllowedFuelConsumption Integer&gt; fuelConsumption = new HashMap&lt;&gt;();
</code></pre>
<h2 id="类级别约束"><a class="header" href="#类级别约束">类级别约束</a></h2>
<p>在这种情况下，验证的对象不是单个属性，而是完整的对象。如果验证依赖于对象的多个属性之间的相关性，则类级约束非常有用。
如：汽车中，乘客数量不能大于座椅数量，否则超载</p>
<pre><code class="language-java">@ValidPassengerCount
public class Car {

    private int seatCount;

    private List&lt;Person&gt; passengers;

    //...
}
</code></pre>
<h2 id="约束继承"><a class="header" href="#约束继承">约束继承</a></h2>
<p>当一个类继承/实现另一个类时，父类声明的所有约束也会应用在子类继承的对应属性上。
如果方法<code>重写</code>，约束注解将会聚合，也就是此方法父类和子类声明的约束都会起作用。</p>
<h2 id="级联验证"><a class="header" href="#级联验证">级联验证</a></h2>
<p><code>Bean Validation API</code> 不仅允许验证单个类实例，也支持级联验证。</p>
<p>只需使用 <code>@Valid</code> 修饰对象属性的引用，则对象属性中声明的所有约束也会起作用。</p>
<pre><code class="language-java">public class Car {
    @NotNull
    @Valid
    private Person driver;
    //...
}
public class Person {
    @NotNull
    private String name;
    //...
}
</code></pre>
<h1 id="声明方法约束"><a class="header" href="#声明方法约束">声明方法约束</a></h1>
<h2 id="参数约束"><a class="header" href="#参数约束">参数约束</a></h2>
<p>通过向方法或构造函数的参数添加约束注解来指定方法或构造函数的<code>前置条件</code>，官方示例如下：</p>
<pre><code class="language-java">public RentalStation(@NotNull String name){}

public void rentCar(@NotNull Customer customer,
                          @NotNull @Future Date startDate,
                          @Min(1) int durationInDays){}
</code></pre>
<h2 id="返回值约束"><a class="header" href="#返回值约束">返回值约束</a></h2>
<p>通过在方法体上添加约束注解来给方法或构造函数指定<code>后置条件</code>，官方示例如下：</p>
<pre><code class="language-java">public class RentalStation {
    @ValidRentalStation
    public RentalStation() {
        //...
    }
    @NotNull
    @Size(min = 1)
    public List&lt;@NotNull Customer&gt; getCustomers() {
        //...
        return null;
    }
}
</code></pre>
<p>此示例指定了三个约束：</p>
<ul>
<li>任何新创建的 RentalStation 对象都必须满足 @validRentalStation 约束</li>
<li>getCustomers() 返回的客户列表不能为空，并且必须至少包含 1 个元素</li>
<li>getCustomers() 返回的客户列表不能包含空对象</li>
</ul>
<h2 id="级联约束"><a class="header" href="#级联约束">级联约束</a></h2>
<p>类似于 JavaBeans 属性的级联验证，<code>@Valid</code> 注解可用于标记方法参数和返回值的级联验证。</p>
<p>类似于 javabeans 属性的级联验证（参见第 2.1.6 节“对象图”），@valid 注释可用于标记可执行参数和级联验证的返回值。当验证用@valid 注释的参数或返回值时，也会验证在参数或返回值对象上声明的约束。
而且，也可用在容器元素中。</p>
<pre><code class="language-java">public class Garage {
    public boolean checkCars(@NotNull List&lt;@Valid Car&gt; cars) {
        //...
        return false;
    }
}
</code></pre>
<h2 id="继承验证"><a class="header" href="#继承验证">继承验证</a></h2>
<p>当在继承体系中声明方法约束时，必须了解两个规则：</p>
<ul>
<li>方法调用方要满足前置条件不能在子类型中得到加强 参数</li>
<li>方法调用方要保证后置条件不能再子类型中被削弱 返回值</li>
</ul>
<p>这些规则是由子类行为概念所决定的：在使用类型 T 的任何地方，也能在不改变程序行为的情况下使用 T 的子类。</p>
<p>当两个类分别有一个同名且形参列表相同的方法，而另一个类用一个方法重写/实现上述两个类的同名方法时，这两个父类的同名方法上不能有任何参数约束，因为不管怎样都会与上述规则冲突。
示例：</p>
<pre><code class="language-java">public interface Vehicle {
  void drive(@Max(75) int speedInMph);
}
public interface Car {
  void drive(int speedInMph);
}

public class RacingCar implements Car, Vehicle {
  @Override
  public void drive(int speedInMph) {
      //...
  }
}
</code></pre>
<h1 id="分组约束"><a class="header" href="#分组约束">分组约束</a></h1>
<p><code>注意</code>：上述的 22 个约束注解都有 <code>groups</code> 属性。当不指定 groups 时，默认为 <code>Default</code> 分组。</p>
<p><code>JSR</code> 规范支持手动校验，不直接支持使用注解校验，不过 <code>spring</code> 提供了分组校验注解扩展支持，即：<code>@Validated</code>，参数为 group 类集合</p>
<h2 id="分组继承"><a class="header" href="#分组继承">分组继承</a></h2>
<p>在某些场景下，需要定义一个组，它包含其它组的约束，可以用分组继承。
如：</p>
<pre><code class="language-java">public class SuperCar extends Car {
    @AssertTrue(
            message = &quot;Race car must have a safety belt&quot;,
            groups = RaceCarChecks.class
    )
    private boolean safetyBelt;
    // getters and setters ...
}
public interface RaceCarChecks extends Default {}
</code></pre>
<p>但因为此处，是想 <code>Default</code> 分组一直都要校验</p>
<pre><code class="language-java">public interface DefaultInherGroup extends Default {}
</code></pre>
<h2 id="定义分组序列"><a class="header" href="#定义分组序列">定义分组序列</a></h2>
<p>默认情况下，不管约束是属于哪个分组，它们的计算是没有特定顺序的，而在某些场景下，控制约束的计算顺序是有用的。
如：先检查汽车的默认约束，再检查汽车的性能约束，最后在开车前，检查驾驶员的实际约束。
可以定义一个接口，并用 <code>@GroupSequence</code> 来定义需要验证的分组的序列。</p>
<pre><code class="language-java">@GroupSequence({ Default.class, CarChecks.class, DriverChecks.class })
public interface OrderedChecks {}
</code></pre>
<p>此分组用法与其它分组一样，只是此分组拥有按分组顺序校验的功能</p>
<blockquote>
<p>定义序列的组和组成序列的组不能通过级联序列定义或组继承直接或间接地参与循环依赖关系。如果对包含此类循环的组计算，则会引发 GroupDefinitionException。</p>
</blockquote>
<h2 id="重新定义默认分组序列"><a class="header" href="#重新定义默认分组序列">重新定义默认分组序列</a></h2>
<h4 id="groupsequence"><a class="header" href="#groupsequence">@GroupSequence</a></h4>
<p><code>@GroupSequence</code> 除了定义分组序列外，还允许重新定义指定类的默认分组。为此，只需将<code>@GroupSequence</code> 添加到类中，并在注解中用指定序列的分组替换 <code>Default</code> 默认分组。</p>
<pre><code class="language-java">@GroupSequence({ RentalChecks.class, CarChecks.class, RentalCar.class })
public class RentalCar extends Car {}
</code></pre>
<p>在验证约束时，直接把其当做默认分组方式来验证</p>
<h4 id="groupsequenceprovider"><a class="header" href="#groupsequenceprovider">@GroupSequenceProvider</a></h4>
<p>注意：此为 hibernate-validator 提供，JSR 规范不支持</p>
<p>可用于根据对象状态动态地重新定义默认分组序列。
需要做两步：</p>
<ol>
<li>实现接口：DefaultGroupSequenceProvider</li>
<li>在指定类上使用 @GroupSequenceProvider，并指定 value 为上一步的类</li>
</ol>
<pre><code class="language-java">public class RentalCarGroupSequenceProvider
        implements DefaultGroupSequenceProvider&lt;RentalCar&gt; {
    @Override
    public List&lt;Class&lt;?&gt;&gt; getValidationGroups(RentalCar car) {
        List&lt;Class&lt;?&gt;&gt; defaultGroupSequence = new ArrayList&lt;Class&lt;?&gt;&gt;();
        defaultGroupSequence.add( RentalCar.class );
        if ( car != null &amp;&amp; !car.isRented() ) {
            defaultGroupSequence.add( CarChecks.class );
        }
        return defaultGroupSequence;
    }
}
@GroupSequenceProvider(RentalCarGroupSequenceProvider.class)
public class RentalCar extends Car {
    @AssertFalse(message = &quot;The car is currently rented out&quot;, groups = RentalChecks.class)
    private boolean rented;
    public RentalCar(String manufacturer, String licencePlate, int seatCount) {
        super( manufacturer, licencePlate, seatCount );
    }
    public boolean isRented() {
        return rented;
    }
    public void setRented(boolean rented) {
        this.rented = rented;
    }
}
</code></pre>
<h2 id="分组转换"><a class="header" href="#分组转换">分组转换</a></h2>
<p>如果你想把与汽车相关的检查和驾驶员检查一起验证呢？当然，您可以显式地指定验证多个组，但是如果您希望将这些验证作为默认组验证的一部分进行，该怎么办？这里@ConvertGroup 开始使用，它允许您在级联验证期间使用与最初请求的组不同的组。</p>
<p>在可以使用 @Valid 的任何地方，都能定义分组转换，也可以在同一个元素上定义多个分组转换
必须满足以下限制：</p>
<ul>
<li>@ConvertGroup 只能与 @Valid 结合使用。如果不是，则抛出 ConstraintDeclarationException。</li>
<li>在同一元素上有多个 from 值相同的转换规则是不合法的。在这种情况下，将抛出 ConstraintDeclarationException。</li>
<li>from 属性不能引用分组序列。在这种情况下会抛出 ConstraintDeclarationException</li>
</ul>
<pre><code class="language-java">// 当 driver 为 null 时，不会级联验证，使用的是默认分组，当级联验证时，使用的是 DriverChecks 分组 @Valid @ConvertGroup(from = Default.class, to = DriverChecks.class) private Driver driver;
</code></pre>
<h1 id="全局异常处理"><a class="header" href="#全局异常处理">全局异常处理</a></h1>
<h2 id="引包"><a class="header" href="#引包"><strong>引包</strong></a></h2>
<pre><code class="language-xml">    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
    &lt;/dependency&gt;
</code></pre>
<h2 id="全局异常处理-1"><a class="header" href="#全局异常处理-1"><strong>全局异常处理</strong></a></h2>
<pre><code class="language-java">@ControllerAdvice
public class WebExceptionHandler {
　　 //处理Get请求中 使用@Valid 验证路径中请求实体校验失败后抛出的异常，详情继续往下看代码
    @ExceptionHandler(BindException.class)
    @ResponseBody
    public ResponseVO BindExceptionHandler(BindException e) {
        String message = e.getBindingResult().getAllErrors().stream().map(DefaultMessageSourceResolvable::getDefaultMessage).collect(Collectors.joining());
        return new ResponseVO(message);
    }

    //处理请求参数格式错误 @RequestParam上validate失败后抛出的异常是javax.validation.ConstraintViolationException
    @ExceptionHandler(ConstraintViolationException.class)
    @ResponseBody
    public ResponseVO ConstraintViolationExceptionHandler(ConstraintViolationException e) {
        String message = e.getConstraintViolations().stream().map(ConstraintViolation::getMessage).collect(Collectors.joining());
        return new ResponseVO(message);
    }

    //处理请求参数格式错误 @RequestBody上validate失败后抛出的异常是MethodArgumentNotValidException异常。
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody
    public ResponseVO MethodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e) {
        String message = e.getBindingResult().getAllErrors().stream().map(DefaultMessageSourceResolvable::getDefaultMessage).collect(Collectors.joining());
        return new ResponseVO(message);
    }
}
</code></pre>
<p><strong>多异常统一处理</strong></p>
<pre><code class="language-java">// @RestControllerAdvice

    /*  数据校验处理 */
    @ExceptionHandler({BindException.class, ConstraintViolationException.class})
    public String validatorExceptionHandler(Exception e) {
        String msg = e instanceof BindException ? msgConvertor(((BindException) e).getBindingResult())
            : msgConvertor(((ConstraintViolationException) e).getConstraintViolations());

        return msg;
    }

    /**
     * 校验消息转换拼接
     *
     * @param bindingResult
     * @return
     */
    public static String msgConvertor(BindingResult bindingResult) {
        List&lt;FieldError&gt; fieldErrors = bindingResult.getFieldErrors();
        StringBuilder sb = new StringBuilder();
        fieldErrors.forEach(fieldError -&gt; sb.append(fieldError.getDefaultMessage()).append(&quot;,&quot;));

        return sb.deleteCharAt(sb.length() - 1).toString().toLowerCase();
    }

    private String msgConvertor(Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations) {
        StringBuilder sb = new StringBuilder();
        constraintViolations.forEach(violation -&gt; sb.append(violation.getMessage()).append(&quot;,&quot;));

        return sb.deleteCharAt(sb.length() - 1).toString().toLowerCase();
    }

</code></pre>
<h1 id="嵌套对象的校验"><a class="header" href="#嵌套对象的校验">嵌套对象的校验</a></h1>
<pre><code class="language-java">@Setter
@Getter
public class BuyFlowerRequest {

    @NotEmpty(field = &quot;花名&quot;)
    private String name;

    @Min(field = &quot;价格&quot;, value = 1)
    private int price;

    @NotNull
    private List&lt;PayType&gt; payTypeList;

} 

@Setter
@Getter
public class PayType {

    @Valid
    @Min(value = 1)
    private int payType;

    @Valid
    @Min(value = 1)
    private int payAmount;

}
</code></pre>
<h1 id="三种校验方式"><a class="header" href="#三种校验方式">三种校验方式</a></h1>
<h2 id="全局异常处理-2"><a class="header" href="#全局异常处理-2">全局异常处理</a></h2>
<p>在Controller方法参数前加@Valid注解——校验不通过时直接抛异常</p>
<h2 id="用户自行判断并处理"><a class="header" href="#用户自行判断并处理">用户自行判断并处理</a></h2>
<p>在Controller方法参数前加@Valid注解，参数后面定义一个BindingResult类型参数——执行时会将校验结果放进bindingResult里面，用户自行判断并处理</p>
<pre><code class="language-java">@PostMapping(&quot;/test2&quot;)
	public Object test2(@RequestBody @Valid User user, BindingResult bindingResult) {
		// 参数校验
		if (bindingResult.hasErrors()) {
			String messages = bindingResult.getAllErrors()
				.stream()
				.map(ObjectError::getDefaultMessage)
				.reduce((m1, m2) -&gt; m1 + &quot;；&quot; + m2)
				.orElse(&quot;参数输入有误！&quot;);
			throw new IllegalArgumentException(messages);
		}
		return &quot;操作成功！&quot;;


	}
</code></pre>
<h5 id="bindingresult-的使用"><a class="header" href="#bindingresult-的使用">BindingResult 的使用</a></h5>
<p><code>BindingResult</code>必须跟在被校验参数之后,若被校验参数之后没有<code>BindingResult</code>对象，将会抛出<code>BindException</code>。</p>
<h2 id="手动验证"><a class="header" href="#手动验证">手动验证</a></h2>
<p>用户手动调用对应API执行校验——Validation.buildDefault ValidatorFactory().getValidator().validate(xxx)</p>
<pre><code class="language-java">    /**
 * 用户手动调用对应API执行校验
 * @param user
 * @return
 */
@PostMapping(&quot;/test3&quot;)
public Object test3(@RequestBody User user) {
	// 参数校验
	validate(user);
	
	return &quot;操作成功！&quot;;
}
 
private void validate(@Valid User user) {
	Set&lt;ConstraintViolation&lt;@Valid User&gt;&gt; validateSet = Validation.buildDefaultValidatorFactory()
			.getValidator()
			.validate(user, new Class[0]);
		if (!CollectionUtils.isEmpty(validateSet)) {
			String messages = validateSet.stream()
				.map(ConstraintViolation::getMessage)
				.reduce((m1, m2) -&gt; m1 + &quot;；&quot; + m2)
				.orElse(&quot;参数输入有误！&quot;);
			throw new IllegalArgumentException(messages);
			
		}
}
</code></pre>
<p><strong>获取Validtor对象</strong></p>
<pre><code class="language-java">import org.hibernate.validator.HibernateValidator;
import org.springframework.util.ClassUtils;
import org.springframework.validation.BindException;
import org.springframework.validation.DataBinder;
import org.springframework.validation.SmartValidator;
import org.springframework.validation.beanvalidation.SpringValidatorAdapter;

import javax.validation.ConstraintViolation;
import javax.validation.ConstraintViolationException;
import javax.validation.Validation;
import javax.validation.Validator;
import java.util.Set;

/**
 * hibernate-validator校验工具类
 */
public class ValidatorUtils {
    private static Validator validator;
    private static SmartValidator validatorAdapter;

    static {
        // 快速返回模式
        validator = Validation.byProvider(HibernateValidator.class)
            .configure()
            .failFast(true)
            .buildValidatorFactory()
            .getValidator();
    }

    public static Validator getValidator() {
        return validator;
    }

    private static SmartValidator getValidatorAdapter(Validator validator) {
        if (validatorAdapter == null) {
            validatorAdapter = new SpringValidatorAdapter(validator);
        }
        return validatorAdapter;
    }

    /**
     * 校验参数，用于普通参数校验 [未测试！]
     *
     * @param
     */
    public static void validateParams(Object... params) {
        Set&lt;ConstraintViolation&lt;Object&gt;&gt; constraintViolationSet = validator.validate(params);

        if (!constraintViolationSet.isEmpty()) {
            throw new ConstraintViolationException(constraintViolationSet);
        }
    }

    /**
     * 校验对象
     *
     * @param object
     * @param groups
     * @param &lt;T&gt;
     */
    public static &lt;T&gt; void validate(T object, Class&lt;?&gt;... groups) {
        Set&lt;ConstraintViolation&lt;T&gt;&gt; constraintViolationSet = validator.validate(object, groups);

        if (!constraintViolationSet.isEmpty()) {
            throw new ConstraintViolationException(constraintViolationSet);
        }
    }

    /**
     * 校验对象
     * 使用与 Spring 集成的校验方式。
     * 
     * @param object 待校验对象
     * @param groups 待校验的组
     * @throws BindException
     */
    public static &lt;T&gt; void validateBySpring(T object, Class&lt;?&gt;... groups)
        throws BindException {
        DataBinder dataBinder = getBinder(object);
        dataBinder.validate((Object[]) groups);

        if (dataBinder.getBindingResult().hasErrors()) {
            throw new BindException(dataBinder.getBindingResult());
        }
    }

    private static &lt;T&gt; DataBinder getBinder(T object) {
        DataBinder dataBinder = new DataBinder(object, ClassUtils.getShortName(object.getClass()));
        dataBinder.setValidator(getValidatorAdapter(validator));
        return dataBinder;
    }

}
</code></pre>
<h1 id="快速失败"><a class="header" href="#快速失败">快速失败</a></h1>
<p><strong>校验完后不继续校验</strong></p>
<pre><code class="language-java">@Configuration
public class WebConfig {
    @Bean
    public Validator validator() {
        ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class)
                .configure()
                //failFast的意思只要出现校验失败的情况，就立即结束校验，不再进行后续的校验。
                .failFast(true)
                .buildValidatorFactory();

        return validatorFactory.getValidator();
    }

    @Bean
    public MethodValidationPostProcessor methodValidationPostProcessor() {
        MethodValidationPostProcessor methodValidationPostProcessor = new MethodValidationPostProcessor();
        methodValidationPostProcessor.setValidator(validator());
        return methodValidationPostProcessor;
    }
}
</code></pre>
<h1 id="绑定多个校验对象"><a class="header" href="#绑定多个校验对象">绑定多个校验对象</a></h1>
<pre><code class="language-java">@PostMapping(&quot;save&quot;)
public void v1(@RequestBody @Valid AppUser appUser,BindingResult result,@RequestBody @Valid AppUser appUser2,BindingResult result2){
      if(result.hasErrors()){
            for (ObjectError error : result.getAllErrors()) {
                System.out.println(error.getDefaultMessage());
            }
        }
}
</code></pre>
<h1 id="message属性国际化"><a class="header" href="#message属性国际化">message属性国际化</a></h1>
<h2 id="指定properties"><a class="header" href="#指定properties">指定properties</a></h2>
<p><code>message</code>中填写国际化消息的<code>code</code>，在抛出异常时根据<code>code</code>处理一下就好了。</p>
<pre><code class="language-java">    @GetMapping(&quot;/room&quot;)
    @Validated
    public String validator(@NotNull(message = &quot;demo.message.notnull&quot;) String name) {
        if (result.hasErrors()) {
            return result.getFieldError().getDefaultMessage();
        }
        return &quot;ok&quot;;
    }
</code></pre>
<p>idea乱码 勾选 <em>transparent native-to-ascii conversion</em></p>
<p><strong>在/resources的根目录下添加上ValidationMessages.properties文件</strong></p>
<p>​	国际化配置文件必须放在classpath的根目录下，即src/java/resources的根目录下。
国际化配置文件必须以ValidationMessages开头，比如ValidationMessages.properties 或者 ValidationMessages_en.properties。</p>
<h2 id="自定义properties文件"><a class="header" href="#自定义properties文件">自定义properties文件</a></h2>
<p>重写LocalValidatorFactoryBean</p>
<pre><code class="language-java">@Configuration
public class ValidatorConfiguration extends WebMvcConfigurationSupport {
    @Autowired
    private MessageSource messageSource;

    @Override
    public Validator getValidator() {
        return validator();
    }

    @Bean
    public Validator validator() {
        LocalValidatorFactoryBean validator = new LocalValidatorFactoryBean();
        validator.setValidationMessageSource(messageSource);
        return validator;
    }
}
</code></pre>
<h1 id="自定义validtor"><a class="header" href="#自定义validtor">自定义validtor</a></h1>
<h2 id="bean-validation-注解规范"><a class="header" href="#bean-validation-注解规范">Bean Validation 注解规范</a></h2>
<p><code>Bean Validation API</code> 规范要求任何约束注解定义以下要求：</p>
<p>一个 <code>message</code> 属性：在违反约束的情况下返回一个默认 key 以用于创建错误消息</p>
<p>一个 <code>groups</code> 属性：允许指定此约束所属的验证分组。必须默认是一个空 Class 数组</p>
<p>一个 <code>payload</code> 属性：能被 Bean Validation API 客户端使用，以自定义一个注解的 payload 对象。API 本身不使用此属性。自定义 payload 可以是用来定义严重程度。如下：</p>
<pre><code class="language-java">public class Severity{
  public interface Info extends Payload{}
  public interface Error extends Payload{}
}
public class ContactDetails{
  @NotNull(message=&quot;名字必填&quot;, payload=Severity.Error.class)
  private String name;
  
  @NotNull(message=&quot;手机号没有指定，但不是必填项&quot;, payload=Severity.Info.class)
  private String phoneNumber;
}
</code></pre>
<p>然后客户端在 ContactDetails 实例验证之后，可以通过 <code>ConstraintViolation.getConstraintDescriptor().getPayload()</code> 获取 severity ，然后根据 severity 调整其行为。</p>
<p>此外，约束注解上还修饰了一些元注解：</p>
<ul>
<li>@Target：指定此注解支持的元素类型，比如：FIELD（属性）、METHOD（方法）等</li>
<li>@Rentention(RUNTIME)：指定此类型的注解将在运行时通过反射方式可用</li>
<li>@Constraint()：标记注解的类型为约束，指定注解所使用的验证器（写验证逻辑的类），如果约束可以用在多种数据类型中，则每种数据类型对应一个验证器。</li>
<li>@Documented：用此注解会被包含在使用方的 JavaDoc 中</li>
<li>@Repeatable(List.class)：指示注解可以在相同的位置重复多次，通常具有不同的配置。List 包含注解类型。</li>
</ul>
<h2 id="验证器"><a class="header" href="#验证器">验证器</a></h2>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<pre><code class="language-java">public class CheckCaseValidator implements ConstraintValidator&lt;CheckCase, String&gt; {
    private CaseMode caseMode;
    @Override
    public void initialize(CheckCase constraintAnnotation) {
        this.caseMode = constraintAnnotation.value();
    }
    @Override
    public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
        if ( object == null ) {
            return true;
        }
        if ( caseMode == CaseMode.UPPER ) {
            return object.equals( object.toUpperCase() );
        }else {
            return object.equals( object.toLowerCase() );
        }
    }
}
</code></pre>
<h3 id="constraintvalidator-指定了两个泛型类型"><a class="header" href="#constraintvalidator-指定了两个泛型类型"><strong><code>ConstraintValidator</code> 指定了两个泛型类型：</strong></a></h3>
<ol>
<li>第一个是指定需要验证的注解类</li>
<li>第二个是指定要验证的数据类型，当注解支持多种类型时，就要写多个实现类，并分别指定对应的类型</li>
</ol>
<h3 id="需要实现两个方法"><a class="header" href="#需要实现两个方法"><strong>需要实现两个方法</strong>：</a></h3>
<ul>
<li><code>initialize()</code> 让你可以获取到使用注解时所指定的参数（可以将它们保存起来以供下一步使用）</li>
<li><code>isValid()</code> 包含实际的校验逻辑。注意：Bean Validation 规范建议将 null 值视为有效值。如果一个元素 null 不是一个有效值，则应该显示的用 @NotNull 标注。</li>
</ul>
<h3 id="isvalid-方法中的-constraintvalidatorcontext-对象参数"><a class="header" href="#isvalid-方法中的-constraintvalidatorcontext-对象参数"><strong>isValid() 方法中的 ConstraintValidatorContext 对象参数：</strong></a></h3>
<p>当应用指定约束验证器时，提供上下文数据和操作。</p>
<p>此对象至少有一个 <code>ConstraintViolation</code></p>
<p><strong>示例</strong></p>
<p>官方示例展示了禁用默认消息并自定义了一个错误消息提示。</p>
<pre><code class="language-java">@Override
public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
    if ( object == null ) {
        return true;
    }

    boolean isValid;
    if ( caseMode == CaseMode.UPPER ) {
        isValid = object.equals( object.toUpperCase() );
    }
    else {
        isValid = object.equals( object.toLowerCase() );
    }

    if ( !isValid ) {
    // 禁用默认 ConstraintViolation，并自定义一个
        constraintContext.disableDefaultConstraintViolation();
        constraintContext.buildConstraintViolationWithTemplate(
                &quot;{org.hibernate.validator.referenceguide.chapter06.&quot; +
                &quot;constraintvalidatorcontext.CheckCase.message}&quot;
        )
        .addConstraintViolation();
    }

    return isValid;
}
</code></pre>
<h3 id="传递-payload-参数给验证器"><a class="header" href="#传递-payload-参数给验证器">传递 payload 参数给验证器</a></h3>
<p><strong>官方示例</strong></p>
<pre><code class="language-java">HibernateValidatorFactory hibernateValidatorFactory = Validation.byDefaultProvider()
        .configure()
        .buildValidatorFactory()
        .unwrap( HibernateValidatorFactory.class );

Validator validator = hibernateValidatorFactory.usingContext()
        .constraintValidatorPayload( &quot;US&quot; )
        .getValidator();

// [...] US specific validation checks
validator = hibernateValidatorFactory.usingContext()
        .constraintValidatorPayload( &quot;FR&quot; )
        .getValidator();


public class ZipCodeValidator implements ConstraintValidator&lt;ZipCode, String&gt; {

    public String countryCode;

    @Override
    public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
        if ( object == null ) {
            return true;
        }

        boolean isValid = false;

        String countryCode = constraintContext
                .unwrap( HibernateConstraintValidatorContext.class )
                .getConstraintValidatorPayload( String.class );

        if ( &quot;US&quot;.equals( countryCode ) ) {
            // checks specific to the United States
        }
        else if ( &quot;FR&quot;.equals( countryCode ) ) {
            // checks specific to France
        }
        else {
            // ...
        }

        return isValid;
    }
}
</code></pre>
<h3 id="message"><a class="header" href="#message">message</a></h3>
<p><strong>当违反约束时，应该用到的消息</strong>
需要定义一个 <code>ValidationMessages.properties</code>文件，并记录以下内容：</p>
<pre><code class="language-properties"># org.hibernate.validator.referenceguide.chapter06.CheckCase 是注解 CheckCase 的全类名
org.hibernate.validator.referenceguide.chapter06.CheckCase.message=Case mode must be {value}.
</code></pre>
<h2 id="类级别的约束"><a class="header" href="#类级别的约束">类级别的约束</a></h2>
<pre><code class="language-java">public class ValidPassengerCountValidator
        implements ConstraintValidator&lt;ValidPassengerCount, Car&gt; {

    @Override
    public void initialize(ValidPassengerCount constraintAnnotation) {}

    @Override
    public boolean isValid(Car car, ConstraintValidatorContext constraintValidatorContext) {
        if ( car == null ) {
            return true;
        }
        // 用来验证两个属性之间必须满足一种关系
        // 验证乘客数量不能大于座椅数量
        boolean isValid = car.getPassengers().size() &lt;= car.getSeatCount();

        if ( !isValid ) {
            constraintValidatorContext.disableDefaultConstraintViolation();
            constraintValidatorContext
                    .buildConstraintViolationWithTemplate( &quot;{my.custom.template}&quot; )
                    .addPropertyNode( &quot;passengers&quot; ).addConstraintViolation();
        }

        return isValid;
    }
}
</code></pre>
<h2 id="组合约束"><a class="header" href="#组合约束">组合约束</a></h2>
<h3 id="示例-1"><a class="header" href="#示例-1">示例</a></h3>
<pre><code class="language-java">@NotNull
@Size(min = 2, max = 14)
@CheckCase(CaseMode.UPPER)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, TYPE_USE })
@Retention(RUNTIME)
@Constraint(validatedBy = { })
@Documented
public @interface ValidLicensePlate {
    String message() default &quot;{org.hibernate.validator.referenceguide.chapter06.&quot; +
            &quot;constraintcomposition.ValidLicensePlate.message}&quot;;

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };
}
</code></pre>
<h3 id="遇到违反一个约束即返回"><a class="header" href="#遇到违反一个约束即返回">遇到违反一个约束即返回</a></h3>
<p>一个注解拥有多个注解的功能，而且此组合注解通常不需要再指定验证器。此注解验证之后会得到违反所有约束的集合，如果想违反其中一个约束之后就有对应的违约信息，可以使用 <code>@ReportAsSingleViolation</code></p>
<pre><code class="language-java">//...
@ReportAsSingleViolation
public @interface ValidLicensePlate {

    String message() default &quot;{org.hibernate.validator.referenceguide.chapter06.&quot; +
            &quot;constraintcomposition.reportassingle.ValidLicensePlate.message}&quot;;

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };
}
</code></pre>
<h1 id="示例-2"><a class="header" href="#示例-2">示例</a></h1>
<h2 id="自定义简单约束"><a class="header" href="#自定义简单约束">自定义简单约束</a></h2>
<p>三个步骤：</p>
<ul>
<li>创建一个约束注解</li>
<li>实现一个验证器</li>
<li>定义一个默认的错误消息</li>
</ul>
<ol>
<li>
<p>定义注解</p>
<pre><code class="language-java">
@Target( { ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER })
@Constraint(validatedBy = { NotNullValidator.class })
@Retention(RetentionPolicy.RUNTIME)
public @interface NotNull {

    String field() default &quot;&quot;;

    String message() default &quot;{field} can not be null&quot;;

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};
}

</code></pre>
</li>
<li>
<p>定义注解处理类</p>
<pre><code class="language-java">package com.weisanju.validtortest.common;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class NotNullValidator implements ConstraintValidator&lt;NotNull, Object&gt; {

    @Override
    public void initialize(NotNull annotation) {
        System.out.println(annotation);
    }

    @Override
    public boolean isValid(Object str, ConstraintValidatorContext constraintValidatorContext) {
        System.out.println(str);
        return str != null;
    }

}

</code></pre>
</li>
</ol>
<h1 id="spring-validation实现关键代码"><a class="header" href="#spring-validation实现关键代码">spring validation实现关键代码</a></h1>
<h2 id="requestbody"><a class="header" href="#requestbody">@<strong>RequestBody</strong></a></h2>
<pre><code class="language-java">public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
    Object arg = this.readWithMessageConverters(webRequest, parameter, parameter.getGenericParameterType());
    String name = Conventions.getVariableNameForParameter(parameter);
    WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);
    if (arg != null) {
        this.validateIfApplicable(binder, parameter);
        if (binder.getBindingResult().hasErrors() &amp;&amp; this.isBindExceptionRequired(binder, parameter)) {
            throw new MethodArgumentNotValidException(parameter, binder.getBindingResult());
        }
    }

    mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());
    return arg;
}
</code></pre>
<h2 id="modelattibute"><a class="header" href="#modelattibute">@ModelAttibute</a></h2>
<pre><code class="language-java">public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
    String name = ModelFactory.getNameForParameter(parameter);
    Object attribute = mavContainer.containsAttribute(name) ? mavContainer.getModel().get(name) : this.createAttribute(name, parameter, binderFactory, webRequest);
    if (!mavContainer.isBindingDisabled(name)) {
        ModelAttribute ann = (ModelAttribute)parameter.getParameterAnnotation(ModelAttribute.class);
        if (ann != null &amp;&amp; !ann.binding()) {
            mavContainer.setBindingDisabled(name);
        }
    }

    WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
    if (binder.getTarget() != null) {
        if (!mavContainer.isBindingDisabled(name)) {
            this.bindRequestParameters(binder, webRequest);
        }

        this.validateIfApplicable(binder, parameter);
        if (binder.getBindingResult().hasErrors() &amp;&amp; this.isBindExceptionRequired(binder, parameter)) {
            throw new BindException(binder.getBindingResult());
        }
    }

    Map&lt;String, Object&gt; bindingResultModel = binder.getBindingResult().getModel();
    mavContainer.removeAttributes(bindingResultModel);
    mavContainer.addAllAttributes(bindingResultModel);
    return binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);
}
</code></pre>
<h2 id="为什么-bindingresult-接收不到简单对象的校验信息"><a class="header" href="#为什么-bindingresult-接收不到简单对象的校验信息">为什么 <code>BindingResult</code> 接收不到简单对象的校验信息？</a></h2>
<p>注入实体对象时使用<code>ModelAttributeMethodProcessor</code>而注入 String 对象使用<code>AbstractNamedValueMethodArgumentResolver</code></p>
<p>而正是这个差异导致了<code>BindingResult</code>无法接受到简单对象(简单的入参参数类型)的校验信息。</p>
<pre><code class="language-java">public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
            NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {
            
        // bean 参数绑定和校验
        WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
        
        // 参数校验
        validateIfApplicable(binder, parameter);
        // 校验结果包含错误，并且该对象后不存在 BindingResult 对象，就抛出异常
        if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) {
            throw new BindException(binder.getBindingResult());
        }

        // 在对象后注入 BindingResult 对象
        Map&lt;String, Object&gt; bindingResultModel = bindingResult.getModel();
        mavContainer.removeAttributes(bindingResultModel);
        mavContainer.addAllAttributes(bindingResultModel);
    }
</code></pre>
<pre><code class="language-java">    // HandlerMethodArgumentResolverComposite.class
    public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
            NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {
        // 获取 parameter 参数的解析器
        HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);
        // 调用解析器获取参数
        return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);
    }
    
    // 获取 parameter 参数的解析器
    private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {
        // 从缓存中获取参数对应的解析器
        HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);
        for (HandlerMethodArgumentResolver methodArgumentResolver : this.argumentResolvers) {
            // 解析器是否支持该参数类型
            if (methodArgumentResolver.supportsParameter(parameter)) {
                result = methodArgumentResolver;
                this.argumentResolverCache.put(parameter, result);
                break;
            }
        }
        return result;
    }
</code></pre>
<p><strong>简单参数类型检验</strong></p>
<pre><code class="language-java">// MethodValidationInterceptor.class

public Object invoke(MethodInvocation invocation) throws Throwable {
        ExecutableValidator execVal = this.validator.forExecutables();
        // 校验参数
        try {
            result = execVal.validateParameters(
                    invocation.getThis(), methodToValidate, invocation.getArguments(), groups);
        }
        catch (IllegalArgumentException ex) {
            // 解决参数错误异常、再次校验
            methodToValidate = BridgeMethodResolver.findBridgedMethod(
                    ClassUtils.getMostSpecificMethod(invocation.getMethod(), invocation.getThis().getClass()));
            result = execVal.validateParameters(
                    invocation.getThis(), methodToValidate, invocation.getArguments(), groups);
        }
        if (!result.isEmpty()) {
            throw new ConstraintViolationException(result);
        }
        
        // 执行结果
        Object returnValue = invocation.proceed();
        
        // 校验返回值
        result = execVal.validateReturnValue(invocation.getThis(), methodToValidate, returnValue, groups);
        if (!result.isEmpty()) {
            throw new ConstraintViolationException(result);
        }

        return returnValue;
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="并发相关知识"><a class="header" href="#并发相关知识">并发相关知识</a></h2>
<h4 id="并发concurrency并行parallelism"><a class="header" href="#并发concurrency并行parallelism">并发(Concurrency),并行(Parallelism)</a></h4>
<p>并发:多项任务,交替执行</p>
<p>并行:多项任务,同时执行</p>
<h4 id="同步synchronous异步asynchronous"><a class="header" href="#同步synchronous异步asynchronous">同步(Synchronous),异步(Asynchronous)</a></h4>
<p>描述的是针对某个调用 获取返回结果的方式:是同步等待,还是异步通知</p>
<p>同步:调用某项方法时,等待方法返回结果</p>
<p>异步:调用后马上返回,结果计算完后,通知调用者</p>
<h4 id="阻塞blocking非阻塞non-blocking"><a class="header" href="#阻塞blocking非阻塞non-blocking">阻塞(blocking),非阻塞(non-blocking)</a></h4>
<p>描述的是多线程之间的相互影响</p>
<p>阻塞:一个线程占用了临界资源,其他线程必须等待这个线程释放资源</p>
<p>非阻塞:访问被其他线程占用的临界资源时, 不会阻塞等待,而立即返回</p>
<h4 id="临界区"><a class="header" href="#临界区">临界区</a></h4>
<p>表示公共资源,多个线程访问或修改同一个资源</p>
<h4 id="多线程竞争锁导致会问题"><a class="header" href="#多线程竞争锁导致会问题">多线程竞争锁导致会问题</a></h4>
<p>死锁:所有线程都不能动</p>
<p>饥饿锁:某个线程一直无法获取所需的资源</p>
<p>活锁:线程秉承谦让的原则,主动释放给他人使用,这样可能会导致资源在两个线程中跳动,而没有一个线程正常执行</p>
<h3 id="并发级别"><a class="header" href="#并发级别">并发级别</a></h3>
<h4 id="阻塞"><a class="header" href="#阻塞">阻塞</a></h4>
<p>一个线程会阻塞在 获取资源的步骤中,直到其他线程释放该资源,synchronized 的锁为阻塞级别</p>
<h4 id="无饥饿"><a class="header" href="#无饥饿">无饥饿</a></h4>
<p>如果获取锁是公平的,各个线程排队获取锁,则该锁是无饥饿的</p>
<h4 id="无障碍"><a class="header" href="#无障碍">无障碍</a></h4>
<p>最弱的非阻塞调度</p>
<p>两个线程访问同一个临界区,都不会被对方所阻塞,一旦检测到某一方把数据改动了,则所有线程操作全部回滚</p>
<p>阻塞的控制方式是 悲观策略,假定两个线程之间很可能发生冲突,而非阻塞的调度是乐观的策略,认为多个线程不会发生冲突,或者概率不大,一旦发生冲突,就应该回滚</p>
<h4 id="无锁"><a class="header" href="#无锁">无锁</a></h4>
<p>要求有一个线程可以在有限步内完成操作</p>
<p>当所有线程都能尝试对临界区访问,但只有一个线程能 进入临界区,其他的线程会不断尝试</p>
<h4 id="无等待"><a class="header" href="#无等待">无等待</a></h4>
<ol>
<li>要求所有线程必须在有限步内完成</li>
<li>典型的无等待结构是 RCU(read-copy-update),读无等待,更新时,先取得副本更新,然后适时写回</li>
</ol>
<h3 id="并行的两个重要定律"><a class="header" href="#并行的两个重要定律">并行的两个重要定律</a></h3>
<h4 id="amdahl-定律"><a class="header" href="#amdahl-定律">Amdahl 定律</a></h4>
<ol>
<li>定义了串行系统并行化的加速比的计算公式,和理论上限</li>
</ol>
<p>$$
加速比 = 优化前系统耗时 / 优化后系统耗时\F:为系统串行比例\T_1:为一个处理器的耗时\T_n:为n个处理器优化后的耗时\T_n = T_1(F+\frac{1}{n}<em>(1-F))\加速比 = \frac{T_1}{T_n} = \frac{1}{F+\frac{1}{n}</em>(1-F)}
$$</p>
<ol start="2">
<li>由公式可分析出
<ol>
<li>CPU 处理器数量趋近于无穷,那么加速比与系统串行率成反比</li>
<li>如果系统串行率为 50%,则系统最大加速比为 2</li>
</ol>
</li>
</ol>
<h4 id="gustafson-定律"><a class="header" href="#gustafson-定律">Gustafson 定律</a></h4>
<p>$$
a:串行时间,b:并行时间,n处理器个数\
实际执行时间 = a+b\
总执行时间 = a+n<em>b\
加速比= \frac{a+n</em>b}{a+b}\
串行比例 = F = \frac{a}{a+b}\
加速比 = \frac{a+n<em>b}{a+b} = \frac{a}{a+b}+\frac{n</em>(a+b-a)}{a+b}=F+n*(1-F)=n-F*(n-1)
$$</p>
<ol start="3">
<li>
<p>两个定律的不同点</p>
<ol>
<li>Amdahl 定律侧重于 当 总任务一定时, 当串行比例一定时,加速比是有上线的</li>
<li>Gustafson 定律侧重于 不管 F 的值有多高,只要 n 足够大,有足够的时间和 工作量,就能达到某个加速比</li>
</ol>
</li>
</ol>
<h3 id="java-多线程并发原则"><a class="header" href="#java-多线程并发原则">java 多线程并发原则</a></h3>
<h4 id="原子性-atomicity"><a class="header" href="#原子性-atomicity">原子性 <code>Atomicity</code></a></h4>
<p>函数调用过程中 不可被其他线程打断,要么成功,要么失败</p>
<h4 id="可见性-visibility"><a class="header" href="#可见性-visibility">可见性 <code>visibility</code></a></h4>
<p>对某一线程修改了某一个共享变量,其他线程能够立刻知道</p>
<h4 id="有序性-ordering"><a class="header" href="#有序性-ordering">有序性 <code>ordering</code></a></h4>
<ol>
<li>在程序编译时可能 有指令重排:通过指令重排 减少 CPU 流水线指令的停顿</li>
<li>线程重排原则
<ol>
<li>程序顺序原则:一个线程内保证语义的串行性,不保证并行性</li>
<li>volatile 变量的写 先发生于读</li>
<li>锁规则:解锁必然发生在 加锁前</li>
<li>传递性: a 先于 b,b 先于 c,a 必然先于 c</li>
<li>线程 start 方法优先于它的每一个动作</li>
<li>所有操作先于 线程的终结</li>
<li>中断先于 被中断线程的代码</li>
<li>对象的构造函数执行,结束先于 finalize 方法</li>
</ol>
</li>
</ol>
<h2 id="java-并行程序基础"><a class="header" href="#java-并行程序基础">java 并行程序基础</a></h2>
<h3 id="线程状态变更图"><a class="header" href="#线程状态变更图">线程状态变更图</a></h3>
<p><img src="https://i.loli.net/2020/10/24/3zNEiyP9eDkvdBa.png" alt="20201024111905" /></p>
<h3 id="线程基本操作"><a class="header" href="#线程基本操作">线程基本操作</a></h3>
<p><a href="5.java%E5%9F%BA%E7%A1%80_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C.html">线程操作链接</a></p>
<h3 id="volatile-关键字"><a class="header" href="#volatile-关键字">volatile 关键字</a></h3>
<p>修饰变量</p>
<p>告知各个线程,取变量值时,从主内存中取,不要从副本取</p>
<h3 id="线程组"><a class="header" href="#线程组">线程组</a></h3>
<pre><code class="language-java">package com.weisanju;

public class ThreadGroupTest {
    public static class AThread implements  Runnable{
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName());
        }
    }

    public static void main(String[] args) {
        ThreadGroup threadGroup = new ThreadGroup(&quot;xjq&quot;);
        Thread t1 = new Thread(threadGroup,new AThread(),&quot;t1&quot;);
        Thread t2 = new Thread(threadGroup,new AThread(),&quot;t2&quot;);
        t1.start();
        t2.start();
        threadGroup.list();
        System.out.println(threadGroup.activeCount());
        System.out.println(threadGroup.activeGroupCount());
    }
}

</code></pre>
<h3 id="守护线程"><a class="header" href="#守护线程">守护线程</a></h3>
<ol>
<li>
<p>线程分为用户线程 ,守护线程</p>
</li>
<li>
<p>当用户线程执行完毕之后, 守护线程会自行退出</p>
</li>
<li>
<p>守护线程一般完成系统性服务,例如垃圾回收,JIT 线程</p>
</li>
<li>
<p>代码</p>
<pre><code class="language-java">package com.weisanju;

public class DeamonTest {
    public static class  Athread implements  Runnable{

        @Override
        public void run() {
            while(true){
                System.out.println(1);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(new Athread());
        t.setDaemon(true);
        t.start();
        Thread.sleep(2000);
    }
}

</code></pre>
</li>
</ol>
<h3 id="线程优先级"><a class="header" href="#线程优先级">线程优先级</a></h3>
<ol>
<li><code>Thread.MAX_PRIORITY</code> = 10</li>
<li><code>Thread.NORM_PRIORITY</code> = 5</li>
<li><code>Thread.MIN_PRIORITY = 1</code></li>
</ol>
<h2 id="java-锁"><a class="header" href="#java-锁">Java 锁</a></h2>
<p><a href="5.java%E5%9F%BA%E7%A1%80_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/java%E9%94%81.html">java 锁</a></p>
<h2 id="jdk-并发包"><a class="header" href="#jdk-并发包">jdk 并发包</a></h2>
<p><a href="5.java%E5%9F%BA%E7%A1%80_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/JUC%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7.html">JUC线程同步工具</a></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="可重入锁"><a class="header" href="#可重入锁">可重入锁</a></h3>
<ol>
<li>
<p>重入锁可以完全替代 synchronized 关键字, jdk1.5 之间重入锁性能远远好于 synchronized 从 1.6 开始,jdk 在 synchronized 做了大量优化,使得两者性能差距并不大</p>
</li>
<li>
<p>特性</p>
<ol>
<li>可重入性质: 一个线程可以连续两次获得锁, 但相应的得释放两次锁</li>
</ol>
<pre><code class="language-java">ReentryantLock lock1 = new ReentryantLock();
lock1.lock()
lock1.lock()
lock1.unlock()
lock1.unlock()
</code></pre>
<ol start="2">
<li>可中断性质
<ol>
<li>线程在尝试获取锁时,可被打断,并被打断后,释放相应的锁,让其他线程获取锁</li>
<li>案例 : 线程 a, 线程 b ,a 先得到锁 1,然后请求锁 2,b 先得到锁 2,然后请求锁 1</li>
<li>代码</li>
</ol>
</li>
</ol>
<pre><code class="language-java">package com.weisanju;

import java.util.concurrent.locks.ReentrantLock;

public class DeadLock {
    private static ReentrantLock lock1= new ReentrantLock();
    private static ReentrantLock lock2= new ReentrantLock();

    public static class  ThreadTest implements  Runnable{
        private char name;

        public ThreadTest(char name) {
            this.name = name;
        }

        @Override
        public void run() {
            if(name == 'A'){
                try {
                    lock1.lockInterruptibly();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                try {
                    Thread.sleep(1000);
                    lock2.lockInterruptibly();
                    System.out.println(&quot;A 得到锁了&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    if(lock1.isHeldByCurrentThread()){
                        lock1.unlock();
                    }
                    if(lock2.isHeldByCurrentThread()){
                        lock2.unlock();
                    }
                }

            }else{
                try {
                    lock2.lockInterruptibly();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                try {
                    Thread.sleep(1000);
                    lock1.lockInterruptibly();
                    System.out.println(&quot;B 得到锁了&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    if(lock1.isHeldByCurrentThread()){
                        lock1.unlock();
                    }
                    if(lock2.isHeldByCurrentThread()){
                        lock2.unlock();
                    }
                }
            }
        }
    }

    public static void main(String[] args) {
        Thread ta = new Thread(new ThreadTest('A'));
        Thread tb = new Thread(new ThreadTest('B'));

        ta.start();
        tb.start();

        try {
            Thread.sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        tb.interrupt();

    }
}

</code></pre>
<ol start="3">
<li>超时性质
<ol>
<li><code>tryLock()</code>:尝试获取锁,获取不成功则马上返回</li>
<li><code>tryLock(long mili)</code>:尝试获取锁,并等待指定时间段</li>
</ol>
</li>
<li>公平锁
<ol>
<li>锁的申请遵循 先到先到,支持排队</li>
<li><code>public ReentrantLock(boolean fair)</code></li>
<li>实现公平锁,系统需要维护一个有序队列,实现成本较高,性能太低</li>
<li>根据系统的调度,一个线程会倾向于再次获取已经持有的锁,这种锁分配是高效的</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="conditional-条件等待"><a class="header" href="#conditional-条件等待">Conditional 条件等待</a></h3>
<ol>
<li>与 synchronized 配合 wait,notify 使用类似 , condition 配合与 Reentryant 锁使用实现线程间通信</li>
<li>代码</li>
</ol>
<pre><code class="language-java">package com.weisanju;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ConditionalTest {
    private  static  int flag =0;
    private static ReentrantLock lock = new ReentrantLock();
    private static Condition condition= lock.newCondition();
    private  static class  AThread implements Runnable{
        @Override
        public void run() {
            lock.lock();
            System.out.println(&quot;正等待条件发生&quot;);
            try {
                condition.await();
                System.out.println(flag);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                lock.unlock();
            }

        }
    }

    public static void main(String[] args) throws InterruptedException {
        new Thread(new AThread()).start();
        flag = 666;
        Thread.sleep(200);
        lock.lock();
        System.out.println(&quot;已经获取锁&quot;);
        Thread.sleep(1000);

        condition.signal();
        lock.unlock();
    }
}
</code></pre>
<h3 id="信号量"><a class="header" href="#信号量">信号量</a></h3>
<ol>
<li>API
<ol>
<li>构造函数:<code>public Semaphore(int premits)</code></li>
<li>逻辑方法
<ol>
<li>acquire|acquireUninterruptible()|tryAcquire()</li>
<li>release</li>
</ol>
</li>
</ol>
</li>
<li>例子:省略</li>
</ol>
<h3 id="读写锁"><a class="header" href="#读写锁">读写锁</a></h3>
<ol>
<li>
<p>读写操作互斥表</p>
<p>|      | 读     | 写   |
| ---- | ------ | ---- |
| 读   | 不阻塞 | 阻塞 |
| 写   | 阻塞   | 阻塞 |</p>
</li>
<li>
<p>API</p>
<ol>
<li><code>ReentrantReadWriteLock</code></li>
<li><code>lock.readLock(),lock.writeLock()</code></li>
</ol>
</li>
</ol>
<h3 id="倒计时"><a class="header" href="#倒计时">倒计时</a></h3>
<ol>
<li>API
<ol>
<li>构造函数:<code>public CountDownLatch(int count)</code></li>
<li>逻辑操作
<ol>
<li>计时器减 1:<code>CountDownLatch.countDown()</code></li>
<li>等待计时器归 0:``CountDownLatch.await();`</li>
<li>获取计数器:<code>CountDownLatch.getCount()</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="cyclicbarrier-循环栅栏"><a class="header" href="#cyclicbarrier-循环栅栏">CyclicBarrier 循环栅栏</a></h3>
<ol start="0">
<li>
<p>每当有 <code>parties</code> 个 到达 <code>wait</code> 点时, 则执行 barrierAction</p>
</li>
<li>
<p>APi</p>
<ol>
<li>
<p>构造函数:<code>public CyclicBarrier(int parties, Runnable barrierAction)</code></p>
</li>
<li>
<p><code>await</code>:等待</p>
</li>
<li>
<p>一个线程在等待时被打断, 则其他线程抛出<code>BrokenBarrierException</code>,该线程抛出:<code>InterruptedException</code></p>
</li>
<li>
<p>code</p>
<pre><code class="language-java">package com.weisanju;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierTest {
    private static CyclicBarrier barrier = new CyclicBarrier(5,new BarrierRun(false));
    public  static  class Solider implements  Runnable{
        private int i;

        public Solider(int i) {
            this.i = i;
        }

        @Override
        public void run() {
            try {
                barrier.await();

                Thread.sleep(1000);
                System.out.println(&quot;士兵&quot;+i+&quot;完成任务&quot;);
                barrier.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        }
    }
    public  static  class BarrierRun implements  Runnable{
        private boolean flag ;

        public BarrierRun(boolean flag) {
            this.flag = flag;
        }

        @Override
        public void run() {
            if (flag) {
                System.out.println(&quot;任务完成&quot;);
            }else{
                System.out.println(&quot;集合完毕&quot;);
                flag = true;
            }
        }
    }

    public static void main(String[] args) {
        int n = 5;

        for (int i = 0; i &lt; n; i++) {
            System.out.println(&quot;士兵报数:&quot;+i);
            new  Thread(new Solider(i)).start();
        }
    }
}

</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="线程阻塞工具类"><a class="header" href="#线程阻塞工具类">线程阻塞工具类</a></h3>
<p><strong>API</strong></p>
<ol>
<li><code>LockSupport.unpack(Object)</code>,<code>LockSupport.pack(Thread)</code></li>
<li>类似于 值为 1 的信号量 操作</li>
<li>unpack 操作发生在 pack 操作之前,unpack 使得许可可用,pack 消耗许可</li>
<li>不需要获取锁</li>
<li>为每一个线程都拥有一个许可证</li>
<li>被打断之后正常返回,可以通过 <code>Thread.isInterrputed</code></li>
<li><code>unpack(Object)</code>:object 为日志打印时的对象</li>
</ol>
<p><strong>code</strong></p>
<pre><code class="language-java">package com.weisanju;

import java.util.concurrent.locks.LockSupport;

public class LockSupportTest {
    public static  class AThread implements Runnable{
        @Override
        public void run() {
            LockSupport.park();
            if(Thread.currentThread().isInterrupted()){
                System.out.println(&quot;被打断了&quot;);
                return;
            }
            System.out.println(&quot;正常运行&quot;);
        }
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(new AThread());
        Thread t2 = new Thread(new AThread());

        t1.start();
        t2.start();
        t1.interrupt();
        LockSupport.unpark(t2);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<ul>
<li>
<p>用来创建 工具锁，以及其他同步类的基本线程阻塞原语</p>
</li>
<li>
<p>此类与使用它的每个线程关联一个许可</p>
</li>
<li>
<p>如果许可 可用的化，调用 <em>park</em>立即返回，否则会阻塞</p>
</li>
<li>
<p><em>unpark</em> 会产生一个 许可，许可不会 积累，最多一个</p>
</li>
<li>
<p><em>unpark</em> 与 <em>park</em> 提供 了 比 <em>Thread.suspend</em> and <em>Thread.resume</em> 更 加有效的 线程 阻塞方式，支持可中断，可超时</p>
</li>
<li>
<p>同时也支持 <em>blocker object</em> 参数，线程被阻塞时会记录该对象，以允许监视和诊断工具确定线程被阻塞的原因。（此类工具可以使用方法getBlocker（Thread）访问 <em>blocker object</em>）</p>
</li>
<li>
<p>强烈建议使用 带 <em>blocker</em> 形式，而不要使用没有此参数的原始形式。</p>
</li>
<li>
<p>这些方法旨在用作创建高级同步实用程序的工具,本身对大多数并发控制应用程序都不有用。</p>
</li>
<li>
<p>一般使用以下形式</p>
<pre><code class="language-java"> while (!canProceed()) { ... LockSupport.park(this); }
</code></pre>
<p>任何中间对 <em>park</em> 或 <em>unpark</em>d的调用将会 影响 预期效果</p>
</li>
<li>
<p>先进先出 不可重入的示意图</p>
<pre><code class="language-java"> class FIFOMutex {
   private final AtomicBoolean locked = new AtomicBoolean(false);
   private final Queue&lt;Thread&gt; waiters
     = new ConcurrentLinkedQueue&lt;Thread&gt;();

   public void lock() {
     boolean wasInterrupted = false;
     Thread current = Thread.currentThread();
     waiters.add(current);

     // Block while not first in queue or cannot acquire lock
     while (waiters.peek() != current ||
            !locked.compareAndSet(false, true)) {
       LockSupport.park(this);
       if (Thread.interrupted()) // ignore interrupts while waiting
         wasInterrupted = true;
     }

     waiters.remove();
     if (wasInterrupted)          // reassert interrupt status on exit
       current.interrupt();
   }

   public void unlock() {
     locked.set(false);
     LockSupport.unpark(waiters.peek());
   }
 }
</code></pre>
</li>
</ul>
<h1 id="park"><a class="header" href="#park">Park</a></h1>
<p><strong>方法声明</strong></p>
<pre><code class="language-java">    public static void park() {
        UNSAFE.park(false, 0L);
    }
</code></pre>
<p>线程会阻塞在此方法，并且不会被调度，直到以下情况发生</p>
<ul>
<li>其他线程调用了 <em>unPark</em> </li>
<li>线程被中断，不会抛异常</li>
<li>虚假调用</li>
</ul>
<p>需要调用者自己检查 被唤醒原因，例如 是否被中断</p>
<h1 id="超时park"><a class="header" href="#超时park">超时Park</a></h1>
<pre><code class="language-java">public static void parkNanos(long nanos) {
    if (nanos &gt; 0)
        UNSAFE.park(false, nanos);
}
</code></pre>
<h1 id="deadline-park"><a class="header" href="#deadline-park"><em>DeadLine Park</em></a></h1>
<blockquote>
<p>从公元 Epoch 开始的绝对时间</p>
</blockquote>
<pre><code class="language-java">    public static void parkUntil(long deadline) {
        UNSAFE.park(true, deadline);
    }
</code></pre>
<h1 id="unpark"><a class="header" href="#unpark">Unpark</a></h1>
<ul>
<li>调用之后 会对 信号量+1，那么下次 <em>Park</em> 将会 不阻塞，能够精确的 发送 可靠信号</li>
</ul>
<pre><code class="language-java">public static void unpark(Thread thread) {
    if (thread != null)
        UNSAFE.unpark(thread);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java内存模型"><a class="header" href="#java内存模型">Java内存模型</a></h1>
<p>​		Java Memory Modle，简称 JMM，中文名称 <strong>Java内存模型</strong>，它是一个抽象的概念，用来描述或者规范访问内存变量的方式。因为各中计算机的操作系统和硬件不同，方式机制也可能不同，Java内存模型用于屏蔽（适配）各种差异，以此来达到访问各个平台的一致的效果。这也是Java夸平台的重要原因之一。</p>
<p><strong>主内存</strong></p>
<ul>
<li>规定了所有变量都存储在主内存（Main Memory）中，各个线程又有自己的本地内存（工作内存）</li>
<li>本地内存保存着主内存中部分变量</li>
</ul>
<p><strong>JVM内存操作指令</strong></p>
<ol>
<li>**lock加锁：**为了保证访问主内存变量的线程安全性，在访问前一般会加锁处理；</li>
<li>**read读：**从主内存中读取一个变量到工作内存；</li>
<li>**load加载：**把read读到的变量加载到工作内存的变量副本中；</li>
<li>**use使用：**此时线程可以使用其工作内存中的变量了；</li>
<li>**assign赋值：**将处理后的变量赋值给工作内存中的变量；</li>
<li>**store存储：**将工作内存中的变量存储到主内存中，以新建new 一个新变量的方式存储；</li>
<li>**write写：**将store存在的新变量的引用赋值给被处理的变量；</li>
<li>**unload解锁：**所有的工作做完，最后解锁释放资源。</li>
</ol>
<h1 id="java内存模型的三大特性"><a class="header" href="#java内存模型的三大特性">Java内存模型的三大特性</a></h1>
<p><strong>原子性</strong>（Atomicity）</p>
<ul>
<li>
<p>这里的原子性如同数据库事务中是原子性，一个或多个操作要么全执行成功要么全执行失败</p>
</li>
<li>
<p>Java内存模型只保证单一的操作具有原子性</p>
</li>
</ul>
<p><strong>可见性</strong>（Visibility）</p>
<p>如何解决内存的可见性的问题</p>
<ol>
<li>对进入临界区的线程做同步处理（比如 synchronized）,同一时刻仅有一个线程能够访问临界区的资源；</li>
<li>使用 volatile 关键字保证内存可见性，它能保证访问临界区资源的所有线程总能看到共享资源的最新值；</li>
<li>CAS无锁化。</li>
</ol>
<p><strong>有序性</strong>（Ordering</p>
<p>线程内的所有操作都是有序的，既程序执行的顺序按照代码的先后顺序执行</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线程状态"><a class="header" href="#线程状态">线程状态</a></h1>
<p>java中Thread有6种状态，分别是：</p>
<ol>
<li>NEW - 新创建的Thread，还没有开始执行</li>
<li>RUNNABLE - 可运行状态的Thread，包括准备运行和正在运行的。</li>
<li>BLOCKED - 正在等待资源锁的线程</li>
<li>WAITING - 正在无限期等待其他线程来执行某个特定操作</li>
<li>TIMED_WAITING - 在一定的时间内等待其他线程来执行某个特定操作</li>
<li>TERMINATED - 线程执行完毕</li>
</ol>
<h1 id="线程生命周期"><a class="header" href="#线程生命周期">线程生命周期</a></h1>
<p><img src="5.java%E5%9F%BA%E7%A1%80_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81//images/thread_state.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="java-锁分类"><a class="header" href="#java-锁分类">Java 锁分类</a></h2>
<p><img src="https://i.loli.net/2020/10/24/1mnIWzliAFjD9Qu.png" alt="导图1" /></p>
<h1 id="jvm-锁优化"><a class="header" href="#jvm-锁优化">JVM 锁优化</a></h1>
<h2 id="锁消除"><a class="header" href="#锁消除">锁消除</a></h2>
<p><strong>锁消除是在编译器级别的事情</strong>。虚拟机即时编译器在运行时，如果发现不可能存在共享数据竞争的锁，则可以消除这些对象的锁操作。</p>
<h2 id="锁粗化"><a class="header" href="#锁粗化">锁粗化</a></h2>
<p>原则上，同步块的作用范围要尽量小。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体内，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p><strong>锁粗化就是增大锁的作用域,减少锁定的次数。</strong></p>
<h1 id="jvm-锁状态"><a class="header" href="#jvm-锁状态">JVM 锁状态</a></h1>
<h2 id="锁的四种状态"><a class="header" href="#锁的四种状态"><strong>锁的四种状态</strong></a></h2>
<p><strong>锁主要存在四中状态，依次是：</strong></p>
<ul>
<li>
<p><strong>无锁状态</strong></p>
</li>
<li>
<p><strong>偏向锁状态</strong></p>
</li>
<li>
<p><strong>轻量级锁状态</strong></p>
</li>
<li>
<p><strong>重量级锁状态</strong></p>
</li>
</ul>
<h2 id="轻量级锁"><a class="header" href="#轻量级锁">轻量级锁</a></h2>
<p>引入轻量级锁的主要目的是在<strong>没有多线程竞争</strong>的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<blockquote>
<p>当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：</p>
</blockquote>
<p><strong>获取锁</strong></p>
<ul>
<li>
<p><strong>无锁状态</strong></p>
</li>
<li>
<p>在线程私有栈帧 中建立 锁记录存储 <strong>markWord</strong>拷贝</p>
</li>
<li>
<p>利用 CAS 操作尝试将对象的 MarkWord 更新为指向 LockRecord 的 指针,成功 表示竞争到锁</p>
</li>
</ul>
<h2 id="偏向锁"><a class="header" href="#偏向锁">偏向锁</a></h2>
<h3 id="比较标识"><a class="header" href="#比较标识"><strong>比较标识</strong></a></h3>
<p>比较 <strong>是否为偏向锁</strong> , <strong>偏向锁所偏向的线程 id</strong></p>
<h3 id="偏向锁竞争"><a class="header" href="#偏向锁竞争"><strong>偏向锁竞争</strong></a></h3>
<p><strong>CAS 竞争成功</strong></p>
<p>如果当前锁 偏向的线程 Id, 不为当前线程的 id, 则通过 CAS 竞争锁 竞争成功,则将线程 id 替换为当前线程 id,然后执行同步代码</p>
<p><strong>CAS 竞争失败</strong></p>
<p>CAS 竞争锁失败,证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</p>
<h3 id="偏向锁释放"><a class="header" href="#偏向锁释放">偏向锁释放</a></h3>
<p><strong>只有竞争才会释放锁</strong></p>
<blockquote>
<p>线程是不会主动去释放偏向锁，需要等待其他线程来竞争。 偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。</p>
</blockquote>
<h2 id="自旋锁与自适应自旋锁"><a class="header" href="#自旋锁与自适应自旋锁">自旋锁与自适应自旋锁</a></h2>
<ul>
<li>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多</li>
<li>反之,如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</li>
</ul>
<p><strong>自旋与非自旋</strong></p>
<p><img src="https://i.loli.net/2020/10/24/dUJvRxQXbhiOAuz.png" alt="自旋与非自旋" /></p>
<h1 id="jvm锁实现"><a class="header" href="#jvm锁实现">JVM锁实现</a></h1>
<h2 id="synchronized的实现"><a class="header" href="#synchronized的实现"><strong>synchronized</strong>的实现</a></h2>
<p>每个锁关联一个线程持有者和一个计数器</p>
<ul>
<li>当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁</li>
<li>当一个线程请求成功后，JVM会记下持有锁的线程id，并将计数器计为1</li>
<li>此时其他线程请求该锁，则必须等待。</li>
<li>而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增</li>
</ul>
<p>故 <strong>synchronized</strong> 是可重入锁</p>
<p>java线程是基于“每线程（per-thread）”，而不是基于“每调用（per-invocation）”的</p>
<p><a href="https://www.toutiao.com/i6884966680137728526/">参考</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="虚拟机运行时的java线程模型"><a class="header" href="#虚拟机运行时的java线程模型">虚拟机运行时的java线程模型</a></h1>
<h1 id="线程创生纪"><a class="header" href="#线程创生纪">线程创生纪</a></h1>
<ul>
<li><strong>线程模型描述了Java虚拟机中的执行单元，是所有虚拟机组件的最终使能的对象。</strong></li>
<li>了解Java线程模型有助于了解虚拟机运行的概况。</li>
<li>Java程序可以轻松创建线程，虚拟机本身也需要创建线程。</li>
<li>解释器、JIT编译器、GC是抽象出来执行某一具体任务的组件，这些组件执行任务时都需要依托线程。</li>
</ul>
<p>所以，为了管理这些五花八门的线程，虚拟机将它们的公有特性抽象出来构成一个<strong>线程模型</strong>，如图4-1所示。</p>
<p><img src="5.java%E5%9F%BA%E7%A1%80_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81//images/java_thread_structure.png" alt="" /></p>
<p>1）Thread：线程基类，定义所有线程都具有的功能。</p>
<p>2）JavaThread：Java线程在虚拟机层的实现。</p>
<p>3）NonJavaThread：相比Thread只多了一个可以遍历所有NonJavaThread的能力。</p>
<p>4）ServiceThread：服务线程，会处理一些杂项任务，如检查内存过低、JVMTI事件发生。</p>
<p>5）JvmtiAgentThread：JVMTI的RunAgentThread()方法启动的线程。</p>
<p>6）CompilerThread：JIT编译器线程。</p>
<p>7）CodeCacheSweeperThread：清理Code Cache的线程。</p>
<p>8）WatcherThread：计时器（Timer）线程。</p>
<p>9）JfrThreadSampler：JFR数据采样线程。</p>
<p>10）VMThread：虚拟机线程，会创建其他线程的线程，也会执行GC、退优化等。</p>
<p>11）ConcurrentGCThread：与WorkerThread及其子类一样，都是为GC服务的线程。</p>
<p>当使用命令行工具java启动应用程序时，<strong>操作系统会定位到java启动器的main函数</strong>，</p>
<p>java启动器调用JavaMain完成一个程序的生命周期，如代码清单4-1所示，这其中涉及各种线程的创建与销毁：</p>
<p>......</p>
<p><a href="https://www.toutiao.com/i6934925749275394573/">建议了解文章</a></p>
<div style="break-before: page; page-break-before: always;"></div><p>线程在参与竞争前会提前 检测竞争程度</p>
<ul>
<li>
<p>如果其他线程啥都干完了</p>
<p>则 当前线程只能 重开始下一轮</p>
</li>
<li>
<p>如果其他线程 竞争到了，但还有扫尾工作没完成</p>
<p>则帮忙 完成余下的工作</p>
</li>
<li>
<p>如果参与竞争失败了，也尝试帮忙 完成 其他线程的扫尾工作</p>
</li>
<li>
<p>如果参与竞争成功了，则开始自己的扫尾工作</p>
</li>
</ul>
<p>关于此模式的分析详见</p>
<p><a href="5.java%E5%9F%BA%E7%A1%80_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/..%5Cjava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%5CSynchronousQueue.html">SynchronousQueue</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="新建线程start"><a class="header" href="#新建线程start">新建线程:start</a></h1>
<p><code>Thread.start()</code></p>
<h1 id="线程停止stop"><a class="header" href="#线程停止stop">线程停止:stop</a></h1>
<ol>
<li><code>Thread.stop()</code> :线程放弃一切工作,马上退出,这样会导致很多隐患</li>
<li>在线程内部设置停止标识:有线程自己决定在哪地方退出</li>
</ol>
<h1 id="线程中断interrupt"><a class="header" href="#线程中断interrupt">线程中断:interrupt</a></h1>
<ol>
<li>
<p>java 已经实现中断标识,用于线程自行决定在哪里退出</p>
<ol>
<li>判断是否中断:Thread.isInterrupted()</li>
<li>判断是否中断并清除中断标记:static Thread.interrupted()</li>
<li>发出中断:Thread.interrupt()</li>
</ol>
</li>
<li>
<p>Thread.sleep() 捕捉到中断之后,会清除中断标记</p>
</li>
<li>
<p>code</p>
<pre><code class="language-java">package com.weisanju;
public class InterruptedTest {
    public static class AThread implements  Runnable{
        @Override
        public void run() {
            while(true){
                if(Thread.currentThread().isInterrupted()){
                    System.out.println(&quot;已被中断&quot;);
                    break;
                }
                System.out.println(1);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new AThread());
        thread.start();
        Thread.sleep(1000);

        thread.interrupt();
    }
}
</code></pre>
</li>
</ol>
<h1 id="线程等待waitnotify"><a class="header" href="#线程等待waitnotify">线程等待:wait,notify</a></h1>
<p><strong>Notify与NotifyAll的区别</strong></p>
<ul>
<li>
<p><strong>notify</strong>总是唤醒队列中的第一个线程,且当有多个 线程在 当前锁对象 wait时, 会导致阻塞</p>
</li>
<li>
<p><strong>notifyAll</strong> 唤醒所有等在该队列的 线程,  按最近 原则</p>
</li>
</ul>
<p><strong>示例</strong></p>
<pre><code class="language-java">**示例1**
public class NotifyDemo {

    private static void sleep(long sleepVal){
        try{
            Thread.sleep(sleepVal);
        }catch(Exception e){
            e.printStackTrace();
        }
    }

    private static void log(String desc){
        System.out.println(Thread.currentThread().getName() + &quot; : &quot; + desc);
    }

    final Object lock = new Object();

    public void startThreadA(){
        new Thread(() -&gt; {
            synchronized (lock){
                log(&quot;get lock&quot;);
                startThreadB();
                try {
                    lock.wait();
                }catch(InterruptedException e){
                    e.printStackTrace();
                }

                log(&quot;get lock after wait&quot;);
                log(&quot;release lock&quot;);
            }
        }, &quot;thread-A&quot;).start();
    }

    public void startThreadB(){
        new Thread(()-&gt;{
            synchronized (lock){
                log(&quot;get lock&quot;);
                startThreadC();
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log(&quot;get lock after wait&quot;);
                log(&quot;release lock&quot;);
            }
        },&quot;thread-B&quot;).start();
    }

    public void startThreadC(){
        new Thread(() -&gt; {
            synchronized (lock){
                log(&quot;get lock&quot;);
                sleep(100);
                log(&quot;start notify&quot;);
                lock.notifyAll();
                log(&quot;release lock&quot;);
            }
        }, &quot;thread-C&quot;).start();
    }

    public static void main(String[] args){
        new NotifyDemo().startThreadA();
    }
}
</code></pre>
<h1 id="挂起与继续执行suspendresume"><a class="header" href="#挂起与继续执行suspendresume">挂起与继续执行:suspend,resume</a></h1>
<p>挂起,与恢复, 建议使用wait notify 替换,<strong>容易死锁</strong></p>
<pre><code class="language-java">import java.util.Objects;

public class DeadLock {
    static final Object object = new Object();
    public static void main(String[] args) {
        Thread t1 = new Thread(() -&gt; {
            NotifyDemo.log(&quot;线程启动&quot;);
            synchronized (object) {
                Thread.currentThread().suspend();
                NotifyDemo.log(&quot;线程复原&quot;);
            }
        });
        t1.start();
        NotifyDemo.sleep(2000);
        synchronized (object){
            t1.resume();
        }
    }
}

</code></pre>
<h1 id="等待线程结束join"><a class="header" href="#等待线程结束join">等待线程结束:join</a></h1>
<blockquote>
<p>利用 <code>wait 特性</code>  等待</p>
</blockquote>
<p><strong>join 的实现</strong></p>
<ol>
<li>使用 Thread对象作为锁，当线程结束时 会调用 this.notifyAll</li>
<li>不要使用 线程实例的  wait, notify, or notifyAll</li>
</ol>
<pre><code class="language-java">
public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;
        if (millis &lt; 0) {
            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
        }

        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay &lt;= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
</code></pre>
<h1 id="让出cpu时间片yeild"><a class="header" href="#让出cpu时间片yeild">让出CPU时间片:yeild</a></h1>
<p>让出CPU时间片 重新参与等待</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线程运行时间"><a class="header" href="#线程运行时间">线程运行时间</a></h1>
<p>一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间如果 T1+T3 远大于 T2 则可以采用线程池，以提高服务器性能</p>
<h1 id="线程池技术"><a class="header" href="#线程池技术">线程池技术</a></h1>
<blockquote>
<p>一个线程池包括以下四个基本组成部分</p>
</blockquote>
<ul>
<li><strong>线程池管理器</strong> 用于创建线程，回收线程，销毁线程，添加任务</li>
<li><strong>工作线程</strong> 线程池中线程，在没有任务时，处于等待状态，可以循环执行任务</li>
<li><strong>任务接口</strong> 每个任务必须实现的接口，以供工作线程 任务的执行。它主要规定了任务的入口，任务执行完成后的收尾工作，任务的执行状态等</li>
<li><strong>任务队列</strong> 存放没有处理的任务。提供缓冲机制</li>
</ul>
<h1 id="threadpoolexecutor"><a class="header" href="#threadpoolexecutor">ThreadPoolExecutor</a></h1>
<blockquote>
<p>java中的  <em>ThreadPoolExecutor</em> 正是线程池的一种实现</p>
</blockquote>
<h2 id="初始化状态"><a class="header" href="#初始化状态">初始化状态</a></h2>
<p><strong>可指定</strong></p>
<ul>
<li><em>java.util.concurrent.BlockingQueue#workQueue</em> 任务缓存队列</li>
<li><em>corePoolSize</em> 常驻线程大小</li>
<li><em>maximumPoolSize</em> 最大线程大小</li>
<li><em>keepAliveTime</em>  线程存活时间，表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，   keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize：即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize；但是如果调用了**allowCoreThreadTimeOut(boolean)**方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0</li>
<li><em>ThreadFactory</em> 线程工厂 ，默认 <em>java.util.concurrent.Executors.DefaultThreadFactory</em></li>
<li><em>RejectedExecutionHandler</em>  任务队列满了之后的策略，默认 <em>java.util.concurrent.ThreadPoolExecutor.AbortPolicy</em></li>
<li><em>AccessControlContext</em> 访问控制上下文</li>
</ul>
<p><strong>自动初始化</strong></p>
<ul>
<li><em>ctl</em> <em>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</em></li>
<li><em>java.util.concurrent.locks.ReentrantLock#mainLock</em>  可重入锁</li>
<li><em>java.util.concurrent.ThreadPoolExecutor#workers</em>  工作线程的抽象</li>
<li><em>java.util.concurrent.ThreadPoolExecutor#termination</em> terminal锁</li>
<li><em>java.util.concurrent.ThreadPoolExecutor#largestPoolSize</em> 历史最大的线程数</li>
<li><em>java.util.concurrent.ThreadPoolExecutor#completedTaskCount</em> 用来记录已经执行完毕的任务个数</li>
</ul>
<h2 id="提交任务或执行任务"><a class="header" href="#提交任务或执行任务">提交任务或执行任务</a></h2>
<pre><code class="language-java">        int c = ctl.get();
        if (workerCountOf(c) &lt; corePoolSize) { //1.当前工作线程 小于 核心线程数，新增工作线程
                return;
            c = ctl.get();
        }
		//2.工作线程新增失败，（可能是由于其他线程新增了常驻线程，并达到了阈值），则将任务放到缓存队列中
        if (isRunning(c) &amp;&amp; workQueue.offer(command)) { 
            int recheck = ctl.get();	//2.1新增完之后，二次检查下，当前线程池 的状态，如果已经停止了，则回退操作，并拒绝
            if (! isRunning(recheck) &amp;&amp; remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0) //2.2如果工作线程个数为0，则添加一个工作线程
                addWorker(null, false);
        }
        else if (!addWorker(command, false))//3.如果线程队列满了，或者线程池已经关闭了，则拒绝
            reject(command);
</code></pre>
<h2 id="新增工作线程"><a class="header" href="#新增工作线程"><strong>新增工作线程</strong></a></h2>
<pre><code class="language-java">        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);
            // Check if queue empty only if necessary. 1.当线程池已经结束，而且 线程池不能满足以下条件 （正处于SHUTDOWN状态，且workQueue不为空，且给定的 firstTask）
            if (rs &gt;= SHUTDOWN &amp;&amp;
                ! (rs == SHUTDOWN &amp;&amp;
                   firstTask == null &amp;&amp;
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                int wc = workerCountOf(c);
                //工作线程超过指定容量
                if (wc &gt;= CAPACITY ||
                    wc &gt;= (core ? corePoolSize : maximumPoolSize))
                    return false;
                //没有超过则 对 ctl中的 workCount 自增
                //自增成功，则退出，
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                //自增失败，刷新 ctl
                c = ctl.get();  // Re-read ctl
                //如果 运行状态变了，则返回顶层循环，否则继续本层循环
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

		//自增成功，真正处理 worker
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    //以锁访问 ctl的值
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    //正在运行，或者 关闭中
                    if (rs &lt; SHUTDOWN ||
                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable 线程不是可启动的 报异常
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        //更新 历史 poolSize
                        if (s &gt; largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                //启动线程
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
</code></pre>
<h2 id="判断线程池状态"><a class="header" href="#判断线程池状态">判断线程池状态</a></h2>
<pre><code class="language-java">//不处于运行状态
public boolean isShutdown() {
        return ! isRunning(ctl.get());
}
//是否运行
private static boolean isRunning(int c) {
        return c &lt; SHUTDOWN;
}
//完全terminated
public boolean isTerminated() {
        return runStateAtLeast(ctl.get(), TERMINATED);
}
private static boolean runStateAtLeast(int c, int s) {
        return c &gt;= s;
}
//正在结束中，没有彻底结束
public boolean isTerminating() {
        int c = ctl.get();
        return ! isRunning(c) &amp;&amp; runStateLessThan(c, TERMINATED);
}
private static boolean runStateLessThan(int c, int s) {
        return c &lt; s;
}
</code></pre>
<h2 id="运行线程"><a class="header" href="#运行线程">运行线程</a></h2>
<blockquote>
<p>java.util.concurrent.ThreadPoolExecutor.Worker</p>
</blockquote>
<h3 id="运行"><a class="header" href="#运行">运行</a></h3>
<pre><code class="language-java">    final void runWorker(Worker w) {
        //获取当前线程
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            //先取firstTask,如果为空，则从缓存队列来取
            //当线程池 已经关闭，或者工作线程超时 时返回null
            while (task != null || (task = getTask()) != null) {
                //上锁
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                // 如果线程池正停止，
                // 如果没有停止，已经被中断过，并二次检查是否状态是否为STOP
                if (
                     (
					runStateAtLeast(ctl.get(), STOP) ||
                      (
                         Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)
                      )
                     )
                    &amp;&amp;
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run(); //执行任务
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            ///当线程池 已经关闭，或者工作线程超时 时清理 工作线程
            processWorkerExit(w, completedAbruptly);
        }
    }
</code></pre>
<h3 id="取task"><a class="header" href="#取task">取Task</a></h3>
<ul>
<li>调用 <strong>shutdown()</strong> 线程池 状态变为 <em>SHUTDOWN</em>，此时当线程池没有其他任务时 工作线程退出</li>
<li>调用  <strong>shutdownNow()</strong> 时，状态设置为 <strong>STOP</strong>，不会处理队列其他的任务，强行返回 <strong>NULL</strong></li>
</ul>
<pre><code class="language-java">private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary. 线程池正在关闭 ，1.当为STOP 强行返回NULL，2.当工作线程为空了则强行返回NULL
        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling? 判断 是否超时，1.手动设置 allowCoreThreadTimeOut 2.当工作线程大于常驻线程则需要超时
        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;
		//超过最大工作线程数，或者超时，
        //工作线程数 大于1，或者 任务队列为空
        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
</code></pre>
<h3 id="回收工作线程"><a class="header" href="#回收工作线程">回收工作线程</a></h3>
<blockquote>
<p>processWorkerExit</p>
</blockquote>
<pre><code class="language-java">    private void processWorkerExit(Worker w, boolean completedAbruptly) {
        if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
            decrementWorkerCount();

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            completedTaskCount += w.completedTasks;
            workers.remove(w);
        } finally {
            mainLock.unlock();
        }

        tryTerminate();

        int c = ctl.get();
        if (runStateLessThan(c, STOP)) {
            if (!completedAbruptly) {
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
                if (min == 0 &amp;&amp; ! workQueue.isEmpty())
                    min = 1;
                if (workerCountOf(c) &gt;= min)
                    return; // replacement not needed
            }
            addWorker(null, false);
        }
    }

</code></pre>
<h2 id="关闭线程池"><a class="header" href="#关闭线程池">关闭线程池</a></h2>
<h3 id="关闭线程池-1"><a class="header" href="#关闭线程池-1">关闭线程池</a></h3>
<pre><code class="language-java">    public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock(); //上锁
        try {
            checkShutdownAccess(); //检查权限校验
            advanceRunState(SHUTDOWN); //设置线程池 ctl 为 SHUTDOWN
            interruptIdleWorkers(); //中断空闲线程
            onShutdown(); // hook for ScheduledThreadPoolExecutor，中断后回调
        } finally {
            mainLock.unlock(); //释放锁
        }
        tryTerminate();//中断线程
    }
</code></pre>
<h3 id="立即关闭线程池"><a class="header" href="#立即关闭线程池">立即关闭线程池</a></h3>
<pre><code class="language-java">    public List&lt;Runnable&gt; shutdownNow() {
        List&lt;Runnable&gt; tasks;
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            checkShutdownAccess(); //检查权限校验
            advanceRunState(STOP); //设置线程池 ctl 为 CTL
            interruptWorkers(); //中断工作中线程
            tasks = drainQueue(); //获取工作线程工作结果
        } finally {
            mainLock.unlock();
        }
        tryTerminate();	//中断线程
        return tasks;
    }
</code></pre>
<h3 id="尝试关闭线程池"><a class="header" href="#尝试关闭线程池">尝试关闭线程池</a></h3>
<p>线程池 有以下四种状态</p>
<ul>
<li>运行中</li>
<li><em>SHUTDOWN</em> 等待所有任务完成后停止</li>
<li>STOP  强行停止</li>
<li>TINYTERMINTATOR 与 TERMINATED 停止状态</li>
</ul>
<p>当 状态 为 STOP 强行停止  或者  SHUTDOWN 且任务都 已经运行完毕时，才尝试 进一步停止 线程池</p>
<pre><code class="language-java">final void tryTerminate() {
        for (;;) {
            int c = ctl.get();
            //1.正在运行
            //2.已经在关闭完成
            //3.正在关闭，且队列不为空 则退出
            if (isRunning(c) ||
                runStateAtLeast(c, TIDYING) ||
                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))
                return;
            //工作线程不为0，中断空闲线程
            if (workerCountOf(c) != 0) { // Eligible to terminate
                interruptIdleWorkers(ONLY_ONE);
                return;
            }

            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                //已经位于关闭状态，且工作线程池为空，任务队列为空，则设置为 TIDYING,调用 termined()回调，设置为彻底关闭 TERMINATED,条件锁唤醒
                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                    try {
                        terminated();
                    } finally {
                        ctl.set(ctlOf(TERMINATED, 0));
                        termination.signalAll();
                    }
                    return;
                }
            } finally {
                mainLock.unlock();
            }
            // else retry on failed CAS
        }
    }
</code></pre>
<h2 id="设置线程池ctl"><a class="header" href="#设置线程池ctl">设置线程池ctl</a></h2>
<pre><code class="language-java">   private void advanceRunState(int targetState) {
        for (;;) {
            int c = ctl.get();
            //如果已经 处于 TERMINAL了，则退出
            //没有位于 TERMINAl，通过CAS设置
            //设置失败则，继续设置
            if (runStateAtLeast(c, targetState) ||
                ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))
                break;
        }
    }
</code></pre>
<h2 id="中断线程"><a class="header" href="#中断线程">中断线程</a></h2>
<pre><code class="language-java">    private void interruptIdleWorkers(boolean onlyOne) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            for (Worker w : workers) {
                Thread t = w.thread;
                if (!t.isInterrupted() &amp;&amp; w.tryLock()) {
                    try {
                        t.interrupt();
                    } catch (SecurityException ignore) {
                    } finally {
                        w.unlock();
                    }
                }
                if (onlyOne)
                    break;
            }
        } finally {
            mainLock.unlock();
        }
    }
</code></pre>
<h2 id="线程池缓冲区"><a class="header" href="#线程池缓冲区">线程池缓冲区</a></h2>
<p><strong>workQueue</strong>：一个阻塞队列，用来存储等待执行的任务，这个参数的选择会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</p>
<ul>
<li>直接提交的队列
<ol>
<li>新任务提交给线程池时,如果线程数量&lt;<code>maximumPoolSize</code>,则直接创建,否则拒绝</li>
<li><code>SynchronousQueue</code></li>
</ol>
</li>
<li>有界任务队列
<ol>
<li><code>ArrayBlockingQueue</code></li>
<li>若已有线程数量 小于 corePoolSize ,则创建新的线程,直接运行</li>
<li>若大于 corePoolSize ,则加入等待队列</li>
<li>若等待队列已满,且当前线程数量小于<code>maximumPoolSize</code>则新建线程</li>
<li>若当前线程数量已等于<code>maximumPoolSize</code>,则执行拒绝策略</li>
</ol>
</li>
<li>无界任务队列
<ol>
<li><code>LinkedBlockingQueue</code></li>
<li>若已有线程数量 小于 corePoolSize ,则创建新的线程,直接运行</li>
<li>若大于 corePoolSize ,则加入等待队列</li>
<li>无界队列会一直增长 直到内存耗尽</li>
</ol>
</li>
<li>优先任务队列:特殊的无界队列
<ol>
<li><code>PriorityBlockingQueue</code>:</li>
</ol>
</li>
</ul>
<h2 id="线程池状态"><a class="header" href="#线程池状态"><strong>线程池状态</strong></a></h2>
<pre><code class="language-java">private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;
private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;
private static final int STOP = 1 &lt;&lt; COUNT_BITS;
private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;
private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;
</code></pre>
<ul>
<li>SHUTDOWN 与STOP 状态 是平级状态，SHUTDOWN是等待所有任务全部完成后退出，STOP是强行停止所有任务并停止</li>
</ul>
<h2 id="拒绝策略"><a class="header" href="#拒绝策略">拒绝策略</a></h2>
<p>内置四种拒绝策略</p>
<ol>
<li><code>AbortPolicy</code>: 直接抛出异常</li>
<li><code>CallerRunsPolicy</code>:直接在调用者线程中运行当前被丢弃的任务</li>
<li><code>DiscardOldestPolicy</code>:丢弃最老的请求,也就是即将被执行的,并尝试再次提交当前任务</li>
<li><code>DiscardPolicy</code>:丢弃该任务</li>
</ol>
<h2 id="扩展线程池"><a class="header" href="#扩展线程池">扩展线程池</a></h2>
<ol>
<li><code>ThreadPoolExecutor</code> 可扩展线程池</li>
<li>code</li>
</ol>
<pre><code class="language-java">package com.weisanju;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolTest {
    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 100, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;&gt;(20)) {
            protected void beforeExecute(Thread t, Runnable r) {
                System.out.println(&quot;线程&quot; + t.getName() + &quot;开始运行&quot;);
            }
            protected void afterExecute(Runnable r, Throwable t) {
                System.out.println( r.toString()+ &quot;结束运行&quot;);
            }

            protected void terminated() {
                System.out.println(&quot;线程池退出&quot;);
            }
        };
        executor.execute(()-&gt;{
            System.out.println(&quot;helloWorld&quot;);
        });
        executor.shutdown();
    }
}

</code></pre>
<h1 id="executors-创建的线程池"><a class="header" href="#executors-创建的线程池">Executors 创建的线程池</a></h1>
<pre><code class="language-java">public static ExecutorService newFixedThreadPool(int nThreads){
    return new ThreadPoolExecutor(nThreads,nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre>
<ul>
<li>它是一种固定大小的线程池；</li>
<li>corePoolSize和maximunPoolSize都为用户设定的线程数量nThreads；</li>
<li>keepAliveTime为0，意味着一旦有多余的空闲线程，就会被立即停止掉；但这里keepAliveTime无效；</li>
<li>阻塞队列采用了LinkedBlockingQueue，它是一个无界队列；</li>
<li>由于阻塞队列是一个无界队列，因此永远不可能拒绝任务；</li>
<li>由于采用了无界队列，实际线程数量将永远维持在nThreads，因此maximumPoolSize和keepAliveTime将无效。</li>
</ul>
<pre><code class="language-java">public static ExecutorService newCachedThreadPool(){
    return new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.MILLISECONDS,new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre>
<ul>
<li>它是一个可以无限扩大的线程池；</li>
<li>它比较适合处理执行时间比较小的任务；</li>
<li>corePoolSize为0，maximumPoolSize为无限大，意味着线程数量可以无限大；</li>
<li>keepAliveTime为60S，意味着线程空闲时间超过60S就会被杀死；</li>
<li>采用SynchronousQueue装等待的任务，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。</li>
</ul>
<pre><code class="language-java">public static ExecutorService newSingleThreadExecutor(){
    return new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre>
<ul>
<li>它只会创建一条工作线程处理任务；</li>
<li>采用的阻塞队列为LinkedBlockingQueue；</li>
</ul>
<h1 id="线程池监控"><a class="header" href="#线程池监控">线程池监控</a></h1>
<ol>
<li><code>long getTaskCount()</code>，获取已经执行或正在执行的任务数</li>
<li><code>long getCompletedTaskCount()</code>，获取已经执行的任务数</li>
<li><code>int getLargestPoolSize()</code>，获取线程池曾经创建过的最大线程数，根据这个参数，我们可以知道线程池是否满过</li>
<li><code>int getPoolSize()</code>，获取线程池线程数</li>
<li><code>int getActiveCount()</code>，获取活跃线程数（正在执行任务的线程数）</li>
</ol>
<p>其次，<code>ThreadPoolExecutor</code>留给我们自行处理的方法有3个，它在<code>ThreadPoolExecutor</code>中为空实现（也就是什么都不做）。</p>
<ol>
<li><code>protected void beforeExecute(Thread t, Runnable r)</code> // 任务执行前被调用</li>
<li><code>protected void afterExecute(Runnable r, Throwable t)</code> // 任务执行后被调用</li>
<li><code>protected void terminated()</code> // 线程池结束后被调用</li>
</ol>
<h1 id="线程池动态扩容"><a class="header" href="#线程池动态扩容">线程池动态扩容</a></h1>
<p>ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，</p>
<ul>
<li>setCorePoolSize：设置核心池大小</li>
<li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小</li>
</ul>
<p>　　当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。</p>
<h1 id="线程池中的线程初始化"><a class="header" href="#线程池中的线程初始化">线程池中的线程初始化</a></h1>
<ul>
<li>prestartCoreThread()：初始化一个核心线程；</li>
<li>prestartAllCoreThreads()：初始化所有核心线程</li>
</ul>
<h1 id="java线程池的调优"><a class="header" href="#java线程池的调优">java线程池的调优</a></h1>
<ul>
<li>先从以下几个角度分析任务的特性：</li>
</ul>
<ol>
<li><strong>任务的性质：</strong> <code>CPU 密集型任务</code>、<code>IO 密集型任务</code>和<code>混合型任务</code>。</li>
<li><strong>任务的优先级：</strong> 高、中、低。</li>
<li><strong>任务的执行时间：</strong> 长、中、短。</li>
<li><strong>任务的依赖性：</strong> <code>是否依赖其他系统资源</code>，如<code>数据库连接</code>。</li>
</ol>
<ul>
<li><strong>任务性质不同的任务可以用不同规模的线程池分开处理。</strong> 可以通过 <code>Runtime.getRuntime().availableProcessors()</code> 方法获得当前设备的 CPU 个数。</li>
</ul>
<ol>
<li><strong>CPU 密集型任务</strong>配置<code>尽可能小的线程</code>，如配置 N c p u + 1 N_{cpu}+1<em>N<strong>c</strong>p**u</em>+1 个线程的线程池。</li>
<li><strong>IO 密集型任务</strong>则由于线程并不是一直在执行任务，则<code>配置尽可能多的线程</code>，如2 ∗ N c p u 2<em>N_{cpu}2∗</em>N<strong>c</strong>p**u*。</li>
<li><strong>混合型任务</strong>，如果可以拆分，则<code>将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务</code>。只要这<code>两个任务执行的时间相差不是太大</code>，那么<code>分解后执行的吞吐率要高于串行执行的吞吐率</code>；如果这两个任务执行时间相差太大，则没必要进行分解。</li>
</ol>
<ul>
<li><strong>优先级不同的任务</strong>可以使用优先级队列 <code>PriorityBlockingQueue</code> 来处理，它可以让优先级高的任务先得到执行。但是，如果<code>一直有高优先级的任务加入到阻塞队列中</code>，那么<code>低优先级的任务可能永远不能执行</code>。</li>
<li><strong>执行时间不同的任务</strong>可以交给<code>不同规模的线程池</code>来处理，或者<code>也可以使用优先级队列</code>，让<code>执行时间短的任务先执行</code>。</li>
<li><strong>依赖数据库连接池的任务</strong>，因为线程提交 SQL 后需要等待数据库返回结果，<code>线程数应该设置得较大</code>，这样才能更好的利用 CPU。</li>
<li><strong>建议使用有界队列</strong>，有界队列能<code>增加系统的稳定性和预警能力</code>。可以根据需要设大一点，比如几千。<code>使用无界队列</code>，线程池的队列就会越来越大，<strong>有可能会撑满内存，导致整个系统不可用</strong>。</li>
</ul>
<h1 id="scheduledthreadpool"><a class="header" href="#scheduledthreadpool">ScheduledThreadPool</a></h1>
<ul>
<li>它接收SchduledFutureTask类型的任务，有两种提交任务的方式：</li>
</ul>
<ol>
<li>scheduledAtFixedRate</li>
<li>scheduledWithFixedDelay</li>
</ol>
<ul>
<li>SchduledFutureTask接收的参数：</li>
</ul>
<ol>
<li>time：任务开始的时间</li>
<li>sequenceNumber：任务的序号</li>
<li>period：任务执行的时间间隔</li>
</ol>
<ul>
<li>它采用DelayQueue存储等待的任务</li>
<li>DelayQueue内部封装了一个PriorityQueue，它会根据time的先后时间排序，若time相同则根据sequenceNumber排序；</li>
<li>DelayQueue也是一个无界队列；</li>
<li>工作线程的执行过程：</li>
<li>工作线程会从DelayQueue取已经到期的任务去执行；</li>
<li>执行结束后重新设置任务的到期时间，再次放回DelayQueue</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aqs框架"><a class="header" href="#aqs框架">AQS框架</a></h1>
<h2 id="aqs数据结构图"><a class="header" href="#aqs数据结构图">AQS数据结构图</a></h2>
<p><img src="5.java%E5%9F%BA%E7%A1%80_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/%E5%9F%BA%E4%BA%8EAQS%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/../../../images/aqs_clh_queen.png" alt="" /></p>
<p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。</p>
<h2 id="资源访问的两种方式"><a class="header" href="#资源访问的两种方式">资源访问的两种方式</a></h2>
<p><strong>AQS定义两种资源共享方式</strong>：</p>
<ul>
<li>
<p>Exclusive（独占，只有一个线程能执行，如ReentrantLock）和</p>
</li>
<li>
<p>Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p>
</li>
</ul>
<p><strong>自定义同步器实现</strong></p>
<blockquote>
<p>不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可</strong>, 至于具体线程等待队列的维护（ 如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
</blockquote>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>
<p><strong>示例</strong></p>
<p><strong>ReentrantLock</strong></p>
<pre><code>state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。
</code></pre>
<p><strong>CountDownLatch</strong>	</p>
<pre><code>任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。
</code></pre>
<h1 id="源码解析-1"><a class="header" href="#源码解析-1">源码解析</a></h1>
<h2 id="结点状态"><a class="header" href="#结点状态">结点状态</a></h2>
<blockquote>
<p>Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。</p>
</blockquote>
<p>变量 <em>waitStatus</em> 则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。</p>
<ul>
<li><strong>CANCELLED</strong>(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li>
<li><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li>
<li><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li><strong>0</strong>：新结点入队时的默认状态。</li>
</ul>
<p>注意，<strong>负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常</strong>。</p>
<h2 id="获取独占锁入口"><a class="header" href="#获取独占锁入口">获取独占锁入口</a></h2>
<h3 id="方法体"><a class="header" href="#方法体">方法体</a></h3>
<blockquote>
<p><em>acquire</em> 方法是在独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：</p>
</blockquote>
<pre><code class="language-java">    public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
</code></pre>
<p>函数流程如下：</p>
<ol>
<li><em>tryAcquire()</em> 尝试直接去获取资源，如果成功则直接返回（这里体现了<strong>非公平锁</strong>，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待）；</li>
<li><em>addWaiter()</em> 将该线程加入等待队列的尾部，并标记为独占模式；</li>
<li><em>acquireQueued()</em> 使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>
<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>
</ol>
<h3 id="tryacquireint"><a class="header" href="#tryacquireint"><em>tryAcquire(int)</em></a></h3>
<ul>
<li>
<p>此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false</p>
</li>
<li>
<p>具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）至于能不能重入，能不能加塞，交由实现决定</p>
</li>
<li>
<p>之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared</p>
</li>
</ul>
<h3 id="addwaiternode"><a class="header" href="#addwaiternode"><em>addWaiter(Node)</em></a></h3>
<blockquote>
<p>此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点</p>
</blockquote>
<pre><code class="language-java">private Node addWaiter(Node mode) {
    //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）
    Node node = new Node(Thread.currentThread(), mode);

    //尝试快速方式直接放到队尾。
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }

    //上一步失败则通过enq入队。
    enq(node);
    return node;
}
//循环取 tail，设置值
    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
</code></pre>
<h3 id="acquirequeuednode-int"><a class="header" href="#acquirequeuednode-int"><em>acquireQueued(Node, int)</em></a></h3>
<blockquote>
<p>获取锁失败，入队列，进入等待状态休息，直到其他线程彻底释放资源后唤醒自己</p>
</blockquote>
<pre><code class="language-java">    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {//自旋
                final Node p = node.predecessor();//拿到前驱
                //如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。
                if (p == head &amp;&amp; tryAcquire(arg)) {
                    setHead(node); //拿到资源后，将head指向该结点。所以head所指的结点，就是当前获取到资源的那个结点或null。
                    p.next = null; // help GC，setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！
                    failed = false; //成功获取资源标识
                    return interrupted; //返回等待过程中是否被中断过
                }
                //如果自己可以休息了，就通过park()进入waiting状态，直到被unpark()。如果不可中断的情况下被中断了，那么会从park()中醒过来，发现拿不到资源，从而继续进入park()等待。
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed) // 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。
                cancelAcquire(node);
        }
    }
</code></pre>
<h3 id="shouldparkafterfailedacquire"><a class="header" href="#shouldparkafterfailedacquire"><em>shouldParkAfterFailedAcquire</em></a></h3>
<blockquote>
<p>此方法主要用于检查状态，看看自己是否真的可以去休息了，要是 队列前边的线程都放弃了 那么当前线程可以尝试 竞争下</p>
</blockquote>
<p><strong>如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</strong></p>
<pre><code class="language-java">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;//拿到前驱的状态
    if (ws == Node.SIGNAL)
        //如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了
        return true;
    if (ws &gt; 0) {
        /*
         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。
         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！
         * 回收已经处于  CANCELLED 状态的 等待线程结点
         */
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {
         //如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，可能前驱刚刚释放锁完毕
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
</code></pre>
<h3 id="parkandcheckinterrupt"><a class="header" href="#parkandcheckinterrupt"><em>parkAndCheckInterrupt()</em></a></h3>
<blockquote>
<p>如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。</p>
</blockquote>
<pre><code class="language-java">private final boolean parkAndCheckInterrupt() {
     LockSupport.park(this);//调用park()使线程进入waiting状态
     return Thread.interrupted();//如果被唤醒，查看自己是不是被中断的。
}
</code></pre>
<p><strong>park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。</strong></p>
<h3 id="小结"><a class="header" href="#小结">小结</a></h3>
<h4 id="入队列流程"><a class="header" href="#入队列流程">入队列流程</a></h4>
<ol>
<li>结点进入队尾后，检查状态，找到安全休息点；</li>
<li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</li>
<li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</li>
</ol>
<h4 id="获取独占锁总体流程"><a class="header" href="#获取独占锁总体流程"><strong>获取独占锁总体流程</strong></a></h4>
<ul>
<li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li>
<li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>
<li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。</li>
<li>如果在整个等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li>
</ul>
<p><strong>流程图</strong></p>
<p><img src="5.java%E5%9F%BA%E7%A1%80_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/%E5%9F%BA%E4%BA%8EAQS%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/../../../images/aqs_clh_acquire.png" alt="" /></p>
<h2 id="释放独占锁"><a class="header" href="#释放独占锁">释放独占锁</a></h2>
<blockquote>
<p>此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</p>
</blockquote>
<pre><code class="language-java">public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;//找到头结点
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);//唤醒等待队列里的下一个线程
        return true;
    }
    return false;
}
</code></pre>
<h3 id="unparksuccessor"><a class="header" href="#unparksuccessor"><em>unparkSuccessor</em></a></h3>
<blockquote>
<p>此方法用于唤醒等待队列中下一个线程,用unpark()唤醒等待队列中最前边的那个未放弃线程</p>
</blockquote>
<pre><code class="language-java">private void unparkSuccessor(Node node) {
    //这里，node一般为当前线程所在的结点。
    int ws = node.waitStatus;
    if (ws &lt; 0)//置零当前线程所在的结点状态，允许失败。
        compareAndSetWaitStatus(node, ws, 0);

    Node s = node.next;//找到下一个需要唤醒的结点s
    if (s == null || s.waitStatus &gt; 0) {//如果为空或已取消
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) // 从后向前找。
            if (t.waitStatus &lt;= 0)//从这里可以看出，&lt;=0的结点，都是还有效的结点。
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);//唤醒
}
</code></pre>
<h2 id="取消结点"><a class="header" href="#取消结点">取消结点</a></h2>
<blockquote>
<p>因为中断和超时导致的 结点取消</p>
</blockquote>
<h3 id="code"><a class="header" href="#code">Code</a></h3>
<pre><code class="language-java">private void cancelAcquire(Node node) {
    // Ignore if node doesn't exist
    if (node == null)
        return;

    node.thread = null;

    // Skip cancelled predecessors
    Node pred = node.prev;
    while (pred.waitStatus &gt; 0)
        node.prev = pred = pred.prev;

    // predNext is the apparent node to unsplice. CASes below will
    // fail if not, in which case, we lost race vs another cancel
    // or signal, so no further action is necessary.
    Node predNext = pred.next;

    // Can use unconditional write instead of CAS here.
    // After this atomic step, other Nodes can skip past us.
    // Before, we are free of interference from other threads.
    node.waitStatus = Node.CANCELLED;

    // If we are the tail, remove ourselves.
    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {
        compareAndSetNext(pred, predNext, null);
    } else {
        // If successor needs signal, try to set pred's next-link
        // so it will get one. Otherwise wake it up to propagate.
        int ws;
        if (pred != head &amp;&amp;
            ((ws = pred.waitStatus) == Node.SIGNAL ||
             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;
            pred.thread != null) {
            Node next = node.next;
            if (next != null &amp;&amp; next.waitStatus &lt;= 0)
                compareAndSetNext(pred, predNext, next);
        } else {
            unparkSuccessor(node);
        }

        node.next = node; // help GC
    }
}
</code></pre>
<h3 id="流程图"><a class="header" href="#流程图"><strong>流程图</strong></a></h3>
<p><img src="5.java%E5%9F%BA%E7%A1%80_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/%E5%9F%BA%E4%BA%8EAQS%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/../../../images/aqs_canceled.png" alt="" /></p>
<h3 id="无效结点的移除逻辑"><a class="header" href="#无效结点的移除逻辑"><strong>无效结点的移除逻辑</strong></a></h3>
<p><strong>分两步</strong></p>
<ul>
<li>第一步 将 当前结点 前驱的 后继 指向 当前结点的后继</li>
</ul>
<p><strong>伪代码</strong></p>
<pre><code class="language-c">Node prev = current.prev;
Node next = current.next;
prev.next = next;
</code></pre>
<p>这一步可能会产生冲突</p>
<p>如果前驱被取消，则唤醒后继</p>
<p>如果后继被取消，不做任何处理</p>
<ul>
<li>第二步 每个结点各自 维护自己 的<em>prev</em> 指针</li>
</ul>
<p><strong>伪代码</strong></p>
<p><strong>在调用取消结点时</strong></p>
<pre><code class="language-java">private void cancelAcquire(Node node){
    ...
    Node pred = node.prev;
	while (pred.waitStatus &gt; 0)
		node.prev = pred = pred.prev;
    ...
}

</code></pre>
<p><strong>结点入队列 结点被唤醒时，且没有获取到锁</strong></p>
<pre><code class="language-java">//判断是否应该阻塞
shouldParkAfterFailedAcquire(){
    ...
    do {
	node.prev = pred = pred.prev;
	} while (pred.waitStatus &gt; 0);
	pred.next = node;
    ...
}
//入队列
acquireQueued(){
    ...
    for (;;) {
        final Node p = node.predecessor();
        if (p == head &amp;&amp; tryAcquire(arg)) {
            setHead(node);
            p.next = null; // help GC
            failed = false;
            return interrupted;
        }
        if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
            parkAndCheckInterrupt())
            interrupted = true;
        }
    ...
}

</code></pre>
<h2 id="获取共享锁入口"><a class="header" href="#获取共享锁入口">获取共享锁入口</a></h2>
<blockquote>
<p>它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止.整个过程忽略中断</p>
</blockquote>
<pre><code class="language-java">public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}
</code></pre>
<h3 id="tryacquireshared"><a class="header" href="#tryacquireshared"><em>tryAcquireShared</em></a></h3>
<ul>
<li>
<p>该方法由子类实现</p>
</li>
<li>
<p><strong>获取指定量的共享锁</strong></p>
</li>
<li>
<p>返回值负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源</p>
</li>
</ul>
<h3 id="doacquireshared"><a class="header" href="#doacquireshared"><em>doAcquireShared</em></a></h3>
<pre><code class="language-java">private void doAcquireShared(int arg) {
    final Node node = addWaiter(Node.SHARED); //加入队列尾部
    boolean failed = true; //是否成功标志
    try {
        boolean interrupted = false; //等待过程中是否被中断过的标志
        for (;;) {
            final Node p = node.predecessor(); //前驱
            if (p == head) { //如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的
                int r = tryAcquireShared(arg);  //尝试获取资源
                if (r &gt;= 0) { //获取资源成功
                    setHeadAndPropagate(node, r);  //将head指向自己，还有剩余资源可以再唤醒之后的线程
                    p.next = null; // help GC
                    if (interrupted) //如果等待过程中被打断过，此时将中断补上。
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            //判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>
<h3 id="setheadandpropagate"><a class="header" href="#setheadandpropagate"><em>setHeadAndPropagate</em></a></h3>
<pre><code class="language-java">private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below,记录唤醒当前结点的前驱结点，也就是头结点
    setHead(node);
    /*
     * Try to signal next queued node if:
     *   Propagation was indicated by caller,
     *     or was recorded (as h.waitStatus either before
     *     or after setHead) by a previous operation
     *     (note: this uses sign-check of waitStatus because
     *      PROPAGATE status may transition to SIGNAL.)
     * and
     *   The next node is waiting in shared mode,
     *     or we don't know, because it appears null
     *
     * The conservatism in both of these checks may cause
     * unnecessary wake-ups, but only when there are multiple
     * racing acquires/releases, so most need signals now or soon
     * anyway.
     */
    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||
        (h = head) == null || h.waitStatus &lt; 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}
</code></pre>
<ul>
<li>
<p>如果 propagate 大于0，说明资源仍有余量 可以唤醒</p>
</li>
<li>
<p>如果 <em>propagate = 0</em>，但 头节点的状态 小于0，说明此时处于 <em>PROPAGATE</em>  状态 或者   <em>SIGNAL</em> 状态 也可以释放资源</p>
</li>
</ul>
<h2 id="释放共享锁入口"><a class="header" href="#释放共享锁入口">释放共享锁入口</a></h2>
<blockquote>
<p>它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源</p>
</blockquote>
<pre><code class="language-java">public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {//尝试释放资源
        doReleaseShared();//唤醒后继结点
        return true;
    }
    return false;
}
</code></pre>
<ul>
<li>
<p>一句话总结：<strong>释放掉资源后，唤醒后继</strong>。</p>
</li>
<li>
<p>跟独占模式下的release()区别：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；</p>
</li>
<li>
<p>例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p>
</li>
</ul>
<h3 id="doreleaseshared"><a class="header" href="#doreleaseshared"><em>doReleaseShared</em></a></h3>
<p><strong>分析</strong></p>
<p>每次循环中重新读取一次head，配合<em>if(h == head) break;</em>，循环检测到head没有变化时就会退出循环</p>
<p>head变化一定是因为：acquire thread被唤醒，之后它成功获取锁，然后setHead设置了新head。</p>
<pre><code>所以设置这种中间状态的head的status为PROPAGATE，让其status又变成负数，这样可能被 被唤醒线程
（因为正常来讲，被唤醒线程的前驱，也就是head会被设置为0的，所以被唤醒线程发现head不为0，就会知道自己应该去唤醒自己的后继了） 检测到。
如果状态为PROPAGATE，直接判断head是否变化。
两个continue保证了进入那两个分支后，只有当CAS操作成功后，才可能去执行if(h == head) break;，才可能退出循环。
if(h == head) break;保证了，只要在某个循环的过程中有线程刚获取了锁且设置了新head，就会再次循环。目的当然是为了再次执行unparkSuccessor(h)，即唤醒队列中第一个等待的线程。
</code></pre>
<p><strong>代码</strong></p>
<ul>
<li>如果头节点为 SIGNAL，说明后继结点在等候，则先将自身结点置为0，然后唤醒后继</li>
<li>如果头结点为 0，说明h的后继所代表的线程已经被唤醒或即将被唤醒，这种状态是一个中间状态，</li>
</ul>
<pre><code class="language-java">private void doReleaseShared() {
    for (;;) {
        Node h = head; //循环中重新读取一次head
        if (h != null &amp;&amp; h != tail) { //判断队列是否至少有两个node，如果队列从来没有初始化过（head为null），或者head就是tail，那么中间逻辑直接不走
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) { //如果状态为SIGNAL,说明h的后继是需要被通知的
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))//只要head成功得从SIGNAL修改为0，那么head的后继的代表线程肯定会被唤醒了。
                    continue;
                unparkSuccessor(h);//唤醒后继
            }
            // 如果状态为0，说明h的后继所代表的线程已经被唤醒或即将被唤醒，并且这个中间状态即将消失,要么由于acquire thread获取锁失败再次设置head为 SIGNAL并再次阻塞,要么由于acquire thread获取锁成功而将自己（head后继）设置为新head并且只要head后继不是队尾，那么新head肯定为SIGNAL。
            else if (ws == 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;
        }
        if (h == head)// head发生变化
           break;
    }
}
</code></pre>
<h1 id="个人理解"><a class="header" href="#个人理解">个人理解</a></h1>
<h2 id="aqs为什么要用双向队列"><a class="header" href="#aqs为什么要用双向队列">AQS为什么要用双向队列？</a></h2>
<ul>
<li>
<p>如果 不需要支持 中断或超时，则可以使用 单向队列，所有线程入队列之后，只可能会被阻塞直到获取锁时被唤醒</p>
</li>
<li>
<p>但如果需要支持中断或超时，则会造成链条中 出现许多 无效结点，如果使用单向链表，很难凭借无锁设计 实现原子的 结点的移除，而且被取消的结点 查找自己的前驱比较 麻烦</p>
</li>
<li>
<p><strong>AQS 使用双向队列 处理 无效结点的移除</strong></p>
</li>
<li>
<p><strong>移除无效结点</strong> 重要原则：断开其他结点对当前结点的引用 ： 前驱的引用，断开后继的引用, 而 prev结点由各个结点各自维护</p>
</li>
</ul>
<p><strong>使用双向队列的优点</strong></p>
<p><strong>减少数据竞争</strong> 取消结点时，在 维护 前驱的 next引用时，不影响 prev 引用的 使用，在决定下一个被唤醒者时， 只将 next结点作为一种优化路径，next为空或者 已取消 则使用prev结点查找 下一个候选者。</p>
<h2 id="aqs的核心"><a class="header" href="#aqs的核心">AQS的核心</a></h2>
<blockquote>
<p>AQS的核心在于 如何 原子的或者 保证队列结构安全的情况 下  将  取消的 结点 及时的 移出队列</p>
</blockquote>
<h2 id="aqs共享锁工作机制"><a class="header" href="#aqs共享锁工作机制">AQS共享锁工作机制</a></h2>
<ul>
<li>成功获取 共享锁 时候，会尝试 唤醒其他线程来 抢占资源</li>
<li>释放共享锁的时候 尝试唤醒其他线程来抢占资源</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="condition接口方法"><a class="header" href="#condition接口方法">Condition接口方法</a></h1>
<h2 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h2>
<ul>
<li>
<p><em>Condition</em> 对象 将 对象监视锁方法（<em>wait</em>，<em>notify</em>，<em>noyifyAll</em> ） 分解成多个对象，通过与任意Lock实现结合使用，使得每个锁实例对象有多个等待集</p>
</li>
<li>
<p>条件（也称为条件队列或条件变量）为一个线程挂起（“等待”），直到另一线程通知某些状态条件现在可能为真提供了一种方法。</p>
</li>
<li>
<p>condition的关键特性： 它自动释放关联的锁并挂起当前线程，就像Object.wait一样。</p>
</li>
<li>
<p>condition与锁实例 紧密关联，通过  <em>newCondition</em> 创建*Condition**</p>
</li>
<li>
<p><em>Condition</em> 子类实现能提供 比 对象锁方法 （ <em>wait</em>，<em>notify</em>，<em>noyifyAll</em> ） 更多的功能，例如 有序通知，没有必要 只能在拥有锁的情况下通知，</p>
</li>
<li>
<p>不要使用 Condition对象身上的 对象锁</p>
</li>
</ul>
<h2 id="实现注意事项"><a class="header" href="#实现注意事项">实现注意事项</a></h2>
<blockquote>
<p>当条件等待时，允许 <em>spurious wakeup</em>情况发生，</p>
</blockquote>
<p>实现可以自由地消除虚假唤醒的可能性，但是建议应用程序程序员始终假定它们会发生，因此总是在循环中等待。</p>
<p>三种形式的条件等待 （interruptible, non-interruptible, and timed）应实现各异</p>
<h2 id="举例说明"><a class="header" href="#举例说明">举例说明</a></h2>
<p>假设我们有一个有界缓冲区，它支持put和take方法。</p>
<p>当缓冲区为空， take方法 会阻塞</p>
<p>当缓冲区为满，put方法会阻塞</p>
<p>这样可以使用两个 Condition实例</p>
<p><strong>Code</strong></p>
<blockquote>
<p>该实例，将put与take 分离，分别做两个等待条件</p>
<p>java.util.concurrent.ArrayBlockingQueue  就是如此的实现思想</p>
</blockquote>
<pre><code class="language-java">   class BoundedBuffer {
     final Lock lock = new ReentrantLock();
     final Condition notFull  = lock.newCondition(); 
     final Condition notEmpty = lock.newCondition(); 
  
     final Object[] items = new Object[100];
     int putptr, takeptr, count;
  
     public void put(Object x) throws InterruptedException {
       lock.lock();
       try {
         while (count == items.length)
           notFull.await();
         items[putptr] = x;
         if (++putptr == items.length) putptr = 0;
         ++count;
         notEmpty.signal();
       } finally {
         lock.unlock();
       }
     }
  
     public Object take() throws InterruptedException {
       lock.lock();
       try {
         while (count == 0)
           notEmpty.await();
         Object x = items[takeptr];
         if (++takeptr == items.length) takeptr = 0;
         --count;
         notFull.signal();
         return x;
       } finally {
         lock.unlock();
       }
     }
   }
</code></pre>
<h2 id="接口方法-1"><a class="header" href="#接口方法-1">接口方法</a></h2>
<h3 id="await"><a class="header" href="#await">Await</a></h3>
<p><strong>方法申明</strong></p>
<pre><code class="language-java">void await() throws InterruptedException;
</code></pre>
<h4 id="方法语义"><a class="header" href="#方法语义"><strong>方法语义</strong></a></h4>
<ul>
<li>与此条件相关联的锁被原子释放，当前线程处于休眠状态，直到发生以下四种情况之一：
<ul>
<li>其他线程 调用了 该 condition的 <em>signal</em> 方法，且碰巧当前线程被选中 唤醒</li>
<li>其他线程 调用了 <em>signalAll</em> 方法</li>
<li>其他线程 打断了 该线程，且 该Condition支持 中断</li>
<li>虚假唤醒 </li>
</ul>
</li>
<li>只有线程重新竞争到锁了，之后代码才会继续执行</li>
</ul>
<h4 id="同类型方法"><a class="header" href="#同类型方法"><strong>同类型方法</strong></a></h4>
<p><strong>不可中断等待</strong></p>
<blockquote>
<p>不支持中断</p>
</blockquote>
<pre><code>void awaitUninterruptibly();
</code></pre>
<p><strong>超时等待</strong></p>
<blockquote>
<p>可不可中断，看各自的实现</p>
</blockquote>
<pre><code>boolean awaitUntil(Date deadline) throws InterruptedException;
boolean await(long time, TimeUnit unit) throws InterruptedException;
long awaitNanos(long nanosTimeout) throws InterruptedException;
</code></pre>
<h3 id="signal"><a class="header" href="#signal">Signal</a></h3>
<blockquote>
<p>唤醒等待在该条件的线程</p>
</blockquote>
<p><strong>方法申明</strong></p>
<pre><code>void signal();
void signalAll();
</code></pre>
<p><strong>方法语义</strong></p>
<ul>
<li>唤醒原则 决定于实现</li>
<li>唤醒一个，随机，或者公平，或者 全部唤醒</li>
</ul>
<h1 id="conditionobject"><a class="header" href="#conditionobject"><em>ConditionObject</em></a></h1>
<blockquote>
<p>唯一的 具体实现类，</p>
</blockquote>
<h2 id="类声明"><a class="header" href="#类声明"><strong>类声明</strong></a></h2>
<pre><code class="language-java">public abstract class AbstractQueuedSynchronizer
    extends AbstractOwnableSynchronizer
    implements java.io.Serializable {
	//与AQS 同步器 实例，相关联，一个AQS实例 可以 拥有 多个ConditionObject
    public class ConditionObject implements Condition, java.io.Serializable {}
}
</code></pre>
<h2 id="条件等待"><a class="header" href="#条件等待">条件等待</a></h2>
<h3 id="await方法"><a class="header" href="#await方法">AWAIT方法</a></h3>
<ul>
<li>是将当前线程 入 条件队列，并等待唤醒，或者中断</li>
<li>被<em>signal</em> 唤醒后，将其 从条件队列  移出 到 同步队列等待</li>
<li>被中断时 也将其 从条件队列  移出 到 同步队列等待</li>
<li>获取锁成功之后 清理 条件队列中cancelled结点</li>
</ul>
<pre><code class="language-java">        public final void await() throws InterruptedException {
            //如果是中断的，则抛异常
            if (Thread.interrupted())
                throw new InterruptedException();
            Node node = addConditionWaiter();//在 该条件队列 新增一个等待结点
            int savedState = fullyRelease(node); //释放当前线程所占有的 锁资源
            int interruptMode = 0;
            while (!isOnSyncQueue(node)) { 判断当前 线程结点 是否在AQS同步队列
                LockSupport.park(this);//如果不在 则阻塞
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    //当线程被唤醒后，判断 是由于 中断唤醒的，还是 signal 唤醒的，如果是由于中断唤醒的则，将结点 从 条件队列转移到同步队列
                    break;
            }
            //尝试在同步队列等待获取锁，如果被中断了，且之前未发生中断，或者 signal先发生于中断
            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            if (node.nextWaiter != null) // clean up if cancelled ，清理cancelled结点
                unlinkCancelledWaiters();
            if (interruptMode != 0) //重放中断
                reportInterruptAfterWait(interruptMode);
        }
</code></pre>
<h3 id="往条件队列尾部插入结点"><a class="header" href="#往条件队列尾部插入结点">往条件队列尾部插入结点</a></h3>
<pre><code class="language-java">        private Node addConditionWaiter() {
            Node t = lastWaiter;
            // If lastWaiter is cancelled, clean out. 清理cancelled结点
            if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
                unlinkCancelledWaiters();
                t = lastWaiter;
            }
            Node node = new Node(Thread.currentThread(), Node.CONDITION);
            if (t == null)
                firstWaiter = node;
            else
                t.nextWaiter = node;
            lastWaiter = node;
            return node;
        }
</code></pre>
<h3 id="释放当前线程持有锁"><a class="header" href="#释放当前线程持有锁">释放当前线程持有锁</a></h3>
<ul>
<li>如果释放失败，当前线程抛异常，并将结点置为 CANCELLED</li>
<li>其他等待在该条件队列的结点 会自动清理 CANCELLED结点</li>
</ul>
<pre><code class="language-java">    final int fullyRelease(Node node) {
        boolean failed = true;
        try {
            int savedState = getState();
            if (release(savedState)) {
                failed = false;
                return savedState;
            } else {
                throw new IllegalMonitorStateException();
            }
        } finally {
            
            if (failed)
                node.waitStatus = Node.CANCELLED;
        }
    }
</code></pre>
<h3 id="判断是否在同步队列"><a class="header" href="#判断是否在同步队列">判断是否在同步队列</a></h3>
<p><strong>在条件队列满足的情况</strong></p>
<ul>
<li>状态 为 CONDITION肯定位于 条件队列</li>
<li>prev指针为空，肯定是位于 条件队列 （同步队列CAS操作维护的是<em>prev</em> 指针，所以一定不可能为空）</li>
<li>next指针 不为<em>null</em> 一定是在同步队列</li>
<li>以上判断均不通过则
<ul>
<li>从尾到头 遍历结点 找到了则 在同步队列 找不到则不在</li>
</ul>
</li>
</ul>
<pre><code class="language-java">    final boolean isOnSyncQueue(Node node) {
        if (node.waitStatus == Node.CONDITION || node.prev == null)
            return false;
        if (node.next != null) // If has successor, it must be on queue
            return true;
        /*
         * node.prev can be non-null, but not yet on queue because
         * the CAS to place it on queue can fail. So we have to
         * traverse from tail to make sure it actually made it.  It
         * will always be near the tail in calls to this method, and
         * unless the CAS failed (which is unlikely), it will be
         * there, so we hardly ever traverse much.
         */
        return findNodeFromTail(node);
    }

    private boolean findNodeFromTail(Node node) {
        Node t = tail;
        for (;;) {
            if (t == node)
                return true;
            if (t == null)
                return false;
            t = t.prev;
        }
    }
</code></pre>
<h3 id="唤醒判断"><a class="header" href="#唤醒判断">唤醒判断</a></h3>
<blockquote>
<p>条件队列等待的结点被唤醒后，可能有两种情况，一种是被 中断唤醒，一种是 被 signal唤醒</p>
</blockquote>
<ul>
<li>判断是否存在中断
<ul>
<li>存在中断
<ul>
<li>如果CAS没有失败，中断前没有发生 <em>signal</em> 则直接入同步队列，更新 结点状态为0</li>
<li>如果CAS失败了，则中断前发生了 <em>signal</em>，则等待 自旋等待 其入同步队列</li>
</ul>
</li>
<li>不存在中断则返回0</li>
</ul>
</li>
</ul>
<pre><code class="language-java">private int checkInterruptWhileWaiting(Node node) {
    return Thread.interrupted() ?
        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
    0;
}

final boolean transferAfterCancelledWait(Node node) {
    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
        enq(node);
        return true;
    }
    /*
         * If we lost out to a signal(), then we can't proceed
         * until it finishes its enq().  Cancelling during an
         * incomplete transfer is both rare and transient, so just
         * spin.
         */
    while (!isOnSyncQueue(node))
        Thread.yield();
    return false;
}
</code></pre>
<h2 id="条件唤醒"><a class="header" href="#条件唤醒">条件唤醒</a></h2>
<blockquote>
<p>唤醒条件队列，需要持有锁，且以队列先进先出形式 唤醒.</p>
</blockquote>
<p><strong>先进先出唤醒</strong></p>
<pre><code class="language-java">        public final void signal() {
            //唤醒条件 需要持有锁
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            Node first = firstWaiter;
            //唤醒队列中的第一个
            if (first != null)
                doSignal(first);
        }
</code></pre>
<p><strong>头节点出队列</strong></p>
<pre><code class="language-java">        private void doSignal(Node first) {
        //移除头结点，并清空引用，当头结点也为空了，尾结点也置空
            do {
                if ( (firstWaiter = first.nextWaiter) == null)
                    lastWaiter = null;
                first.nextWaiter = null;
            } while (!transferForSignal(first) &amp;&amp;
                     (first = firstWaiter) != null);
        }
</code></pre>
<p><strong>入同步队列</strong></p>
<pre><code class="language-java">    final boolean transferForSignal(Node node) {
        /*
         * If cannot change waitStatus, the node has been cancelled.如果结点被取消了。则尝试唤醒下一个结点
         */
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;

        /*
         * Splice onto queue and try to set waitStatus of predecessor to
         * indicate that thread is (probably) waiting. If cancelled or
         * attempt to set waitStatus fails, wake up to resync (in which
         * case the waitStatus can be transiently and harmlessly wrong).
         */
        Node p = enq(node);
        int ws = p.waitStatus;
        if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
            LockSupport.unpark(node.thread);
        return true;
    }
</code></pre>
<p><strong>总结</strong></p>
<ul>
<li>首先发信号需要持有锁</li>
<li>先唤醒 条件队列中的第一个，如果已取消则顺延到下一个</li>
<li>然后入同步队列，并尝试修改 前驱的 状态为 SIGNAL，修改失败可能是由于 线程中断，超时，取消等原因</li>
<li>修改失败，则唤醒 当前结点 同步前驱引用</li>
</ul>
<h2 id="唤醒全部"><a class="header" href="#唤醒全部">唤醒全部</a></h2>
<p>循环遍历 条件队列中的每一个 结点调用 上述 唤醒逻辑</p>
<h2 id="不可中断等待"><a class="header" href="#不可中断等待">不可中断等待</a></h2>
<ul>
<li>新增结点</li>
<li>释放锁</li>
<li>如果不在同步队列则 阻塞</li>
<li>如果 中途被中断了 则记录中断状态</li>
<li>后续被唤醒后 重放中断</li>
</ul>
<pre><code class="language-java">public final void awaitUninterruptibly() {
    Node node = addConditionWaiter();
    int savedState = fullyRelease(node);
    boolean interrupted = false;
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        if (Thread.interrupted())
            interrupted = true;
    }
    if (acquireQueued(node, savedState) || interrupted)
        selfInterrupt();
}
</code></pre>
<h2 id="超时等待"><a class="header" href="#超时等待">超时等待</a></h2>
<ul>
<li>新增结点</li>
<li>释放锁</li>
<li>如果不在同步队列则 阻塞指定纳秒，（当小于1000NS，则应该自旋比阻塞更快）</li>
<li>如果中间存在中断则 响应中断</li>
<li>如果 时间到期了，则入同步队列</li>
</ul>
<pre><code class="language-java">public final long awaitNanos(long nanosTimeout)
    throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    Node node = addConditionWaiter();
    int savedState = fullyRelease(node);
    final long deadline = System.nanoTime() + nanosTimeout;
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {
        if (nanosTimeout &lt;= 0L) {
            transferAfterCancelledWait(node);
            break;
        }
        if (nanosTimeout &gt;= spinForTimeoutThreshold)
            LockSupport.parkNanos(this, nanosTimeout);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
        nanosTimeout = deadline - System.nanoTime();
    }
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null)
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
    return deadline - System.nanoTime();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍-2"><a class="header" href="#介绍-2">介绍</a></h1>
<ul>
<li>
<p>一种同步工具类  旨在 允许一个或多个线程等待，直到在其他线程中执行的一组操作完成为止</p>
</li>
<li>
<p><em>await</em> 方法 会阻塞 直到 调用 <em>countDown</em> 使得 <em>count</em> 数量为0，所有线程 将会执行接下来的操作</p>
</li>
<li>
<p>这是一次性的 现象，如果需要 重置 <em>count</em> 请使用 <em>CyclicBarrier</em></p>
</li>
<li>
<p>简单使用</p>
<p><strong>example1</strong></p>
<pre><code class="language-java">class Driver { // ...
   void main() throws InterruptedException {
       //启动信号量
     CountDownLatch startSignal = new CountDownLatch(1);
     CountDownLatch doneSignal = new CountDownLatch(N);

     for (int i = 0; i &lt; N; ++i) // create and start threads
       new Thread(new Worker(startSignal, doneSignal)).start();

     doSomethingElse();            // don't let run yet
      //启动线程
     startSignal.countDown();      // let all threads proceed
     doSomethingElse();
       //等待线程
     doneSignal.await();           // wait for all to finish
   }
 }

 class Worker implements Runnable {
   private final CountDownLatch startSignal;
   private final CountDownLatch doneSignal;
   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
     this.startSignal = startSignal;
     this.doneSignal = doneSignal;
   }
   public void run() {
     try {
         //所有线程等待启动
       startSignal.await();
       doWork();
       doneSignal.countDown();
     } catch (InterruptedException ex) {} // return;
   }

   void doWork() { ... }
 }
</code></pre>
<p><strong>example2</strong></p>
<pre><code class="language-java"> class Driver2 { // ...
   void main() throws InterruptedException {
     CountDownLatch doneSignal = new CountDownLatch(N);
     Executor e = ...

     for (int i = 0; i &lt; N; ++i) // create and start threads
       e.execute(new WorkerRunnable(doneSignal, i));

     doneSignal.await();           // wait for all to finish
   }
 }

 class WorkerRunnable implements Runnable {
   private final CountDownLatch doneSignal;
   private final int i;
   WorkerRunnable(CountDownLatch doneSignal, int i) {
     this.doneSignal = doneSignal;
     this.i = i;
   }
   public void run() {
     try {
       doWork(i);
       doneSignal.countDown();
     } catch (InterruptedException ex) {} // return;
   }

   void doWork() { ... }
 }
</code></pre>
</li>
<li>
<p><strong>Memory consistency effects</strong>: Until the count reaches zero, actions in a thread prior to calling countDown() happen-before actions following a successful return from a corresponding await() in another thread.</p>
</li>
</ul>
<h1 id="await-1"><a class="header" href="#await-1">AWAIT</a></h1>
<p><strong>等待</strong></p>
<pre><code class="language-java">public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}
//AQS尝试获取 锁，获取锁失败则阻塞在同步队列中等待
public final void acquireSharedInterruptibly(int arg)
    throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireSharedInterruptibly(arg);
}
</code></pre>
<p><strong>尝试获取锁资源</strong></p>
<p><strong>只要 状态不为0，则一直等待</strong></p>
<pre><code class="language-java">protected int tryAcquireShared(int acquires) {
    return (getState() == 0) ? 1 : -1;
}
</code></pre>
<h1 id="countdown"><a class="header" href="#countdown">CountDown</a></h1>
<ul>
<li>自旋释放</li>
<li>如果 状态量为0 ，则 唤醒所有等待 在 该同步队列的 线程</li>
</ul>
<pre><code class="language-java">public void countDown() {
    sync.releaseShared(1);
}

protected boolean tryReleaseShared(int releases) {
    // Decrement count; signal when transition to zero
    for (;;) {
        int c = getState();
        if (c == 0)
            return false;
        int nextc = c-1;
        if (compareAndSetState(c, nextc))
            return nextc == 0;
    }
}
</code></pre>
<h1 id="超时await"><a class="header" href="#超时await">超时AWAIT</a></h1>
<pre><code class="language-java">    public boolean await(long timeout, TimeUnit unit)
        throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍-3"><a class="header" href="#介绍-3">介绍</a></h1>
<ul>
<li>
<p>同步工具类 旨在 允许 所有线程 等待直到 他们 达到了 某个 障碍点</p>
</li>
<li>
<p>CyclicBarriers在涉及固定大小的线程的程序中很有用，该线程方有时必须互相等待</p>
</li>
<li>
<p>The barrier is called cyclic  是因为 它可以在释放等待线程后重新使用。</p>
</li>
<li>
<p><em>CyclicBarrier</em> 支持可选的Runnable命令，该命令在障碍中的最后一个线程到达之后 但在释放任何线程之前，每个障碍点运行一次。
this barrier action 对于在任何线程继续之前  更新共享状态很有用。</p>
</li>
</ul>
<h1 id="await-2"><a class="header" href="#await-2">AWAIT</a></h1>
<p>阻塞 直到 所有线程都 阻塞在 该 <em>barrier</em> </p>
<p><strong>从AWAIT唤醒</strong></p>
<p>如果当前线程 不是 最后一个 调用 <em>AWAIT</em> ，那么该线程会被 休眠，不回被调度。直到以下事情发生</p>
<ul>
<li>最后一个线程到达</li>
<li>当前线程被打断了</li>
<li>位于等待的  其他线程之一 被打断了</li>
<li>等待中的 线程 超时了</li>
<li>其他线程调用 <em>reset</em></li>
</ul>
<p><strong>中断异常抛出</strong></p>
<ul>
<li>
<p>如果当前线程 进入这个方法之前被 中断了</p>
</li>
<li>
<p>或者在等待 的过程中  被中断了 则 先清除中断状态 抛出 <em>InterruptedException</em></p>
</li>
</ul>
<p><strong>BrokenBarrierException抛出</strong></p>
<ul>
<li>如果 调用 <em>reset</em> 时 有线程 在等待，</li>
<li>或者 有线程调用 <em>await</em> 或者 <em>barrier</em> is <em>broken</em> </li>
</ul>
<p><strong>BarrierAction</strong></p>
<p>如果一个线程 被中断了，则其他线程 将会 抛出 <em>BrokenBarrierException</em></p>
<p>如果一个线程是最后调用 <em>await</em> 而且 提供了 非空的  <em>BarrierAction</em> ，它会首先执行 <em>BarrierAction</em> 然后在唤醒其他线程</p>
<p>如果执行 BarrierAction 抛异常，则异常会被 抛出到当前线程，barrier也被置位 <em>broken</em></p>
<p><strong>非超时等待</strong></p>
<pre><code class="language-java">public int await() throws InterruptedException, BrokenBarrierException {
    try {
        return dowait(false, 0L);
    } catch (TimeoutException toe) {
        throw new Error(toe); // cannot happen
    }
}
</code></pre>
<pre><code class="language-java">private int dowait(boolean timed, long nanos)
    throws InterruptedException, BrokenBarrierException,
           TimeoutException {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        //获取当前的 barrier代
        final Generation g = generation;

        //如果已经 破损，则抛出破损异常
        if (g.broken)
            throw new BrokenBarrierException();

        //如果当前线程被中断了，则 将 barrier 置位 broken，并抛出中断异常
        if (Thread.interrupted()) {
            breakBarrier();
            throw new InterruptedException();
        }
		//对 count自减
        int index = --count;
        
        //最后一个 arrive 则执行 BarrierAction
        if (index == 0) {  // tripped
            boolean ranAction = false;
            try {
                final Runnable command = barrierCommand;
                if (command != null)
                    command.run();
                ranAction = true; //更新换代 barrier generation
                nextGeneration();
                return 0;
            } finally { //如果抛异常了，则 将 barrier置位 broken
                if (!ranAction)
                    breakBarrier();
            }
        }
		//如果不是最后一个 arrive的线程，则 自选等待
        // loop until tripped, broken, interrupted, or timed out
        for (;;) {
            try {
                if (!timed)
                    trip.await();
                else if (nanos &gt; 0L)
                    nanos = trip.awaitNanos(nanos);
            } catch (InterruptedException ie) {
                //被中断了，且还没有 broken 则 broken
                if (g == generation &amp;&amp; ! g.broken) {
                    breakBarrier();
                    throw ie;
                } else {
                    //被中断了，但已经更新换代了，则可以认为 继续执行
                    // We're about to finish waiting even if we had not
                    // been interrupted, so this interrupt is deemed to
                    // &quot;belong&quot; to subsequent execution.
                    Thread.currentThread().interrupt();
                }
            }

            if (g.broken)
                throw new BrokenBarrierException();
			
            //如果更新换代了，则说明是被最后一个 arriver 唤醒的，则返回index,到达的索引
            if (g != generation)
                return index;

            //如果超时了，则 置 breakBarrier 为 broken
            if (timed &amp;&amp; nanos &lt;= 0L) {
                breakBarrier();
                throw new TimeoutException();
            }
        }
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h1 id="重置"><a class="header" href="#重置">重置</a></h1>
<pre><code class="language-java">    public void reset() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            //将 barrier 置位 broken
            breakBarrier();   // break the current generation
            //开始下一个 generation
            nextGeneration(); // start a new generation
        } finally {
            lock.unlock();
        }
    }
</code></pre>
<h1 id="打破barrier"><a class="header" href="#打破barrier">打破Barrier</a></h1>
<ul>
<li>代数置位 <em>true</em></li>
<li>重置 count</li>
<li>唤醒其他 阻塞线程</li>
</ul>
<pre><code class="language-java">private void breakBarrier() {
    generation.broken = true;
    count = parties;
    trip.signalAll();
}
</code></pre>
<h1 id="更新换代"><a class="header" href="#更新换代">更新换代</a></h1>
<ul>
<li>通知其他 线程</li>
<li>重置 count</li>
<li>更新 generation 引用</li>
</ul>
<pre><code class="language-java">private void nextGeneration() {
    // signal completion of last generation
    trip.signalAll();
    // set up next generation
    count = parties;
    generation = new Generation();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍-4"><a class="header" href="#介绍-4">介绍</a></h1>
<ul>
<li>
<p>与使用 <em>synchronized</em> 方法和语句相比，锁实现提供了更扩展的锁操作。</p>
</li>
<li>
<p>锁是 在多线程环境中，对共享资源 的访问控制</p>
</li>
<li>
<p>尽管 <em>synchronized</em>关键字提供的 作用域使得编程更为简单，但有时候需要更为 弹性的方式使用锁 例如 <code>链式锁</code></p>
</li>
</ul>
<pre><code>获取 nodeA的锁，获取nodeB的锁，然后释放A，
获取C的锁，释放B，获取D的锁
</code></pre>
<ul>
<li>灵活性的提高带来了额外的工作量，例如不会 像 <em>synchronized</em> 自动释放锁</li>
</ul>
<p><strong>锁实现提供了 比 <em>synchronized</em> 更多的功能</strong></p>
<ul>
<li>非阻塞获取锁 <em>tryLock()</em></li>
<li>可中断的方式获取锁 <em>lockInterruptibly</em> ，<em>tryLock(long, TimeUnit)</em></li>
<li>非可重入</li>
<li>死锁检测</li>
<li>公平与公平</li>
</ul>
<p><strong>内存同步语义</strong></p>
<p>所有Lock实现都必须强制执行与内置监视器锁相同的内存同步语义</p>
<p>三种获取锁的形式（可中断，不可中断，超时）根据 不同的实现而不同</p>
<p>实现需要清楚地记录每个锁定方法提供的语义和保证。</p>
<h1 id="lock接口方法"><a class="header" href="#lock接口方法">Lock接口方法</a></h1>
<h2 id="lock"><a class="header" href="#lock">LOCK</a></h2>
<p><strong>签名</strong></p>
<pre><code>void lock();
</code></pre>
<ul>
<li>获取锁，如果锁不可用，则当前线程进入休眠状态，不会被CPU进行线程调度</li>
<li>子类实现 要求 能够进行 错误检测，例如死锁，错误检测需要 标识出文档</li>
</ul>
<h2 id="trylock"><a class="header" href="#trylock">TryLock</a></h2>
<p><strong>签名</strong></p>
<pre><code>boolean tryLock();
</code></pre>
<ul>
<li>当锁可用时 上锁，并返回<em>True</em></li>
<li>当锁不可用时，返回<em>false</em></li>
</ul>
<p><em>用法</em></p>
<pre><code class="language-java"> Lock lock = ...;
 if (lock.tryLock()) {
   try {
     // manipulate protected state
   } finally {
     lock.unlock();
   }
 } else {
   // perform alternative actions
 }
</code></pre>
<h2 id="timed-trylock"><a class="header" href="#timed-trylock">Timed TryLock</a></h2>
<p><strong>签名</strong></p>
<pre><code class="language-java">boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
</code></pre>
<ul>
<li>如果锁在给定的等待时间内是空闲的，并且当前线程尚未中断，则获取该锁。</li>
<li>如果锁可用，则此方法立即返回true值。如果该锁不可用，当前线程处于休眠状态，直到发生以下三种情况之一：
<ul>
<li>当前线程获取锁，返回true</li>
<li>其他线程中断了此线程（获取锁支持中断） 抛出 <em>InterruptedException</em> 并清除中断标志</li>
<li>指定时间到了 返回<em>false</em></li>
</ul>
</li>
</ul>
<h2 id="unlock"><a class="header" href="#unlock">Unlock</a></h2>
<p><strong>签名</strong></p>
<pre><code>void unlock();
</code></pre>
<h2 id="condition"><a class="header" href="#condition">Condition</a></h2>
<blockquote>
<p><strong>新建与 锁实例绑定的  条件</strong></p>
<p><em>synchronized</em> 与 wait,notify,notifyAll 的关系 等同于 <em>Condition</em> 与 Lock的关系</p>
</blockquote>
<p><strong>签名</strong></p>
<pre><code>Condition newCondition();
</code></pre>
<p>具体 条件类 见 <a href="5.java%E5%9F%BA%E7%A1%80_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/%E5%9F%BA%E4%BA%8EAQS%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/Condition%E6%9D%A1%E4%BB%B6%E7%AD%89%E5%BE%85.html">Condition接口</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍-5"><a class="header" href="#介绍-5">介绍</a></h1>
<p>可重入互斥锁，实现了与 隐式锁 <em>synchronized</em> 同样的 行为 与 语义，但扩展了其功能</p>
<h2 id="锁逻辑"><a class="header" href="#锁逻辑"><strong>锁逻辑</strong></a></h2>
<ul>
<li>可重入锁  被上次成功上锁，但目前还未解锁 的线程拥有</li>
<li>如果 锁还未被任何线程占有，则当线程上锁时能成功获取锁</li>
<li>如果当前线程已经 占有改锁，重复加锁会记录加锁的次数，次数通过 *isHeldByCurrentThread, and getHoldCount.*获取</li>
</ul>
<h2 id="公平与非公平"><a class="header" href="#公平与非公平">公平与非公平</a></h2>
<p><strong>公平锁</strong></p>
<p>遵循先来先获取锁的原则，倾向于分配给等待时间最长的线程</p>
<p>使用公平锁会降低系统整体吞吐量，但减少 饥饿锁的现象</p>
<p>锁的公平获取不保证 线程的公平调度</p>
<p><em>untimed tryLock()</em> 不会遵循公平与非公平，当锁可用时则 立即获取锁</p>
<h2 id="建议使用方式"><a class="header" href="#建议使用方式">建议使用方式</a></h2>
<blockquote>
<p>使用 try finally 保证锁会被释放</p>
</blockquote>
<pre><code class="language-java"> class X {
   private final ReentrantLock lock = new ReentrantLock();
   // ...

   public void m() {
     lock.lock();  // block until condition holds
     try {
       // ... method body
     } finally {
       lock.unlock()
     }
   }
 }
</code></pre>
<h1 id="可重入锁-1"><a class="header" href="#可重入锁-1">可重入锁</a></h1>
<blockquote>
<p>Lock接口方法 全部委托于 <em>Sync</em> 类来实现</p>
</blockquote>
<ul>
<li>主要有两个同步器 <em>NonfairSync</em> <em>FairSync</em></li>
</ul>
<h2 id="nonfairsync"><a class="header" href="#nonfairsync"><em>NonfairSync</em></a></h2>
<blockquote>
<p>非公平锁同步器</p>
</blockquote>
<h3 id="独占锁获取逻辑"><a class="header" href="#独占锁获取逻辑">独占锁获取逻辑</a></h3>
<blockquote>
<p>先尝试获取锁，体现了非公平的方式，如果没有获取成功则 入队列等待</p>
</blockquote>
<pre><code class="language-java">        final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
</code></pre>
<h3 id="独占锁释放逻辑"><a class="header" href="#独占锁释放逻辑">独占锁释放逻辑</a></h3>
<blockquote>
<p>直接以独占锁的方式释放锁</p>
</blockquote>
<pre><code class="language-java">        protected final boolean tryRelease(int releases) {
            int c = getState() - releases; //拥有锁的线程不是 当前线程则报错
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
</code></pre>
<h3 id="尝试获取锁"><a class="header" href="#尝试获取锁">尝试获取锁</a></h3>
<blockquote>
<p>尝试获取锁，只能是非公平方式</p>
</blockquote>
<pre><code class="language-java">    public boolean tryLock() {
        return sync.nonfairTryAcquire(1);
    }


    final boolean nonfairTryAcquire(int acquires) {
        	//获取当前线程，获取当前线程状态
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) { //锁可用
                if (compareAndSetState(0, acquires)) {  //尝试获取锁
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) { //获取锁失败，判断是否是同一线程
                int nextc = c + acquires;
                if (nextc &lt; 0) // overflow
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }
</code></pre>
<h2 id="fairsync"><a class="header" href="#fairsync">FairSync</a></h2>
<h3 id="公平方式获取独占锁"><a class="header" href="#公平方式获取独占锁"><strong>公平方式获取独占锁</strong></a></h3>
<ul>
<li>一开始不尝试获取锁，直接进入队列排队</li>
<li>如果没有继任者，尝试获取锁，如果获取锁成功，则返回true</li>
</ul>
<pre><code class="language-java">final void lock() {
    acquire(1);
}

protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (!hasQueuedPredecessors() &amp;&amp;
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &lt; 0)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}
</code></pre>
<h3 id="判断是否可以获取锁"><a class="header" href="#判断是否可以获取锁">判断是否可以获取锁</a></h3>
<blockquote>
<p><strong>查询是否有任何线程在等待获取比当前线程更长的时间</strong></p>
</blockquote>
<ul>
<li>不存在排队队列</li>
<li>或者 head的下一个结点 不是 自己 <code>getFirstQueuedThread（）！= Thread.currentThread（）&amp;&amp; hasQueuedThreads（）</code></li>
</ul>
<p>请注意，由于中断和超时引起的取消可能随时发生，因此返回true不能保证某些其他线程将在当前线程之前获取。</p>
<pre><code class="language-java">public final boolean hasQueuedPredecessors() {
    // The correctness of this depends on head being initialized
    // before tail and on head.next being accurate if the current
    // thread is first in queue.
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
    return h != t &amp;&amp;
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
</code></pre>
<h3 id="释放锁"><a class="header" href="#释放锁">释放锁</a></h3>
<p><strong>同非公平锁一样</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述"><a class="header" href="#概述">概述</a></h1>
<p><strong>简介</strong></p>
<ul>
<li>ReentrantReadWriteLock是Lock的另一种实现方式，ReentrantLock是一个可重入的排他锁，同一时间只允许一个线程访问</li>
<li>而ReentrantReadWriteLock允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。</li>
<li>在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时ReentrantReadWriteLock能够提供比排他锁更好的并发性和吞吐量。</li>
<li>读写锁内部维护了两个锁，一个用于读操作，一个用于写操作。所有 ReadWriteLock实现都必须保证 writeLock操作的内存同步效果也要保持与相关 readLock的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。</li>
</ul>
<p>　　</p>
<p><strong>ReentrantReadWriteLock锁功能</strong></p>
<ol>
<li>支持公平和非公平的获取锁的方式；</li>
<li>支持可重入。读线程在获取了读锁后还可以获取读锁；写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；</li>
<li>还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的；</li>
<li>读取锁和写入锁都支持锁获取期间的中断；</li>
<li>Condition支持。仅写入锁提供了一个 Conditon 实现；读取锁不支持 Conditon ，readLock().newCondition() 会抛出 UnsupportedOperationException。 </li>
</ol>
<h1 id="实现原理"><a class="header" href="#实现原理">实现原理</a></h1>
<p>​		ReentrantReadWriteLock 也是基于AQS实现的，它的自定义同步器（继承AQS）需要在同步状态（一个整型变量state）上维护多个读线程和一个写线程的状态，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。</p>
<p><img src="5.java%E5%9F%BA%E7%A1%80_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/%E5%9F%BA%E4%BA%8EAQS%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/../../../images/reentrant_read_write_state.png" alt="读写锁状态设计图" /></p>
<h2 id="写锁的获取与释放writelock"><a class="header" href="#写锁的获取与释放writelock">写锁的获取与释放（WriteLock）</a></h2>
<h3 id="获取写锁"><a class="header" href="#获取写锁">获取写锁</a></h3>
<ul>
<li>如果存在读锁 则 返回失败</li>
<li>如果存在 写锁 且不为当前线程所拥有，则返回失败</li>
<li>如果存在 写锁  且为当前线程 且没有超过 极值，则加锁成功</li>
<li>如果读写锁都不存在
<ul>
<li>如果是公平锁则 进入队列等待</li>
<li>如果是非公平锁，则先尝试获取 锁，然后进入队列等待</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//获取写锁
public void lock() {
    sync.acquire(1);
}

//AQS实现的独占式获取同步状态方法
public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

//自定义重写的tryAcquire方法
protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    int c = getState();
    int w = exclusiveCount(c);    //取同步状态state的低16位，写同步状态
    if (c != 0) {
        // (Note: if c != 0 and w == 0 then shared count != 0)
        //存在读锁或当前线程不是已获取写锁的线程，返回false
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
		//说明当前线程获取了写锁，判断可重入次数（最大次数65535）
        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)    //
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        // Reentrant acquire
        setState(c + acquires);
        return true;
    }
    //此时c=0,读锁和写锁都没有被获取
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}
</code></pre>
<h3 id="释放写锁"><a class="header" href="#释放写锁">释放写锁</a></h3>
<blockquote>
<p>支持可重入的释放</p>
</blockquote>
<pre><code class="language-java">//写锁释放
public void unlock() {
    sync.release(1);
}

//AQS提供独占式释放同步状态的方法
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}

//自定义重写的tryRelease方法
protected final boolean tryRelease(int releases) {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    int nextc = getState() - releases;    //同步状态减去releases
    //判断同步状态的低16位（写同步状态）是否为0，如果为0则返回true，否则返回false.
    //因为支持可重入
    boolean free = exclusiveCount(nextc) == 0;
    if (free)
        setExclusiveOwnerThread(null);
    setState(nextc);    //以获取写锁，不需要其他同步措施，是线程安全的
    return free;
}
</code></pre>
<h2 id="读锁的获取与释放"><a class="header" href="#读锁的获取与释放">读锁的获取与释放</a></h2>
<h3 id="获取读锁"><a class="header" href="#获取读锁">获取读锁</a></h3>
<ul>
<li>如果有写锁在且当前线程没有拥有锁  则 返回失败</li>
<li>如果是 非公平锁 则判断下一个排队的是否为写锁，如果不是 则 直接 尝试 CAS获取一个读锁。</li>
</ul>
<pre><code class="language-java">public void lock() {
    sync.acquireShared(1);
}

//使用AQS提供的共享式获取同步状态的方法
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}

//自定义重写的tryAcquireShared方法，参数是unused，因为读锁的重入计数是内部维护的
protected final int tryAcquireShared(int unused) {
    /*
             * Walkthrough:
             * 1. If write lock held by another thread, fail.
             * 2. Otherwise, this thread is eligible for
             *    lock wrt state, so ask if it should block
             *    because of queue policy. If not, try
             *    to grant by CASing state and updating count.
             *    Note that step does not check for reentrant
             *    acquires, which is postponed to full version
             *    to avoid having to check hold count in
             *    the more typical non-reentrant case.
             * 3. If step 2 fails either because thread
             *    apparently not eligible or CAS fails or count
             *    saturated, chain to version with full retry loop.
             */
    Thread current = Thread.currentThread();
    int c = getState();
    if (exclusiveCount(c) != 0 &amp;&amp;
        getExclusiveOwnerThread() != current)
        return -1;
    int r = sharedCount(c);
    if (!readerShouldBlock() &amp;&amp;
        r &lt; MAX_COUNT &amp;&amp;
        compareAndSetState(c, c + SHARED_UNIT)) {
        if (r == 0) { //缓存第一个获取读锁的线程
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) { //可重入获取第一个读锁计数
            firstReaderHoldCount++;
        } else { //不是第一个获取读锁的线程
            HoldCounter rh = cachedHoldCounter; //当前线程缓存的 holdCounter,每个线程一个
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0) // 当前线程 获取读锁-&gt;释放读锁-&gt;获取读锁，这个过程没有第三方线程获取读锁，这种情况需要重新设置 ThreadLocal
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    
     //第一次获取读锁失败，有两种情况：
		//1）没有写锁被占用时，尝试通过一次CAS去获取锁时，更新失败（说明有其他读锁在申请）
		//2）（非公平锁的逻辑）当前线程占有写锁，并且有其他写锁在当前线程的下一个节点等待获取写锁，除非当前线程的下一个节点被取消，否则fullTryAcquireShared也获取不到读锁
    return fullTryAcquireShared(current);
}
</code></pre>
<p>**公平与非公平 <em>readerShouldBlock()<em>逻辑</em></em></p>
<pre><code class="language-java">//FairSync中需要判断是否有前驱节点，如果有则返回false，否则返回true。遵循FIFO
final boolean readerShouldBlock() {
    return hasQueuedPredecessors();
}
//unfair
final boolean readerShouldBlock() {
    return apparentlyFirstQueuedIsExclusive();
}
//当head节点不为null且head节点的下一个节点s不为null且s是独占模式（写线程）且s的线程不为null时，返回true。
//目的是不应该让写锁始终等待。作为一个启发式方法用于避免可能的写线程饥饿，这只是一种概率性的作用，因为如果有一个等待的写线程在其他尚未从队列中出队的读线程后面等待，那么新的读线程将不会被阻塞。
final boolean apparentlyFirstQueuedIsExclusive() {
    Node h, s;
    return (h = head) != null &amp;&amp;
        (s = h.next)  != null &amp;&amp;
        !s.isShared()         &amp;&amp;
        s.thread != null;
}
//头节点的 下一个不是当前线程，则继续阻塞
 public final boolean hasQueuedPredecessors() {
        // The correctness of this depends on head being initialized
        // before tail and on head.next being accurate if the current
        // thread is first in queue.
        Node t = tail; // Read fields in reverse initialization order
        Node h = head;
        Node s;
        return h != t &amp;&amp;
            ((s = h.next) == null || s.thread != Thread.currentThread());
    }
</code></pre>
<p><strong>第一次获取失败，尝试完整版本的自旋获取锁</strong></p>
<pre><code class="language-java">       final int fullTryAcquireShared(Thread current) {
            /*
             * This code is in part redundant with that in
             * tryAcquireShared but is simpler overall by not
             * complicating tryAcquireShared with interactions between
             * retries and lazily reading hold counts.
             */
            HoldCounter rh = null;
            for (;;) {
                int c = getState();
                if (exclusiveCount(c) != 0) { //如果当前线程不是写锁的持有者，直接返回-1，结束尝试获取读锁，需要排队去申请读锁
                    if (getExclusiveOwnerThread() != current) //且不是当前线程，则返回
                        return -1;
                    // else we hold the exclusive lock; blocking here
                    // would cause deadlock.
                	} else if (readerShouldBlock()) { //如果当前线程持有写锁，而且还有其他线程已经排队在申请写锁，故，即使申请读锁的线程已经持有写锁（写锁内部再次申请读锁，俗称锁降级）还是会失败，因为有其他线程也在申请写锁，此时，只能结束本次申请读锁的请求，转而去排队。
                    // Make sure we're not acquiring read lock reentrantly
                    if (firstReader == current) { 
                        // 当前线程已持有写锁，且有其他线程在申请写锁，且当前线程已获取过读锁，则可以继续获取读锁
                        // assert firstReaderHoldCount &gt; 0;
                    } else {
                        // 当前线程已持有写锁，且有其他线程在申请写锁，且当前线程未获取读锁，则返回阻塞
                        if (rh == null) {
                            rh = cachedHoldCounter;
                            if (rh == null || rh.tid != getThreadId(current)) {
                                rh = readHolds.get();
                                if (rh.count == 0)
                                    readHolds.remove();  
                            }
                        }
                        if (rh.count == 0)
                            return -1;
                    }
                }
                //共享锁最大值判定
                if (sharedCount(c) == MAX_COUNT)
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                //尝试获取一个读锁,获取失败 则继续
                if (compareAndSetState(c, c + SHARED_UNIT)) {
                    //第一次使用 firstReader，firstReaderHoldCount
                    if (sharedCount(c) == 0) {
                        firstReader = current;
                        firstReaderHoldCount = 1;
                    } else if (firstReader == current) {
                        firstReaderHoldCount++;
                    } else {
                        //其他线程使用 ThreadLocal
                        if (rh == null)
                            rh = cachedHoldCounter;
                        if (rh == null || rh.tid != getThreadId(current))
                            rh = readHolds.get();
                        else if (rh.count == 0)
                            readHolds.set(rh);
                        rh.count++;
                        cachedHoldCounter = rh; // cache for release
                    }
                    return 1;
                }
            }
        }
</code></pre>
<h3 id="释放写锁-1"><a class="header" href="#释放写锁-1">释放写锁</a></h3>
<pre><code class="language-java">        protected final boolean tryReleaseShared(int unused) {
            //第一个获取读锁 更新 重入计数
            Thread current = Thread.currentThread();
            if (firstReader == current) {
                // assert firstReaderHoldCount &gt; 0;
                if (firstReaderHoldCount == 1)
                    firstReader = null;
                else
                    firstReaderHoldCount--;
            } else {
                //否则 从 ThreadLocal 中 取 HoldCount
                HoldCounter rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    rh = readHolds.get();
                int count = rh.count;
                if (count &lt;= 1) {
                    readHolds.remove();
                    if (count &lt;= 0)
                        throw unmatchedUnlockException();
                }
                --rh.count;
            }
            
            //更新状态，为0 返回true，表示全部读锁释放完毕
            for (;;) {
                int c = getState();
                int nextc = c - SHARED_UNIT;
                if (compareAndSetState(c, nextc))
                    // Releasing the read lock has no effect on readers,
                    // but it may allow waiting writers to proceed if
                    // both read and write locks are now free.
                    return nextc == 0;
            }
        }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍-6"><a class="header" href="#介绍-6">介绍</a></h1>
<ul>
<li>
<p>计数信号量，从概念上讲，信号量维护一组许可证。</p>
</li>
<li>
<p>每一个<em>acquire</em> 消费一个许可，每一个<em>release</em> 增加一个许可</p>
</li>
<li>
<p>当许可不够时，<em>acquire</em> 会被阻塞</p>
</li>
<li>
<p>信号量一般使用于 限制 指定数量线程 能够访问某些资源</p>
</li>
</ul>
<p><strong>example</strong></p>
<pre><code class="language-java">class Pool {
   private static final int MAX_AVAILABLE = 100;
   private final Semaphore available = new Semaphore(MAX_AVAILABLE, true);

   public Object getItem() throws InterruptedException {
     available.acquire();
     return getNextAvailableItem();
   }

   public void putItem(Object x) {
     if (markAsUnused(x))
       available.release();
   }

   // Not a particularly efficient data structure; just for demo

   protected Object[] items = ... whatever kinds of items being managed
   protected boolean[] used = new boolean[MAX_AVAILABLE];

   protected synchronized Object getNextAvailableItem() {
     for (int i = 0; i &lt; MAX_AVAILABLE; ++i) {
       if (!used[i]) {
          used[i] = true;
          return items[i];
       }
     }
     return null; // not reached
   }

   protected synchronized boolean markAsUnused(Object item) {
     for (int i = 0; i &lt; MAX_AVAILABLE; ++i) {
       if (item == items[i]) {
          if (used[i]) {
            used[i] = false;
            return true;
          } else
            return false;
       }
     }
     return false;
   }
 }
</code></pre>
<ul>
<li>
<p>信号量的获取可以保证公平与非公平</p>
</li>
<li>
<p><em>untimed</em> <em>try</em> 操作不保证公平</p>
</li>
<li>
<p>一般 信号量 使用公平的方式 初始化，以确保不会造成 饥饿，当使用 信号量作为另类的 同步器，建议使用 非公平，以提升吞吐量</p>
</li>
<li>
<p>同样 可以 获取 多个 或者释放多个资源</p>
</li>
</ul>
<h1 id="构造"><a class="header" href="#构造">构造</a></h1>
<blockquote>
<p>初始化，信号量 类似生产消费者模型</p>
</blockquote>
<pre><code class="language-java">public Semaphore(int permits, boolean fair) {
    sync = fair ? new FairSync(permits) : new NonfairSync(permits);
}
</code></pre>
<h1 id="acquire操作"><a class="header" href="#acquire操作">Acquire操作</a></h1>
<blockquote>
<p>可中断，阻塞 获取</p>
</blockquote>
<ul>
<li>尝试获取指定量的信号量</li>
<li>获取成功则返回 剩余量</li>
<li>获取失败则 入队列</li>
</ul>
<pre><code class="language-java">// Semphre 信号量调用
public void acquire() throws InterruptedException {
sync.acquireSharedInterruptibly(1);
}
// sync同步器调用
public final void acquireSharedInterruptibly(int arg)
    throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireSharedInterruptibly(arg);
}
//NonfairSync 非公平的 资源获取
protected int tryAcquireShared(int acquires) {
    return nonfairTryAcquireShared(acquires);
}

final int nonfairTryAcquireShared(int acquires) {
    for (;;) {
        int available = getState();
        int remaining = available - acquires;
        if (remaining &lt; 0 ||
            compareAndSetState(available, remaining))
            return remaining;
    }
}
</code></pre>
<h1 id="reducepermists"><a class="header" href="#reducepermists"><em>ReducePermists</em></a></h1>
<p><strong>扣减可用的资源</strong></p>
<pre><code class="language-java">        final void reducePermits(int reductions) {
            for (;;) {
                int current = getState();
                int next = current - reductions;
                if (next &gt; current) // underflow
                    throw new Error(&quot;Permit count underflow&quot;);
                if (compareAndSetState(current, next))
                    return;
            }
        }
</code></pre>
<h1 id="release"><a class="header" href="#release"><em>Release</em></a></h1>
<p><strong>释放一个许可证</strong></p>
<pre><code class="language-java">public void release() {
    sync.releaseShared(1);
}
//通用 释放共享锁
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
</code></pre>
<p><strong>子类实现state更新</strong></p>
<blockquote>
<p>release既 给 增加 state，只要不超过 Integer.MaxVALUE 就能通过</p>
</blockquote>
<pre><code class="language-java">protected final boolean tryReleaseShared(int releases) {
    for (;;) {
        int current = getState();
        int next = current + releases;
        if (next &lt; current) // overflow
            throw new Error(&quot;Maximum permit count exceeded&quot;);
        if (compareAndSetState(current, next))
            return true;
    }
}
</code></pre>
<h1 id="drainpermits"><a class="header" href="#drainpermits"><em>DrainPermits</em></a></h1>
<p><strong>立即将许可证置为0</strong></p>
<pre><code class="language-java">final int drainPermits() {
    for (;;) {
        int current = getState();
        if (current == 0 || compareAndSetState(current, 0))
            return current;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍-7"><a class="header" href="#介绍-7">介绍</a></h1>
<ul>
<li>
<p>StampedLock类，在JDK1.8时引入，是对读写锁ReentrantReadWriteLock的增强，该类提供了一些功能，优化了读锁、写锁的访问，同时使读写锁之间可以互相转换，更细粒度控制并发。</p>
</li>
<li>
<p>ReentrantReadWriteLock使得多个读线程同时持有读锁（只要写锁未被占用），而写锁是独占的。但是，读写锁如果使用不当，很容易产生“饥饿”问题：</p>
<p>比如在读线程非常多，写线程很少的情况下，很容易导致写线程“饥饿”，虽然使用“公平”策略可以一定程度上缓解这个问题，但是“公平”策略是以牺牲系统吞吐量为代价的。</p>
</li>
<li>
<p>try系列获取锁的函数，当获取锁失败后会返回为0的stamp值。当调用释放锁和转换锁的方法时候需要传入获取锁时候返回的stamp值。</p>
</li>
</ul>
<h1 id="使用示例"><a class="header" href="#使用示例">使用示例</a></h1>
<pre><code class="language-java">class Point {
    private double x, y;
    private final StampedLock sl = new StampedLock();

    void move(double deltaX, double deltaY) {
        long stamp = sl.writeLock();    //涉及对共享资源的修改，使用写锁-独占操作
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            sl.unlockWrite(stamp);
        }
    }

    /**
     * 使用乐观读锁访问共享资源
     * 注意：乐观读锁在保证数据一致性上需要拷贝一份要操作的变量到方法栈，并且在操作数据时候可能其他写线程已经修改了数据，
     * 而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性还是得到保障的。
     *
     * @return
     */
    double distanceFromOrigin() {
        long stamp = sl.tryOptimisticRead();    // 使用乐观读锁
        double currentX = x, currentY = y;      // 拷贝共享资源到本地方法栈中
        if (!sl.validate(stamp)) {              // 如果有写锁被占用，可能造成数据不一致，所以要切换到普通读锁模式
            stamp = sl.readLock();             
            try {
                currentX = x;
                currentY = y;
            } finally {
                sl.unlockRead(stamp);
            }
        }
        return Math.sqrt(currentX * currentX + currentY * currentY);
    }

    void moveIfAtOrigin(double newX, double newY) { // upgrade
        // Could instead start with optimistic, not read mode
        long stamp = sl.readLock();
        try {
            while (x == 0.0 &amp;&amp; y == 0.0) {
                long ws = sl.tryConvertToWriteLock(stamp);  //读锁转换为写锁
                if (ws != 0L) {
                    stamp = ws;
                    x = newX;
                    y = newY;
                    break;
                } else {
                    sl.unlockRead(stamp);
                    stamp = sl.writeLock();
                }
            }
        } finally {
            sl.unlock(stamp);
        }
    }
}
</code></pre>
<h1 id="使用乐观锁-遵循的模式"><a class="header" href="#使用乐观锁-遵循的模式">使用乐观锁 遵循的模式</a></h1>
<pre><code class="language-java">long stamp = lock.tryOptimisticRead();  // 非阻塞获取版本信息
copyVaraibale2ThreadMemory();           // 拷贝变量到线程本地堆栈
if(!lock.validate(stamp)){              // 校验
    long stamp = lock.readLock();       // 获取读锁
    try {
        copyVaraibale2ThreadMemory();   // 拷贝变量到线程本地堆栈
     } finally {
       lock.unlock(stamp);              // 释放悲观锁
    }

}
useThreadMemoryVarables();              // 使用线程本地堆栈里面的数据进行操作
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集合类继承图"><a class="header" href="#集合类继承图">集合类继承图</a></h1>
<p><img src="6.java%E5%9F%BA%E7%A1%80_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6//images/collection_structure.png" alt="" /></p>
<h1 id="collection接口"><a class="header" href="#collection接口"><em>Collection</em>接口</a></h1>
<h2 id="查询操作"><a class="header" href="#查询操作">查询操作</a></h2>
<p><em>int size();</em>，<em>boolean isEmpty();</em>，<em>boolean contains(Object o)</em></p>
<h2 id="数组与集合转换"><a class="header" href="#数组与集合转换">数组与集合转换</a></h2>
<p><strong>返回Object数组</strong></p>
<p>返回一个全新的数组，可以任意修改</p>
<pre><code class="language-java">Object[] toArray();
</code></pre>
<p><strong>返回指定类型的数组</strong></p>
<ul>
<li>如果数组大小正合适，则将元素 填充至该指定数组，否则，返回全新数组</li>
<li>如果数组元素有多的，则第一个多的元素会被置为 <em>NULL</em>，以示区分</li>
<li>这个方法能精确控制 数组返回的 运行时类型</li>
</ul>
<pre><code class="language-java">&lt;T&gt; T[] toArray(T[] a);
//一般使用
String[] y = x.toArray(new String[0]);
</code></pre>
<h2 id="修改操作"><a class="header" href="#修改操作">修改操作</a></h2>
<pre><code>boolean add(E e);
boolean remove(Object o);
</code></pre>
<h2 id="批量操作"><a class="header" href="#批量操作">批量操作</a></h2>
<pre><code class="language-java">//判断当前集合  是否 包含 指定集合
boolean containsAll(Collection&lt;?&gt; c);
//添加到集合中
boolean addAll(Collection&lt;? extends E&gt; c);
//通过迭代器，迭代，移除
boolean removeAll(Collection&lt;?&gt; c);
    default boolean removeIf(Predicate&lt;? super E&gt; filter) {
        Objects.requireNonNull(filter);
        boolean removed = false;
        final Iterator&lt;E&gt; each = iterator();
        while (each.hasNext()) {
            if (filter.test(each.next())) {
                each.remove();
                removed = true;
            }
        }
        return removed;
    }

//取交集，只保留 当前集合与 指定集合 都含有的元素
boolean retainAll(Collection&lt;?&gt; c);
//清空集合
void clear();
</code></pre>
<h2 id="排序与比较"><a class="header" href="#排序与比较">排序与比较</a></h2>
<pre><code class="language-java">boolean equals(Object o);
int hashCode();
</code></pre>
<h1 id="abstractcollection"><a class="header" href="#abstractcollection">AbstractCollection</a></h1>
<pre><code class="language-java">//类声明
public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {
}
</code></pre>
<h2 id="是否包含"><a class="header" href="#是否包含">是否包含</a></h2>
<pre><code class="language-java">//包含
public boolean contains(Object o) {
    Iterator&lt;E&gt; it = iterator();
    if (o==null) { //如果对象是NULL，则判断集合中有没有NULL值
        while (it.hasNext())
            if (it.next()==null)
                return true;
    } else { //如果不是NULL，则equals判断
        while (it.hasNext())
            if (o.equals(it.next()))
                return true;
    }
    return false;
}
</code></pre>
<h2 id="转数组"><a class="header" href="#转数组">转数组</a></h2>
<ul>
<li>新建 <em>Object</em> 数组</li>
<li>如果迭代器返回少数据
<ul>
<li>则将数组调整至实际大小</li>
</ul>
</li>
<li>如果迭代器返回多数据
<ul>
<li>则将数组 扩容至 实际迭代器返回的个数</li>
<li>扩容速率是<code>(n/2+1)</code> </li>
<li>超过 INT的最大值，则会 抛出 <em>OutOfMemoryError</em></li>
</ul>
</li>
</ul>
<pre><code class="language-java">public Object[] toArray() {
    // Estimate size of array; be prepared to see more or fewer elements，先以集合大小作为数组大小
    Object[] r = new Object[size()];
    Iterator&lt;E&gt; it = iterator();
    for (int i = 0; i &lt; r.length; i++) {
        if (! it.hasNext()) // fewer elements than expected
            return Arrays.copyOf(r, i);
        r[i] = it.next();
    }
    return it.hasNext() ? finishToArray(r, it) : r;
}

private static &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) {
    int i = r.length;
    while (it.hasNext()) {
        int cap = r.length;
        if (i == cap) {
            int newCap = cap + (cap &gt;&gt; 1) + 1;
            // overflow-conscious code
            if (newCap - MAX_ARRAY_SIZE &gt; 0)
                newCap = hugeCapacity(cap + 1);
            r = Arrays.copyOf(r, newCap);
        }
        r[i++] = (T)it.next();
    }
    // trim if overallocated
    return (i == r.length) ? r : Arrays.copyOf(r, i);
}

private static int hugeCapacity(int minCapacity) {
    if (minCapacity &lt; 0) // overflow
        throw new OutOfMemoryError
        (&quot;Required array size too large&quot;);
    return (minCapacity &gt; MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
    MAX_ARRAY_SIZE;
}
</code></pre>
<h2 id="指定运行时类型转数组"><a class="header" href="#指定运行时类型转数组">指定运行时类型转数组</a></h2>
<ul>
<li>如果数组大小 足够，则使用传入的数组，不够则 反射实例化一个</li>
<li>当 迭代器返回的 元素个数不够时
<ul>
<li>如果使用的是 传入的数组 则 置为NULL</li>
<li>如果使用的不是 传入的数组，但时 传入数组大小 大于 实际迭代器返回的元素个数，则返回 传入的元素数组</li>
<li>如果使用的不是 传入的数组，且传入数组大小 小于 实际迭代器返回的元素个数，则重新调整数组大小并返回</li>
</ul>
</li>
<li>当迭代器返回的 比预期多的 元素时
<ul>
<li>重新调整数组大小</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public &lt;T&gt; T[] toArray(T[] a) {
    // Estimate size of array; be prepared to see more or fewer elements
    int size = size();
    T[] r = a.length &gt;= size ? a :
              (T[])java.lang.reflect.Array
              .newInstance(a.getClass().getComponentType(), size);
    Iterator&lt;E&gt; it = iterator();

    for (int i = 0; i &lt; r.length; i++) {
        if (! it.hasNext()) { // fewer elements than expected
            if (a == r) {
                r[i] = null; // null-terminate
            } else if (a.length &lt; i) {
                return Arrays.copyOf(r, i);
            } else {
                System.arraycopy(r, 0, a, 0, i);
                if (a.length &gt; i) {
                    a[i] = null;
                }
            }
            return a;
        }
        r[i] = (T)it.next();
    }
    // more elements than expected
    return it.hasNext() ? finishToArray(r, it) : r;
}
</code></pre>
<h2 id="remove"><a class="header" href="#remove">Remove</a></h2>
<ul>
<li>如果是 NULL 则移除 第一个为NULL的</li>
<li>如果不是NULL，则移除 相等的为NULL的</li>
</ul>
<pre><code class="language-java">public boolean remove(Object o) {
    Iterator&lt;E&gt; it = iterator();
    if (o==null) {
        while (it.hasNext()) {
            if (it.next()==null) {
                it.remove();
                return true;
            }
        }
    } else {
        while (it.hasNext()) {
            if (o.equals(it.next())) {
                it.remove();
                return true;
            }
        }
    }
    return false;
}
</code></pre>
<h2 id="containsall"><a class="header" href="#containsall"><em>containsAll</em></a></h2>
<p>循环调用<em>Contains</em></p>
<pre><code class="language-java">public boolean containsAll(Collection&lt;?&gt; c) {
    for (Object e : c)
        if (!contains(e))
            return false;
    return true;
}
</code></pre>
<h2 id="addall"><a class="header" href="#addall">addAll</a></h2>
<p>循环调用 <em>add</em></p>
<pre><code class="language-java">public boolean addAll(Collection&lt;? extends E&gt; c) {
    boolean modified = false;
    for (E e : c)
        if (add(e))
            modified = true;
    return modified;
}
</code></pre>
<h2 id="removeall"><a class="header" href="#removeall"><em>removeAll</em></a></h2>
<p>循环调用 迭代器的remove</p>
<pre><code class="language-java">public boolean removeAll(Collection&lt;?&gt; c) {
    Objects.requireNonNull(c);
    boolean modified = false;
    Iterator&lt;?&gt; it = iterator();
    while (it.hasNext()) {
        if (c.contains(it.next())) {
            it.remove();
            modified = true;
        }
    }
    return modified;
}
</code></pre>
<h2 id="retainall"><a class="header" href="#retainall">retainAll</a></h2>
<pre><code class="language-java">public boolean retainAll(Collection&lt;?&gt; c) {
    Objects.requireNonNull(c);
    boolean modified = false;
    Iterator&lt;E&gt; it = iterator();
    while (it.hasNext()) {
        if (!c.contains(it.next())) {
            it.remove();
            modified = true;
        }
    }
    return modified;
}
</code></pre>
<h2 id="clear"><a class="header" href="#clear">clear</a></h2>
<pre><code class="language-java">public void clear() {
    Iterator&lt;E&gt; it = iterator();
    while (it.hasNext()) {
        it.next();
        it.remove();
    }
}
</code></pre>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>利用 迭代器 实现了 contains与 remove的语义 ，add的语义还未实现</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockingqueue接口"><a class="header" href="#blockingqueue接口">BlockingQueue接口</a></h1>
<h2 id="声明"><a class="header" href="#声明">声明</a></h2>
<pre><code class="language-java">public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; {
</code></pre>
<h2 id="概述-1"><a class="header" href="#概述-1">概述</a></h2>
<p><strong>额外功能</strong></p>
<p>blockingQueue是 一个队列，提供额外的功能</p>
<ul>
<li>当向队列取元素时，会阻塞直到队列存在元素</li>
<li>当向队列存元素时，会阻塞直到队列有空余</li>
</ul>
<p><strong>形式</strong></p>
<p>BlockingQueue方法有四种形式，它们以不同的方式处理操作，这些操作无法立即满足，但将来可能会满足</p>
<ul>
<li>第一种抛异常</li>
<li>第二种 有返回值</li>
<li>第三种 阻塞，直到操作可执行</li>
<li>第四种 超时阻塞</li>
</ul>
<table><thead><tr><th></th><th>Throws Exception</th><th>SpecialValue</th><th>Blocks</th><th>TimesOut</th></tr></thead><tbody>
<tr><td>Insert</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr>
<tr><td>remove</td><td>remove()</td><td>poll</td><td>take()</td><td>poll(time,unit)</td></tr>
<tr><td>examine</td><td>element()</td><td>peek()</td><td></td><td></td></tr>
</tbody></table>
<p><strong>NULL值</strong></p>
<p>blockingQueue 不能 插入<em>NULL</em> ，所有插入<em>NULL</em>的操作 抛NPE，空值在内部视为  失败</p>
<p><strong>容量限制</strong></p>
<p>BlockingQueue可能受容量限制。在任何给定时间，它可能具有剩余容量，超过该容量就不能放置其他元素而不会阻塞。
没有任何内部容量约束的BlockingQueue始终报告Integer.MAX_VALUE的剩余容量。</p>
<p><strong>集合关系</strong></p>
<p>BlockingQueue实现被设计为主要用于生产者-消费者队列，但额外也支持 集合接口，也可以随机 移除 一个数据 <code>remove(x)</code>，这样的操作效率不会很高，建议很少使用，例如 当消息队列中，某个消息被取消</p>
<p><strong>线程安全</strong></p>
<p>BlockingQueue实现是线程安全的。所有排队方法 都由内部锁实现并发控制</p>
<p>批量操作不保证 原子性，除非在实现中另行指定，否则批量Collection操作addAll，containsAll，retainAll和removeAll不一定是原子执行的。
因此，例如，仅在c中添加一些元素之后，addAll（c）可能会失败（引发异常）。</p>
<p><strong>关闭操作</strong></p>
<p>BlockingQueue本质上不支持任何类型的“关闭”或“关闭”操作，以指示将不再添加任何项目。
此类功能的需求和使用往往取决于实现。
例如，一种常见的策略是让生产者插入特殊的<strong>流尾对象或有毒对象</strong>（ special end-of-stream or poison objects）当消费者采取这种方法时会对其进行相应的解释。</p>
<h2 id="接口"><a class="header" href="#接口">接口</a></h2>
<p><strong>新增</strong></p>
<pre><code class="language-java">boolean add(E e);
boolean offer(E e);
void put(E e) throws InterruptedException;
boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;
</code></pre>
<p><strong>移除</strong></p>
<pre><code class="language-java">E take() throws InterruptedException;
E poll(long timeout, TimeUnit unit) throws InterruptedException;
boolean remove(Object o);
</code></pre>
<p><strong>批量移除</strong></p>
<pre><code class="language-java">//将队列中的元素 倒入 指定集合
int drainTo(Collection&lt;? super E&gt; c);
//maxElements 指定最大要倒的集合
int drainTo(Collection&lt;? super E&gt; c, int maxElements);
</code></pre>
<h1 id="arrayblockingqueue"><a class="header" href="#arrayblockingqueue">ArrayBlockingQueue</a></h1>
<h2 id="初始化"><a class="header" href="#初始化">初始化</a></h2>
<p><strong>空初始化</strong></p>
<ul>
<li>立即初始化容量</li>
<li>使用 可重入锁</li>
<li>两个条件：<em>notEmpty</em>，<em>notFull</em></li>
</ul>
<pre><code class="language-java">public ArrayBlockingQueue(int capacity, boolean fair) {
    if (capacity &lt;= 0)
        throw new IllegalArgumentException();
    this.items = new Object[capacity];
    lock = new ReentrantLock(fair);
    notEmpty = lock.newCondition();
    notFull =  lock.newCondition();
}
</code></pre>
<p><strong>复制初始化</strong></p>
<ul>
<li>使用者 自行确保容量 不能小于 <em>Collection</em></li>
</ul>
<pre><code class="language-java">public ArrayBlockingQueue(int capacity, boolean fair,
                          Collection&lt;? extends E&gt; c) {
    this(capacity, fair);

    final ReentrantLock lock = this.lock;
    lock.lock(); // Lock only for visibility, not mutual exclusion ,出于可见性，上锁。不是为了互斥
    try {
        int i = 0;
        try {
            for (E e : c) {
                checkNotNull(e);
                items[i++] = e;
            }
        } catch (ArrayIndexOutOfBoundsException ex) {
            throw new IllegalArgumentException();
        }
        count = i;
        putIndex = (i == capacity) ? 0 : i;
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h2 id="重要方法"><a class="header" href="#重要方法">重要方法</a></h2>
<h3 id="入队列"><a class="header" href="#入队列">入队列</a></h3>
<ul>
<li>确保 已经获取到锁</li>
<li>确保 当前位置 为空</li>
<li>放入元素</li>
<li>容量自增</li>
<li><em>putIndex</em> 自增</li>
<li>通知 消费者队列</li>
</ul>
<pre><code class="language-java">private void enqueue(E x) {
    // assert lock.getHoldCount() == 1;
    // assert items[putIndex] == null;
    final Object[] items = this.items;
    items[putIndex] = x;
    if (++putIndex == items.length)
        putIndex = 0;
    count++;
    notEmpty.signal();
}
</code></pre>
<h3 id="出队列"><a class="header" href="#出队列"><strong>出队列</strong></a></h3>
<ul>
<li>确保 已经获取到锁</li>
<li>确保 当前位置 不为空</li>
<li>根据 <em>takeIndex</em> 取数据</li>
<li>原位置置空</li>
<li>容量自减</li>
<li>通知 生产者队列</li>
</ul>
<pre><code class="language-java">private E dequeue() {
    // assert lock.getHoldCount() == 1;
    // assert items[takeIndex] != null;
    final Object[] items = this.items;
    @SuppressWarnings(&quot;unchecked&quot;)
    E x = (E) items[takeIndex];
    items[takeIndex] = null;
    if (++takeIndex == items.length)
        takeIndex = 0;
    count--;
    if (itrs != null)
        itrs.elementDequeued(); //关于迭代器的维护比较复杂，在此不赘叙
    notFull.signal();
    return x;
}
</code></pre>
<h2 id="新增元素"><a class="header" href="#新增元素">新增元素</a></h2>
<h3 id="非阻塞新增"><a class="header" href="#非阻塞新增"><strong>非阻塞新增</strong></a></h3>
<p>容量满了立刻退出返回 <em>false</em></p>
<pre><code class="language-java">public boolean offer(E e) {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        if (count == items.length)
            return false;
        else {
            enqueue(e);
            return true;
        }
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h3 id="阻塞新增"><a class="header" href="#阻塞新增"><strong>阻塞新增</strong></a></h3>
<ul>
<li>获取锁</li>
<li>如果队列不为空，则等待</li>
<li>否则入队列</li>
</ul>
<pre><code class="language-java">public void put(E e) throws InterruptedException {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == items.length)
            notFull.await();
        enqueue(e);
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h3 id="超时新增"><a class="header" href="#超时新增"><strong>超时新增</strong></a></h3>
<ul>
<li>尝试获取锁</li>
<li><strong>成功获取锁 之后 在开始计时</strong></li>
<li>锁超时之后 立刻返回 <em>false</em></li>
</ul>
<pre><code class="language-java">public boolean offer(E e, long timeout, TimeUnit unit)
    throws InterruptedException {

    checkNotNull(e);
    long nanos = unit.toNanos(timeout);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == items.length) {
            if (nanos &lt;= 0)
                return false;
            nanos = notFull.awaitNanos(nanos);
        }
        enqueue(e);
        return true;
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h2 id="移除元素"><a class="header" href="#移除元素">移除元素</a></h2>
<h3 id="阻塞移除"><a class="header" href="#阻塞移除">阻塞移除</a></h3>
<pre><code class="language-java">public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == 0)
            notEmpty.await();
        return dequeue();
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h3 id="超时移除"><a class="header" href="#超时移除">超时移除</a></h3>
<pre><code class="language-java">public E poll(long timeout, TimeUnit unit) throws InterruptedException {
    long nanos = unit.toNanos(timeout);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == 0) {
            if (nanos &lt;= 0)
                return null;
            nanos = notEmpty.awaitNanos(nanos);
        }
        return dequeue();
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h3 id="随机指定对象移除"><a class="header" href="#随机指定对象移除">随机指定对象移除</a></h3>
<ul>
<li>需要将 移除对象后面的元素 全都 左移一位</li>
</ul>
<pre><code class="language-java">public boolean remove(Object o) {
    if (o == null) return false;
    final Object[] items = this.items;
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        if (count &gt; 0) {
            final int putIndex = this.putIndex;
            int i = takeIndex;
            do {
                if (o.equals(items[i])) {
                    removeAt(i);
                    return true;
                }
                if (++i == items.length)
                    i = 0;
            } while (i != putIndex);
        }
        return false;
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h3 id="批量移除数据到指定集合中"><a class="header" href="#批量移除数据到指定集合中">批量移除数据到指定集合中</a></h3>
<ul>
<li>获取锁</li>
<li>循环 把数据加入到 新集合</li>
<li>维护<em>count</em> 变量</li>
<li></li>
</ul>
<pre><code class="language-java">public int drainTo(Collection&lt;? super E&gt; c, int maxElements) {
    checkNotNull(c);
    if (c == this)
        throw new IllegalArgumentException();
    if (maxElements &lt;= 0)
        return 0;
    final Object[] items = this.items;
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        int n = Math.min(maxElements, count);
        int take = takeIndex;
        int i = 0;
        try {
            while (i &lt; n) {
                @SuppressWarnings(&quot;unchecked&quot;)
                E x = (E) items[take];
                c.add(x);
                items[take] = null;
                if (++take == items.length)
                    take = 0;
                i++;
            }
            return n;
        } finally {
            // Restore invariants even if c.add() threw
            if (i &gt; 0) {
                count -= i;
                takeIndex = take;
                if (itrs != null) {
                    if (count == 0)
                        itrs.queueIsEmpty();
                    else if (i &gt; take)
                        itrs.takeIndexWrapped();
                }
                for (; i &gt; 0 &amp;&amp; lock.hasWaiters(notFull); i--)
                    notFull.signal();
            }
        }
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h1 id="总结-1"><a class="header" href="#总结-1">总结</a></h1>
<h2 id="arrayblockingqueue的实现原理"><a class="header" href="#arrayblockingqueue的实现原理">ArrayBlockingQueue的实现原理</a></h2>
<p><strong>同步实现方式</strong></p>
<ul>
<li>使用可重入锁 实现，所有方法基本都加锁</li>
</ul>
<p><strong>take与put的实现方式</strong></p>
<ul>
<li>使用 两个条件锁，实现 take与 put的阻塞与通知</li>
</ul>
<p><strong>存储结构</strong></p>
<ul>
<li>使用循环队列作为存储结构</li>
<li>内部使用 数组，加上 两个 索引 takeIndex负责 取，putIndex负责存 实现的双向循环队列</li>
<li>takeIndex总是指向 下一个待取的数据，而 putIndex总是指向 下一个空闲的位置</li>
</ul>
<h2 id="应用"><a class="header" href="#应用">应用</a></h2>
<p>线程池的默认底层数据结构</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arraylist"><a class="header" href="#arraylist">ArrayList</a></h1>
<h2 id="初始化-1"><a class="header" href="#初始化-1">初始化</a></h2>
<p><strong>空参初始化空集合</strong></p>
<pre><code class="language-java">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
</code></pre>
<p><strong>指定容量初始化</strong></p>
<pre><code class="language-java">public ArrayList(int initialCapacity) {
    if (initialCapacity &gt; 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    }
}
</code></pre>
<p><strong>指定集合初始化</strong></p>
<ul>
<li>集合转数组</li>
<li>数组可能不是  <em>Object[].class</em> 则强行copy成 Object[]数组类型</li>
</ul>
<pre><code class="language-java">public ArrayList(Collection&lt;? extends E&gt; c) {
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        // replace with empty array.
        this.elementData = EMPTY_ELEMENTDATA;
    }
}
</code></pre>
<h2 id="放入元素"><a class="header" href="#放入元素">放入元素</a></h2>
<h3 id="尾部插入"><a class="header" href="#尾部插入">尾部插入</a></h3>
<pre><code class="language-java">public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
//扩容
private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}
//当底层数组为空数组时，给定一个默认的容量10
private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}
//当前指针 超过了数组容量，则数组扩容
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}
//new=old+old/2 = (3/2) * old
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre>
<h3 id="中间插入"><a class="header" href="#中间插入">中间插入</a></h3>
<ul>
<li>将index之后的往后 移动一位</li>
<li>插入数据</li>
</ul>
<pre><code class="language-java">public void add(int index, E element) {
    rangeCheckForAdd(index);

    ensureCapacityInternal(size + 1);  // Increments modCount!!
    System.arraycopy(elementData, index, elementData, index + 1,
                     size - index);
    elementData[index] = element;
    size++;
}
</code></pre>
<h3 id="尾部批量插入"><a class="header" href="#尾部批量插入">尾部批量插入</a></h3>
<ul>
<li>获取底层数组</li>
<li>扩容</li>
<li>拷贝</li>
</ul>
<pre><code class="language-java">public boolean addAll(Collection&lt;? extends E&gt; c) {
    Object[] a = c.toArray();
    int numNew = a.length;
    ensureCapacityInternal(size + numNew);  // Increments modCount
    System.arraycopy(a, 0, elementData, size, numNew);
    size += numNew;
    return numNew != 0;
}
</code></pre>
<h3 id="中间批量插入"><a class="header" href="#中间批量插入">中间批量插入</a></h3>
<ul>
<li>索引范围检查</li>
<li>获取底层数组，容量检查</li>
<li>判断是否需要移动后面元素</li>
<li>拷贝 a数组到 目标数组</li>
</ul>
<pre><code class="language-java">public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
    rangeCheckForAdd(index);

    Object[] a = c.toArray();
    int numNew = a.length;
    ensureCapacityInternal(size + numNew);  // Increments modCount

    int numMoved = size - index;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index, elementData, index + numNew,
                         numMoved);

    System.arraycopy(a, 0, elementData, index, numNew);
    size += numNew;
    return numNew != 0;
}
</code></pre>
<h2 id="移除元素-1"><a class="header" href="#移除元素-1">移除元素</a></h2>
<h3 id="根据索引移除"><a class="header" href="#根据索引移除">根据索引移除</a></h3>
<pre><code class="language-java">public E remove(int index) {
    //索引检查
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);

    //将 后面的元素 往前移动一位
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);//将最后一个元素置为 null
    elementData[--size] = null; // clear to let GC do its work
//返回旧元素
    return oldValue;
}
</code></pre>
<h3 id="根据对象移除"><a class="header" href="#根据对象移除">根据对象移除</a></h3>
<ul>
<li>循环迭代 查找索引</li>
<li>然后将该索引后面的元素 往前移动一位</li>
</ul>
<pre><code class="language-java">public boolean remove(Object o) {
    if (o == null) {
        for (int index = 0; index &lt; size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index &lt; size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}


private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work
}
</code></pre>
<h3 id="移除全部元素"><a class="header" href="#移除全部元素">移除全部元素</a></h3>
<pre><code class="language-java">public void clear() {
    modCount++;

    // clear to let GC do its work
    for (int i = 0; i &lt; size; i++)
        elementData[i] = null;

    size = 0;
}
</code></pre>
<h3 id="保留交集元素"><a class="header" href="#保留交集元素">保留交集元素</a></h3>
<ul>
<li>重新整理相等的元素，并放到 数组的前段</li>
<li>如果 <em>contains</em> 发生异常 把未处理完的元素 都移动到 新的 位置上来</li>
<li>并将 移动完之后的元素 之外的索引 置为空，以便GC</li>
</ul>
<pre><code class="language-java">public boolean retainAll(Collection&lt;?&gt; c) {
    Objects.requireNonNull(c);
    return batchRemove(c, true);
}
//complement为true
private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
    final Object[] elementData = this.elementData;
    int r = 0, w = 0;
    boolean modified = false;
    try {
        for (; r &lt; size; r++)
            if (c.contains(elementData[r]) == complement)
                elementData[w++] = elementData[r];
    } finally {
        // Preserve behavioral compatibility with AbstractCollection,
        // even if c.contains() throws.
        if (r != size) {
            System.arraycopy(elementData, r,
                             elementData, w,
                             size - r);
            w += size - r;
        }
        if (w != size) {
            // clear to let GC do its work
            for (int i = w; i &lt; size; i++)
                elementData[i] = null;
            modCount += size - w;
            size = w;
            modified = true;
        }
    }
    return modified;
}
</code></pre>
<h3 id="删除交集元素"><a class="header" href="#删除交集元素">删除交集元素</a></h3>
<p>重新整理 不相等的元素，并放到 数组的前段</p>
<pre><code class="language-java">public boolean removeAll(Collection&lt;?&gt; c) {
    Objects.requireNonNull(c);
    return batchRemove(c, false);
}
</code></pre>
<h3 id="按条件移除"><a class="header" href="#按条件移除">按条件移除</a></h3>
<ul>
<li>
<p>遍历每一个元素</p>
</li>
<li>
<p>标记要修改的数据</p>
<p>条件测试成功 则记录index，记录 <em>removeCount</em></p>
</li>
<li>
<p>如果在这个过程中遇到并发修改，则报错</p>
</li>
<li>
<p>循环移动需要更改的 索引位</p>
</li>
<li>
<p>多余的 元素位置空</p>
</li>
<li>
<p>如果在这个过程中遇到并发修改，则报错</p>
</li>
</ul>
<pre><code class="language-java">public boolean removeIf(Predicate&lt;? super E&gt; filter) {
    Objects.requireNonNull(filter);
    // figure out which elements are to be removed
    // any exception thrown from the filter predicate at this stage
    // will leave the collection unmodified
    int removeCount = 0;
    final BitSet removeSet = new BitSet(size);
    final int expectedModCount = modCount;
    final int size = this.size;
    for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
        @SuppressWarnings(&quot;unchecked&quot;)
        final E element = (E) elementData[i];
        if (filter.test(element)) {
            removeSet.set(i);
            removeCount++;
        }
    }
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }

    // shift surviving elements left over the spaces left by removed elements
    final boolean anyToRemove = removeCount &gt; 0;
    if (anyToRemove) {
        final int newSize = size - removeCount;
        for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) {
            i = removeSet.nextClearBit(i);
            elementData[j] = elementData[i];
        }
        for (int k=newSize; k &lt; size; k++) {
            elementData[k] = null;  // Let gc do its work
        }
        this.size = newSize;
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }

    return anyToRemove;
}
</code></pre>
<h2 id="替换元素"><a class="header" href="#替换元素">替换元素</a></h2>
<h3 id="根据索引替换"><a class="header" href="#根据索引替换">根据索引替换</a></h3>
<pre><code class="language-java">public E set(int index, E element) {
    rangeCheck(index);

    E oldValue = elementData(index);
    elementData[index] = element;
    return oldValue;
}
</code></pre>
<h3 id="替换所有元素"><a class="header" href="#替换所有元素">替换所有元素</a></h3>
<pre><code class="language-java">public void replaceAll(UnaryOperator&lt;E&gt; operator) {
    Objects.requireNonNull(operator);
    final int expectedModCount = modCount;
    final int size = this.size;
    for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
        elementData[i] = operator.apply((E) elementData[i]);
    }
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
    modCount++;
}
</code></pre>
<h2 id="排序"><a class="header" href="#排序">排序</a></h2>
<pre><code class="language-java">public void sort(Comparator&lt;? super E&gt; c) {
    final int expectedModCount = modCount;
    Arrays.sort((E[]) elementData, 0, size, c);
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
    modCount++;
}
</code></pre>
<h2 id="转数组-1"><a class="header" href="#转数组-1">转数组</a></h2>
<pre><code class="language-java">public &lt;T&gt; T[] toArray(T[] a) {
    if (a.length &lt; size)
        // Make a new array of a's runtime type, but my contents:
        return (T[]) Arrays.copyOf(elementData, size, a.getClass());
    System.arraycopy(elementData, 0, a, 0, size);
    if (a.length &gt; size)
        a[size] = null;
    return a;
}

public Object[] toArray() {
    return Arrays.copyOf(elementData, size);
}
</code></pre>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<ul>
<li>完整的利用 索引 实现了List接口的定义的各个方法，扩容时的倍率 是 3/2，初始值是10</li>
<li>在每次修改完 数组后，会检查 有没有被其他线程修改过，如果是 则 <em>fastFail</em></li>
</ul>
<h1 id="arraylist的sublist"><a class="header" href="#arraylist的sublist">ArrayList的SubList</a></h1>
<h2 id="类声明-1"><a class="header" href="#类声明-1"><strong>类声明</strong></a></h2>
<pre><code class="language-java">private class SubList extends AbstractList&lt;E&gt; implements RandomAccess {}
</code></pre>
<h2 id="初始化-2"><a class="header" href="#初始化-2">初始化</a></h2>
<ul>
<li>parent 父List</li>
<li><em>offSet</em> 偏移量</li>
<li><em>fromIndex</em> 从哪开始</li>
<li><em>toIndex</em> 从结束</li>
<li>记录父List的 修改次数</li>
</ul>
<pre><code class="language-java">SubList(AbstractList&lt;E&gt; parent,
        int offset, int fromIndex, int toIndex) {
    this.parent = parent;
    this.parentOffset = fromIndex;
    this.offset = offset + fromIndex;
    this.size = toIndex - fromIndex;
    this.modCount = ArrayList.this.modCount;
}
</code></pre>
<h2 id="取值"><a class="header" href="#取值">取值</a></h2>
<p>取值过程中，父容器不能修改</p>
<pre><code class="language-java">public E get(int index) {
    rangeCheck(index);
    checkForComodification();
    return ArrayList.this.elementData(offset + index);
}


private void checkForComodification() {
    if (ArrayList.this.modCount != this.modCount)
        throw new ConcurrentModificationException();
}
</code></pre>
<h2 id="存值"><a class="header" href="#存值">存值</a></h2>
<p>往父容器存值</p>
<pre><code class="language-java">public void add(int index, E e) {
    rangeCheckForAdd(index);
    checkForComodification();
    parent.add(parentOffset + index, e);
    this.modCount = parent.modCount;
    this.size++;
}
</code></pre>
<h2 id="更新"><a class="header" href="#更新">更新</a></h2>
<p>直接往父容器更新</p>
<pre><code class="language-java">public E set(int index, E e) {
    rangeCheck(index);
    checkForComodification();
    E oldValue = ArrayList.this.elementData(offset + index);
    ArrayList.this.elementData[offset + index] = e;
    return oldValue;
}
</code></pre>
<h2 id="移除"><a class="header" href="#移除">移除</a></h2>
<pre><code class="language-java">public E remove(int index) {
    rangeCheck(index);
    checkForComodification();
    E result = parent.remove(parentOffset + index);
    this.modCount = parent.modCount;
    this.size--;
    return result;
}
</code></pre>
<p>...等等</p>
<h2 id="总结-3"><a class="header" href="#总结-3">总结</a></h2>
<ul>
<li>一旦 外部List修改了 集合，则所有<em>sublist</em> 都会 失效</li>
</ul>
<h1 id="randomaccesssublist"><a class="header" href="#randomaccesssublist"><em>RandomAccessSubList</em></a></h1>
<p>是一个标记了 <em>RandomAccess</em> 接口的 <em>SubList</em></p>
<p>暂时不知道有什么用</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections中api的分类"><a class="header" href="#collections中api的分类">Collections中API的分类</a></h1>
<ul>
<li>排序操作</li>
<li>查找替换</li>
<li>checkedxxx 检查集合</li>
<li>emptyxxx 返回空集合</li>
<li>synchronizedXXX 同步集合</li>
<li>unmodifiableXXX 不可变集合</li>
</ul>
<h1 id="排序操作"><a class="header" href="#排序操作">排序操作</a></h1>
<p><strong>static <T>boolean addAIl(Collection &lt;? super T&gt;c,T... elements)</strong></p>
<p>将所有指定元素添加到指定的collection中</p>
<p><strong>static void reverse(List list)</strong></p>
<p>反转指定List集合中元素的顺序</p>
<p><strong>static void shuffle(List list)</strong></p>
<p>对List集合中的元素进行随机排序（模拟玩扑克中的“洗牌”）</p>
<p><strong>static void sort(List list)</strong></p>
<p>根据元素的自然顺序对List集合中的元素进行排序</p>
<p><strong>static void swap(List list,int i，int j)</strong></p>
<p>将指定List集合中i处元素和j处元素进行交换</p>
<h1 id="查找替换"><a class="header" href="#查找替换"><strong>查找替换</strong></a></h1>
<p><strong>static int binaryScarch ( List list,Object key)</strong></p>
<p>使用二分法搜索指定对象在List集合中的索引，查找的 List集合中的元素必须是有序的</p>
<p><strong>static Object max(Collection col)</strong></p>
<p>返回给定集合中最大的元素</p>
<p><strong>static Object min (Collection col)</strong></p>
<p>返回给定集合中最小的元素</p>
<p><strong>static boolean replaccAll (List list，Object oldVal,Object newVal)</strong></p>
<p>用一个新的newVal替换List集合中所有的旧值oldVal</p>
<h1 id="checkedxxx-检查集合"><a class="header" href="#checkedxxx-检查集合">checkedxxx 检查集合</a></h1>
<p>返回类型检查的集合，在对类型进行set 或者add的时候会做类型检查</p>
<pre><code class="language-java">用法：

ArrayList list = Lists.newArrayList();

list.add(new Player(&quot;香菜&quot;));

// 返回的safeList 在add时会进行类型检查

List safeList = Collections.checkedList(list, Player.class);

//此时会对类型进行检查，不是Player类型，抛出异常 java.lang.ClassCastException:
</code></pre>
<h1 id="emptyxxx-返回空的集合"><a class="header" href="#emptyxxx-返回空的集合">emptyxxx 返回空的集合</a></h1>
<p>返回一个空集合，不能添加，不能删除</p>
<h1 id="synchronizedxxx-同步集合"><a class="header" href="#synchronizedxxx-同步集合">synchronizedxxx 同步集合</a></h1>
<p>对集合进行了二次包装，在内部加了一把锁</p>
<h1 id="unmodifiablexxx-不可变集合"><a class="header" href="#unmodifiablexxx-不可变集合">unmodifiableXxx 不可变集合</a></h1>
<p>传入的集合返回后不可以改变。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-2"><a class="header" href="#概述-2">概述</a></h1>
<p>ConcurrentHashMap是conccurrent家族中的一个类，由于它可以高效地支持并发操作，以及被广泛使用，经典的开源框架<a href="http://lib.csdn.net/base/javaee">spring</a>的底层<a href="http://lib.csdn.net/base/datastructure">数据结构</a>就是使用ConcurrentHashMap实现的。与同是线程安全的老大哥HashTable相比，它已经更胜一筹，因此它的锁更加细化，而不是像HashTable一样为几乎每个方法都添加了synchronized锁，这样的锁无疑会影响到性能。</p>
<h1 id="重要的属性"><a class="header" href="#重要的属性">重要的属性</a></h1>
<h2 id="sizectl"><a class="header" href="#sizectl">sizeCtl</a></h2>
<p><strong>申明</strong></p>
<pre><code class="language-java">private transient volatile int sizeCtl;
</code></pre>
<ul>
<li>
<p>负数代表正在进行初始化或扩容操作</p>
<ul>
<li>-1代表正在初始化</li>
<li>-N 表示有N-1个线程正在进行扩容操作</li>
</ul>
</li>
<li>
<p>正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小，这一点类似于扩容阈值的概念。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的。</p>
</li>
</ul>
<h2 id="table"><a class="header" href="#table">table</a></h2>
<pre><code class="language-java">transient volatile Node&lt;K,V&gt;[] table;  
</code></pre>
<p>盛装Node元素的数组 它的大小是2的整数次幂</p>
<h1 id="使用-countercells-记录数据容量"><a class="header" href="#使用-countercells-记录数据容量">使用 <em>CounterCells</em> 记录数据容量</a></h1>
<ul>
<li>ConcurrentHashMap是采用CounterCell数组来记录元素个数的，像一般的集合记录集合大小，直接定义一个size的成员变量即可，当出现改变的时候只要更新这个变量就行。</li>
</ul>
<p><strong>为什么ConcurrentHashMap要用这种形式来处理呢？</strong> </p>
<ul>
<li>问题还是处在并发上，<em>ConcurrentHashMap</em>是并发集合，如果用一个成员变量来统计元素个数的话，为了保证并发情况下共享变量的的安全，势必会需要通过加锁或者自旋来实现</li>
<li>如果竞争比较激烈的情况下，size的设置上会出现比较大的冲突反而影响了性能，所以在ConcurrentHashMap采用了分片的方法来记录大小</li>
</ul>
<h1 id="三个核心方法"><a class="header" href="#三个核心方法">三个核心方法</a></h1>
<pre><code class="language-java"> @SuppressWarnings(&quot;unchecked&quot;)
//获得在i位置上的Node节点,保证获取得是最新的改动
static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {
    return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);
}
//利用CAS算法设置i位置上的Node节点。之所以能实现并发是因为他指定了原来这个节点的值是多少
//在CAS算法中，会比较内存中的值与你指定的这个值是否相等，如果相等才接受你的修改，否则拒绝你的修改
//因此当前线程中的值并不是最新的值，这种修改可能会覆盖掉其他线程的修改结果  有点类似于SVN
static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,
                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) {
    return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);
}
//利用volatile方法设置节点位置的值
static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) {
    U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);
}
</code></pre>
<h1 id="扩容"><a class="header" href="#扩容">扩容</a></h1>
<h2 id="inittable"><a class="header" href="#inittable">initTable</a></h2>
<blockquote>
<p>懒加载初始化</p>
</blockquote>
<p>CAS 设置  <em>sizeCtl</em> 为 -1</p>
<ul>
<li>初始化竞争成功
<ul>
<li>设置 sizeCtl为-1，表示已占据</li>
<li>新建数组</li>
<li>修改table引用</li>
<li>变更 sizeCtl为 sc，即3/4的当前容量</li>
</ul>
</li>
<li>初始化竞争失败（判断 sizeCtl&lt;0）
<ul>
<li>自旋</li>
</ul>
</li>
</ul>
<pre><code class="language-java">private final Node&lt;K,V&gt;[] initTable() {
    Node&lt;K,V&gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        if ((sc = sizeCtl) &lt; 0)
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                    table = tab = nt;
                    sc = n - (n &gt;&gt;&gt; 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
</code></pre>
<h2 id="addcount"><a class="header" href="#addcount">addCount</a></h2>
<ul>
<li>此方法 用于维护 map的 size大小</li>
<li>二是用于 判断是否需要扩容</li>
</ul>
<pre><code class="language-java">private final void addCount(long x, int check) {
	......//舍去size维护 code
    if (check &gt;= 0) {
        Node&lt;K,V&gt;[] tab, nt; int n, sc;
        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;
               (n = tab.length) &lt; MAXIMUM_CAPACITY) { //如果 当前元素个数 大于 sc,且数组不为0，且数组大小没有超过最大值
            int rs = resizeStamp(n); //取得扩容标志：  16的容量，返回28，且第16位为1，保证 右移16位后为负数，则该值为 65536+28 = 65564
            if (sc &lt; 0) { //sc小于0，表示当前正在扩容
                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex &lt;= 0)
                    break; //进入此路的情况是：已经完成了扩容，且更新了 table变量，但还未来得及更新 ctl字段
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) //加入扩容
                    transfer(tab, nt);
            }
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) //还未扩容，则将 sc直接 覆盖为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，+2： 1表示初始化，1表示有一个线程在扩容
                transfer(tab, null);
            s = sumCount(); //更新大小
        }
    }
}
</code></pre>
<h2 id="transfer"><a class="header" href="#transfer">transfer</a></h2>
<p>扩容是ConcurrentHashMap的精华之一，扩容操作的核心在于数据的转移</p>
<p>在单线程环境下数据的转移很简单，无非就是把旧数组中的数据迁移到新的数组。</p>
<p>但是这在多线程环境下，在扩容的时候其他线程也可能正在添加元素，这时又触发了扩容怎么办？</p>
<p>可能大家想到的第一个解决方案是加互斥锁，把转移过程锁住，虽然是可行的解决方案，但是会带来较大的性能开销。</p>
<p>因为互斥锁会导致所有访问临界区的线程陷入到阻塞状态，持有锁的线程耗时越长，其他竞争线程就会一直被阻塞，导致吞吐量较低。</p>
<p>而且还可能导致死锁。 </p>
<p>而ConcurrentHashMap并没有直接加锁，而是采用CAS实现无锁的并发同步策略</p>
<p>最精华的部分是它可以利用多线程来进行协同扩容 简单来说，</p>
<ul>
<li>
<p><strong>它把Node数组当作多个线程之间共享的任务队列</strong></p>
</li>
<li>
<p><strong>然后通过维护一个指针来划分每个线程锁负责的区间</strong></p>
</li>
<li>
<p><strong>每个线程通过区间逆向遍历来实现扩容</strong></p>
</li>
<li>
<p>一个已经迁移完的bucket会被替换为一个ForwardingNode节点，标记当前bucket已经被其他线程迁移完了。接下来分析一下它的源码实现</p>
</li>
</ul>
<p>1、fwd:这个类是个标识类，用于指向新表用的，其他线程遇到这个类会主动跳过这个类，因为这个类要么就是扩容迁移正在进行，要么就是已经完成扩容迁移，也就是这个类要保证线程安全，再进行操作。</p>
<p>2、advance:这个变量是用于提示代码是否进行推进处理，也就是当前桶处理完，处理下一个桶的标识</p>
<p>3、finishing:这个变量用于提示扩容是否结束用的</p>
<pre><code class="language-java">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {
        int n = tab.length, stride;
//将 (n&gt;&gt;&gt;3相当于 n/8) 然后除以 CPU核心数。如果得到的结果小于 16，那么就使用 16
 
    // 这里的目的是让每个 CPU 处理的桶一样多，避免出现转移任务不均匀的现象，如果桶较少的话，默认一个 CPU（一个线程）处理 16 个桶，也就是长度为16的时候，扩容的时候只会有一个线程来扩容
    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE; // subdivide range
    
    //nextTab未初始化，nextTab是用来扩容的node数组
    if (nextTab == null) {            // initiating
        try {
 
            //新建一个n&lt;&lt;1原始table大小的nextTab,也就是32
            @SuppressWarnings(&quot;unchecked&quot;)
            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];
 
            //赋值给nextTab
            nextTab = nt;
        } catch (Throwable ex) {      // try to cope with OOME
 
            //扩容失败，sizeCtl使用int的最大值
            sizeCtl = Integer.MAX_VALUE;
            return;
        }
 
        //更新成员变量
        nextTable = nextTab;
 
        //更新转移下标，表示转移时的下标
        transferIndex = n;
    }
 
    //新的tab的长度
    int nextn = nextTab.length;
 
    // 创建一个 fwd 节点，表示一个正在被迁移的Node，并且它的hash值为-1(MOVED)，也就是前面我们在讲putval方法的时候，会有一个判断MOVED的逻辑。它的作用是用来占位，表示原数组中位置i处的节点完成迁移以后，就会在i位置设置一个fwd来告诉其他线程这个位置已经处理过了，具体后续还会在讲
    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);
 
    // 首次推进为 true，如果等于 true，说明需要再次推进一个下标（i--），反之，如果是 false，那么就不能推进下标，需要将当前的下标处理完毕才能继续推进
    boolean advance = true;
 
    //判断是否已经扩容完成，完成就return，退出循环
    boolean finishing = false; // to ensure sweep before committing nextTab
 
    //通过for自循环处理每个槽位中的链表元素，默认advace为真，通过CAS设置transferIndex属性值，并初始化i和bound值，i指当前处理的槽位序号，bound指需要处理的槽位边界，先处理槽位15的节点；
    for (int i = 0, bound = 0;;) {
 
        // 这个循环使用CAS不断尝试为当前线程分配任务
 
        // 直到分配成功或任务队列已经被全部分配完毕
 
        // 如果当前线程已经被分配过bucket区域
 
        // 那么会通过--i指向下一个待处理bucket然后退出该循环
        Node&lt;K,V&gt; f; int fh;
        while (advance) {
            int nextIndex, nextBound;
 
            //--i表示下一个待处理的bucket，如果它&gt;=bound,表示当前线程已经分配过bucket区域
            if (--i &gt;= bound || finishing)
                advance = false;
 
            //表示所有bucket已经被分配完毕 给nextIndex赋予初始值 = 16
            else if ((nextIndex = transferIndex) &lt;= 0) {
                i = -1;
                advance = false;
            }
            //通过cas来修改TRANSFERINDEX,为当前线程分配任务，处理的节点区间为(nextBound,nextIndex)-&gt;(0,15)
            else if (U.compareAndSwapInt
                     (this, TRANSFERINDEX, nextIndex,
                      nextBound = (nextIndex &gt; stride ?
                                   nextIndex - stride : 0))) {
 
                //0
                bound = nextBound;
 
                //15
                i = nextIndex - 1;
                advance = false;
            }
        }
 
        //i&lt;0说明已经遍历完旧的数组，也就是当前线程已经处理完所有负责的bucket
        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {
            int sc;
 
            //如果完成了扩容
            if (finishing) {
 
                //删除成员变量
                nextTable = null;
 
                //更新table数组
                table = nextTab;
 
                //更新阈值(32*0.75=24)
                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);
                return;
            }
 
            // sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2 (详细介绍点击这里)
 
            // 然后，每增加一个线程参与迁移就会将 sizeCtl 加 1，
 
            // 这里使用 CAS 操作对 sizeCtl 的低16位进行减 1，代表做完了属于自己的任务
            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
 
                //第一个扩容的线程，执行transfer方法之前，会设置 sizeCtl = (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)
 
                //后续帮其扩容的线程，执行transfer方法之前，会设置 sizeCtl = sizeCtl+1
 
                //每一个退出transfer的方法的线程，退出之前，会设置 sizeCtl = sizeCtl-1
 
                //那么最后一个线程退出时：必然有
                //sc == (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，即 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT
 
                // 如果 sc - 2 不等于标识符左移 16 位。如果他们相等了，说明没有线程在帮助他们扩容了。也就是说，扩容结束了。
                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)
                    return;
 
                // 如果相等，扩容结束了，更新 finising 变量
                finishing = advance = true;
 
                // 再次循环检查一下整张表
                i = n; // recheck before commit
            }
        }
 
        // 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“
        else if ((f = tabAt(tab, i)) == null)
            advance = casTabAt(tab, i, null, fwd);
 
        //表示该位置已经完成了迁移，也就是如果线程A已经处理过这个节点，那么线程B处理这个节点时，hash值一定为MOVED
        else if ((fh = f.hash) == MOVED)
            advance = true; // already processed
        else { //真正开始迁移
            synchronized (f) {
                ...... //省略
            }
        }
    }
}
</code></pre>
<h2 id="数据迁移"><a class="header" href="#数据迁移">数据迁移</a></h2>
<p><strong>链表迁移优化</strong></p>
<ul>
<li>
<p>如果在链表 尾端存在 类似的数据，那么尾端的三个0 可以直接搬过来，减少内存的使用，lastRun的作用</p>
<p><code>1-&gt;1-&gt;0-&gt;0-&gt;0</code></p>
</li>
<li></li>
</ul>
<pre><code class="language-java"> synchronized (f) {
    if (tabAt(tab, i) == f) {
        Node&lt;K,V&gt; ln, hn;
        if (fh &gt;= 0) {
            int runBit = fh &amp; n;
            Node&lt;K,V&gt; lastRun = f;
            for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {
                int b = p.hash &amp; n;
                if (b != runBit) {
                    runBit = b;
                    lastRun = p;
                }
            }
            if (runBit == 0) {
                ln = lastRun;
                hn = null;
            }
            else {
                hn = lastRun;
                ln = null;
            }
            for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {
                int ph = p.hash; K pk = p.key; V pv = p.val;
                if ((ph &amp; n) == 0)
                    ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);
                else
                    hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);
            }
            setTabAt(nextTab, i, ln);
            setTabAt(nextTab, i + n, hn);
            setTabAt(tab, i, fwd);
            advance = true;
        }
        else if (f instanceof TreeBin) {
            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;
            TreeNode&lt;K,V&gt; lo = null, loTail = null;
            TreeNode&lt;K,V&gt; hi = null, hiTail = null;
            int lc = 0, hc = 0;
            for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {
                int h = e.hash;
                TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;
                    (h, e.key, e.val, null, null);
                if ((h &amp; n) == 0) {
                    if ((p.prev = loTail) == null)
                        lo = p;
                    else
                        loTail.next = p;
                    loTail = p;
                    ++lc;
                }
                else {
                    if ((p.prev = hiTail) == null)
                        hi = p;
                    else
                        hiTail.next = p;
                    hiTail = p;
                    ++hc;
                }
            }
            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;
            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;
            setTabAt(nextTab, i, ln);
            setTabAt(nextTab, i + n, hn);
            setTabAt(tab, i, fwd);
            advance = true;
        }
    }
 }
</code></pre>
<h2 id="helptransfer"><a class="header" href="#helptransfer">helpTransfer</a></h2>
<ul>
<li>当发现 存在 ForwardingNode结点，则加入扩容行列上来</li>
</ul>
<pre><code class="language-java">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) {
    Node&lt;K,V&gt;[] nextTab; int sc;
    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;
        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) {
        int rs = resizeStamp(tab.length);
        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;
               (sc = sizeCtl) &lt; 0) {
            //已经扩容完，但还未来得及更新SC
            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)
                break;
            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {
                transfer(tab, nextTab);
                break;
            }
        }
        return nextTab;
    }
    return table;
}
</code></pre>
<h2 id="sizectl为负数的含义分析"><a class="header" href="#sizectl为负数的含义分析">sizeCtl为负数的含义分析</a></h2>
<h3 id="组成图"><a class="header" href="#组成图"><strong>组成图</strong></a></h3>
<p><img src="6.java%E5%9F%BA%E7%A1%80_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%5Cimages%5Cconcurrent_hash_map_sizectl_negate.png" alt="image-20210322234319630" /></p>
<h3 id="这样存储带来的好处"><a class="header" href="#这样存储带来的好处"><strong>这样存储带来的好处？？</strong></a></h3>
<p>首先在 CHM 中是支持并发扩容的，也就是说如果当前的数组需要进行扩容操作，可以由多个线程来共同负责；
第一个扩容的线程，执行 transfer 方法之前，
会设置 sizeCtl =(resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</p>
<ul>
<li>后续帮其扩容的线程，执行 transfer 方法之前，会设置 sizeCtl = sizeCtl+1</li>
<li>每一个退出 transfer 的方法的线程，退出之前，会设置 sizeCtl = sizeCtl-1
那么最后一个线程退出时：必然有 sc == (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，
如果 sc - 2 不等于标识符左移 16 位。</li>
</ul>
<p>如果他们相等了，说明没有线程在帮助他们扩容了。也就是说，扩容结束了。</p>
<p>可以保证每次扩容都生成唯一的生成戳， 每次新的扩容，都有一个不同的 n（n是map的size），这个生成戳就是根据 n 来计算出来的一个数字， n 不同，这个数字也不同</p>
<h3 id="第一个线程尝试扩容的时候为什么是2-"><a class="header" href="#第一个线程尝试扩容的时候为什么是2-"><strong>第一个线程尝试扩容的时候，为什么是+2 ？？</strong></a></h3>
<p>因为 1 表示初始化，2 表示一个线程在执行扩容，而且对 sizeCtl 的操作都是基于位运算的，
所以不会关心它本身的数值是多少，只关心它在二进制上的数值，而 sc + 1 会在
低 16 位上加 1。</p>
<h3 id="多线程扩容要注意的问题"><a class="header" href="#多线程扩容要注意的问题"><strong>多线程扩容要注意的问题？</strong></a></h3>
<h1 id="putval"><a class="header" href="#putval">PUTVAL</a></h1>
<ul>
<li>如果还未初始化，则初始化</li>
<li>如果当前 位置空闲，则直接插入结点</li>
<li>如果当前位置 为 <em>MOVED</em> 则说明有 扩容存在，则参与扩容</li>
<li>对当前结点加锁
<ul>
<li>如果是链表 则往链表后插入</li>
<li>如果是红黑树，则按红黑树插入</li>
</ul>
</li>
<li>桶中有两种结点，一种是 链表结点，一种是 TreeBin结点，TreeBin结点负责 维护红黑树的 形成，插入删除</li>
</ul>
<pre><code class="language-java">final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node&lt;K,V&gt;[] tab = table;;) {
        Node&lt;K,V&gt; f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
            if (casTabAt(tab, i, null,
                         new Node&lt;K,V&gt;(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    if (fh &gt;= 0) {
                        binCount = 1;
                        for (Node&lt;K,V&gt; e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;&amp; key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node&lt;K,V&gt; pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node&lt;K,V&gt;(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {
                        Node&lt;K,V&gt; p;
                        binCount = 2;
                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                if (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}
</code></pre>
<h1 id="红黑树操作"><a class="header" href="#红黑树操作">红黑树操作</a></h1>
<ul>
<li>红黑树，即维护了 红黑树 的信息，又维护了 线性链表</li>
</ul>
<h2 id="查询"><a class="header" href="#查询">查询</a></h2>
<ul>
<li>如果当前 root结点 有写锁存在，则 使用线性查找</li>
<li>没有写锁，则 使用红黑树查找，并设置一个 读锁</li>
<li>读完之后，如果当前 有阻塞在此处的线程则 唤醒</li>
</ul>
<pre><code class="language-java">final Node&lt;K,V&gt; find(int h, Object k) {
    if (k != null) {
        for (Node&lt;K,V&gt; e = first; e != null; ) {
            int s; K ek;
            if (((s = lockState) &amp; (WAITER|WRITER)) != 0) {
                if (e.hash == h &amp;&amp;
                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))
                    return e;
                e = e.next;
            }
            else if (U.compareAndSwapInt(this, LOCKSTATE, s,
                                         s + READER)) {
                TreeNode&lt;K,V&gt; r, p;
                try {
                    p = ((r = root) == null ? null :
                         r.findTreeNode(h, k, null));
                } finally {
                    Thread w;
                    if (U.getAndAddInt(this, LOCKSTATE, -READER) ==
                        (READER|WAITER) &amp;&amp; (w = waiter) != null)
                        LockSupport.unpark(w);
                }
                return p;
            }
        }
    }
    return null;
}
</code></pre>
<h2 id="新增"><a class="header" href="#新增">新增</a></h2>
<ul>
<li>对跟结点上锁</li>
<li>定位到叶子结点</li>
<li>红黑树上锁
<ul>
<li>先尝试上写锁</li>
<li>上锁失败，则尝试更加 耗时的锁竞争
<ul>
<li>如果当前没有 人获取读写锁，则尝试 获取写锁</li>
<li>如果当前没有 等待者，则设置 自己为 等待者，且进入 等待</li>
<li>如果当前 锁被人占用，且等待者 也被人占用，则自旋</li>
</ul>
</li>
</ul>
</li>
<li>进行插入操作</li>
<li>解锁：<em>state</em> 置为0</li>
</ul>
<h2 id="删除"><a class="header" href="#删除">删除</a></h2>
<ul>
<li>对根节点上锁</li>
<li>定位到该结点</li>
<li>红黑树上锁
<ul>
<li>先尝试上写锁</li>
<li>上锁失败，则尝试更加 耗时的锁竞争
<ul>
<li>如果当前没有 人获取读写锁，则尝试 获取写锁</li>
<li>如果当前没有 等待者，则设置 自己为 等待者，且进入 等待</li>
<li>如果当前 锁被人占用，且等待者 也被人占用，则自旋</li>
</ul>
</li>
</ul>
</li>
<li>进行删除操作</li>
<li>解锁：<em>state</em> 置为0</li>
</ul>
<h1 id="总结-4"><a class="header" href="#总结-4">总结</a></h1>
<h2 id="如何保证并发下的数据安全性"><a class="header" href="#如何保证并发下的数据安全性">如何保证并发下的数据安全性</a></h2>
<p><strong>维护 <em>map</em> 大小</strong></p>
<p>使用分段锁，先尝试更新 baseCount，更新失败然后尝试  更新 某个 <em>CounterCell</em> 更新某个<em>CounterCell失败</em> 最后尝试 全量更新<em>CounterCell</em></p>
<p><strong>扩容</strong></p>
<p>并发扩容，每个线程负责 迁移 部分范围的 桶的数据</p>
<p><strong>维护红黑树</strong></p>
<p>使用读写锁</p>
<h2 id="concurrenthashmap如何扩容"><a class="header" href="#concurrenthashmap如何扩容">ConcurrentHashMap如何扩容</a></h2>
<ul>
<li>并发扩容，每个线程负责维护 数组的固定段</li>
<li>当其他线程 查询，新增，删除时遇到 扩容则 参与扩容</li>
</ul>
<p><a href="https://blog.csdn.net/luzhensmart/article/details/105968886">参考链接</a></p>
<p><a href="https://blog.csdn.net/anlian523/article/details/107328200">JDK ConcurrentHashMap的BUG集锦</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linkedlist"><a class="header" href="#linkedlist"><em>LinkedList</em></a></h1>
<h2 id="初始化-3"><a class="header" href="#初始化-3">初始化</a></h2>
<pre><code class="language-java">public LinkedList() {
}
public LinkedList(Collection&lt;? extends E&gt; c) {
    this();
    addAll(c);
}
</code></pre>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<h3 id="头插法"><a class="header" href="#头插法">头插法</a></h3>
<pre><code class="language-java">private void linkFirst(E e) {
    final Node&lt;E&gt; f = first;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);
    first = newNode;
    if (f == null)
        last = newNode;
    else
        f.prev = newNode;
    size++;
    modCount++;
}
</code></pre>
<h3 id="尾插法"><a class="header" href="#尾插法">尾插法</a></h3>
<pre><code class="language-java">void linkLast(E e) {
    final Node&lt;E&gt; l = last;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}
</code></pre>
<h3 id="中间插入-1"><a class="header" href="#中间插入-1">中间插入</a></h3>
<pre><code class="language-java">void linkBefore(E e, Node&lt;E&gt; succ) {
    // assert succ != null;
    final Node&lt;E&gt; pred = succ.prev;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);
    succ.prev = newNode;
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
}
</code></pre>
<h3 id="移除头"><a class="header" href="#移除头">移除头</a></h3>
<pre><code class="language-java">private E unlinkFirst(Node&lt;E&gt; f) {
    // assert f == first &amp;&amp; f != null;
    final E element = f.item;
    final Node&lt;E&gt; next = f.next;
    f.item = null;
    f.next = null; // help GC
    first = next;
    if (next == null)
        last = null;
    else
        next.prev = null;
    size--;
    modCount++;
    return element;
}
</code></pre>
<h3 id="移除尾"><a class="header" href="#移除尾">移除尾</a></h3>
<pre><code class="language-java">private E unlinkLast(Node&lt;E&gt; l) {
    // assert l == last &amp;&amp; l != null;
    final E element = l.item;
    final Node&lt;E&gt; prev = l.prev;
    l.item = null;
    l.prev = null; // help GC
    last = prev;
    if (prev == null)
        first = null;
    else
        prev.next = null;
    size--;
    modCount++;
    return element;
}
</code></pre>
<h3 id="移除中间"><a class="header" href="#移除中间">移除中间</a></h3>
<pre><code class="language-java">E unlink(Node&lt;E&gt; x) {
    // assert x != null;
    final E element = x.item;
    final Node&lt;E&gt; next = x.next;
    final Node&lt;E&gt; prev = x.prev;

    if (prev == null) {
        first = next;
    } else {
        prev.next = next;
        x.prev = null;
    }

    if (next == null) {
        last = prev;
    } else {
        next.prev = prev;
        x.next = null;
    }

    x.item = null;
    size--;
    modCount++;
    return element;
}
</code></pre>
<h3 id="获取头"><a class="header" href="#获取头">获取头</a></h3>
<pre><code class="language-java">public E getFirst() {
    final Node&lt;E&gt; f = first;
    if (f == null)
        throw new NoSuchElementException();
    return f.item;
}
</code></pre>
<h3 id="获取尾"><a class="header" href="#获取尾">获取尾</a></h3>
<pre><code class="language-java">public E getLast() {
    final Node&lt;E&gt; l = last;
    if (l == null)
        throw new NoSuchElementException();
    return l.item;
}
</code></pre>
<h3 id="根据索引查找结点"><a class="header" href="#根据索引查找结点">根据索引查找结点</a></h3>
<ul>
<li>如果索引 在前半段 则从前往后找</li>
<li>如果索引 在后半段 则从后往前找</li>
</ul>
<pre><code class="language-java">Node&lt;E&gt; node(int index) {
    // assert isElementIndex(index);

    if (index &lt; (size &gt;&gt; 1)) {
        Node&lt;E&gt; x = first;
        for (int i = 0; i &lt; index; i++)
            x = x.next;
        return x;
    } else {
        Node&lt;E&gt; x = last;
        for (int i = size - 1; i &gt; index; i--)
            x = x.prev;
        return x;
    }
}
</code></pre>
<h2 id="线性集合方法"><a class="header" href="#线性集合方法">线性集合方法</a></h2>
<h3 id="插入元素"><a class="header" href="#插入元素">插入元素</a></h3>
<p><strong>默认插入尾部</strong></p>
<pre><code class="language-java">public boolean add(E e) {
    linkLast(e);
    return true;
}
</code></pre>
<p><strong>根据索引插入</strong></p>
<pre><code class="language-java">public void add(int index, E element) {
    checkPositionIndex(index);

    if (index == size)
        linkLast(element);
    else
        linkBefore(element, node(index));
}
</code></pre>
<p><strong>批量插入</strong></p>
<ul>
<li>找到插入的索引点</li>
<li>循环将数组 生成链表</li>
</ul>
<pre><code class="language-java">public boolean addAll(Collection&lt;? extends E&gt; c) {
    return addAll(size, c);
}

public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
    checkPositionIndex(index);

    Object[] a = c.toArray();
    int numNew = a.length;
    if (numNew == 0)
        return false;

    Node&lt;E&gt; pred, succ;
    if (index == size) {
        succ = null;
        pred = last;
    } else {
        succ = node(index);
        pred = succ.prev;
    }

    for (Object o : a) {
        @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;
        Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        pred = newNode;
    }

    if (succ == null) {
        last = pred;
    } else {
        pred.next = succ;
        succ.prev = pred;
    }

    size += numNew;
    modCount++;
    return true;
}
</code></pre>
<h3 id="删除元素"><a class="header" href="#删除元素">删除元素</a></h3>
<p><strong>根据索引删除</strong></p>
<ul>
<li>根据索引找到结点</li>
<li>维护索引前后 链表</li>
</ul>
<pre><code class="language-java">public E remove(int index) {
    checkElementIndex(index);
    return unlink(node(index));
}
</code></pre>
<p><strong>根据对象删除</strong></p>
<pre><code class="language-java">public boolean remove(Object o) {
    if (o == null) {
        for (Node&lt;E&gt; x = first; x != null; x = x.next) {
            if (x.item == null) {
                unlink(x);
                return true;
            }
        }
    } else {
        for (Node&lt;E&gt; x = first; x != null; x = x.next) {
            if (o.equals(x.item)) {
                unlink(x);
                return true;
            }
        }
    }
    return false;
}


public boolean removeFirstOccurrence(Object o) {
    return remove(o);
}

public boolean removeLastOccurrence(Object o) {
    if (o == null) {
        for (Node&lt;E&gt; x = last; x != null; x = x.prev) {
            if (x.item == null) {
                unlink(x);
                return true;
            }
        }
    } else {
        for (Node&lt;E&gt; x = last; x != null; x = x.prev) {
            if (o.equals(x.item)) {
                unlink(x);
                return true;
            }
        }
    }
    return false;
}
</code></pre>
<p><strong>清空链表</strong></p>
<pre><code class="language-java">public void clear() {
    // Clearing all of the links between nodes is &quot;unnecessary&quot;, but:
    // - helps a generational GC if the discarded nodes inhabit
    //   more than one generation
    // - is sure to free memory even if there is a reachable Iterator
    for (Node&lt;E&gt; x = first; x != null; ) {
        Node&lt;E&gt; next = x.next;
        x.item = null;
        x.next = null;
        x.prev = null;
        x = next;
    }
    first = last = null;
    size = 0;
    modCount++;
}
</code></pre>
<h3 id="获取元素"><a class="header" href="#获取元素">获取元素</a></h3>
<pre><code class="language-java">public E get(int index) {
    checkElementIndex(index);
    return node(index).item;
}
</code></pre>
<h3 id="修改元素"><a class="header" href="#修改元素">修改元素</a></h3>
<pre><code class="language-java">public E set(int index, E element) {
    checkElementIndex(index);
    Node&lt;E&gt; x = node(index);
    E oldVal = x.item;
    x.item = element;
    return oldVal;
}
</code></pre>
<h2 id="队列方法"><a class="header" href="#队列方法">队列方法</a></h2>
<h3 id="插入元素-1"><a class="header" href="#插入元素-1">插入元素</a></h3>
<blockquote>
<p>同集合插入，尾部</p>
</blockquote>
<pre><code class="language-java">public boolean offer(E e) {
    return add(e);
}
</code></pre>
<h3 id="移除元素-2"><a class="header" href="#移除元素-2">移除元素</a></h3>
<pre><code class="language-java">//移除头元素
public E poll() {
    final Node&lt;E&gt; f = first;
    return (f == null) ? null : unlinkFirst(f);
}
</code></pre>
<h3 id="查看元素"><a class="header" href="#查看元素">查看元素</a></h3>
<ul>
<li>peek遇到空 队列不会报错，element会报错</li>
</ul>
<pre><code class="language-java">public E peek() {
    final Node&lt;E&gt; f = first;
    return (f == null) ? null : f.item;
}

public E element() {
    return getFirst();
}
</code></pre>
<h2 id="双向队列方法"><a class="header" href="#双向队列方法">双向队列方法</a></h2>
<p>包括 头尾曾删改查</p>
<p><strong>省略</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list接口"><a class="header" href="#list接口">List接口</a></h1>
<h2 id="查询操作-1"><a class="header" href="#查询操作-1">查询操作</a></h2>
<pre><code class="language-java">int size();
boolean isEmpty();
boolean contains(Object o);
Iterator&lt;E&gt; iterator();
Object[] toArray();
&lt;T&gt; T[] toArray(T[] a);
</code></pre>
<h2 id="修改操作-1"><a class="header" href="#修改操作-1">修改操作</a></h2>
<pre><code class="language-java">boolean add(E e);
boolean remove(Object o);
boolean containsAll(Collection&lt;?&gt; c);
boolean addAll(Collection&lt;? extends E&gt; c);
boolean addAll(int index, Collection&lt;? extends E&gt; c);
boolean removeAll(Collection&lt;?&gt; c);
boolean retainAll(Collection&lt;?&gt; c);
default void replaceAll(UnaryOperator&lt;E&gt; operator) {
    Objects.requireNonNull(operator);
    final ListIterator&lt;E&gt; li = this.listIterator();
    while (li.hasNext()) {
    	li.set(operator.apply(li.next()));
    }
}
void clear();
</code></pre>
<h2 id="排序-1"><a class="header" href="#排序-1">排序</a></h2>
<ul>
<li>先取出数组</li>
<li>后调用 数组静态排序方法</li>
<li>然后设置回当前 <em>ListIterator</em></li>
</ul>
<pre><code class="language-java">default void sort(Comparator&lt;? super E&gt; c) {
    Object[] a = this.toArray();
    Arrays.sort(a, (Comparator) c);
    ListIterator&lt;E&gt; i = this.listIterator();
    for (Object e : a) {
        i.next();
        i.set((E) e);
    }
}
</code></pre>
<h2 id="基于索引的操作"><a class="header" href="#基于索引的操作">基于索引的操作</a></h2>
<pre><code class="language-java">E get(int index);
E set(int index, E element);
void add(int index, E element);
E remove(int index);
int indexOf(Object o);
int lastIndexOf(Object o);
</code></pre>
<h2 id="基于索引的迭代器"><a class="header" href="#基于索引的迭代器">基于索引的迭代器</a></h2>
<pre><code class="language-java">ListIterator&lt;E&gt; listIterator();
ListIterator&lt;E&gt; listIterator(int index);
</code></pre>
<h2 id="基于索引的视图"><a class="header" href="#基于索引的视图">基于索引的视图</a></h2>
<pre><code class="language-java">List&lt;E&gt; subList(int fromIndex, int toIndex);
</code></pre>
<h2 id="总结-5"><a class="header" href="#总结-5">总结</a></h2>
<ul>
<li>List接口 增加了 基于索引的方法
<ul>
<li>包括基于索引的增删查改</li>
<li>以及基于索引的 视图</li>
</ul>
</li>
<li>同时提供了  基于 list迭代器  的两个默认实现 <em>sort</em> 与 <em>replaceAll</em> </li>
</ul>
<h1 id="abstractlist"><a class="header" href="#abstractlist"><em>AbstractList</em></a></h1>
<h2 id="类声明-2"><a class="header" href="#类声明-2">类声明</a></h2>
<pre><code class="language-java">public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {
	
}
</code></pre>
<h2 id="未实现方法"><a class="header" href="#未实现方法">未实现方法</a></h2>
<pre><code class="language-java">public void add(int index, E element) {}
abstract public E get(int index);
public E set(int index, E element) {}
public E remove(int index) {}
</code></pre>
<h2 id="搜索"><a class="header" href="#搜索">搜索</a></h2>
<p><strong>根据对象本身查找对象索引</strong></p>
<ul>
<li>依赖 <em>ListIterator</em> 实现</li>
<li>从头往后查找</li>
</ul>
<pre><code class="language-java">public int indexOf(Object o) {
    ListIterator&lt;E&gt; it = listIterator();
    if (o==null) {
        while (it.hasNext())
            if (it.next()==null)
                return it.previousIndex();
    } else {
        while (it.hasNext())
            if (o.equals(it.next()))
                return it.previousIndex();
    }
    return -1;
}
</code></pre>
<p><strong>查找最后一次出现的</strong></p>
<ul>
<li>依赖 <em>ListIterator</em> 实现</li>
<li>从后往前查找</li>
</ul>
<pre><code class="language-java">public int lastIndexOf(Object o) {
    ListIterator&lt;E&gt; it = listIterator(size());
    if (o==null) {
        while (it.hasPrevious())
            if (it.previous()==null)
                return it.nextIndex();
    } else {
        while (it.hasPrevious())
            if (o.equals(it.previous()))
                return it.nextIndex();
    }
    return -1;
}
</code></pre>
<h2 id="移除-1"><a class="header" href="#移除-1">移除</a></h2>
<ul>
<li>依赖 <em>ListIterator</em> 实现</li>
<li>从前往后 移除范围内的元素</li>
</ul>
<pre><code class="language-java">public void clear() {
    removeRange(0, size());
}

protected void removeRange(int fromIndex, int toIndex) {
    ListIterator&lt;E&gt; it = listIterator(fromIndex);
    for (int i=0, n=toIndex-fromIndex; i&lt;n; i++) {
        it.next();
        it.remove();
    }
}
</code></pre>
<h2 id="比较"><a class="header" href="#比较">比较</a></h2>
<ul>
<li>
<p>快速比较内存地址</p>
<p>如果内存地址相等 则返回 True</p>
</li>
<li>
<p>类型判断 判断是否是<em>List</em></p>
</li>
<li>
<p>依赖 <em>ListIterator</em></p>
</li>
<li>
<p>空值与空值相等</p>
</li>
</ul>
<pre><code class="language-java">public boolean equals(Object o) {
    if (o == this)
        return true;
    if (!(o instanceof List))
        return false;

    ListIterator&lt;E&gt; e1 = listIterator();
    ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();
    while (e1.hasNext() &amp;&amp; e2.hasNext()) {
        E o1 = e1.next();
        Object o2 = e2.next();
        if (!(o1==null ? o2==null : o1.equals(o2)))
            return false;
    }
    return !(e1.hasNext() || e2.hasNext());
}
</code></pre>
<h2 id="hashcode"><a class="header" href="#hashcode"><em>hashCode</em></a></h2>
<ul>
<li>将每个元素的hashCode累加</li>
<li>确保了，<em>equals</em> 相等 则<em>hashCode</em> 不相等</li>
</ul>
<pre><code class="language-java">public int hashCode() {
    int hashCode = 1;
    for (E e : this)
        hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());
    return hashCode;
}
</code></pre>
<h2 id="普通迭代器子类"><a class="header" href="#普通迭代器子类">普通迭代器子类</a></h2>
<h3 id="变量释义"><a class="header" href="#变量释义"><strong>变量释义</strong></a></h3>
<p><em><strong>lastRet</strong></em></p>
<p>上一次访问的 索引位置，如果没有访问或者 元素被删除了，则置为-1</p>
<p><em><strong>cursor</strong></em></p>
<p>下一次访问的索引</p>
<p><em><strong>expectedModCount</strong></em></p>
<p>当生成迭代器时，记录当前集合被修改的次数</p>
<pre><code class="language-java">private class Itr implements Iterator&lt;E&gt; {
    /**
     * Index of element to be returned by subsequent call to next.
     */
    int cursor = 0;

    /**
     * Index of element returned by most recent call to next or
     * previous.  Reset to -1 if this element is deleted by a call
     * to remove.
     */
    int lastRet = -1;

    /**
     * The modCount value that the iterator believes that the backing
     * List should have.  If this expectation is violated, the iterator
     * has detected concurrent modification.
     */
    int expectedModCount = modCount;

    //是否有下一个
    public boolean hasNext() {
        return cursor != size();
    }
    //取下一个，记录 lastRet，移动cursor
    public E next() {
        checkForComodification();
        try {
            int i = cursor;
            E next = get(i);
            lastRet = i;
            cursor = i + 1;
            return next;
        } catch (IndexOutOfBoundsException e) {
            checkForComodification();
            throw new NoSuchElementException();
        }
    }

    //根据索引，移除最近的元素，并更新 modCount
    public void remove() {
        if (lastRet &lt; 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            AbstractList.this.remove(lastRet);
            if (lastRet &lt; cursor)
                cursor--;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException e) {
            throw new ConcurrentModificationException();
        }
    }

    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
}
</code></pre>
<h2 id="listiterator迭代器"><a class="header" href="#listiterator迭代器">ListIterator迭代器</a></h2>
<p>List迭代器 与  普通迭代器相比，多了以下几个特性</p>
<ul>
<li>可以 往前迭代</li>
<li>且可以获取索引，</li>
<li>可以修改当前位置的值，可以在最后插入值</li>
</ul>
<p><strong>接口定义</strong></p>
<pre><code class="language-java">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {

	boolean hasNext();
    boolean hasPrevious();
   
    
	E next();

	E previous();
	int nextIndex();
	int previousIndex();
	
	
	void remove();
	
	void set(E e);
	void add(E e);
}
</code></pre>
<p><strong>实现</strong></p>
<ul>
<li><em>ListItr</em> 继承于 <em>Itr</em></li>
<li>可以指定 <em>cursor</em></li>
<li>迭代器的头为0</li>
<li><em>previos</em> 实现为 <em>cursor-1</em> 取得</li>
</ul>
<pre><code class="language-java">private class ListItr extends Itr implements ListIterator&lt;E&gt; {
    ListItr(int index) {
        cursor = index;
    }

    public boolean hasPrevious() {
        return cursor != 0;
    }

    public E previous() {
        checkForComodification();
        try {
            int i = cursor - 1;
            E previous = get(i);
            lastRet = cursor = i;
            return previous;
        } catch (IndexOutOfBoundsException e) {
            checkForComodification();
            throw new NoSuchElementException();
        }
    }

    public int nextIndex() {
        return cursor;
    }

    public int previousIndex() {
        return cursor-1;
    }

    public void set(E e) {
        if (lastRet &lt; 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            AbstractList.this.set(lastRet, e);
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    public void add(E e) {
        checkForComodification();

        try {
            int i = cursor;
            AbstractList.this.add(i, e);
            lastRet = -1;
            cursor = i + 1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }
}
</code></pre>
<h2 id="总结-6"><a class="header" href="#总结-6">总结</a></h2>
<ul>
<li><em>AbstractList</em> 提供了 基于 List迭代器，根据 对象查询索引的实现</li>
<li>提供了 基于 List迭代器的 范围删除的实现</li>
<li>实现了 equals 与 hashCode的实现</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-3"><a class="header" href="#概述-3">概述</a></h1>
<ul>
<li>包含 key values 键值对的 集合</li>
<li>不能包含重复<em>key</em></li>
<li>每个key只能映射一个值</li>
<li>该接口代替Dictionary类</li>
<li>Map提供了 三个 集合视图：keys，values，entrys</li>
<li>迭代顺序不做保证</li>
<li>如果使用 可变对象 作为 <em>key</em>，则必须格外小心，如果对象中 影响 equals比较的键变了，那么map的行为可能会未知</li>
<li>禁止Map 自身作为 <em>Key</em></li>
<li>所有 通用Map的 实现类 必须 提供 二个标准的 构造函数
<ul>
<li>无参构造</li>
<li>指定Map类型的 构造，（用作Map拷贝目的）</li>
</ul>
</li>
</ul>
<h1 id="查询操作-2"><a class="header" href="#查询操作-2">查询操作</a></h1>
<h2 id="大小"><a class="header" href="#大小">大小</a></h2>
<pre><code>int size();
</code></pre>
<h2 id="是否为空"><a class="header" href="#是否为空">是否为空</a></h2>
<pre><code>boolean isEmpty();
</code></pre>
<h2 id="是否包含key"><a class="header" href="#是否包含key">是否包含key</a></h2>
<pre><code>boolean containsKey(Object key);
</code></pre>
<h2 id="是否包含值"><a class="header" href="#是否包含值">是否包含值</a></h2>
<pre><code>boolean containsValue(Object value);
</code></pre>
<h2 id="根据key获取值"><a class="header" href="#根据key获取值">根据Key获取值</a></h2>
<pre><code>V get(Object key);
</code></pre>
<h1 id="修改操作-2"><a class="header" href="#修改操作-2">修改操作</a></h1>
<h2 id="放入元素-1"><a class="header" href="#放入元素-1">放入元素</a></h2>
<pre><code>V put(K key, V value);
</code></pre>
<h2 id="移除元素-3"><a class="header" href="#移除元素-3">移除元素</a></h2>
<pre><code>V remove(Object key);
</code></pre>
<h1 id="批量操作-1"><a class="header" href="#批量操作-1">批量操作</a></h1>
<h2 id="放入map"><a class="header" href="#放入map">放入Map</a></h2>
<pre><code>void putAll(Map&lt;? extends K, ? extends V&gt; m);
</code></pre>
<h2 id="清空map"><a class="header" href="#清空map">清空Map</a></h2>
<pre><code>void clear();
</code></pre>
<h1 id="视图"><a class="header" href="#视图">视图</a></h1>
<h2 id="键集合"><a class="header" href="#键集合">键集合</a></h2>
<pre><code>Set&lt;K&gt; keySet();
</code></pre>
<h2 id="values集合"><a class="header" href="#values集合">Values集合</a></h2>
<pre><code>Collection&lt;V&gt; values();
</code></pre>
<h2 id="entry集合"><a class="header" href="#entry集合">Entry集合</a></h2>
<pre><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();
</code></pre>
<h1 id="默认方法"><a class="header" href="#默认方法">默认方法</a></h1>
<h2 id="获取key不存在则取默认值"><a class="header" href="#获取key不存在则取默认值"><strong>获取key,不存在则取默认值</strong></a></h2>
<pre><code class="language-java">default V getOrDefault(Object key, V defaultValue) {
    V v;
    return (((v = get(key)) != null) || containsKey(key))
        ? v
        : defaultValue;
}
</code></pre>
<h2 id="迭代"><a class="header" href="#迭代">迭代</a></h2>
<pre><code class="language-java">default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
    Objects.requireNonNull(action);
    for (Map.Entry&lt;K, V&gt; entry : entrySet()) {
        K k;
        V v;
        try {
            k = entry.getKey();
            v = entry.getValue();
        } catch(IllegalStateException ise) {
            // this usually means the entry is no longer in the map.
            throw new ConcurrentModificationException(ise);
        }
        action.accept(k, v);
    }
}
</code></pre>
<h2 id="批量更新key"><a class="header" href="#批量更新key">批量更新Key</a></h2>
<pre><code class="language-java">default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
    Objects.requireNonNull(function);
    for (Map.Entry&lt;K, V&gt; entry : entrySet()) {
        K k;
        V v;
        try {
            k = entry.getKey();
            v = entry.getValue();
        } catch(IllegalStateException ise) {
            // this usually means the entry is no longer in the map.
            throw new ConcurrentModificationException(ise);
        }

        // ise thrown from function is not a cme.
        v = function.apply(k, v);

        try {
            entry.setValue(v);
        } catch(IllegalStateException ise) {
            // this usually means the entry is no longer in the map.
            throw new ConcurrentModificationException(ise);
        }
    }
}
</code></pre>
<h2 id="不存在则更新"><a class="header" href="#不存在则更新">不存在则更新</a></h2>
<pre><code class="language-java">default V putIfAbsent(K key, V value) {
    V v = get(key);
    if (v == null) {
        v = put(key, value);
    }

    return v;
}
</code></pre>
<h2 id="根据keyvalue移除"><a class="header" href="#根据keyvalue移除">根据KeyValue移除</a></h2>
<pre><code class="language-java">default boolean remove(Object key, Object value) {
    Object curValue = get(key);
    if (!Objects.equals(curValue, value) ||
        (curValue == null &amp;&amp; !containsKey(key))) {
        return false;
    }
    remove(key);
    return true;
}
</code></pre>
<h2 id="替换指定keyvalue的元素的值"><a class="header" href="#替换指定keyvalue的元素的值">替换指定KeyValue的元素的值</a></h2>
<pre><code>default boolean replace(K key, V oldValue, V newValue) {
    Object curValue = get(key);
    if (!Objects.equals(curValue, oldValue) ||
        (curValue == null &amp;&amp; !containsKey(key))) {
        return false;
    }
    put(key, newValue);
    return true;
}
</code></pre>
<h2 id="替换指定key的值"><a class="header" href="#替换指定key的值">替换指定Key的值</a></h2>
<pre><code class="language-java">default V replace(K key, V value) {
    V curValue;
    if (((curValue = get(key)) != null) || containsKey(key)) {
        curValue = put(key, value);
    }
    return curValue;
}
</code></pre>
<h2 id="不存在则放入元素1"><a class="header" href="#不存在则放入元素1">不存在则放入元素1</a></h2>
<pre><code class="language-java">default V computeIfAbsent(K key,
        Function&lt;? super K, ? extends V&gt; mappingFunction) {
    Objects.requireNonNull(mappingFunction);
    V v;
    if ((v = get(key)) == null) {
        V newValue;
        if ((newValue = mappingFunction.apply(key)) != null) {
            put(key, newValue);
            return newValue;
        }
    }

    return v;
}
</code></pre>
<h2 id="不存在则放入元素2"><a class="header" href="#不存在则放入元素2">不存在则放入元素2</a></h2>
<pre><code class="language-java">default V computeIfPresent(K key,
        BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
    Objects.requireNonNull(remappingFunction);
    V oldValue;
    if ((oldValue = get(key)) != null) {
        V newValue = remappingFunction.apply(key, oldValue);
        if (newValue != null) {
            put(key, newValue);
            return newValue;
        } else {
            remove(key);
            return null;
        }
    } else {
        return null;
    }
}
</code></pre>
<h2 id="根据mapping返回的结果更新-或移除-key"><a class="header" href="#根据mapping返回的结果更新-或移除-key">根据Mapping返回的结果更新 或移除 key</a></h2>
<ul>
<li>key，与oldValue 映射为 null，则移除 该 key</li>
<li>如果映射不为 null，则放入元素</li>
</ul>
<pre><code class="language-java">default V compute(K key,
        BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
    Objects.requireNonNull(remappingFunction);
    V oldValue = get(key);

    V newValue = remappingFunction.apply(key, oldValue);
    if (newValue == null) {
        // delete mapping
        if (oldValue != null || containsKey(key)) {
            // something to remove
            remove(key);
            return null;
        } else {
            // nothing to do. Leave things as they were.
            return null;
        }
    } else {
        // add or replace old mapping
        put(key, newValue);
        return newValue;
    }
}
</code></pre>
<h2 id="合并"><a class="header" href="#合并">合并</a></h2>
<p>如果旧值 为<em>NULL</em>，则直接用新值</p>
<p>如果旧值 不为 NULL，则两者的值进行合并</p>
<p>合并的返回值 为 NULL 则移除 该key</p>
<p>不为NULL 则  放入key</p>
<pre><code class="language-java">default V merge(K key, V value,
        BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
    Objects.requireNonNull(remappingFunction);
    Objects.requireNonNull(value);
    V oldValue = get(key);
    V newValue = (oldValue == null) ? value :
               remappingFunction.apply(oldValue, value);
    if(newValue == null) {
        remove(key);
    } else {
        put(key, newValue);
    }
    return newValue;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queue"><a class="header" href="#queue"><em>Queue</em></a></h1>
<blockquote>
<p><strong>队列</strong></p>
</blockquote>
<h2 id="接口申明"><a class="header" href="#接口申明">接口申明</a></h2>
<pre><code class="language-java">public interface Queue&lt;E&gt; extends Collection&lt;E&gt; {
}
</code></pre>
<h2 id="插入"><a class="header" href="#插入">插入</a></h2>
<h3 id="插入1"><a class="header" href="#插入1">插入1</a></h3>
<pre><code class="language-java">boolean add(E e);
</code></pre>
<h3 id="插入2"><a class="header" href="#插入2">插入2</a></h3>
<pre><code class="language-java">boolean offer(E e);
</code></pre>
<h2 id="移除-2"><a class="header" href="#移除-2">移除</a></h2>
<h3 id="移除队头元素1"><a class="header" href="#移除队头元素1">移除队头元素1</a></h3>
<pre><code class="language-java">E remove();
</code></pre>
<h3 id="移除对头元素2"><a class="header" href="#移除对头元素2">移除对头元素2</a></h3>
<ul>
<li>与1相比，如果为空则返回<em>NULL</em>，而1会 抛异常</li>
</ul>
<pre><code class="language-java">E poll();
</code></pre>
<h2 id="取队头元素"><a class="header" href="#取队头元素">取队头元素</a></h2>
<h3 id="取队头元素1"><a class="header" href="#取队头元素1">取队头元素1</a></h3>
<pre><code class="language-java">E element();
</code></pre>
<h3 id="取队头元素2"><a class="header" href="#取队头元素2">取队头元素2</a></h3>
<ul>
<li>与1相比，如果为空则返回<em>NULL</em>，而1会 抛异常</li>
</ul>
<pre><code class="language-java">E peek();
</code></pre>
<h1 id="deque"><a class="header" href="#deque"><em>Deque</em></a></h1>
<p><strong>双向队列</strong></p>
<h2 id="声明-1"><a class="header" href="#声明-1">声明</a></h2>
<pre><code class="language-java">public interface Deque&lt;E&gt; extends Queue&lt;E&gt; {}
</code></pre>
<h2 id="插入元素-2"><a class="header" href="#插入元素-2">插入元素</a></h2>
<pre><code class="language-java">//头部插入
void addFirst(E e);
//尾部插入
void addLast(E e);
//头部插入
boolean offerFirst(E e);
//尾部插入
boolean offerLast(E e);
</code></pre>
<h2 id="移除元素-4"><a class="header" href="#移除元素-4">移除元素</a></h2>
<pre><code class="language-java">E removeFirst();
E removeLast();

//以下移除空队列不会报错
E pollFirst();
E pollLast();

//移除第一个出现的对象
boolean removeFirstOccurrence(Object o);

//移除最后一个出现的对象
boolean removeLastOccurrence(Object o);
</code></pre>
<h2 id="获取元素-1"><a class="header" href="#获取元素-1">获取元素</a></h2>
<pre><code class="language-java">E getFirst();
E getLast();
//以下取空队列不会报错
E peekFirst();
E peekLast();
</code></pre>
<h2 id="栈方法"><a class="header" href="#栈方法">栈方法</a></h2>
<pre><code class="language-java">//头部压栈
void push(E e);

//头部出栈
E pop();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="总结-7"><a class="header" href="#总结-7">总结</a></h1>
<h2 id="linkedhashmap-与hashmap-有什么区别"><a class="header" href="#linkedhashmap-与hashmap-有什么区别"><em>LinkedHashMap</em> 与<em>HashMap</em> 有什么区别</a></h2>
<p><strong>功能上来说</strong></p>
<ol>
<li>可以维持 结点的插入顺序</li>
<li>支持 根据 访问结点的 先后顺序 访问</li>
<li>还支持 LRU 算法的 驱逐，前提是（第二个要开启）</li>
</ol>
<p><strong>如何实现的</strong></p>
<ol>
<li>
<p>第一点是 在 Entry元素 中维持了 before after，在 LinkHashMap中 维持了 以下这两个变量</p>
<p><strong>头尾指针</strong></p>
<pre><code class="language-java">/**
 * The head (eldest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; head;

/**
 * The tail (youngest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; tail;
</code></pre>
<p><strong>前驱后继</strong></p>
<pre><code class="language-java">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
    Entry&lt;K,V&gt; before, after;
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
        super(hash, key, value, next);
    }
}
</code></pre>
<p><strong>重写了 newNode方法</strong></p>
<p>以此来维持插入顺序</p>
<pre><code class="language-java">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {
    LinkedHashMap.Entry&lt;K,V&gt; p =
        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);
    linkNodeLast(p);
    return p;
}
</code></pre>
</li>
<li>
<p>访问顺序的实现 与 LRU 的实现</p>
<p>HashMap留下的 三个回调在<em>LinkHashMap</em> 中的实现</p>
<pre><code class="language-java">// Callbacks to allow LinkedHashMap post-actions，
void afterNodeAccess(Node&lt;K,V&gt; p) { } //当 get,put访问结点都会回调该方法
void afterNodeInsertion(boolean evict) { } //当插入新元素时，判断需不需要 逐出旧元素
void afterNodeRemoval(Node&lt;K,V&gt; p) { } //结点被移除之后 维持 链条
</code></pre>
</li>
</ol>
<h2 id="linkhashmap-的内部视图是如何实现的"><a class="header" href="#linkhashmap-的内部视图是如何实现的"><em>LinkHashMap</em> 的内部视图是如何实现的</a></h2>
<p>都借助于迭代器，在内部进行了一个实现</p>
<p>可以实现 访问与  删除 但不能新增</p>
<p><img src="6.java%E5%9F%BA%E7%A1%80_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%5Cimages%5CLinkedHashMap_views_class.png" alt="image-20210321145129074" /></p>
<h2 id="如何用-linkhashmap使用-lru"><a class="header" href="#如何用-linkhashmap使用-lru">如何用 LinkHashMap使用 LRU</a></h2>
<pre><code class="language-java">package com.example.demo;

import java.util.LinkedHashMap;
import java.util.Map;

public class LRU&lt;K,V&gt; extends LinkedHashMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

    private static final long serialVersionUID = 1L;

    public LRU(int initialCapacity,
             float loadFactor,
                        boolean accessOrder) {
        super(initialCapacity, loadFactor, accessOrder);
    }

    /** 
     * @description 重写LinkedHashMap中的removeEldestEntry方法，当LRU中元素多余6个时，
     *              删除最不经常使用的元素
     * @param eldest
     * @return     
     * @see java.util.LinkedHashMap#removeEldestEntry(java.util.Map.Entry)     
     */  
    @Override
    protected boolean removeEldestEntry(java.util.Map.Entry&lt;K, V&gt; eldest) {
        // TODO Auto-generated method stub
        if(size() &gt; 6){
            return true;
        }
        return false;
    }

    public static void main(String[] args) {

        LRU&lt;Character, Integer&gt; lru = new LRU&lt;Character, Integer&gt;(
                16, 0.75f, true);

        String s = &quot;abcdefghijkl&quot;;
        for (int i = 0; i &lt; s.length(); i++) {
            lru.put(s.charAt(i), i);
        }
        System.out.println(&quot;LRU中key为h的Entry的值为： &quot; + lru.get('h'));
        System.out.println(&quot;LRU的大小 ：&quot; + lru.size());
        System.out.println(&quot;LRU ：&quot; + lru);
    }
}
</code></pre>
<h2 id="linkedhashset与linkedhashmap的关系"><a class="header" href="#linkedhashset与linkedhashmap的关系">LinkedHashSet与LinkedHashMap的关系</a></h2>
<p><strong>底层使用 LinkedHashMap 实现</strong></p>
<pre><code class="language-java">HashSet(int initialCapacity, float loadFactor, boolean dummy) {
    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
}
</code></pre>
<h2 id="hashmap的序列化与反序列化"><a class="header" href="#hashmap的序列化与反序列化">HashMap的序列化与反序列化</a></h2>
<h2 id="序列化"><a class="header" href="#序列化">序列化</a></h2>
<ul>
<li>写入 阈值，负载因子，</li>
<li>写入容量</li>
<li>写入大小</li>
<li>循环写入 Entry</li>
</ul>
<pre><code class="language-java">private void writeObject(java.io.ObjectOutputStream s)
    throws IOException {
    int buckets = capacity();
    // Write out the threshold, loadfactor, and any hidden stuff
    s.defaultWriteObject();
    s.writeInt(buckets);
    s.writeInt(size);
    internalWriteEntries(s);
}
</code></pre>
<pre><code class="language-java">void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException {
    Node&lt;K,V&gt;[] tab;
    if (size &gt; 0 &amp;&amp; (tab = table) != null) {
        for (int i = 0; i &lt; tab.length; ++i) {
            for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {
                s.writeObject(e.key);
                s.writeObject(e.value);
            }
        }
    }
}
</code></pre>
<h2 id="反序列化"><a class="header" href="#反序列化">反序列化</a></h2>
<ul>
<li>读入默认 成员变量字段</li>
<li>重新初始化 其他字段</li>
<li>读入容量，<strong>忽略</strong></li>
<li>读入 size大小</li>
<li>选择 loadFactor （0.25~4 之间）</li>
<li>计算容量，计算新的阈值</li>
<li>循环批量插入</li>
</ul>
<pre><code class="language-java">private void readObject(java.io.ObjectInputStream s)
    throws IOException, ClassNotFoundException {
    // Read in the threshold (ignored), loadfactor, and any hidden stuff
    s.defaultReadObject();
    reinitialize();
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +
                                         loadFactor);
    s.readInt();                // Read and ignore number of buckets
    int mappings = s.readInt(); // Read number of mappings (size)
    if (mappings &lt; 0)
        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +
                                         mappings);
    else if (mappings &gt; 0) { // (if zero, use defaults)
        // Size the table using given load factor only if within
        // range of 0.25...4.0
        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);
        float fc = (float)mappings / lf + 1.0f;
        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?
                   DEFAULT_INITIAL_CAPACITY :
                   (fc &gt;= MAXIMUM_CAPACITY) ?
                   MAXIMUM_CAPACITY :
                   tableSizeFor((int)fc));
        float ft = (float)cap * lf;
        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?
                     (int)ft : Integer.MAX_VALUE);

        // Check Map.Entry[].class since it's the nearest public type to
        // what we're actually creating.
        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];
        table = tab;

        // Read the keys and values, and put the mappings in the HashMap
        for (int i = 0; i &lt; mappings; i++) {
            @SuppressWarnings(&quot;unchecked&quot;)
                K key = (K) s.readObject();
            @SuppressWarnings(&quot;unchecked&quot;)
                V value = (V) s.readObject();
            putVal(hash(key), key, value, false, false);
        }
    }
}
</code></pre>
<pre><code class="language-java">void reinitialize() {
    table = null;
    entrySet = null;
    keySet = null;
    values = null;
    modCount = 0;
    threshold = 0;
    size = 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-4"><a class="header" href="#概述-4">概述</a></h1>
<p><code>SynchronousQueue</code>类实现了<a href="https://links.jianshu.com/go?to=http%3A%2F%2Ftutorials.jenkov.com%2Fjava-util-concurrent%2Fblockingqueue.html"><code>BlockingQueue</code></a>接口。</p>
<p><code>SynchronousQueue</code>是一个内部只能包含一个元素的队列。插入元素到队列的线程被阻塞，直到另一个线程从队列中获取了队列中存储的元素。同样，如果线程尝试获取元素并且当前不存在任何元素，则该线程将被阻塞，直到线程将元素插入队列。</p>
<p>将这个类称为队列有点不是很形象，这更像是一个点。</p>
<h1 id="源码分析"><a class="header" href="#源码分析">源码分析</a></h1>
<p><code>SynchronousQueue</code>的内部实现了两个类，一个是<code>TransferStack</code>类，使用LIFO顺序存储元素，这个类用于非公平模式；还有一个类是<code>TransferQueue</code>，使用FIFI顺序存储元素，这个类用于公平模式。这两个类继承自&quot;Nonblocking Concurrent Objects with Condition Synchronization&quot;算法，此算法是由W. N. Scherer III 和 M. L. Scott提出的，关于此算法的理论内容在这个网站中：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.cs.rochester.edu%2Fu%2Fscott%2Fsynchronization%2Fpseudocode%2Fduals.html">http://www.cs.rochester.edu/u/scott/synchronization/pseudocode/duals.html</a>。两个类的性能差不多，FIFO通常用于在竞争下支持更高的吞吐量，而LIFO在一般的应用中保证更高的线程局部性。</p>
<p>队列（或者栈）的节点在任何时间要么是&quot;data&quot;模式 —— 通过put操作提供的元素的模式，要么是&quot;request&quot;模式 —— 通过take操作取出元素的模式，要么为空。还有一个模式是&quot;fulfill&quot;模式，当队列有一个data节点时，请求从队列中获取一个元素就会构造一个&quot;fulfill&quot;模式的节点，反之亦然。这个类最有趣的特性在于任何操作都能够计算出现在队列头节点处于什么模式，然后根据它进行操作而无需使用锁。</p>
<p>队列和栈都继承了抽象类<code>Transferer</code>，这个类只定义了一个方法<code>transfer</code>，此方法可以既可以执行put也可以执行take操作。这两个操作被统一到了一个方法中，因为在<code>dual</code>数据结构中，put和take操作是对称的，所以相近的所有结点都可以被结合。使用<code>transfer</code>方法是从长远来看的，它相比分为两个几乎重复的部分来说更加容易理解。</p>
<h2 id="transferer抽象类"><a class="header" href="#transferer抽象类">Transferer抽象类</a></h2>
<pre><code class="language-java">abstract static class Transferer&lt;E&gt; {
    /**
     * 执行put或者take操作/
     * 如果参数e非空，这个元素将被交给一个消费线程；如果为null，
     * 则请求返回一个被生产者提交的元素。
     * 如果返回的结果非空，那么元素被提交了或被接受了；如果为null，
     * 这个操作可能因为超时或者中断失败了。调用者可以通过检查
     * Thread.interrupted来区分到底是因为什么元素失败。
     */
    abstract E transfer(E e, boolean timed, long nanos);
}
</code></pre>
<h2 id="transferstack"><a class="header" href="#transferstack">TransferStack</a></h2>
<h3 id="数据结构定义"><a class="header" href="#数据结构定义">数据结构定义</a></h3>
<pre><code class="language-java">static final class TransferStack&lt;E&gt; extends Transferer&lt;E&gt; {
/* Modes for SNodes, ORed together in node fields */
/** 表示一个未满足的消费者 */
static final int REQUEST    = 0;
/** 表示一个未满足的生产者 */
static final int DATA       = 1;
/** Node is fulfilling another unfulfilled DATA or REQUEST */
static final int FULFILLING = 2;

static boolean isFulfilling(int m) { return (m &amp; FULFILLING) != 0; }

/** Node class for TransferStacks. */
static final class SNode {
    volatile SNode next;        // 栈中的下一个结点
    volatile SNode match;       // 匹配此结点的结点
    volatile Thread waiter;     // 控制 park/unpark
    Object item;                // 数据
    int mode;//结点模式
</code></pre>
<h3 id="stack的核心方法"><a class="header" href="#stack的核心方法">Stack的核心方法</a></h3>
<p>使用put操作时参数e不为空，而使用take操作时参数e为null，而<code>timed</code>和<code>nanos</code>指定是否使用超时。</p>
<p><strong>此方法主要有三个 <em>Action</em></strong></p>
<ul>
<li>当栈为空或者， 栈顶有模式相同的元素：则直接入栈顶</li>
<li>当 栈顶存在不同模式的元素，则 尝试 <em>fullFiller</em> 待插入的元素，入栈顶，并尝试匹配下一个结点 一起出栈</li>
<li>当栈顶 存在 <em>fullfiller</em> 元素 则帮助其 出栈</li>
</ul>
<pre><code class="language-java">E transfer(E e, boolean timed, long nanos) {
    /*
     * 基础算法，循环尝试下面三种操作中的一个：
     *
     * 1. 如果头节点为空或者已经包含了相同模式的结点，尝试将结点
     *    增加到栈中并且等待匹配。如果被取消，返回null
     *
     * 2. 如果头节点是一个模式不同的结点，尝试将一个`fulfilling`结点加入
     *    到栈中，匹配相应的等待结点，然后一起从栈中弹出，
     *    并且返回匹配的元素。匹配和弹出操作可能无法进行，
     *    由于其他线程正在执行操作3
     *
     * 3. 如果栈顶已经有了一个`fulfilling`结点，帮助它完成
     *    它的匹配和弹出操作，然后继续。
     */

    SNode s = null; // constructed/reused as needed
    // 传入参数为null代表请求获取一个元素，否则表示插入元素
    int mode = (e == null) ? REQUEST : DATA;

    for (;;) {
        SNode h = head;
        // 如果头节点为空或者和当前模式相同
        if (h == null || h.mode == mode) {  // empty or same-mode
            // 设置超时时间为 0，立刻返回
            if (timed &amp;&amp; nanos &lt;= 0L) {     // can't wait
                if (h != null &amp;&amp; h.isCancelled())
                    casHead(h, h.next);     // pop cancelled node
                else
                    return null;
            // 构造一个结点并且设为头节点
            } else if (casHead(h, s = snode(s, e, h, mode))) {
                // 等待满足
                SNode m = awaitFulfill(s, timed, nanos);
                if (m == s) {               // wait was cancelled
                    clean(s);
                    return null;
                }
                if ((h = head) != null &amp;&amp; h.next == s)
                    casHead(h, s.next);     // help s's fulfiller
                return (E) ((mode == REQUEST) ? m.item : s.item);
            }
        // 检查头节点是否为FULFILLIING
        } else if (!isFulfilling(h.mode)) { // try to fulfill
            if (h.isCancelled())            // already cancelled
                casHead(h, h.next);         // pop and retry
            // 更新头节点为自己
            else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {
                // 循环直到匹配成功
                for (;;) { // loop until matched or waiters disappear
                    SNode m = s.next;       // m is s's match
                    if (m == null) {        // all waiters are gone
                        casHead(s, null);   // pop fulfill node
                        s = null;           // use new node next time
                        break;              // restart main loop
                    }
                    SNode mn = m.next;
                    if (m.tryMatch(s)) {
                        casHead(s, mn);     // pop both s and m
                        return (E) ((mode == REQUEST) ? m.item : s.item);
                    } else                  // lost match
                        s.casNext(m, mn);   // help unlink
                }
            }
        // 帮助满足的结点匹配
        } else {                            // help a fulfiller
            SNode m = h.next;               // m is h's match
            if (m == null)                  // waiter is gone
                casHead(h, null);           // pop fulfilling node
            else {
                SNode mn = m.next;
                if (m.tryMatch(h))          // help match
                    casHead(h, mn);         // pop both h and m
                else                        // lost match
                    h.casNext(m, mn);       // help unlink
            }
        }
    }
}
</code></pre>
<h3 id="同模式自旋等待"><a class="header" href="#同模式自旋等待">同模式自旋等待</a></h3>
<blockquote>
<p>遇到同模式的结点后，入栈自旋一段时间后等待</p>
</blockquote>
<pre><code class="language-java">SNode awaitFulfill(SNode s, boolean timed, long nanos) {
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    Thread w = Thread.currentThread();
    int spins = (shouldSpin(s) ?
                 (timed ? maxTimedSpins : maxUntimedSpins) : 0); //计算需要自旋的次数
    for (;;) {
        if (w.isInterrupted()) //中断后取消自己
            s.tryCancel();
        SNode m = s.match;
        if (m != null) // 被唤醒之后，匹配不为空，说明匹配成功
            return m;
        if (timed) {
            nanos = deadline - System.nanoTime();
            if (nanos &lt;= 0L) {
                s.tryCancel(); //超时后取消自己
                continue;
            }
        }
        if (spins &gt; 0)
            spins = shouldSpin(s) ? (spins-1) : 0;//当自己是头结点，或者已经是fullFiller了，保持自旋
        else if (s.waiter == null) //自旋完毕，开始等待
            s.waiter = w; // establish waiter so can park next iter
        else if (!timed)
            LockSupport.park(this);
        else if (nanos &gt; spinForTimeoutThreshold)
            LockSupport.parkNanos(this, nanos);
    }
}
</code></pre>
<h3 id="示意图"><a class="header" href="#示意图"><strong>示意图</strong></a></h3>
<p><img src="6.java%E5%9F%BA%E7%A1%80_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%5Cimages%5Csynchronous_queue_stack_example.png" alt="img" /></p>
<h2 id="transferqueue"><a class="header" href="#transferqueue">TransferQueue</a></h2>
<h3 id="数据结构定义-1"><a class="header" href="#数据结构定义-1">数据结构定义</a></h3>
<pre><code class="language-java">static final class TransferQueue&lt;E&gt; extends Transferer&lt;E&gt; {
    /** Head of queue */
    transient volatile QNode head; //队列头结点
    /** Tail of queue */
    transient volatile QNode tail; //队列尾结点
    /**
         * Reference to a cancelled node that might not yet have been
         * unlinked from queue because it was the last inserted node
         * when it was cancelled.
         */
    transient volatile QNode cleanMe;
    /** Node class for TransferQueue. */
    static final class QNode {
        volatile QNode next;          // next node in queue 下节点
        volatile Object item;         // CAS'ed to or from null，数据域
        volatile Thread waiter;       // to control park/unpark
        final boolean isData; //是否包含数
</code></pre>
<h3 id="核心方法"><a class="header" href="#核心方法">核心方法</a></h3>
<ul>
<li>如果 队列为空 或者 与队尾模式相同，则入队尾 自旋等待</li>
<li>如果  与队头模式匹配成功，则尝试 队头出队列，并唤醒匹配的等待结点</li>
</ul>
<pre><code class="language-java">E transfer(E e, boolean timed, long nanos) {
    /* Basic algorithm is to loop trying to take either of
     * two actions:
     *
     * 1. If queue apparently empty or holding same-mode nodes,
     *    try to add node to queue of waiters, wait to be
     *    fulfilled (or cancelled) and return matching item.
     *
     * 2. If queue apparently contains waiting items, and this
     *    call is of complementary mode, try to fulfill by CAS'ing
     *    item field of waiting node and dequeuing it, and then
     *    returning matching item.
     *
     * In each case, along the way, check for and try to help
     * advance head and tail on behalf of other stalled/slow
     * threads.
     *
     * The loop starts off with a null check guarding against
     * seeing uninitialized head or tail values. This never
     * happens in current SynchronousQueue, but could if
     * callers held non-volatile/final ref to the
     * transferer. The check is here anyway because it places
     * null checks at top of loop, which is usually faster
     * than having them implicitly interspersed.
     */

    QNode s = null; // constructed/reused as needed
    boolean isData = (e != null);

    for (;;) {
        QNode t = tail;
        QNode h = head;
        if (t == null || h == null)         // saw uninitialized value
            continue;                       // spin

        // 如果队列为空或者模式与头节点相同
        if (h == t || t.isData == isData) { // empty or same-mode
            QNode tn = t.next;
            // 如果有其他线程修改了tail，进入下一循环重读
            if (t != tail)                  // inconsistent read    还未开始竞争，就输了：已经将tail更新好了，则退出，开始下一轮
                continue;
            // 如果有其他线程修改了tail，尝试cas更新尾节点，进入下一循环重读
            if (tn != null) {               // lagging tail   还未开始竞争，就输了：已经更新了next，还未开始更新tail引用，则帮忙更新下，然后退出开始下一轮
                advanceTail(t, tn);
                continue;
            }
            // 超时返回
            if (timed &amp;&amp; nanos &lt;= 0L)       // can't wait
                return null;
            // 构建一个新节点
            if (s == null)
                s = new QNode(e, isData);
            // 尝试CAS设置尾节点的next字段指向自己
            // 如果失败，重试
            if (!t.casNext(null, s))        // failed to link in，正式开始竞争，竞争失败，则退出
                continue;
      
            // cas设置当前节点为尾节点
            advanceTail(t, s);              // swing tail and wait  竞争成功设置 尾结点
            // 等待匹配的节点
            Object x = awaitFulfill(s, e, timed, nanos); //自旋等待
            // 如果被取消，删除自己，返回null
            if (x == s) {                   // wait was cancelled 由于中断被唤醒了，则取消
                clean(t, s);
                return null;
            }

            // 如果此节点没有被模式匹配的线程出队:即将 头节点 从上一个指向自己，
            // 那么自己进行出队操作
            if (!s.isOffList()) {           // not already unlinked  唤醒自己的结点还没来得扫尾，则自己开始扫尾
                advanceHead(t, s);          // unlink if head 此时头节点理应是t， 更新为s 指向自己，即出队列，此出发生在 队列已经成功匹配，且已经唤醒了配对的线程，也就是当前线程，但还未来得及 出队列故 出队列，小优化：不是必要
                if (x != null)              // and forget fields：取消对 item的引用，加快GC
                    s.item = s;
                s.waiter = null;//取消对 线程对象的引用，加快GC
            }
            return (x != null) ? (E)x : e;

        } else {                            // complementary-mode
            QNode m = h.next;               // node to fulfill
            // 数据不一致，重读
            if (t != tail || m == null || h != head)
                continue;                   // inconsistent read

            Object x = m.item;
            if (isData == (x != null) ||    // m already fulfilled     m已经匹配成功了
                x == m ||                   // m cancelled             m被取消了
                !m.casItem(x, e)) {         // lost CAS                CAS竞争失败
                // 上面三个条件无论哪一个满足，都证明m已经失效无用了，
                // 需要将其出队
                advanceHead(h, m);          // dequeue and retry
                continue;
            }

            // 成功匹配，依然需要将节点出队
            advanceHead(h, m);              // successfully fulfilled
            // 唤醒匹配节点，如果它被阻塞了
            LockSupport.unpark(m.waiter);
            return (x != null) ? (E)x : e;
        }
    }
}

Object awaitFulfill(QNode s, E e, boolean timed, long nanos) {
    /* Same idea as TransferStack.awaitFulfill */
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    Thread w = Thread.currentThread();
    int spins = (head.next == s)
        ? (timed ? MAX_TIMED_SPINS : MAX_UNTIMED_SPINS)
        : 0;
    for (;;) {
        if (w.isInterrupted())
            s.tryCancel(e);
        Object x = s.item;
        // item被修改后返回
        // 如果put操作在此等待，item会被更新为null
        // 如果take操作再次等待，item会由null变为一个值
        if (x != e)
            return x;
        if (timed) {
            nanos = deadline - System.nanoTime();
            if (nanos &lt;= 0L) {
                s.tryCancel(e);
                continue;
            }
        }
        if (spins &gt; 0) {
            --spins;
            Thread.onSpinWait();
        }
        else if (s.waiter == null)
            s.waiter = w;
        else if (!timed)
            LockSupport.park(this);
        else if (nanos &gt; SPIN_FOR_TIMEOUT_THRESHOLD)
            LockSupport.parkNanos(this, nanos);
    }
}
</code></pre>
<h3 id="等待"><a class="header" href="#等待">等待</a></h3>
<ul>
<li>先自旋一段时间判断 是否已经匹配，匹配成功 则 返回</li>
<li>否则 超时等待</li>
<li>如果被打断 则取消自身结点</li>
</ul>
<pre><code class="language-java">Object awaitFulfill(QNode s, E e, boolean timed, long nanos) {
    /* Same idea as TransferStack.awaitFulfill */
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    Thread w = Thread.currentThread();
    int spins = ((head.next == s) ?
                 (timed ? maxTimedSpins : maxUntimedSpins) : 0);
    for (;;) {
        if (w.isInterrupted())
            s.tryCancel(e);
        Object x = s.item;
        if (x != e)
            return x;
        if (timed) {
            nanos = deadline - System.nanoTime();
            if (nanos &lt;= 0L) {
                s.tryCancel(e);
                continue;
            }
        }
        if (spins &gt; 0)
            --spins;
        else if (s.waiter == null)
            s.waiter = w;
        else if (!timed)
            LockSupport.park(this);
        else if (nanos &gt; spinForTimeoutThreshold)
            LockSupport.parkNanos(this, nanos);
    }
}
</code></pre>
<h3 id="示意图-1"><a class="header" href="#示意图-1"><strong>示意图</strong></a></h3>
<p><strong>PUT -&gt; PUT -&gt; TAKE</strong></p>
<p><img src="6.java%E5%9F%BA%E7%A1%80_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%5Cimages%5Csynchronous_queue_queue_example_put_take.png" alt="img" /></p>
<p><strong>TAKE -&gt; TAKE -&gt; PUT</strong></p>
<p><img src="6.java%E5%9F%BA%E7%A1%80_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%5Cimages%5Csynchronous_queue_queue_example_take_put.png" alt="img" /></p>
<h2 id="公共方法"><a class="header" href="#公共方法">公共方法</a></h2>
<h3 id="初始化-4"><a class="header" href="#初始化-4">初始化</a></h3>
<ul>
<li>公平、非公平</li>
</ul>
<pre><code class="language-java">public SynchronousQueue(boolean fair) {
    transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();
}
</code></pre>
<h3 id="queue的方法"><a class="header" href="#queue的方法">Queue的方法</a></h3>
<pre><code class="language-java">//非阻塞 取数据，失败 返回*NULL*,成功 返回数据
public E poll() {
    return transferer.transfer(null, true, 0);
}
</code></pre>
<pre><code class="language-java">//同步队列 不存放任何数据，所以返回NULL
public E peek() {
    return null;
}
</code></pre>
<h3 id="blockingqueued的方法"><a class="header" href="#blockingqueued的方法">BlockingQueued的方法</a></h3>
<p><strong>PUT</strong></p>
<ul>
<li>不允许空</li>
<li>阻塞获取数据 直到数据返回</li>
<li>如果返回<em>NULL</em> 则表明是被中断了，则手动中断</li>
</ul>
<pre><code class="language-java">public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException();
    if (transferer.transfer(e, false, 0) == null) {
        Thread.interrupted();
        throw new InterruptedException();
    }
}
</code></pre>
<p><strong>Offer</strong></p>
<ul>
<li>超时等待</li>
<li>超时则返回false</li>
<li>中断抛异常</li>
</ul>
<pre><code class="language-java">public boolean offer(E e, long timeout, TimeUnit unit)
    throws InterruptedException {
    if (e == null) throw new NullPointerException();
    if (transferer.transfer(e, true, unit.toNanos(timeout)) != null)
        return true;
    if (!Thread.interrupted())
        return false;
    throw new InterruptedException();
}
</code></pre>
<p><strong>Take</strong></p>
<ul>
<li>阻塞获取数据</li>
<li>为空则认为是中断，抛异常</li>
</ul>
<pre><code class="language-java">public E take() throws InterruptedException {
    E e = transferer.transfer(null, false, 0);
    if (e != null)
        return e;
    Thread.interrupted();
    throw new InterruptedException();
}
</code></pre>
<p><strong>Poll</strong></p>
<ul>
<li>超时取数据</li>
<li>获取数据成功或者超时 则返回 e</li>
<li>否则 抛异常</li>
</ul>
<pre><code class="language-java">public E poll(long timeout, TimeUnit unit) throws InterruptedException {
    E e = transferer.transfer(null, true, unit.toNanos(timeout));
    if (e != null || !Thread.interrupted())
        return e;
    throw new InterruptedException();
}
</code></pre>
<h2 id="drainto"><a class="header" href="#drainto">DrainTo</a></h2>
<ul>
<li>非阻塞循环 快速取数据</li>
<li>能取多少是多少，直到无法取到</li>
</ul>
<pre><code class="language-java">public int drainTo(Collection&lt;? super E&gt; c) {
    if (c == null)
        throw new NullPointerException();
    if (c == this)
        throw new IllegalArgumentException();
    int n = 0;
    for (E e; (e = poll()) != null;) {
        c.add(e);
        ++n;
    }
    return n;
}
</code></pre>
<h1 id="总结-8"><a class="header" href="#总结-8">总结</a></h1>
<h2 id="synchronousqueue的实现原理是怎样的"><a class="header" href="#synchronousqueue的实现原理是怎样的">SynchronousQueue的实现原理是怎样的？</a></h2>
<ul>
<li>使用栈 或者队列 实现 公平与非公平</li>
<li>利用 模式匹配 统一 存或取操作，如果队尾 或 栈顶 是 同种 模式则 自旋一定次数进入等待，如果不是同种模式则 匹配成功
<ul>
<li>如果是队列 则 直接将队头结点 出队列，并唤醒等待在该结点的 线程</li>
<li>如果是栈，则入栈一个 匹配结点，然后将两个结点 出栈</li>
</ul>
</li>
</ul>
<h2 id="transferqueue与transferstack的异同"><a class="header" href="#transferqueue与transferstack的异同">TransferQueue与TransferStack的异同</a></h2>
<h3 id="核心不同点"><a class="header" href="#核心不同点">核心不同点</a></h3>
<ul>
<li>一个FIFO，一个FILO </li>
</ul>
<h3 id="共同点"><a class="header" href="#共同点"><strong>共同点</strong></a></h3>
<ul>
<li>都使用 <em>NULL</em> 值返回 表明 没有取到数据</li>
<li>都使用 匹配 模式，实现1对1的存取</li>
<li>都通过 将指针 指向自己  表明 结点的取消状态</li>
</ul>
<h3 id="不同处"><a class="header" href="#不同处">不同处</a></h3>
<ul>
<li>队列实际匹配时，不会将待匹配的结点入队列，而是直接 将已匹配的结点出队列</li>
<li>栈 在 模式匹配时，会将两个结点都入栈</li>
</ul>
<h2 id="transferstack与queue如何-减少多线程间的竞争"><a class="header" href="#transferstack与queue如何-减少多线程间的竞争">TransferStack与Queue如何 减少多线程间的竞争</a></h2>
<ul>
<li>通过设置 标记位 通知正 在自旋的线程已 完成匹配</li>
<li><em>Stack</em>：当检测到 其他结点 在 进行匹配操作时 会 其他线程会帮助 匹配的那对元素 出栈 后 在进行自己的 入栈</li>
<li>Queue：多个线程在队头 竞争一个资源
<ul>
<li>还未开始竞争，其他线程已经 到手了，则默默退出</li>
<li>竞争失败后，会默默帮对方做 好善后工作：例如更新 队头结点</li>
<li>竞争成功后，唤醒等待在该结点的线程</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="前言-1"><a class="header" href="#前言-1">前言</a></h1>
<ul>
<li>java.util.Map接口常用的实现类：HashMap、TreeMap、HashTable、SortedMap。这些实现中最常用的是HashMap。</li>
<li>HashMap是存放键值对key-value的散列表，它的底层数据结构是数组+链表+红黑树。</li>
<li><img src="6.java%E5%9F%BA%E7%A1%80_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6//images/hashMap_structure.png" alt="hashMap结构图" /></li>
</ul>
<h1 id="核心参数"><a class="header" href="#核心参数">核心参数</a></h1>
<ul>
<li><em>DEFAULT_INITIAL_CAPACITY</em> 为16，默认大小</li>
<li><em>MAXIMUM_CAPACITY</em> 为 <em>1 &lt;&lt; 30</em> ，最大大小</li>
<li><em>TREEIFY_THRESHOLD</em> 8，树形化阈值，当链表的个数大于8 ，才从链表转 红黑树</li>
<li><em>UNTREEIFY_THRESHOLD</em> 6 去树形话阈值，从红黑树转 链表的阈值</li>
<li><em>MIN_TREEIFY_CAPACITY</em> 当 容器的大小大于 64 才会  在 链表过长时 转 红黑树</li>
<li><em>DEFAULT_LOAD_FACTOR</em> 负载因子 0.75 ，当元素个数/容器大小 超过 0.75时，会扩容</li>
</ul>
<h1 id="hashmap的node对象"><a class="header" href="#hashmap的node对象"><strong>HashMap的Node对象</strong></a></h1>
<p>Node对象定义了4个变量：</p>
<ul>
<li>hash：key的hash值</li>
<li>key：需要存储的键值对的key值</li>
<li>value：需要存储的键值对的value值</li>
<li>next：指向下一个元素的指针地址，如果不是链表或者树next为null</li>
</ul>
<h1 id="对键取hash方法"><a class="header" href="#对键取hash方法">对键取Hash方法</a></h1>
<pre><code class="language-java">//将hashCode的 低16位与高16位 做异或
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>
<h1 id="put方法"><a class="header" href="#put方法">PUT方法</a></h1>
<h2 id="put方法流程图"><a class="header" href="#put方法流程图">PUT方法流程图</a></h2>
<p><img src="6.java%E5%9F%BA%E7%A1%80_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/....%5Cimages%5ChashMap_put_value.png" alt="image-20210215151635333" /></p>
<h2 id="put_value-code"><a class="header" href="#put_value-code">PUT_VALUE CODE</a></h2>
<pre><code class="language-java">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        //判断table是否初始化，如果为空则 扩容
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //如果没有冲突则直接插入
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        //如果存在冲突则
        else {
            Node&lt;K,V&gt; e; K k;
            //当key跟 数组的第一个结点一样，则只更新 value
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            //当结点为 TreeNode 则插入红黑树
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            //当结点为 普通Node，则插入普通结点，如果已经存在结点，则只更新value
            //当超过了树形化阈值，则树形化
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        //如果大小超过了 容量阈值，则扩容
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
</code></pre>
<h1 id="树形化"><a class="header" href="#树形化">树形化</a></h1>
<p>略，参照红黑树</p>
<h2 id="结点转换"><a class="header" href="#结点转换">结点转换</a></h2>
<ul>
<li>首先将 普通node结点转换为 TreeNode结点</li>
<li>然后从将 链表树形化</li>
</ul>
<pre><code class="language-java">
final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {
    int n, index; Node&lt;K,V&gt; e;
    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
        resize();
    
    //链表结点 转树形结点
    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
        TreeNode&lt;K,V&gt; hd = null, tl = null;
        do {
            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}
</code></pre>
<h2 id="树形化-1"><a class="header" href="#树形化-1">树形化</a></h2>
<ul>
<li>遍历 结点树链表，依次平衡插入</li>
</ul>
<p><strong>key值比较逻辑</strong></p>
<ul>
<li>hash 大于 根节点的 放右边，小于根节点的hash放 左边</li>
<li>如果hash相等，则判断 key是否实现了 Compareable类，如果实现了则 调用 compareable方法</li>
<li>如果hash相等，也没有实现 compareable,则 调用全局系统的 判定方法</li>
</ul>
<pre><code class="language-java">        final void treeify(Node&lt;K,V&gt;[] tab) {
            TreeNode&lt;K,V&gt; root = null;
            for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) {
                next = (TreeNode&lt;K,V&gt;)x.next;
                x.left = x.right = null;
                //树立根结点
                if (root == null) {
                    x.parent = null;
                    x.red = false;
                    root = x;
                }
                else {
                    K k = x.key;
                    int h = x.hash;
                    Class&lt;?&gt; kc = null;
                    //大于根节点的放在 
                    for (TreeNode&lt;K,V&gt; p = root;;) {
                        int dir, ph;
                        K pk = p.key;
                        if ((ph = p.hash) &gt; h)
                            dir = -1;
                        else if (ph &lt; h)
                            dir = 1;
                        else if ((kc == null &amp;&amp;
                                  (kc = comparableClassFor(k)) == null) ||
                                 (dir = compareComparables(kc, k, pk)) == 0)
                            dir = tieBreakOrder(k, pk);

                        TreeNode&lt;K,V&gt; xp = p;
                        if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {
                            x.parent = xp;
                            if (dir &lt;= 0)
                                xp.left = x;
                            else
                                xp.right = x;
                            root = balanceInsertion(root, x);
                            break;
                        }
                    }
                }
            }
            moveRootToFront(tab, root);
        }
</code></pre>
<h2 id="平衡插入"><a class="header" href="#平衡插入">平衡插入</a></h2>
<p>略，具体实现见 <a href="6.java%E5%9F%BA%E7%A1%80_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/....%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%5C%E6%A0%91%5C%E7%BA%A2%E9%BB%91%E6%A0%91.html">红黑树</a></p>
<h1 id="重新扩容"><a class="header" href="#重新扩容">重新扩容</a></h1>
<ul>
<li>
<p>如果容量 超过了 允许的最大的个数 <em>MAXIMUM_CAPACITY = 1 &lt;&lt; 30</em> 则退出</p>
</li>
<li>
<p>将容量翻倍 ，阈值翻倍</p>
</li>
<li>
<p>遍历旧 容器的 所有结点</p>
<ul>
<li>
<p>如果 链条中结点只有一个 则直接使用 新容量  重新计算 位置</p>
</li>
<li>
<p>如果是 链条结点 则将链条数据分为 两类，一类是需要改变位置的结点，一类是不需要改变位置结点</p>
<ul>
<li><em>(e.hash &amp; oldCap) == 0</em> 判断 hash值的高位 是否为0
<ul>
<li>如果为0 则说明 hash值&lt; <em>oldCap</em> 在新数组中的位置 不用变，</li>
<li>如果为1 则说明 hash值&gt; <em>oldCap</em> 需要重新改变</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果是 红黑树  将数据分为 两类，一类是需要改变位置的结点，一类是不需要改变位置结点</p>
<ul>
<li>
<p><em>(e.hash &amp; oldCap) == 0</em> 判断 hash值的高位 是否为0</p>
<ul>
<li>如果为0 则说明 hash值&lt; <em>oldCap</em> 在新数组中的位置 不用变，</li>
<li>如果为1 则说明 hash值&gt; <em>oldCap</em> 需要重新改变</li>
</ul>
</li>
<li>
<p>如果链条长度 超过了树形话的阈值，则树形话</p>
<pre><code>loHead.treeify(tab);
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="重新扩容主方法"><a class="header" href="#重新扩容主方法">重新扩容主方法</a></h2>
<pre><code class="language-java"> final Node&lt;K,V&gt;[] resize() {
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) {
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1; // double threshold
        }
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do {
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
</code></pre>
<h2 id="对红黑树进行重新hash"><a class="header" href="#对红黑树进行重新hash">对红黑树进行重新hash</a></h2>
<blockquote>
<pre><code>((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
</code></pre>
</blockquote>
<pre><code class="language-java">        final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) {
            TreeNode&lt;K,V&gt; b = this;
            // Relink into lo and hi lists, preserving order
            TreeNode&lt;K,V&gt; loHead = null, loTail = null;
            TreeNode&lt;K,V&gt; hiHead = null, hiTail = null;
            int lc = 0, hc = 0;
            for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) {
                next = (TreeNode&lt;K,V&gt;)e.next;
                e.next = null;
                if ((e.hash &amp; bit) == 0) {
                    if ((e.prev = loTail) == null)
                        loHead = e;
                    else
                        loTail.next = e;
                    loTail = e;
                    ++lc;
                }
                else {
                    if ((e.prev = hiTail) == null)
                        hiHead = e;
                    else
                        hiTail.next = e;
                    hiTail = e;
                    ++hc;
                }
            }

            if (loHead != null) {
                if (lc &lt;= UNTREEIFY_THRESHOLD)
                    tab[index] = loHead.untreeify(map);
                else {
                    tab[index] = loHead;
                    if (hiHead != null) // (else is already treeified)
                        loHead.treeify(tab);
                }
            }
            if (hiHead != null) {
                if (hc &lt;= UNTREEIFY_THRESHOLD)
                    tab[index + bit] = hiHead.untreeify(map);
                else {
                    tab[index + bit] = hiHead;
                    if (loHead != null)
                        hiHead.treeify(tab);
                }
            }
        }
</code></pre>
<h1 id="移除结点"><a class="header" href="#移除结点">移除结点</a></h1>
<ul>
<li>根据 <em>hash</em> 索引数组 </li>
</ul>
<pre><code class="language-java">p = tab[index = (n - 1) &amp; hash]
</code></pre>
<ul>
<li>查找结点
<ul>
<li>通过 链条查找结点</li>
<li>通过 红黑树查找结点</li>
</ul>
</li>
<li>找到结点之后
<ul>
<li>如果是链条 则 断开该节点的链条</li>
<li>如果是红黑树，则 调用红黑树的删除</li>
</ul>
</li>
</ul>
<pre><code class="language-java">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (p = tab[index = (n - 1) &amp; hash]) != null) {
        Node&lt;K,V&gt; node = null, e; K k; V v;
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            node = p;
        else if ((e = p.next) != null) {
            if (p instanceof TreeNode)
                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
            else {
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key ||
                         (key != null &amp;&amp; key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                             (value != null &amp;&amp; value.equals(v)))) {
            if (node instanceof TreeNode)
                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
            else if (node == p)
                tab[index] = node.next;
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
</code></pre>
<h1 id="面试总结"><a class="header" href="#面试总结">面试总结</a></h1>
<h2 id="hashmap-的底层结构"><a class="header" href="#hashmap-的底层结构">hashMap 的底层结构</a></h2>
<p>数组+链表+红黑树，通过数组存储 <em>hash</em> 散列后的位置，使用链条 解决 hash冲突，当冲突足够多时，为了提高查询效率 使用 红黑树</p>
<h2 id="hashmap-容量大小为什么是-2的倍数"><a class="header" href="#hashmap-容量大小为什么是-2的倍数"><em>hashMap</em> 容量大小为什么是 2的倍数</a></h2>
<ul>
<li>
<p>hash散列 时 是使用 key的 hash值 与   <code>hash(key) &amp; (capacity-1)</code>   能够充分的散列 </p>
</li>
<li>
<p>在扩容时减少 数据移动</p>
<ul>
<li>数据索引的位置 跟 <em>hash</em> 与 <em>capacity-1</em> 有关</li>
<li>扩容后  hash不变   要么 变化为 <em>index+oldCapcity</em></li>
</ul>
</li>
</ul>
<h2 id="hashmap-的key值-允许为空吗"><a class="header" href="#hashmap-的key值-允许为空吗">hashMap 的key值 允许为空吗？</a></h2>
<p>允许，因为无论 null Key取hash的值为0</p>
<p>hashTab 在插入null Key时直接报错</p>
<h2 id="hashmap与-hashtab的区别"><a class="header" href="#hashmap与-hashtab的区别">HashMap与 HashTab的区别</a></h2>
<ul>
<li>
<p><strong>数据结构不同</strong> 数组加链表</p>
</li>
<li>
<p>没有 容量懒加载</p>
</li>
<li>
<p>key值不能为空</p>
</li>
<li>
<p>容量 不用满足 2的幂方</p>
</li>
<li>
<p>求 hash散列方式略微不同</p>
</li>
</ul>
<p><strong>最重要的</strong></p>
<p><strong>所有 新增，删除，扩容方法 都加了锁</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="hashcode的约定"><a class="header" href="#hashcode的约定">HashCode的约定</a></h3>
<p>在java.lang.Object的JavaDoc注释上对hashCode方法有三项约定</p>
<ol>
<li>当一个对象equals方法所使用的字段不变时，多次调用hashCode方法的值应保持不变</li>
<li>如果两个对象equals(Object o)方法是相等的，则hashCode方法值必须相等</li>
<li>如果两个对象equals(Object o)方法是不相等，则hashCode方法值不要求相等，但在这种情况下尽量确保hashCode不同，以提升性能。</li>
</ol>
<h1 id="验证"><a class="header" href="#验证">验证</a></h1>
<pre><code class="language-java">public static void main(String[] args) {
    Object obj = new Object();
    //获取当前地址
    long address = VM.current().addressOf(obj);
    //取hashCode
    long hashCode = obj.hashCode();
    System.out.println(&quot;before GC : The memory address is &quot; + address);
    System.out.println(&quot;before GC : The hash code is &quot; + hashCode);

    new Object();
    new Object();
    new Object();

    System.gc();

    long afterAddress = VM.current().addressOf(obj);
    long afterHashCode = obj.hashCode();
    System.out.println(&quot;after GC : The memory address is &quot; + afterAddress);
    System.out.println(&quot;after GC : The hash code is &quot; + afterHashCode);
    System.out.println(&quot;---------------------&quot;);

    System.out.println(&quot;memory address = &quot; + (address == afterAddress));
    System.out.println(&quot;hash code = &quot; + (hashCode == afterHashCode));
}
</code></pre>
<h1 id="hashcode不变的原理"><a class="header" href="#hashcode不变的原理">hashCode不变的原理</a></h1>
<p><strong>存储到对象头</strong></p>
<p>原来的hashcode值被存储在了某个地方，以备再用。对此以Hotspot为例，最直接的实现方式就是在对象的header区域中划分出来一部分（32位机器上是占用25位，64位机器上占用31）用来存储hashcode值。但这种方式会添加额外信息到对象中，而在大多数情况下hashCode方法并不会被调用，这就造成空间浪费</p>
<p><strong>懒计算</strong></p>
<p>当hashCode方法未被调用时，object header中用来存储hashcode的位置为0，只有当hashCode方法（本质上是System#identityHashCode）首次被调用时，才会计算对应的hashcode值，并存储到object header中。当再次被调用时，则直接获取计算好hashcode即可。</p>
<h1 id="hashcode生成的方式"><a class="header" href="#hashcode生成的方式">hashcode生成的方式</a></h1>
<p>不同的JVM对hashcode值的生成方式不同。Open JDK中提供了6中生成hash值的方法。</p>
<ul>
<li>0：随机数生成器（A randomly generated number.）；</li>
<li>1：通过对象内存地址的函数生成（A function of memory address of the object.）；</li>
<li>2：硬编码1（用于敏感度测试）（A hardcoded 1 (used for sensitivity testing.)）；</li>
<li>3：通过序列（A sequence.）；</li>
<li>4：对象的内存地址，强制转换为int。（The memory address of the object, cast to int.）</li>
<li>5：线程状态与xorshift结合（Thread state combined with xorshift）；</li>
</ul>
<p>其中在OpenJDK6、7中使用的是随机数生成器的（第0种）方式，OpenJDK8、9则采用第5种作为默认的生成方式。所以，单纯从OpenJDK的实现来说，其实hashcode的生成与对象内存地址没有什么关系。而Object类中hashCode方法上的注释，很有可能是早期版本中使用到了第4种方式。</p>
<h1 id="hashcode与identityhashcode"><a class="header" href="#hashcode与identityhashcode">hashCode与identityHashCode</a></h1>
<p><strong>重写hashCode</strong></p>
<p>上面我们多次提到hashCode方法，还提到identityHashCode方法，如果单纯以Object类中的hashCode方法来说，它与System类中提供了的identityHashCode方法是一致的</p>
<p>但在实践中我们往往会重写hashCode方法，此时object header中存储的hashcode值便有两种情况，一个是父类Object的，一个是实现类的。</p>
<p><strong>实时调用</strong></p>
<p>在OpenJDK中，header中存储的是通过System#identityHashCode获得的hashcode，而重写的hashCode方法的子类的hashcode则是通过实时调用其实现方法获得的。</p>
<p><strong>获取固定HashCode</strong></p>
<pre><code class="language-text">System.identityHashCode(person)
</code></pre>
<h1 id="验证jvm-hashcode懒存储"><a class="header" href="#验证jvm-hashcode懒存储">验证JVM hashCode懒存储</a></h1>
<pre><code class="language-java">public static void main(String[] args) {
    Object obj = new Object();

    System.out.println(ClassLayout.parseInstance(obj).toPrintable());
    System.out.println(Integer.toHexString(obj.hashCode()));

    System.out.println(ClassLayout.parseInstance(obj).toPrintable());

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jmm"><a class="header" href="#jmm">JMM</a></h1>
<h2 id="java内存模型是什么"><a class="header" href="#java内存模型是什么">Java内存模型是什么？</a></h2>
<p>Java是跨平台的语言，因为JVM屏蔽了底层操作系统和物理计算机的差异，<strong>JMM也是JVM规范定义的一部分</strong>，JMM抽象地定义了JVM在计算机内存中的工作方式。</p>
<p>JMM规定了所有的变量都存储在<strong>主内存（Main Memory）<strong>中。每个线程还有自己的</strong>工作内存（Working Memory）</strong>。</p>
<p><img src="7.jvm_jvm%E5%9F%BA%E7%A1%80/../../images/jmm_thread_memory.jpg" alt="" /></p>
<p>线程的工作内存中保存了该线程使用的主内存变量的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。</p>
<p>不同的线程之间无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。</p>
<h2 id="线程的数据共享"><a class="header" href="#线程的数据共享">线程的数据共享</a></h2>
<ul>
<li>
<p>JMM规定了线程之间的通信必须经过主内存，例如：线程a要将变量传给线程b，首先线程a要将本地工作内存中的变量刷新到主内存中的共享变量，然后线程b去主内存中读取刚刚被线程a更新后的共享变量，才能完成变量的传递。</p>
</li>
<li>
<p>线程间的传递需要将变量数据在工作内存和主内存之间来回传递。JMM 定义了 8 个操作来完成<strong>主内存和工作内存</strong>之间的交互操作。</p>
<ul>
<li><strong>assign(赋值)</strong>：作用于工作内存的变量，把一个从执行引擎接收到的值赋值给工作内存的变量；</li>
<li><strong>store (存储)</strong>：作用于工作内存的变量，把工作内存中的变量的值传送到主内存中 , 以便随后的写入操作；</li>
<li><strong>write (写入)</strong>：作用于主内存的变量, 它把传送给主内存的变量的值写入到主内存的变量中；</li>
<li><strong>unlock(解锁)</strong>：作用于主内存的变量，把一个处于锁定状态的变量释放出来 , 释放后的变量才可以被其他线程锁定；</li>
<li><strong>lock(锁定)</strong>：作用于主内存的变量，另外一个需要使用这个变量的线程对变量锁定，把一个主内存的变量标识为线程独占状态；</li>
<li><strong>read(读取)</strong>：作用于主内存的变量，把变量值从主内存的变量中读取出来，以便随后载入工作内存的变量副本；</li>
<li><strong>load(载入)</strong>：作用于工作内存的变量，它把从主内存中得到的变量值放入工作内存的变量副本中；</li>
<li><strong>use (使用)</strong>：作用于工作内存的变量 ，将工作内存中的变量值传递给执行引擎使用。</li>
</ul>
<p>至此，两个线程完成了变量的传递。</p>
</li>
</ul>
<p><img src="7.jvm_jvm%E5%9F%BA%E7%A1%80/../../images/jmm_thread_communication.jpg" alt="" /></p>
<h2 id="jmm的三大特性"><a class="header" href="#jmm的三大特性">JMM的三大特性</a></h2>
<p>JMM是一个抽象的概念，是围绕着并发编程中原子性、可见性、有序性这三个特性来建立的。上面介绍的Java 内存交互的8个基本操作，都遵循这三个特性。</p>
<p><strong>原子性</strong></p>
<p>一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态。</p>
<p><strong>可见性</strong></p>
<p>一个线程对共享变量做了修改之后，其他的线程立即能够看到该变量的这种修改。JMM是通过主内存作为变量传递媒介来实现的。</p>
<p><strong>有序性</strong></p>
<p>在本线程内观察，所有的操作都是有序的；观察另外的线程，所有的操作都是无序的。编译器和处理器可能会对操作做重排序。对于单线程，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序，<strong>但不保证多线程的数据依赖</strong>。</p>
<h1 id="volatile关键字"><a class="header" href="#volatile关键字">Volatile关键字</a></h1>
<p>volatile关键词作用于变量，具有两种语义：一是<strong>保证变量对所有线程的可见性</strong>，二是<strong>禁止进行指令重排序</strong>。下面分别加以说明。</p>
<h2 id="线程可见性"><a class="header" href="#线程可见性">线程可见性</a></h2>
<p>volatile的作用是确保每次对volatile变量的读操作都从主内存里读取变量的值，每次对volatile变量的写操作也都将值写到主内存里。</p>
<h2 id="禁止重排序"><a class="header" href="#禁止重排序">禁止重排序</a></h2>
<h3 id="禁止重排序规则"><a class="header" href="#禁止重排序规则"><strong>禁止重排序规则</strong></a></h3>
<p>编译器有时候会对指令进行重排序优化以获得更好的性能</p>
<p>volatile禁止重排序的规则如下：</p>
<ul>
<li>当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果对后面的操作可见；在其后面的操作肯定还没有进行；</li>
<li>在进行指令优化时，不能将后面的代码放到volatile变量访问语句之前执行，也不能将前面的代码放到volatile变量访问语句之后执行。</li>
</ul>
<h3 id="volatile-实现禁止重排序的原理"><a class="header" href="#volatile-实现禁止重排序的原理"><strong>volatile 实现禁止重排序的原理</strong></a></h3>
<p>JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的**内存屏障（Memory Barriers）**指令，通过内存屏障来禁止特定类型的处理器重排序。</p>
<p>内存屏障类型包括下表列出的四种。</p>
<p><img src="7.jvm_jvm%E5%9F%BA%E7%A1%80/../../images/volatile_memory_barrier.jpg" alt="" /></p>
<p>volatile实现禁止重排序的方式就是在编译生成字节码时，在对volatile变量的读写操作前后增加了内存屏障，以阻止和其他指令的执行顺序被重排。</p>
<p><strong>操作之间的重排序规则</strong></p>
<p><img src="7.jvm_jvm%E5%9F%BA%E7%A1%80/../../images/volatile_memory_operation.png" alt="" /></p>
<ul>
<li>只要第二个操作是volatile写，不管第一个操作是什么都不会重排序</li>
<li>只要第一个操作是volatile读，不管第二个操作是什么都不会重排序</li>
<li>第一个操作是volatile写，第二个操作是volatile读，也不会发生重排序</li>
</ul>
<p><strong>volatile 的使用场景</strong>总结起来，就是“一次写入，到处读取”</p>
<p><strong>volatile不保证原子性</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="堆内存结构"><a class="header" href="#堆内存结构">堆内存结构</a></h1>
<blockquote>
<p>堆是 Java 虚拟机进行垃圾回收的主要场所，其次要场所是方法区</p>
</blockquote>
<blockquote>
<p><strong>在 JDK1.8 之后，堆的永久区取消了由元空间取代</strong></p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/25/VHxZERUfGOLWp2r.png" alt="20201025083104" /></p>
<h1 id="jvm-如何判定一个对象是否要回收"><a class="header" href="#jvm-如何判定一个对象是否要回收"><strong>JVM 如何判定一个对象是否要回收？</strong></a></h1>
<blockquote>
<p>判断一个对象是否应该被回收，主要是看其是否还有引用</p>
</blockquote>
<h2 id="引用计数法"><a class="header" href="#引用计数法"><strong>引用计数法</strong></a></h2>
<p>对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只需要收集计数为 0 的对象。此算法最致命的是<strong>无法处理循环引用</strong>的问题。</p>
<h2 id="可达性分析"><a class="header" href="#可达性分析"><strong>可达性分析</strong></a></h2>
<p>是通过一系列可以做为 root 的对象作为起始点，从这些节点开始向下搜索。当一个对象到 root 节点没有任何引用链接时，则证明此对象是可以被回收的。以下对象会被认为是 root 对象：</p>
<ul>
<li>虚拟机栈 ( 栈帧的本地变量表 ) 中的引用对象。</li>
<li>方法区中类静态属性的引用的对象,常量引用的对象。</li>
<li>被启动类（bootstrap 加载器）加载的类和创建的对象</li>
<li>本地方法栈中<strong>JNI</strong>引用的对象。(native 方法)</li>
</ul>
<p><strong>一句话总结</strong>： 只要你的对象被<strong>方法的局部变量、类的静态变量</strong>给引用了，就不会回收他们。</p>
<h1 id="jvm-垃圾回收算法有哪些"><a class="header" href="#jvm-垃圾回收算法有哪些"><strong>JVM 垃圾回收算法有哪些</strong></a></h1>
<blockquote>
<p>HotSpot 虚拟机采用了<strong>可达性分析</strong>来进行内存回收，常见的回收算法有<strong>标记-清除算法，复制算法和标记整理算法。</strong></p>
</blockquote>
<h2 id="标记-清除算法mark-sweep"><a class="header" href="#标记-清除算法mark-sweep">标记-清除算法(Mark-Sweep)</a></h2>
<ol>
<li>
<p>从引用根节点开始标记所有被引用的对象，</p>
</li>
<li>
<p>遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，并且会产生内存碎片。</p>
</li>
</ol>
<h2 id="复制算法"><a class="header" href="#复制算法">复制算法</a></h2>
<p>复制算法把内存空间划为两个相等的区域，每次只使用其中一个区域</p>
<p><a href="7.jvm_jvm%E5%9F%BA%E7%A1%80/JVM%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.html">复制算法</a></p>
<h2 id="标记-整理算法"><a class="header" href="#标记-整理算法">标记-整理算法</a></h2>
<p>标记-整理算法结合了**“标记-清除”和“复制”**两个算法的优点。也是分两阶段，</p>
<ol>
<li>
<p>从根节点开始标记所有被引用对象，</p>
</li>
<li>
<p>遍历整个堆，清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p>
</li>
</ol>
<h1 id="垃圾收集器"><a class="header" href="#垃圾收集器">垃圾收集器</a></h1>
<p>JVM 中的垃圾收集器主要包括 7 种，即<strong>Serial，Serial Old，ParNew，Parallel Scavenge，Parallel Old 以及 CMS，G1 收集器</strong>
<img src="https://i.loli.net/2020/10/25/uTM4G1b2mVUNKRH.png" alt="20201025083626" /></p>
<h2 id="serial"><a class="header" href="#serial">Serial</a></h2>
<ul>
<li>是否需要 STW : 是</li>
<li>单线程/多线程: 单</li>
<li>算法: 未知</li>
<li>作用区域: 新生代</li>
</ul>
<h2 id="serial-old"><a class="header" href="#serial-old">Serial Old</a></h2>
<ul>
<li>是否需要 STW : 是</li>
<li>单线程/多线程: 单</li>
<li>算法: 未知</li>
<li>作用区域: 老年代</li>
</ul>
<p><strong>当 CMS 并发收集发生 Concurrent Mode Failure 时使用。</strong></p>
<h2 id="parnew-收集器"><a class="header" href="#parnew-收集器">ParNew 收集器</a></h2>
<blockquote>
<p>Serial 收集器的<strong>多线程</strong>版本</p>
</blockquote>
<ul>
<li>
<p>是否需要 STW : 是</p>
</li>
<li>
<p>单线程/多线程: 新生代是并行的（多线程的）,老年代是串行的（单线程的）</p>
</li>
<li>
<p>作用区域: 新生代 ,老年代</p>
</li>
<li>
<p>算法: 新生代采用复制算法，老年代采用标记整理算法</p>
</li>
<li>
<p>JVM 参数:</p>
<p><code>-XX：UseParNewGC</code>使用该收集器，</p>
<p><code>-XX：ParallelGCThreads</code> 可以限制线程数量</p>
</li>
</ul>
<h2 id="parallel-scavenge"><a class="header" href="#parallel-scavenge"><strong>Parallel Scavenge</strong></a></h2>
<blockquote>
<p>Paralle 收集器特点是更加关注吞吐量（吞吐量就是 cpu 用于运行用户代码的时间与 cpu 总消耗时间的比值）</p>
<p><strong>自适应调节策略</strong>是 Parallel Scavenge 收集器和 ParNew 的主要区别之一。</p>
</blockquote>
<ul>
<li>
<p>是否需要 STW : 是</p>
</li>
<li>
<p>单线程/多线程: <strong>多线程</strong></p>
</li>
<li>
<p>作用区域: 新生代</p>
</li>
<li>
<p>算法: 复制算法</p>
</li>
<li>
<p>JVM 参数:</p>
<p><code>-XX:MaxGCPauseMillis</code> 控制最大垃圾收集停顿时间</p>
<p><code>-XX:GCTimeRatio</code> 直接设置吞吐量大小</p>
<p><code>-XX:+UseAdaptiveSizePolicy</code> 可以打开 GC 自适应调节策略</p>
</li>
</ul>
<h2 id="parallel-old"><a class="header" href="#parallel-old">Parallel Old</a></h2>
<blockquote>
<p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用 标记-整理算法。</p>
</blockquote>
<ul>
<li>是否需要 STW : 是</li>
<li>单线程/多线程: <strong>多线程</strong></li>
<li>作用区域: 老年代</li>
<li>算法: 标记整理</li>
</ul>
<h2 id="cms"><a class="header" href="#cms"><strong>CMS</strong></a></h2>
<blockquote>
<p>Concurrent Mark Sweep,<strong>并发标记清除</strong></p>
</blockquote>
<blockquote>
<p>CMS 收集器是<strong>一种以获取最短回收停顿时间为目标</strong>的收集器</p>
</blockquote>
<ul>
<li>
<p>是否需要 STW : 很短的时间</p>
</li>
<li>
<p>单线程/多线程: <strong>多线程</strong></p>
</li>
<li>
<p>作用区域: 老年代</p>
</li>
<li>
<p>算法: <strong>标记清除</strong></p>
</li>
<li>
<p>步骤</p>
<ul>
<li><strong>初始标记</strong>：需要“Stop the World”，初始标记仅仅只是标记一下 GC Root 能直接关联到的对象，速度很快。</li>
<li><strong>并发标记</strong>：是主要标记过程，这个标记过程是和用户线程并发执行的。</li>
<li><strong>重新标记</strong>：需要“Stop the World”，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（停顿时间比初始标记长，但比并发标记短得多）。</li>
<li><strong>并发清除</strong>：和用户线程并发执行的，基于标记结果来清理对象。</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/10/25/OA54YwmhG1eSXaI.png" alt="20201025091029" /></p>
<ul>
<li>
<p>优点</p>
<p>STW时间短</p>
</li>
<li>
<p>缺点</p>
<ul>
<li><strong>对CPU资源非常敏感</strong>与用户线程并行, 资源不足导致效率低</li>
<li>产生<strong>浮动垃圾</strong>,  不可以在老年代内存不够用了才进行垃圾回收,必须提前进行垃圾收集
<ul>
<li>由于在应用运行的同时进行垃圾回收，所以有些垃圾可能在垃圾回收进行完成时产生，这样就造成了**“Floating Garbage”**，这些垃圾需要在下次垃圾回收周期时才能回收掉。所以，<strong>并发收集器一般需要20%的预留空间</strong>用于这些浮动垃圾。</li>
<li><strong>-XX:CMSInitiatingOccupancyFraction</strong>的值来控制内存使用百分比。如果该值设置的太高，</li>
<li>那么在CMS运行期间预留的内存可能无法满足程序所需，会出现<strong>Concurrent Mode Failure失败，之后会临时使用Serial Old收集器做为老年代收集器</strong>，会产生更长时间的停顿。</li>
</ul>
</li>
<li><strong>标记-清除方式会产生内存碎片</strong>
<ul>
<li><strong>-XX:UseCMSCompactAtFullCollection</strong>来控制是否开启内存整理（无法并发，默认是开启的）。</li>
<li><strong>-XX:CMSFullGCsBeforeCompaction</strong>用于设置执行多少次不压缩的Full GC后进行一次带压缩的内存碎片整理（默认值是0）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="g1"><a class="header" href="#g1"><strong>G1</strong></a></h2>
<blockquote>
<p><strong>Garbage-First</strong></p>
</blockquote>
<p>G1收集器将新生代和老年代取消了，取而代之的是<strong>将堆划分为若干个区域</strong>，每个区域都可以根据需要扮演新生代的Eden和Survivor区或者老年代空间，仍然属于分代收集器，区域的一部分包含新生代，新生代采用复制算法，老年代采用标记-整理算法。</p>
<p>通过<strong>将JVM堆分为一个个的区域（region）</strong>,G1收集器可以避免在Java堆中进行全区域的垃圾收集。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次<strong>根据回收时间来优先回收价值最大的region。</strong></p>
<p><strong>G1收集器的特点：</strong></p>
<ul>
<li><strong>并行与并发</strong>：G1能充分利用多CPU，多核环境下的硬件优势，来缩短Stop the World，是并发的收集器。</li>
<li><strong>分代收集</strong>：G1不需要其他收集器就能独立管理整个GC堆，能够采用不同的方式去处理新建对象、存活一段时间的对象和熬过多次GC的对象。</li>
<li><strong>空间整合</strong>：G1从整体来看是基于标记-整理算法，从局部（两个Region）上看基于复制算法实现，G1运作期间不会产生内存空间碎片。</li>
<li><strong>可预测的停顿</strong>：能够建立可以预测的停顿时间模型，预测停顿时间。</li>
</ul>
<p><strong>和CMS收集器类似，G1收集器的垃圾回收工作也分为了四个阶段：</strong></p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p>其中，筛选回收阶段首先对各个Region的回收价值和成本进行计算，根据用户期望的GC停顿时间来制定回收计划。</p>
<h1 id="java常用版本垃圾收集器"><a class="header" href="#java常用版本垃圾收集器">Java常用版本垃圾收集器</a></h1>
<pre><code class="language-cmd">java -XX:+PrintCommandLineFlags -version
</code></pre>
<p>jdk1.8默认的新生代垃圾收集器：Parallel Scavenge，老年代：Parallel Old</p>
<p>jdk1.9 默认垃圾收集器G1</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jvm内存模型"><a class="header" href="#jvm内存模型">JVM内存模型</a></h1>
<p>Java虚拟机(Java Virtual Machine=JVM)的内存空间分为五个部分，分别是： </p>
<ul>
<li>程序计数器</li>
<li>Java虚拟机栈 </li>
<li>本地方法栈 </li>
<li>堆 </li>
<li>方法区</li>
</ul>
<h2 id="程序计数器"><a class="header" href="#程序计数器">程序计数器</a></h2>
<h3 id="什么是程序计数器"><a class="header" href="#什么是程序计数器">什么是程序计数器？</a></h3>
<p>程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。也就是说，程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。 
**注：**但是，如果当前线程正在执行的是一个本地方法，那么此时程序计数器为空。 </p>
<h3 id="程序计数器的作用"><a class="header" href="#程序计数器的作用">程序计数器的作用</a></h3>
<p>程序计数器有两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 </li>
</ol>
<h3 id="程序计数器的特点"><a class="header" href="#程序计数器的特点">程序计数器的特点</a></h3>
<ol>
<li>是一块较小的存储空间</li>
<li>线程私有。每条线程都有一个程序计数器。</li>
<li>是唯一一个不会出现OutOfMemoryError的内存区域。</li>
<li>生命周期随着线程的创建而创建，随着线程的结束而死亡。 </li>
</ol>
<h2 id="java虚拟机栈jvm-stack"><a class="header" href="#java虚拟机栈jvm-stack">Java虚拟机栈(JVM Stack)</a></h2>
<h3 id="什么是java虚拟机栈"><a class="header" href="#什么是java虚拟机栈">什么是Java虚拟机栈？</a></h3>
<p>Java虚拟机栈是描述Java方法运行过程的内存模型。 
Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域，这块区域用于存储该方法在运行过程中所需要的一些信息，这些信息包括：</p>
<ol>
<li>局部变量表 
存放基本数据类型变量、引用类型的变量、returnAddress类型的变量。</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法出口信息</li>
<li>等</li>
</ol>
<pre><code>当一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。 
当这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。
</code></pre>
<p>J<strong>ava虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。</strong> </p>
<h3 id="java虚拟机栈的特点"><a class="header" href="#java虚拟机栈的特点">Java虚拟机栈的特点</a></h3>
<ol>
<li>
<p>方法的局部变量表不会改变</p>
<p>局部变量表的创建是在方法被执行的时候，随着栈帧的创建而创建。而且，局部变量表的大小在编译时期就确定下来了，在创建的时候只需分配事先规定好的大小即可。此外，在方法运行的过程中局部变量表的大小是不会发生改变的。</p>
</li>
<li>
<p>Java虚拟机栈会出现两种异常：StackOverFlowError和OutOfMemoryError。 </p>
<ol>
<li>StackOverFlowError： 
若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li>
<li>OutOfMemoryError： 
若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li>
</ol>
</li>
<li>
<p>Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
</li>
</ol>
<h2 id="本地方法栈"><a class="header" href="#本地方法栈">本地方法栈</a></h2>
<h3 id="什么是本地方法栈"><a class="header" href="#什么是本地方法栈">什么是本地方法栈？</a></h3>
<p>本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间。</p>
<p>也会抛出StackOverFlowError和OutOfMemoryError异常。</p>
<h2 id="堆"><a class="header" href="#堆">堆</a></h2>
<p>堆是用来存放对象的内存空间。 
<strong>几乎所有</strong>的对象都存储在堆中。 </p>
<h3 id="堆的特点"><a class="header" href="#堆的特点">堆的特点</a></h3>
<ol>
<li>线程共享 
整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是一个线程对应一个的。</li>
<li>在虚拟机启动时创建</li>
<li>垃圾回收的主要场所。</li>
<li>可以进一步细分为：新生代、老年代。 
新生代又可被分为：Eden、From Survior、To Survior。 
不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更高效。</li>
<li>堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出OutOfMemoryError。 </li>
</ol>
<h2 id="方法区"><a class="header" href="#方法区">方法区</a></h2>
<h3 id="什么是方法区"><a class="header" href="#什么是方法区">什么是方法区？</a></h3>
<p>Java虚拟机规范中定义方法区是堆的一个逻辑部分。 
方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。 </p>
<h3 id="方法区的特点"><a class="header" href="#方法区的特点">方法区的特点</a></h3>
<ol>
<li>线程共享 
方法区是堆的<strong>一个逻辑部分</strong>，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。</li>
<li>内存回收效率低 
方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。 
对方法区的内存回收的主要目标是：<strong>对常量池的回收</strong> 和 <strong>对类型的卸载</strong>。</li>
<li>Java虚拟机规范对方法区的要求比较宽松。 
和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。 </li>
</ol>
<h3 id="什么是运行时常量池"><a class="header" href="#什么是运行时常量池">什么是运行时常量池？</a></h3>
<p>方法区中存放三种数据：<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、即时编译器编译后的代码。其中常量存储在运行时常量池中。</p>
<p>我们一般在一个类中通过public static final来声明一个常量。这个类被编译后便生成Class文件，这个类的所有信息都存储在这个class文件中。</p>
<p>当这个类被Java虚拟机加载后，class文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如：String类的intern()方法就能在运行期间向常量池中添加字符串常量。</p>
<p>当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾收集器回收。 </p>
<h3 id="元空间"><a class="header" href="#元空间">元空间</a></h3>
<p><strong>元空间的引入</strong></p>
<ul>
<li>JDK1.8以前的HotSpot JVM，方法区的实现 使用堆内存，也叫 永久代**(permanent generation)**</li>
<li>永久代的<strong>GC</strong>是和老年代(old generation)捆绑在一起的，无论谁满了，都会触发永久代和老年代的垃圾收集。</li>
<li>JDK1.7开始了方法区的部分移除：<strong>符号引用(Symbols)<strong>移至</strong>native heap</strong>，<strong>字面量(interned strings)<strong>和</strong>静态变量(class statics)<strong>移至</strong>java heap。</strong></li>
</ul>
<p><strong>为什么要用Metaspace替代方法区</strong>
随着动态类加载的情况越来越多，这块内存变得不太可控，如果设置小了，系统运行过程中就容易出现内存溢出，设置大了又浪费内存。</p>
<p>这个元空间是使用本地内存（Native Memory）实现的，也就是说它的内存是不在虚拟机内的，所以可以理论上物理机器还有多个内存就可以分配，而不用再受限于JVM本身分配的内存了。</p>
<p>如果使用永久代实现方法区，那么需要手动扩大堆的大小，而使用元空间之后，就可以直接存储在内存当中，不用手动去修改堆的大小。</p>
<h2 id="直接内存"><a class="header" href="#直接内存">直接内存</a></h2>
<p>直接内存是除Java虚拟机之外的内存，但也有可能被Java使用。</p>
<p>在NIO中引入了一种基于通道和缓冲的IO方式。它可以通过调用本地方法直接分配Java虚拟机之外的内存，然后通过一个存储在Java堆中的DirectByteBuffer对象直接操作该内存，而无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率。</p>
<p>直接内存的大小不受Java虚拟机控制，但既然是内存，当内存不足时就会抛出OOM异常。 </p>
<h1 id="示意图-2"><a class="header" href="#示意图-2">示意图</a></h1>
<p><img src="7.jvm_jvm%E5%9F%BA%E7%A1%80/../../images/jvm_runtime_memory.png" alt="image-20210331101338292" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-5"><a class="header" href="#概述-5">概述</a></h1>
<p>JVM参数有很多，其实我们直接使用默认的JVM参数，不去修改都可以满足大多数情况。但是如果你想在有限的硬件资源下，部署的系统达到最大的运行效率，那么进行相关的JVM参数设置是必不可少的。下面我们就来对这些JVM参数进行详细的介绍。</p>
<p>　　JVM参数主要分为以下三种（可以根据书写形式来区分）：</p>
<h1 id="标准参数"><a class="header" href="#标准参数">标准参数</a></h1>
<ul>
<li>
<p>标准参数中包括功能以及输出的结果都是很稳定的，基本上<strong>不会随着JVM版本的变化而变化</strong>。</p>
</li>
<li>
<p>以 - 开头</p>
</li>
</ul>
<p><strong>模块操作</strong></p>
<pre><code>-p &lt;模块路径&gt;
--module-path &lt;模块路径&gt;...
              用 ; 分隔的目录列表, 每个目录
              都是一个包含模块的目录。
--upgrade-module-path &lt;模块路径&gt;...
              用 ; 分隔的目录列表, 每个目录
              都是一个包含模块的目录, 这些模块
              用于替换运行时映像中的可升级模块
--add-modules &lt;模块名称&gt;[,&lt;模块名称&gt;...]
              除了初始模块之外要解析的根模块。
              &lt;模块名称&gt; 还可以为 ALL-DEFAULT, ALL-SYSTEM,
              ALL-MODULE-PATH.
--list-modules
              列出可观察模块并退出
-d &lt;module name&gt;
--describe-module &lt;模块名称&gt;
              描述模块并退出
--validate-modules
              验证所有模块并退出
              --validate-modules 选项对于查找
              模块路径中模块的冲突及其他错误可能非常有用。
--show-module-resolution
              在启动过程中显示模块解析输出
</code></pre>
<p><strong>类路径搜索</strong></p>
<pre><code>-cp &lt;目录和 zip/jar 文件的类搜索路径&gt;
-classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;
--class-path &lt;目录和 zip/jar 文件的类搜索路径&gt;
              使用 ; 分隔的, 用于搜索类文件的目录, JAR 档案
              和 ZIP 档案列表。
              
</code></pre>
<p><strong>版本、详细、帮助</strong></p>
<pre><code>-verbose:[class|module|gc|jni]
              启用详细输出
-version      将产品版本输出到错误流并退出
--version     将产品版本输出到输出流并退出
-showversion  将产品版本输出到错误流并继续
--show-version
              将产品版本输出到输出流并继续

-? -h -help
              将此帮助消息输出到错误流
--help        将此帮助消息输出到输出流
-X            将额外选项的帮助输出到错误流
--help-extra  将额外选项的帮助输出到输出流
</code></pre>
<p><strong>属性与参数</strong></p>
<pre><code>-D&lt;名称&gt;=&lt;值&gt;
              设置系统属性
@argument 文件
              一个或多个包含选项的参数文件
</code></pre>
<p><strong>断言</strong></p>
<pre><code>-ea[:&lt;程序包名称&gt;...|:&lt;类名&gt;]
-enableassertions[:&lt;程序包名称&gt;...|:&lt;类名&gt;]
              按指定的粒度启用断言
-da[:&lt;程序包名称&gt;...|:&lt;类名&gt;]
-disableassertions[:&lt;程序包名称&gt;...|:&lt;类名&gt;]
              按指定的粒度禁用断言
-esa | -enablesystemassertions
              启用系统断言
-dsa | -disablesystemassertions
              禁用系统断言
              

</code></pre>
<p><strong>代理库</strong></p>
<pre><code>-agentlib:&lt;库名&gt;[=&lt;选项&gt;]
              加载本机代理库 &lt;库名&gt;, 例如 -agentlib:jdwp
              另请参阅 -agentlib:jdwp=help
-agentpath:&lt;路径名&gt;[=&lt;选项&gt;]
              按完整路径名加载本机代理库
-javaagent:&lt;jar 路径&gt;[=&lt;选项&gt;]
              加载 Java 编程语言代理, 请参阅 java.lang.instrument
</code></pre>
<p><strong>其他</strong></p>
<pre><code>--dry-run     创建 VM 并加载主类, 但不执行 main 方法。
              此 --dry-run 选项对于验证诸如
              模块系统配置这样的命令行选项可能非常有用。


-splash:&lt;图像路径&gt;
              使用指定的图像显示启动屏幕
              自动支持和使用 HiDPI 缩放图像
              (如果可用)。应始终将未缩放的图像文件名 (例如, image.ext)
              作为参数传递给 -splash 选项。
              将自动选取提供的最合适的缩放
              图像。
              有关详细信息, 请参阅 SplashScreen API 文档

-disable-@files
              阻止进一步扩展参数文件
--enable-preview
              允许类依赖于此发行版的预览功能
</code></pre>
<h1 id="x-参数"><a class="header" href="#x-参数">X 参数</a></h1>
<p>非标准化参数。表示在将来的JVM版本中可能会发生改变，</p>
<p><strong>常用</strong></p>
<pre><code>-Xmn&lt;大小&gt;        为年轻代（新生代）设置初始和最大堆大小
                  （以字节为单位）
-Xms&lt;大小&gt;        设置初始 Java 堆大小
-Xmx&lt;大小&gt;        设置最大 Java 堆大小
-Xss&lt;大小&gt;        设置 Java 线程栈大小
</code></pre>
<pre><code>-Xbatch           禁用后台编译
-Xbootclasspath/a:&lt;以 ; 分隔的目录和 zip/jar 文件&gt;
                  附加在引导类路径末尾
-Xcheck:jni       对 JNI 函数执行其他检查
-Xcomp            在首次调用时强制编译方法
-Xdebug           为实现向后兼容而提供
-Xdiag            显示附加诊断消息
-Xfuture          启用最严格的检查，预期将来的默认值
-Xint             仅解释模式执行
-Xinternalversion
                  显示比 -version 选项更详细的 JVM
                  版本信息
-Xloggc:&lt;文件&gt;    将 GC 状态记录在文件中（带时间戳）
-Xmixed           混合模式执行（默认值）

-Xnoclassgc       禁用类垃圾收集
-Xrs              减少 Java/VM 对操作系统信号的使用（请参见文档）
-Xshare:auto      在可能的情况下使用共享类数据（默认值）
-Xshare:off       不尝试使用共享类数据
-Xshare:on        要求使用共享类数据，否则将失败。
-XshowSettings    显示所有设置并继续
-XshowSettings:all
                  显示所有设置并继续
-XshowSettings:locale
                  显示所有与区域设置相关的设置并继续
-XshowSettings:properties
                  显示所有属性设置并继续
-XshowSettings:vm
                  显示所有与 vm 相关的设置并继续
-XshowSettings:system
                  （仅 Linux）显示主机系统或容器
                  配置并继续
-Xverify          设置字节码验证器的模式
--add-reads &lt;模块&gt;=&lt;目标模块&gt;(,&lt;目标模块&gt;)*
                  更新 &lt;模块&gt; 以读取 &lt;目标模块&gt;，而无论
                  模块声明如何。
                  &lt;目标模块&gt; 可以是 ALL-UNNAMED 以读取所有未命名
                  模块。
--add-exports &lt;模块&gt;/&lt;程序包&gt;=&lt;目标模块&gt;(,&lt;目标模块&gt;)*
                  更新 &lt;模块&gt; 以将 &lt;程序包&gt; 导出到 &lt;目标模块&gt;，
                  而无论模块声明如何。
                  &lt;目标模块&gt; 可以是 ALL-UNNAMED 以导出到所有
                  未命名模块。
--add-opens &lt;模块&gt;/&lt;程序包&gt;=&lt;目标模块&gt;(,&lt;目标模块&gt;)*
                  更新 &lt;模块&gt; 以在 &lt;目标模块&gt; 中打开
                  &lt;程序包&gt;，而无论模块声明如何。
--illegal-access=&lt;值&gt;
                  允许或拒绝通过未命名模块中的代码对命名模块中的
                  类型成员进行访问。
                  &lt;值&gt; 为 &quot;deny&quot;、&quot;permit&quot;、&quot;warn&quot; 或 &quot;debug&quot; 之一
                  此选项将在未来发行版中删除。
--limit-modules &lt;模块名&gt;[,&lt;模块名&gt;...]
                  限制可观察模块的领域
--patch-module &lt;模块&gt;=&lt;文件&gt;(;&lt;文件&gt;)*
                  使用 JAR 文件或目录中的类和资源
                  覆盖或增强模块。
--disable-@files  禁止进一步扩展参数文件
--source &lt;版本&gt;
                  设置源文件模式中源的版本。
</code></pre>
<h1 id="xx参数"><a class="header" href="#xx参数">XX参数</a></h1>
<p>这是我们日常开发中接触到最多的参数类型。这也是非标准化参数，相对来说不稳定，随着JVM版本的变化可能会发生变化，主要用于<strong>JVM调优</strong>和debug。</p>
<p>主要有两种类型，Boolean，与key-value</p>
<h2 id="boolean类型"><a class="header" href="#boolean类型">Boolean类型</a></h2>
<p><code>-XX:[+-]&lt;name&gt; 表示启用或者禁用name属性。</code></p>
<p><code>-XX:+UseG1GC（表示启用G1垃圾收集器）</code></p>
<h2 id="key-value类型"><a class="header" href="#key-value类型">Key-Value类型</a></h2>
<pre><code>-XX:&lt;name&gt;=&lt;value&gt; 表示name的属性值为value。
-XX:MaxGCPauseMillis=500（表示设置GC的最大停顿时间是500ms）
</code></pre>
<h1 id="参数详解"><a class="header" href="#参数详解">参数详解</a></h1>
<h2 id="打印jvm参数"><a class="header" href="#打印jvm参数">打印JVM参数</a></h2>
<p><strong>打印已经被用户或者当前虚拟机设置过的参数</strong></p>
<pre><code>-XX:+PrintCommandLineFlags
</code></pre>
<h2 id="最大堆和最小堆内存设置"><a class="header" href="#最大堆和最小堆内存设置"><strong>最大堆和最小堆内存设置</strong></a></h2>
<pre><code>-Xms512M：设置堆内存初始值为512M
-Xmx1024M：设置堆内存最大值为1024M

这里的ms是memory start的简称，mx是memory max的简称，分别代表最小堆容量和最大堆容量。但是别看这里是-X参数，其实这是-XX参数，等价于：
-XX:InitialHeapSize
-XX:MaxHeapSize
</code></pre>
<h2 id="dump异常快照"><a class="header" href="#dump异常快照"><strong>Dump异常快照</strong></a></h2>
<pre><code>-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath

-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./
</code></pre>
<h2 id="发送oom后执行一个脚本"><a class="header" href="#发送oom后执行一个脚本"><strong>发送OOM后，执行一个脚本</strong></a></h2>
<pre><code>-XX:OnOutOfMemoryError
-XX:OnOutOfMemoryError=&quot;C:\Program Files\Java\jdk1.8.0_152\bin\jconsole.exe&quot;

利用这个参数，我们可以在系统OOM后，自定义一个脚本，可以用来发送邮件告警信息，可以用来重启系统等等。
</code></pre>
<h2 id="打印gc信息"><a class="header" href="#打印gc信息"><strong>打印gc信息</strong></a></h2>
<h3 id="打印gc简单信息"><a class="header" href="#打印gc简单信息"><strong>打印GC简单信息</strong></a></h3>
<pre><code>-verbose:gc
-XX:+PrintGC
</code></pre>
<p>一个是标准参数，一个是-XX参数，都是打印详细的gc信息。通常会打印如下信息：</p>
<pre><code>[Full GC (Ergonomics)  12907K-&gt;11228K(19968K), 0.0541310 secs]

比如第一行，表示GC回收之前有12195K的内存，回收之后剩余1088K，总共内存为125951K
</code></pre>
<h3 id="打印详细gc信息"><a class="header" href="#打印详细gc信息"><strong>打印详细GC信息</strong></a></h3>
<pre><code>-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
</code></pre>
<h2 id="指定gc日志以文件输出"><a class="header" href="#指定gc日志以文件输出"><strong>指定GC日志以文件输出</strong></a></h2>
<pre><code>-Xloggc:./gc.log

　　这个在参数用于将gc日志以文件的形式输出，更方便我们去查看日志，定位问题。
</code></pre>
<h2 id="垃圾收集器常用参数"><a class="header" href="#垃圾收集器常用参数"><strong>垃圾收集器常用参数</strong></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jvm-垃圾回收算法复制算法"><a class="header" href="#jvm-垃圾回收算法复制算法">JVM 垃圾回收算法——复制算法</a></h1>
<h2 id="复制算法-1"><a class="header" href="#复制算法-1">复制算法</a></h2>
<p>在复制算法中，回收器将堆空间划分为两个大小相等的半区 (semispace)，分别是 来源空间(fromspace) 和 目标空间(tospace) 。在进行垃圾回收时，回收器将存活对象从来源空间复制到目标空间，复制结束后，所有存活对象紧密排布在目标空间一端，最后将来源空间和目标空间互换。</p>
<h3 id="复制前"><a class="header" href="#复制前"><strong>复制前</strong></a></h3>
<p><img src="7.jvm_jvm%E5%9F%BA%E7%A1%80/../../images/jvm_gc_algorithm_copy.png" alt="20201024093037" /></p>
<h3 id="复制后"><a class="header" href="#复制后"><strong>复制后</strong></a></h3>
<p><img src="7.jvm_jvm%E5%9F%BA%E7%A1%80/../../images/jvm_gc_algorithm_copy_after.png" alt="20201024093052" /></p>
<h3 id="代码段"><a class="header" href="#代码段"><strong>代码段</strong></a></h3>
<pre><code>collect() {
// 变量前面加*表示指针
// free指向TOSPACE半区的起始位置
*free = *to_start;
for(root in Roots) {
copy(*free, root);
}
// 交换FROMSPACE和TOSPACE
swap(*from_start,*to_start);
}
</code></pre>
<p>核心函数 copy 的实现如下所示：</p>
<pre><code>copy(*free,obj) {
// 检查obj是否已经复制完成
// 这里的tag仅是一个逻辑上的域
if(obj.tag != COPIED) {
// 将obj真正的复制到free指向的空间
copy_data(*free,obj);
// 给obj.tag贴上COPIED这个标签
// 即使有多个指向obj的指针，obj也不会被复制多次
obj.tag = COPIED;
// 复制完成后把对象的新地址存放在老对象的forwarding域中
obj.forwarding = *free;
// 按照obj的长度将free指针向前移动
*free += obj.size;

// 递归调用copy函数复制其关联的子对象
for(child ingetRefNode(obj.forwarding)){
*child = copy(*free,child);
}
}
returnobj.forwarding;
}
</code></pre>
<h3 id="两个注意点"><a class="header" href="#两个注意点"><strong>两个注意点</strong></a></h3>
<ul>
<li>
<p>tag=COPIED</p>
<p>标记该对象已经被复制完成</p>
</li>
<li>
<p>forwarding</p>
<p>标记该对象所复制后的地址</p>
</li>
</ul>
<h2 id="算法评价-3"><a class="header" href="#算法评价-3"><strong>算法评价 3</strong></a></h2>
<p><strong>优点</strong></p>
<ul>
<li>吞吐量高：整个 GC 算法只搜索并复制存活对象，尤其是堆越大，差距越明显，毕竟它消耗的时间只是与活动对象数量成正比。</li>
<li>内存连续,无碎片</li>
<li>与缓存兼容：可以回顾一下前面说的局部性原理，由于所有存活对象都紧密的排布在内存里，非常有利于 CPU 的高速缓存。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>堆空间利用率低</li>
<li>递归调用函数：复制某个对象时要递归复制它引用的对象，相较于迭代算法，递归的效率更低，而且有栈空间溢出的风险</li>
</ul>
<h2 id="cheney-复制算法"><a class="header" href="#cheney-复制算法"><strong>Cheney 复制算法</strong></a></h2>
<blockquote>
<p>Cheney 算法是用来解决如何遍历引用关系图并将存活对象移动到 TOSPACE 的算法，它使用迭代算法来代替递归</p>
</blockquote>
<h3 id="注意点"><a class="header" href="#注意点">注意点</a></h3>
<p><strong>双指针</strong></p>
<ul>
<li>
<p>scan 指针扫描对象的所有 第一层级引用, scan 前面的表示 已经被扫描过引用了, 后面的是已经被复制 还未 扫描过引用</p>
</li>
<li>
<p>free 指针 指向链条尾端, 前面的表示已经复制完毕了</p>
</li>
</ul>
<h3 id="代码段-1"><a class="header" href="#代码段-1">代码段</a></h3>
<p>代码实现只需要在之前的代码上稍做修改，即可：</p>
<pre><code>collect() {
// free指向TOSPACE半区的起始位置
*scan = *free = *to_start;
// 复制根节点直接引用的对象
for(root in Roots) {
copy(*free, root);
}
// scan开始向前移动
// 首先获取scan位置处对象所引用的对象
// 所有引用对象复制完成后，向前移动scan
while(*scan != *free) {
for(child ingetRefObject(scan)){
copy(*free, child);
}
*scan += scan.size;
}
swap(*from_start,*to_start);
}
</code></pre>
<p>而 copy 函数也不再包含递归调用，仅仅是完成复制功能：</p>
<pre><code>copy(*free,obj) {
if(!is_pointer_to_heap(obj.forwarding,*to_start)) {
// 将obj真正的复制到free指向的空间
copy_data(*free,obj);
// 复制完成后把对象的新地址存放在老对象的forwarding域中
obj.forwarding = *free;
// 按照obj的长度将free指针向前移动
*free += obj.size;
}
returnobj.forwarding;
}
</code></pre>
<p>通过代码可以看出，Cheney 算法采用的是广度优先算法</p>
<p>广度优先搜索算法是需要一个先进先出的队列来辅助的，但这儿并没有队列。实际上 scan 和 free 之间的堆变成了一个队列，scan 左边是已经搜索完的对象，右边是待搜索对象。free 向前移动，队列就会追加对象，scan 向前移动，都会有对象被取出并进行搜索</p>
<h3 id="算法评价"><a class="header" href="#算法评价">算法评价</a></h3>
<ul>
<li>避免了栈的消耗和可能的栈溢出风险</li>
<li>相互引用的对象并不是相邻的，就没办法充分利用缓存</li>
</ul>
<p><a href="https://www.toutiao.com/i6885208625674093059/">参考</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javaunsafe类与cas操作"><a class="header" href="#javaunsafe类与cas操作">JavaUnsafe类与CAS操作</a></h1>
<h2 id="前言-2"><a class="header" href="#前言-2">前言</a></h2>
<p>最近看java源码发现有多处地方都使用到了Unsafe类,于是在网上查阅资料教程.以下是个人总结</p>
<h2 id="unsafe简介"><a class="header" href="#unsafe简介">Unsafe简介</a></h2>
<p>Unsafe两大功能:</p>
<ol>
<li>直接通过内存地址 修改对象,获取对象引用</li>
<li>使用硬件指令 实现 原子操作 (CAS compare and swap)</li>
</ol>
<p>Unsafe的使用:</p>
<ol>
<li>
<p>Unsafe是典型的单例模式,通过  <code>public static Unsafe getUnsafe()</code>获取实例</p>
</li>
<li>
<p>且 该方法被 <code>@CallerSensitive</code>所注解, 表明只能由系统类加载器加载的类所调用</p>
</li>
<li>
<p>为了在测试代码中使用Unsafe,可以通过反射获取该类的静态字段的实例</p>
<pre><code class="language-java">Field f= Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
f.setAccessible(true);
Unsafe u = (Unsafe) f.get(null);
</code></pre>
</li>
</ol>
<h2 id="unsafe-api"><a class="header" href="#unsafe-api">Unsafe API</a></h2>
<h3 id="获取偏移"><a class="header" href="#获取偏移">获取偏移</a></h3>
<ol>
<li>
<p>获取成员变量在 对象中的偏移</p>
<p><code>public native long objectFieldOffset(Field f);</code></p>
</li>
<li>
<p>获取静态成员所在 的类,返回<code>Class</code>对象</p>
<p><code>public native Object staticFieldBase(Field f);</code></p>
</li>
<li>
<p>获取静态成员在 类中的偏移</p>
<p><code>public native long staticFieldOffset(Field f);</code></p>
</li>
<li>
<p>获取数组首个元素 在数组对象中的偏移</p>
<p><code>public native int arrayBaseOffset(Class arrayClass);</code></p>
</li>
<li>
<p>获取每个数组元素所占空间</p>
<p><code>public native int arrayIndexScale(Class arrayClass);</code></p>
</li>
</ol>
<h3 id="根据-对象偏移--获取或设置-对象中字段的引用或值"><a class="header" href="#根据-对象偏移--获取或设置-对象中字段的引用或值">根据 对象+偏移  获取或设置 对象中字段的引用或值</a></h3>
<ol>
<li>
<p>获取 对象var1内部中偏移为var2的 XXX类型字段的 值或引用</p>
<pre><code class="language-java">public native byte getXxxx(Object var1, long var2);
例如
   public native byte getByte(Object var1, long var2);
   public native int getInt(Object var1, long var2);
   public native double getDouble(long var1);
   public native boolean getBoolean(Object var1, long var2);
   public native Object getObject(Object var1, long var2);
......
</code></pre>
</li>
<li>
<p>设置对象var1内部中偏移为var2的 XXX类型字段的值 为var4</p>
<pre><code class="language-java"> public native void putBoolean(Object var1, long var2, boolean var4);
 public native void putByte(Object var1, long var2, byte var4);
 public native void putInt(Object var1, long var2, int var4);
 public native void putObject(Object var1, long var2, Object var4);
......
</code></pre>
</li>
<li>
<p>带<code>volatile</code>语义的<code>get,put</code>:表示多线程之间的变量可见,一个线程修改一个变量之后,另一个线程立刻能看到</p>
<pre><code class="language-JAVA">public native void putBooleanVolatile(Object var1, long var2, boolean var4);
public native int getIntVolatile(Object var1, long var2);
public native long getLongVolatile(Object var1, long var2);
......
</code></pre>
</li>
</ol>
<h3 id="本地内存操作"><a class="header" href="#本地内存操作">本地内存操作</a></h3>
<ol>
<li>
<p>分配指定大小的一块本地内存 (同C语言中的 malloc)</p>
<p><code>public native long allocateMemory(long bytes);</code></p>
</li>
<li>
<p>重新分配内存(同C语言中的 realloc)</p>
<p><code>public native long reallocateMemory(long address, long bytes);</code></p>
</li>
<li>
<p>将给定的内存块  的所有字节 <code>bytes</code> 设置成固定的值 <code>value</code> (通过 <code>object + offset</code> 确定内存的基址)(同C语言中的 memset)</p>
<p><code>public native void setMemory(Object o, long offset, long bytes, byte value);</code></p>
</li>
<li>
<p>复制内存块,<code>内存块 srcBasc+srcOffset + bytes - &gt; destBase+destOffset + bytes</code>  (同C语言中的 memcpy)</p>
<p><code>public native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset,long bytes);</code></p>
</li>
<li>
<p>释放通过Allocate分配的本地内存(同C语言中的 free)</p>
<p><code> public native void freeMemory(long address);</code></p>
</li>
<li>
<p>获取和设置本地内存中的值,va1表示本地内存绝对地址,var3表示要设置的值</p>
<pre><code class="language-java">public native short getShort(long var1);
public native int getInt(long var1);
public native void putShort(long var1, short var3);
public native void putInt(long var1, int var3);
</code></pre>
</li>
</ol>
<h3 id="cas操作"><a class="header" href="#cas操作">CAS操作</a></h3>
<p><code>java.util.concurrent 包中无锁化的实现就是调用了CAS以下原子操作</code></p>
<ol start="0">
<li>
<p>CAS语义</p>
<ol>
<li>将 由var1+var2确定的地址的值  从var4 修改成 var5 </li>
<li>如果旧值不为 var4,则直接退出</li>
<li>多个线程修改同一个变量时, 只会有一个线程修改成功,其他线程不会被挂起,而是告知失败</li>
<li>这是一种 乐观锁的语义, 每个线程都假设自己的操作能成功,与之相对应的synchronized的悲观锁语义,每次修改操作必须 只能有一个线程独占资源</li>
</ol>
</li>
<li>
<p>设置 通过 var1+var2确定的内存基址的int类型变量,将值原子的从 var4 变成 var5,成功true,失败false</p>
<pre><code class="language-java">替换int值:public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
替换引用:public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);
</code></pre>
</li>
<li>
<p>基于上面操作的包装方法: 得到对象 中某个int字段的值 通过(var1+var2), 并给该值加上 var4,返回相加前的值</p>
<pre><code class="language-Java">典型实现
public final int getAndAddInt(Object var1, long var2, int var4) {
        int var5;
        do {
            var5 = this.getIntVolatile(var1, var2);
        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
        return var5;
    }
</code></pre>
</li>
</ol>
<h3 id="packunpack"><a class="header" href="#packunpack">Pack/Unpack</a></h3>
<ol>
<li>
<p>阻塞和释放任一线程对象</p>
</li>
<li>
<p>内部实现通过 信号量的方式,信号量值为1,pack 消耗值, unpack增加值</p>
</li>
<li>
<p>在 <code>LockSupport </code>类包装使用</p>
</li>
</ol>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code>//测试对象
public class UnsafeEntity {
    private  int a;
    private  int c;
    private  int d;
    private  static  int b = 1;
    getter......
    setter......
}
</code></pre>
<pre><code class="language-java">//测试代码
package com.weisanju;
import sun.misc.Unsafe;
import java.lang.reflect.Field;

public class UnsafeTest {
    public static void main(String[] args) throws Exception {
        Field f= Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
        f.setAccessible(true);
        Unsafe u = (Unsafe) f.get(null);
        //获取成员变量 的偏移
        long a = u.objectFieldOffset(UnsafeEntity.class.getDeclaredField(&quot;a&quot;));
        long c = u.objectFieldOffset(UnsafeEntity.class.getDeclaredField(&quot;c&quot;));
        long d = u.objectFieldOffset(UnsafeEntity.class.getDeclaredField(&quot;d&quot;));
        System.out.println(&quot;成员字段a:&quot;+a);
        System.out.println(&quot;成员字段c:&quot;+c);
        System.out.println(&quot;成员字段d:&quot;+d);

        //设置对象字段的值
        UnsafeEntity testa = new UnsafeEntity();
        testa.setA(666);
        System.out.println(&quot;设置前:&quot;+u.getInt(testa, a));
        u.putInt(testa,a,777);
        System.out.println(&quot;设置后:&quot;+u.getInt(testa, a));

        //获取静态字段所在的类的对象
        System.out.println(u.staticFieldBase(UnsafeEntity.class.getDeclaredField(&quot;b&quot;)));
        //获取静态字段的偏移
        long b = u.staticFieldOffset(UnsafeEntity.class.getDeclaredField(&quot;b&quot;));
        System.out.println(&quot;静态字段b:&quot;+b);

        //静态字段的设置, 注意由于静态字段,存储于方法区,所以起始对象为类的字节码
        System.out.println(&quot;设置前:&quot;+u.getInt(UnsafeEntity.class, b));
        u.putInt(UnsafeEntity.class,b,11);
        System.out.println(&quot;设置后:&quot;+u.getInt(UnsafeEntity.class, b));


        //普通 数组的使用
        int arr[] = {1,2,3,4,5,6,7,8};
        //head为头地址偏移
        long head = u.arrayBaseOffset(int[].class);
        //step为数组元素所占空间
        long step = u.arrayIndexScale(int[].class);
        // 获取 与设置 arr[7] 的值
        int index = 7;
        System.out.println(u.getInt(arr, head + step * index));
        u.putInt(arr,head+step*index,666);
        System.out.println(arr[index]);

        //对象数组的使用
        UnsafeEntity arrObj[] = new UnsafeEntity[10];
        //head为头地址偏移
        head = u.arrayBaseOffset(UnsafeEntity[].class);
        //step为数组元素所占空间
        step = u.arrayIndexScale(UnsafeEntity[].class);
        // 获取 与设置 arr[7] 的值
        index = 7;
        arrObj[index] = new UnsafeEntity();
        System.out.println(u.getObject(arrObj, head + step * index));
        u.putObject(arrObj,head+step*index,new UnsafeEntity());
        System.out.println(arrObj[index]);
    }
}
</code></pre>
<pre><code>输出结果
成员字段a:12
成员字段c:16
成员字段d:20
设置前:666
设置后:777
class com.weisanju.UnsafeEntity
静态字段b:104
设置前:1
设置后:11
8
666
com.weisanju.UnsafeEntity@1540e19d
com.weisanju.UnsafeEntity@677327b6
</code></pre>
<h2 id="总结-9"><a class="header" href="#总结-9">总结</a></h2>
<ol>
<li>Unsafe为从cpu底层指令 层面 为多线程提供了无锁化设计,以及直接操作内存地址的能力,Java中 Atomic原子类,netty,concurrent包等底层都封装了 该对象</li>
<li>当然 极大的效率,也必然意外着 极大的不安全, 如果错误给一块内存区赋值,程序不会有任何反应,这就给程序带来极大的安全隐患</li>
<li>当然了解Unsafe类 能够便于我们更好的阅读 Java底层源码</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存泄漏memory-leak-"><a class="header" href="#内存泄漏memory-leak-">内存泄漏（memory leak ）</a></h1>
<p><strong>占着茅坑不拉 shi</strong>
<img src="7.jvm_jvm%E5%9F%BA%E7%A1%80/../../images/memory_leak_object_life.png" alt="20201018102506" /></p>
<pre><code>如上图，对象X引用对象Y，X的生命周期为60，Y的生命周期为20，当Y生命周期结束的时候，X依然引用着B，这时候，垃圾回收期是不会回收对象Y的；如果对象X还引用着生命周期比较短的A、B、C...对象A又引用着对象a、b、c...

那么就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。
</code></pre>
<h2 id="内存泄漏的分类"><a class="header" href="#内存泄漏的分类">内存泄漏的分类</a></h2>
<ul>
<li>经常（不断）发生：发生内存泄露的代码会被多次执行，每次执行，泄露一块内存；</li>
<li>偶然发生：在某些特定情况下才会发生；</li>
<li>一次性：发生内存泄露的方法只会执行一次；</li>
<li>隐式泄露：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄露，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</li>
</ul>
<h2 id="内存泄露产生的可能原因"><a class="header" href="#内存泄露产生的可能原因">内存泄露产生的可能原因</a></h2>
<ul>
<li>循环过多或死循环，产生大量对象；</li>
<li>静态集合类引起内存泄漏，因为静态集合的生命周期和应用一致，所以静态集合引用的对象不能被释放；</li>
<li>单例模式，和静态集合导致内存泄露的原因类似；</li>
<li>事件监听（listeners）和回调（callbacks）；</li>
<li>各种连接，比如数据库连接、Socket 连接、IO 等，必须显式释放（close）；</li>
<li>内存中加载数据量过大；我之前项目有一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存（内存）中，测试环境只有几百条数据，但是生产环境有几百万的数据。</li>
</ul>
<h1 id="内存溢出outofmemory"><a class="header" href="#内存溢出outofmemory">内存溢出（OutofMemory）</a></h1>
<p>JVM中常见的两个<strong>经典错误</strong></p>
<p>StackoverFlowError ：栈溢出</p>
<p>OutofMemoryError: java heap space：堆溢出</p>
<p>除此之外，还有以下的错误</p>
<ul>
<li>java.lang.StackOverflowError 栈溢出</li>
<li>java.lang.OutOfMemoryError：java heap space  堆溢出</li>
<li>java.lang.OutOfMemoryError：GC overhead limit exceeeded </li>
<li>java.lang.OutOfMemoryError：Direct buffer memory</li>
<li>java.lang.OutOfMemoryError：unable to create new native thread</li>
<li>java.lang.OutOfMemoryError：Metaspace</li>
</ul>
<h2 id="栈溢出stackoverflowerror"><a class="header" href="#栈溢出stackoverflowerror">栈溢出StackoverFlowError</a></h2>
<p>堆栈溢出，我们有最简单的一个递归调用，就会造成堆栈溢出，也就是深度的方法调用</p>
<p>栈一般是512K，不断的深度调用，直到栈被撑破</p>
<h2 id="outofmemoryerror"><a class="header" href="#outofmemoryerror">OutOfMemoryError</a></h2>
<h2 id="java-heap-space"><a class="header" href="#java-heap-space">java heap space</a></h2>
<p>创建了很多对象，导致堆空间不够存储</p>
<pre><code>-Xms10m -Xmx20m
限定堆大小最大为20M,初始为10M
</code></pre>
<h2 id="gc-overhead-limit-exceeded"><a class="header" href="#gc-overhead-limit-exceeded">GC overhead limit exceeded</a></h2>
<p>GC回收时间过长时会抛出OutOfMemoryError，过长的定义是，<strong>超过了98%的时间用来做GC</strong>，<strong>并且回收了不到2%的堆内存</strong></p>
<p>连续多次GC都只回收了不到2%的极端情况下，才会抛出。假设不抛出GC overhead limit 错误会造成什么情况呢？</p>
<p>那就是GC清理的这点内存很快会再次被填满，迫使GC再次执行，这样就形成了恶性循环，CPU的使用率一直都是100%，而GC却没有任何成果。</p>
<h3 id="达到步骤"><a class="header" href="#达到步骤">达到步骤</a></h3>
<p><strong>设置JVM参数</strong></p>
<pre><code>-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m
</code></pre>
<p><strong>代码</strong></p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.List;

public class GCOverheadLimitDemo {
    public static void main(String[] args) {
        int i = 0;
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        try {
            while(true) {
                list.add(String.valueOf(++i).intern());
            }
        } catch (Exception e) {
            System.out.println(&quot;***************i:&quot; + i);
            e.printStackTrace();
            throw e;
        } finally {

        }

    }
}
</code></pre>
<p><strong>结果</strong></p>
<pre><code>&gt; Task :GCOverheadLimitDemo.main()
[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;506K(2560K)] 2048K-&gt;1690K(9728K), 0.0029415 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 2331K-&gt;481K(2560K)] 3515K-&gt;3313K(9728K), 0.0023773 secs] [Times: user=0.00 sys=0.00, 
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded
[Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;0K(2560K)] [ParOldGen: 7051K-&gt;524K(7168K)] 9099K-&gt;524K(9728K), [Metaspace: 2682K-&gt;2682K(1056768K)], 0.0061980 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
	at java.lang.Integer.toString(Integer.java:401)
	at java.lang.String.valueOf(String.java:3099)
	at GCOverheadLimitDemo.main(GCOverheadLimitDemo.java:10)
Heap
 PSYoungGen      total 2560K, used 54K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)
  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0d9b8,0x00000000fff00000)
  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)
  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)
 ParOldGen       total 7168K, used 524K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)
  object space 7168K, 7% used [0x00000000ff600000,0x00000000ff6833d0,0x00000000ffd00000)
 Metaspace       used 2689K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 290K, capacity 386K, committed 512K, reserved 1048576K

&gt; Task :GCOverheadLimitDemo.main() FAILED

Execution failed for task ':GCOverheadLimitDemo.main()'.
&gt; Process 'command 'C:/Program Files/Java/jdk1.8.0_141/bin/java.exe'' finished with non-zero exit value 1

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
</code></pre>
<h2 id="direct-buffer-memory"><a class="header" href="#direct-buffer-memory">Direct buffer memory</a></h2>
<p><strong>原因</strong></p>
<p>这是由于NIO引起的</p>
<p>写NIO程序的时候经常会使用ByteBuffer来读取或写入数据，这是一种基于通道(Channel) 与 缓冲区(Buffer)的I/O方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<p>ByteBuffer.allocate(capability)：第一种方式是分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度相对较慢</p>
<p>ByteBuffer.allocteDirect(capability)：第二种方式是分配OS本地内存，不属于GC管辖范围，由于不需要内存的拷贝，所以速度相对较快</p>
<p>但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那么程序就崩溃了。</p>
<p>一句话说：本地内存不足，但是堆内存充足的时候，就会出现这个问题</p>
<p><strong>配置参数</strong></p>
<p>我们使用 -XX:MaxDirectMemorySize=5m 配置能使用的堆外物理内存为5M</p>
<p><strong>代码</strong></p>
<pre><code class="language-java">import java.nio.ByteBuffer;

public class DirectBufferDemo {
    public static void main(String[] args) {
        ByteBuffer bb = ByteBuffer.allocateDirect(6 * 1024 * 1024);

    }
}
</code></pre>
<p><strong>日志</strong></p>
<pre><code>&gt; Task :DirectBufferDemo.main() FAILED
[GC (System.gc()) [PSYoungGen: 787K-&gt;504K(2560K)] 787K-&gt;648K(9728K), 0.0009607 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 504K-&gt;0K(2560K)] [ParOldGen: 144K-&gt;533K(7168K)] 648K-&gt;533K(9728K), [Metaspace: 2649K-&gt;2649K(1056768K)], 0.0056731 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory
	at java.nio.Bits.reserveMemory(Bits.java:694)
	at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)
	at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)
	at DirectBufferDemo.main(DirectBufferDemo.java:5)
Heap
 PSYoungGen      total 2560K, used 61K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)
  eden space 2048K, 3% used [0x00000000ffd00000,0x00000000ffd0f750,0x00000000fff00000)
  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)
  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)
 ParOldGen       total 7168K, used 533K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)
  object space 7168K, 7% used [0x00000000ff600000,0x00000000ff685708,0x00000000ffd00000)
 Metaspace       used 2682K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 290K, capacity 386K, committed 512K, reserved 1048576K

Execution failed for task ':DirectBufferDemo.main()'.
&gt; Process 'command 'C:/Program Files/Java/jdk1.8.0_141/bin/java.exe'' finished with non-zero exit value 1

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.
</code></pre>
<h2 id="unable-to-create-new-native-thread"><a class="header" href="#unable-to-create-new-native-thread">unable to create new native thread</a></h2>
<p>不能够创建更多的新的线程了，也就是说创建线程的上限达到了</p>
<ul>
<li>应用创建了太多线程，一个应用进程创建多个线程，超过系统承载极限</li>
<li>服务器并不允许你的应用程序创建这么多线程，linux系统默认运行单个进程可以创建的线程为1024个，如果应用创建超过这个数量，就会报 java.lang.OutOfMemoryError:unable to create new native thread</li>
</ul>
<h2 id="metaspace"><a class="header" href="#metaspace">Metaspace</a></h2>
<p>元空间内存不足，Matespace元空间应用的是本地内存</p>
<p>-XX:MetaspaceSize 的处理器大小为20M</p>
<p>元空间就是我们的方法区，存放的是类模板，类信息，常量池等</p>
<p>Metaspace是方法区HotSpot中的实现，它与持久代最大的区别在于：Metaspace并不在虚拟内存中，而是使用本地内存，也即在java8中，class metadata（the virtual machines internal presentation of Java class），被存储在叫做Matespace的native memory</p>
<p>永久代（java8后背元空间Metaspace取代了）存放了以下信息：</p>
<ul>
<li>虚拟机加载的类信息</li>
<li>常量池</li>
<li>静态变量</li>
<li>即时编译后的代码</li>
</ul>
<p>模拟Metaspace空间溢出，我们不断生成类 往元空间里灌输，类占据的空间总会超过Metaspace指定的空间大小</p>
<p><strong>指定元空间大小</strong></p>
<pre><code>-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m
</code></pre>
<p><strong>spring动态字节码技术</strong></p>
<pre><code class="language-java">public class MetaspaceOutOfMemoryDemo {

    // 静态类
    static class OOMTest {

    }

    public static void main(final String[] args) {
        // 模拟计数多少次以后发生异常
        int i =0;
        try {
            while (true) {
                i++;
                // 使用Spring的动态字节码技术
                Enhancer enhancer = new Enhancer();
                enhancer.setSuperclass(OOMTest.class);
                enhancer.setUseCache(false);
                enhancer.setCallback(new MethodInterceptor() {
                    @Override
                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                        return methodProxy.invokeSuper(o, args);
                    }
                });
                enhancer.create();
            }
        } catch (Exception e) {
            System.out.println(&quot;发生异常的次数:&quot; + i);
            e.printStackTrace();
        } finally {

        }

    }
}
</code></pre>
<pre><code>&gt; Task :MetaspaceOutOfMemoryDemo.main() FAILED
1
2
3
4
......
311
312
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace
	at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:348)
	at net.sf.cglib.proxy.Enhancer.generate(Enhancer.java:492)
	at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:117)
	at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:294)
	at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:480)
	at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:305)
	at MetaspaceOutOfMemoryDemo.main(MetaspaceOutOfMemoryDemo.java:27)

Execution failed for task ':MetaspaceOutOfMemoryDemo.main()'.
&gt; Process 'command 'C:/Program Files/Java/jdk1.8.0_141/bin/java.exe'' finished with non-zero exit value 1

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="https://www.toutiao.com/i6872618702160953863/">参考链接</a></p>
<h1 id="java-对象内存模型"><a class="header" href="#java-对象内存模型">Java 对象内存模型</a></h1>
<p><img src="7.jvm_jvm%E5%9F%BA%E7%A1%80/../../images/java_object_model.png" alt="20201017102417" /></p>
<h1 id="object-objnew-object占用字节"><a class="header" href="#object-objnew-object占用字节">Object obj=new Object()占用字节</a></h1>
<ul>
<li>未开启指针压缩
占用大小为：<strong>8(Mark Word)+8(Class Pointer)=16 字节</strong></li>
<li>开启了指针压缩(默认是开启的)
开启指针压缩后，Class Pointer 会被压缩为 4 字节，最终大小为：<strong>8(Mark Word)+4(Class Pointer)+4(对齐填充)=16 字节</strong></li>
</ul>
<ul>
<li>
<p>打印 对象内存分布</p>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;
            &lt;artifactId&gt;jol-core&lt;/artifactId&gt;
            &lt;version&gt;0.10&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">package com.zwx.jvm;

import org.openjdk.jol.info.ClassLayout;

public class HeapMemory {
    public static void main(String[] args) {
        Object obj = new Object();
        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
    }
}
</code></pre>
</li>
</ul>
<h1 id="对象的创建"><a class="header" href="#对象的创建">对象的创建</a></h1>
<p><img src="https://i.loli.net/2020/10/25/obOk5IeSyVqmLtZ.png" alt="new对象的过程" /></p>
<p><strong>类加载检查</strong></p>
<p>当虚拟机遇到一条 new 指令时</p>
<ul>
<li>会去检查这个指令的参数能否在常量池中定位到一个类的符号引用</li>
<li>并检查代表的类是否已经被类加载器加载。如果没有被加载那么必须先执行这个类的加载。</li>
</ul>
<p><strong>内存分配</strong></p>
<ul>
<li>虚拟机将为新对象分配内存，对象所需内存的大小在类加载后便可以确定。</li>
<li>分配方式
<ul>
<li>Java 堆内存是规整的(使用标记整理或带压缩的垃圾收集器)，使用一个指针指向空闲位置，分配内存既将指针移动与分配大小相等的距离</li>
<li>内存不是规整的(使用标记清除的垃圾收集器)，虚拟机维护一个可用内存块列表，分配内存时从列表中找到一个足够大的内存空间划分给对象并更新可用内存列表。</li>
<li>无法找到足够的内存时会触发一次 GC</li>
<li>分配内存时并发问题解决方案：
<ul>
<li>对分配内存空间的动作进行同步操作---采用 CAS 失败重试的方式保证更新操作的原子性。</li>
<li>每个线程在堆中预先分配一块小内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)，哪个线程要分配内存就在它的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时才需要同步锁定。通过-XX:+/-UseTLAB 参数来设定。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>初始化</strong></p>
<p>虚拟机需要将对象初始化为零值，保证对象的<em>实例变量</em>在代码中不赋初始值就能直接使用。类变量在类加载的准备阶段初始化为零值。</p>
<p><strong>设置对象头</strong></p>
<p>对对象头进行必要信息的设置，比如如何找到类的元数据信息、对象的 HashCode、GC 分代年龄等。</p>
<p><strong>执行 init 方法</strong></p>
<p>这时候需要执行<code>&lt;init&gt;</code>方法(构造方法)把对象按照程序员的意愿进行初始化。类变量的初始化操作在类加载的初始化阶段<clinit>方法完成</p>
<h1 id="创建对象指令重排序问题"><a class="header" href="#创建对象指令重排序问题"><strong>创建对象指令重排序问题</strong></a></h1>
<p>new 一个对象的简单分解动作：</p>
<ol>
<li>分配对象的内存空间</li>
<li>初始化对象</li>
<li>设置引用指向分配的内存地址</li>
</ol>
<p>其中 2、3 两步间会发生指令重排序，导致多线程时如果在初始化之前访问对象则会出现问题，单例模式的双重检测锁模式正是会存在这个问题。可以使用 volatile 来禁止指令重排序解决问题</p>
<h1 id="对象的访问"><a class="header" href="#对象的访问">对象的访问</a></h1>
<h2 id="句柄访问"><a class="header" href="#句柄访问">句柄访问</a></h2>
<blockquote>
<p>Java 虚拟机会在堆内划分出一块内存来存储句柄池，那么对象当中存储的就是句柄地址，然后句柄池中才会存储对象实例数据和对象类型数据地址</p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/17/XvVwGWT8yIqJk1Q.png" alt="20201017144112" /></p>
<h2 id="直接指针访问"><a class="header" href="#直接指针访问">直接指针访问</a></h2>
<blockquote>
<p>直接指针访问的话对象中就会直接存储对象类型数据。</p>
</blockquote>
<h2 id="句柄访问和直接指针访问区别"><a class="header" href="#句柄访问和直接指针访问区别">句柄访问和直接指针访问区别</a></h2>
<blockquote>
<p>使用句柄访问的时候，会多了一次指针定位,有一个好处就是，假如一个对象被移动(地址改变了),只需要改变句柄池的指向就可以了，不需要修改 reference 对象内的指向,而如果使用直接指针访问，就还需要到局部变量表内修改 reference 指向。</p>
</blockquote>
<h1 id="javagc"><a class="header" href="#javagc">javaGC</a></h1>
<p><strong>对象分代年龄</strong></p>
<ul>
<li>在 Java 对象头当中的 Mark Word 存储了对象的分代年龄, 一个对象的分代年龄可以理解为垃圾回收次数,当一个对象经过一次垃圾回收之后还存在,那么分代年龄就会加 1</li>
<li>Java 堆内存中按照分代年龄来划分，分为 Young 区和 Old 区，对象分配首先会到 Young 区，达到一定分代年龄(-XX:MaxTenuringThreshold 可以设置大小，默认为 15)就会进入 Old 区(<strong>注意：如果一个对象太大，那么就会直接进入 Old 区</strong>)。</li>
</ul>
<p><strong>为什么 jvm 要划分 GC 分区</strong></p>
<ul>
<li>之所以会这么划分是因为如果整个堆只有一个区的话，那么垃圾回收的时候每次都需要把堆内所有对象都扫描一遍，浪费性能</li>
<li>而其实大部分 Java 对象的生命周期都是很短的，一旦一个对象回收很多次都回收不掉，可以认为下一次垃圾回收的时候可能也回收不掉</li>
<li>只有当 Young 区在进行垃圾回收之后还是没有腾出空间，那么再去触发 Old 区的垃圾回收。</li>
</ul>
<p><strong>不连续导致的内存不连续?</strong></p>
<blockquote>
<p>堆上分配的对象,在内存中是不连续的,有时候,明明有空间,是因为空间不连续，导致对象申请内存失败，导致触发 GC 了</p>
</blockquote>
<p>解决的思路: <strong>就是把 Young 区的对象按顺序放好</strong></p>
<p>所以就产生了一个方法，把 Young 区再次划分一下，分为 2 个区：<strong>Eden 区</strong>和<strong>Survivor 区</strong>。</p>
<p><img src="https://i.loli.net/2020/10/17/7lqx5QuJaIN9get.png" alt="20201017150936" /></p>
<p><strong>工作流程</strong></p>
<p>一个对象来了之后，先分配到 Eden 区，Eden 区满了之后，触发 GC，经过 GC 之后，为了防止空间不连续，把幸存下来的对象复制到 Survivor 区，然后 Eden 区就可以完整清理掉了</p>
<p>前提是:<strong>大部分对象都是生命周期极短的，基本一次垃圾回收就可以把 Eden 区大部分对象回收掉</strong></p>
<p><strong>Survivor 区还是不连续?</strong></p>
<blockquote>
<p>触发 GC 的时候 Survivor 区也会一起回收,Survivor 区又可能产生空间碎片,导致不连续了</p>
</blockquote>
<p>解决办法: <strong>把 Survivor 区给一分为二</strong>
<img src="https://i.loli.net/2020/10/17/slzoXrJwB7T9bdI.png" alt="20201017151846" /></p>
<p><strong>工作流程</strong></p>
<p>首先还是在 Eden 区分配空间，Eden 区满了之后触发 GC，GC 之后把幸存对象 复制到 S0 区(S1 区是空的)，然后继续在 Eden 区分配对象，再次触发 GC 之后如果发现 S0 区放不下了(产生空间碎片，实际还有空间)，那么就把 S0 区对象复制到 S1 区，并把幸存对象也复制到 S1 区，这时候 S0 区是空的了，并依次反复操作，假如说 S0 区或者 S1 区空间对象复制移动了之后还是放不下，那就说明这时候是真的满了，那就去老年区借点空间过来（这就是<strong>担保机制</strong>，老年代需要提供这种空间分配担保），假如说老年区空间也不够了，那就会触发 Full GC，如果还是不够，那就会抛出 OutOfMemeoyError 异常了。</p>
<p>注意：为了确保 S0 和 S1 两个区域之间每次复制都能顺利进行，S0 和 S1 两个区的大小必须要保持一致，而且同一时间有一个区域一定是空的。虽然说这种做法是会导致了一小部分空间的浪费，但是综合其他性能的提升来说，是值得的。</p>
<p>当 Young 区的对象达到设置的分代年龄之后，对象会进入 Old 区，Old 区满了之后会触发 Full GC，如果还是清理不掉空间，那么就抛出 OutOfMemeoyError 异常。</p>
<h1 id="关于-javagc-的名词"><a class="header" href="#关于-javagc-的名词">关于 JavaGC 的名词</a></h1>
<ul>
<li>垃圾回收：简称 GC。</li>
<li>Minor GC：针对新生代的 GC</li>
<li>Major GC：针对老年代的 GC，一般老年代触发 GC 的同时也会触发 Minor GC，也就等于触发了 Full GC。</li>
<li>Full GC：新生代+老年代同时发生 GC。</li>
<li>Young 区：新生代</li>
<li>Old 区：老年代</li>
<li>Eden 区：暂时没发现有什么中文翻译(伊甸园?)</li>
<li>Surcivor 区：幸存区</li>
<li>S0 和 S1：也称之为 from 区和 to 区，注意 from 和 to 两个区是不断互换身份的，且 S0 和 S1 一定要相等，并且保证一块区域是空的</li>
</ul>
<p><strong>内存分配流程图</strong>
<img src="https://i.loli.net/2020/10/17/l3RXCsg45mHULzq.png" alt="20201017152659" /></p>
<h1 id="jdk8-内存结构"><a class="header" href="#jdk8-内存结构">jdk8 内存结构</a></h1>
<p><strong>java 内存分布</strong></p>
<p><img src="https://i.loli.net/2020/10/18/Nu1AsYitoPRnGSW.png" alt="20201018091217" /></p>
<p><strong>元数据空间</strong></p>
<blockquote>
<p>在 jdk8 以后,方法区( 也就是永久代), 变为 元数据空间
<img src="https://i.loli.net/2020/10/18/UpEtouyYnRD4Kbi.png" alt="20201018091508" /></p>
</blockquote>
<p><strong>元数据空间与 永久代的区别</strong></p>
<p>元空间并不在虚拟机中，而是使用本地内存</p>
<p>元空间是方法区的在 HotSpot jvm 中的实现，方法区主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。</p>
<p><strong>常用配置参数</strong></p>
<p><strong>MetaspaceSize</strong></p>
<p>初始化的 Metaspace 大小，控制元空间发生 GC 的阈值。GC 后，动态增加或降低 MetaspaceSize。在默认情况下，这个值大小根据不同的平台在 12M 到 20M 浮动。使用 Java -XX:+PrintFlagsInitial 命令查看本机的初始化参数</p>
<p><strong>MaxMetaspaceSize</strong></p>
<p>限制 Metaspace 增长的上限，防止因为某些情况导致 Metaspace 无限的使用本地内存，影响到其他程序。在本机上该参数的默认值为 4294967295B（大约 4096MB）。</p>
<p><strong>MinMetaspaceFreeRatio</strong></p>
<p>当进行过 Metaspace GC 之后，会计算当前 Metaspace 的空闲空间比，如果空闲比小于这个参数（即实际非空闲占比过大，内存不够用），那么虚拟机将增长 Metaspace 的大小。默认值为 40，也就是 40%。设置该参数可以控制 Metaspace 的增长的速度，太小的值会导致 Metaspace 增长的缓慢，Metaspace 的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致 Metaspace 增长的过快，浪费内存。</p>
<p><strong>MaxMetasaceFreeRatio</strong></p>
<p>当进行过 Metaspace GC 之后， 会计算当前 Metaspace 的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放 Metaspace 的部分空间。默认值为 70，也就是 70%。</p>
<p><strong>MaxMetaspaceExpansion</strong></p>
<p>Metaspace 增长时的最大幅度。在本机上该参数的默认值为 5452592B（大约为 5MB）。</p>
<p><strong>MinMetaspaceExpansion</strong></p>
<p>Metaspace 增长时的最小幅度。在本机上该参数的默认值为 340784B（大约 330KB 为）。</p>
<blockquote>
<p><strong>可以配合 JVisualVM 来看</strong></p>
</blockquote>
<h1 id="java-对象头"><a class="header" href="#java-对象头">Java 对象头</a></h1>
<p><img src="https://i.loli.net/2020/10/22/1H6lcd5rZeWTNX7.png" alt="20201022224155" /></p>
<p><a href="https://www.toutiao.com/i6811393828289774094/">额外参考链接</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-引用类型"><a class="header" href="#java-引用类型">JAVA 引用类型</a></h1>
<blockquote>
<p>在 java 的引用体系中，存在着强引用，软引用，弱引用，虚引用，这 4 种引用类型。关于这四种引用类型，可以查看<a href="https://www.jianshu.com/p/1fc5d1cbb2d4">强引用、弱引用、软引用、虚引用</a></p>
</blockquote>
<table><thead><tr><th>引用类型</th><th>被垃圾回收时间</th><th>用途</th><th>生存时间</th></tr></thead><tbody>
<tr><td>强引用</td><td>从来不会</td><td>对象一般状态</td><td>JVM 停止运行时终止</td></tr>
<tr><td>软引用(SoftReference)</td><td>内存不足时</td><td>对象缓存</td><td>内存不足时被回收</td></tr>
<tr><td>弱引用(WeakReference)</td><td>垃圾回收时</td><td>对象缓存</td><td>GC 运行后后终止</td></tr>
<tr><td>虚引用(PhantomReference)</td><td>Unkonw</td><td>Unkonw</td><td>Unkonw</td></tr>
</tbody></table>
<h1 id="强引用"><a class="header" href="#强引用">强引用</a></h1>
<ul>
<li>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它</li>
</ul>
<h1 id="软引用"><a class="header" href="#软引用">软引用</a></h1>
<ul>
<li>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</li>
<li>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，<a href="https://link.jianshu.com/?t=http://lib.csdn.net/base/javase">Java</a>虚拟机就会把这个软引用加入到与之关联的引用队列中</li>
</ul>
<h1 id="弱引用"><a class="header" href="#弱引用">弱引用</a></h1>
<ul>
<li>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</li>
<li>如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象</li>
<li>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</li>
</ul>
<p><strong>为什么引入？</strong></p>
<blockquote>
<p>考虑下面的场景：现在有一个 Product 类代表一种产品，这个类被设计为不可扩展的，而此时我们想要为每个产品增加一个编号。一种解决方案是使用 HashMap&lt;Product, Integer&gt;。于是问题来了，如果我们已经不再需要一个 Product 对象存在于内存中（比如已经卖出了这件产品），假设指向它的引用为 productA，我们这时会给 productA 赋值为 null，然而这时 productA 过去指向的 Product 对象并不会被回收，因为它显然还被 HashMap 引用着。所以这种情况下，我们想要真正的回收一个 Product 对象，仅仅把它的强引用赋值为 null 是不够的，还要把相应的条目从 HashMap 中移除。显然“从 HashMap 中移除不再需要的条目”这个工作我们不想自己完成，我们希望告诉垃圾收集器：在只有 HashMap 中的 key 在引用着 Product 对象的情况下，就可以回收相应 Product 对象了。显然，根据前面弱引用的定义，使用弱引用能帮助我们达成这个目的。我们只需要用一个指向 Product 对象的弱引用对象来作为 HashMap 中的 key 就可以了。</p>
</blockquote>
<h1 id="虚引用"><a class="header" href="#虚引用">虚引用</a></h1>
<p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>
<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p>
<h1 id="引用图"><a class="header" href="#引用图">引用图</a></h1>
<p><img src="https://i.loli.net/2020/10/25/fpJ3rFgQKP5hosC.png" alt="20201025080109" /></p>
<h1 id="引用队列"><a class="header" href="#引用队列">引用队列</a></h1>
<blockquote>
<p>ReferenceQueue, 当对象被 GC 时, 通知用户线程</p>
</blockquote>
<ul>
<li>对于<code>软引用</code>和<code>弱引用</code>，我们希望当一个对象被 gc 掉的时候通知用户线程，进行额外的处理时，就需要使用引用队列了。ReferenceQueue 即这样的一个对象，当一个 obj 被 gc 掉之后，其相应的包装类，即 ref 对象会被放入 queue 中。我们可以从 queue 中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等。</li>
</ul>
<p><strong>在 weakHashMap 中引用队列的使用</strong></p>
<h2 id="继承-abstractmapmap-接口和-hashmap-一样都是散列表存储的是-key-value键和值都可以为-null"><a class="header" href="#继承-abstractmapmap-接口和-hashmap-一样都是散列表存储的是-key-value键和值都可以为-null">继承 AbstractMap、Map 接口。和 HashMap 一样都是散列表，存储的是 key-value,键和值都可以为 null。</a></h2>
<p><strong>清除代码</strong></p>
<blockquote>
<p>每次对map的操作都会从 ReferenceQueue 获取失效的key, 然后从map中删除。调用该方法</p>
</blockquote>
<pre><code class="language-java">for (Object x; (x = queue.poll()) != null; ) {
    synchronized (queue) {
        @SuppressWarnings(&quot;unchecked&quot;)
            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;
        int i = indexFor(e.hash, table.length);

        Entry&lt;K,V&gt; prev = table[i];
        Entry&lt;K,V&gt; p = prev;
        while (p != null) {
            Entry&lt;K,V&gt; next = p.next;
            if (p == e) {
                if (prev == e)
                    table[i] = next;
                else
                    prev.next = next;
                // Must not null out e.next;
                // stale entries may be in use by a HashIterator
                e.value = null; // Help GC
                size--;
                break;
            }
            prev = p;
            p = next;
        }
    }
}
</code></pre>
<p><strong>weakHashMap总结</strong></p>
<ul>
<li>
<p>WeakHashMap 使用(数据 + 链表 ） 存储结构。</p>
</li>
<li>
<p>WeakHashMap中的key 是弱引用，垃圾回收时会被回收。</p>
</li>
<li>
<p>使用场景： 作为缓存</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="总结-10"><a class="header" href="#总结-10">总结</a></h1>
<h2 id="如果要自定义类加载器可以放在classpath-中吗"><a class="header" href="#如果要自定义类加载器可以放在classpath-中吗">如果要自定义类加载器，可以放在<em>classpath</em> 中吗</a></h2>
<p>不能，默认情况下，Application ClassLoader 会加载 classpath下的  所有类，如果 需要自定义类加载器加载类 则需要将 该class文件放置到<strong>其他路径下</strong></p>
<h2 id="class与classloader的getresourceasstream区别"><a class="header" href="#class与classloader的getresourceasstream区别">Class与ClassLoader的getResourceAsStream区别</a></h2>
<p>不仅ClassLoader中有getResourceAsStream(String name)方法，Class下也有getResourceAsStream(String name)方法，它们两个方法的区别在于：</p>
<p>1、Class的getResourceAsStream(String name)方法，参数不以&quot;/&quot;开头则默认从此类对应的.class文件所在的packge下取资源，以&quot;/&quot;开头则从CLASSPATH下获取</p>
<p>2、ClassLoader的getResourceAsStream(String name)方法，默认就是从CLASSPATH下获取资源，参数不可以以&quot;/&quot;开头</p>
<h2 id="为什么要自定义类加载器"><a class="header" href="#为什么要自定义类加载器"><strong>为什么要自定义类加载器</strong></a></h2>
<p>主流的 Java Web 服务器，比如 Tomcat,都实现了自定义的类加载器（一般都不止一个）。因为一个功能健全的 Web 服务器，要解决如下几个问题：</p>
<ul>
<li>部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以实现相互隔离(不同应用使用不同版本的 同名 Java 类)</li>
<li>部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以相互共享</li>
<li>支持热部署</li>
</ul>
<h2 id="如何判定类是否相同"><a class="header" href="#如何判定类是否相同"><strong>如何判定类是否相同</strong></a></h2>
<ul>
<li>类的全名是否相同</li>
<li>还要看加载此类的类加载器是否一样(被不同的类加载器加载之后所得到的类，也是不同的)</li>
</ul>
<pre><code>两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException
</code></pre>
<h2 id="tomcat等web容器的类加载有何不同"><a class="header" href="#tomcat等web容器的类加载有何不同">tomcat等web容器的类加载有何不同</a></h2>
<ul>
<li>
<p>优先加载 web应用提供的类，而找不到时，才使用 容器提供的类</p>
</li>
<li>
<p>但时java核心类，交给 启动类加载器，或者扩展类加载器启动</p>
</li>
</ul>
<p>这样既保证 应用之间的 不通版本的类可以隔离，又保证相同版本的类可以共享</p>
<h2 id="为什么要使用-classforname加载-sql驱动类"><a class="header" href="#为什么要使用-classforname加载-sql驱动类">为什么要使用 <em>Class.forName</em>加载 sql驱动类</a></h2>
<ul>
<li>高版本的不需要手动加载了</li>
</ul>
<p><a href="https://www.toutiao.com/i6674120935265534467/">参考链接</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类加载器基本概念"><a class="header" href="#类加载器基本概念"><strong>类加载器基本概念</strong></a></h1>
<p>顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。</p>
<p>所有的类加载器都是 java.lang.ClassLoader 类的一个实例。</p>
<h1 id="javalangclassloader"><a class="header" href="#javalangclassloader"><strong>java.lang.ClassLoader</strong></a></h1>
<table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody>
<tr><td>getParent()</td><td>返回该类加载器的分类加载器</td></tr>
<tr><td>loadClass(String name)</td><td>加载类</td></tr>
<tr><td>findClass(String name)</td><td>查询 class</td></tr>
<tr><td>findLoadedClass(String name)</td><td>查询已经被加载过的类</td></tr>
<tr><td>defineClass(String name,byte[] b,int off,int len)</td><td>把 byte 字节数组转换成类</td></tr>
<tr><td>resolveClass(Class&lt;?&gt; c)</td><td>链接指定的 Java 类</td></tr>
</tbody></table>
<h1 id="类加载器的树状组织结构"><a class="header" href="#类加载器的树状组织结构">类加载器的树状组织结构</a></h1>
<ul>
<li>
<p>引导类加载器（bootstrap class loader）</p>
<ul>
<li>它用来加载 Java 的核心库，比如 Object、System、 String ,Java 运行时的 rt.jar 等 jar 包</li>
<li>是用 C++来实现的，并不继承自 java.lang.ClassLoader。</li>
</ul>
</li>
<li>
<p>扩展类加载器（extensions class loader）</p>
<ul>
<li>它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>负责加载&lt;JAVA_HOME&gt;\lib\ext 目录中的，或者 java.ext.dirs 系统变量指定的路径中的所有类库;</li>
</ul>
</li>
<li>
<p>Application ClassLoader</p>
<p>应用类加载器，主要是加载用户定义的 CLASSPATH 路径下的类</p>
</li>
</ul>
<p>它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</p>
<p><img src="7.jvm_jvm%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD/../../../images/classload_hierarchy.png" alt="20201018105054" /></p>
<h1 id="类加载器的代理模式"><a class="header" href="#类加载器的代理模式">类加载器的代理模式</a></h1>
<blockquote>
<p>类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类</p>
</blockquote>
<p><strong>代理模式是为了保证</strong> Java 核心库的类型安全</p>
<p>**注意：**类加载的双亲委派 是需要根据代码遵守，但是可以打破，但是 Java核心类跟 扩展类是没法自定义类加载器加载的</p>
<p><strong>代理流程</strong></p>
<ul>
<li>判断是否已加载</li>
<li>未加载则通过父类 加载器查找</li>
<li>若父类为空 则调用 bootstrap加载器</li>
<li>若父类找不到 则调用本类的查找方法</li>
</ul>
<blockquote>
<p>如果不想打破双亲委派模型，那么只需要重写findClass方法即可</p>
</blockquote>
<blockquote>
<p>如果想打破双亲委派模型，那么就重写整个loadClass方法</p>
</blockquote>
<pre><code class="language-java">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)
    throws ClassNotFoundException
    {
    // First, check if the class has already been loaded
    Class c = findLoadedClass(name);
    if (c == null) {
        try {
        if (parent != null) {
            c = parent.loadClass(name, false);
        } else {
            c = findBootstrapClass0(name);
        }
        } catch (ClassNotFoundException e) {
            // If still not found, then invoke findClass in order
            // to find the class.
            c = findClass(name);
        }
    }
    if (resolve) {
        resolveClass(c);
    }
    return c;
    }
</code></pre>
<h1 id="类加载过程"><a class="header" href="#类加载过程">类加载过程</a></h1>
<p>在前面介绍类加载器的代理模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。</p>
<ul>
<li>
<p>真正完成类的加载工作是通过调用 defineClass来实现的；</p>
</li>
<li>
<p>而启动类的加载过程是通过调用 loadClass来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。</p>
</li>
<li>
<p>在 Java 虚拟机判断两个类是否相同的时候，<strong>使用的是类的定义加载器</strong>。</p>
</li>
<li>
<p>也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。</p>
</li>
<li>
<p>两种类加载器的关联之处在于：一个类的<strong>定义加载器</strong> 是它引用的<strong>其它类的初始加载器</strong>，或者说一个类的 初始加载器 是引用它的类的 定义加载器</p>
<pre><code>如类 com.example.Outer引用了类 com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。

方法 loadClass()抛出的是
java.lang.ClassNotFoundException异常；方法 defineClass()抛出的是
java.lang.NoClassDefFoundError异常。
</code></pre>
</li>
<li>
<p>类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。</p>
</li>
</ul>
<h1 id="classforname"><a class="header" href="#classforname">Class.forName</a></h1>
<p>Class.forName是一个静态方法，同样可以用来加载类。</p>
<p>该方法有两种形式：</p>
<pre><code class="language-java">// name表示的是类的全名,initialize表示是否初始化类,loader表示加载时使用的类加载器
Class.forName(String name, boolean initialize, ClassLoader loader)
//第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器,Class.forName的一个很常见的用法是在加载数据库驱动的时候
Class.forName(String className)。
</code></pre>
<h1 id="自定义文件系统类加载器"><a class="header" href="#自定义文件系统类加载器">自定义文件系统类加载器</a></h1>
<h2 id="示例1"><a class="header" href="#示例1">示例1</a></h2>
<p><img src="7.jvm_jvm%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD/../../../images/classloader_selfdefine_fileSystem.png" alt="" /></p>
<p>在开发自己的类加载器时，最好不要覆写 loadClass()方法，而是覆写 findClass()方法。</p>
<h2 id="示例2"><a class="header" href="#示例2">示例2</a></h2>
<pre><code class="language-java">import java.io.*;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.WritableByteChannel;

public class MyCustomerLoader extends ClassLoader{
    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        //读
        String file = &quot;D:\\Person.class&quot;;
        FileInputStream in = null;
        try {
            in = new FileInputStream(file);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return null;
        }
        FileChannel channel = in.getChannel();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        WritableByteChannel writableByteChannel = Channels.newChannel(baos);
        try {
            channel.transferTo(0,channel.size(),writableByteChannel);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }


        byte[] bytes = baos.toByteArray();

        return defineClass(name,bytes,0,bytes.length);
    }

    public static void main(String[] args) throws IOException, ClassNotFoundException {
        MyCustomerLoader myCustomerLoader = new MyCustomerLoader();
        Class&lt;?&gt; c1 = Class.forName(&quot;Person&quot;, true, myCustomerLoader);

        System.out.println(c1.getClassLoader());
    }
}
</code></pre>
<h1 id="网络类加载器"><a class="header" href="#网络类加载器">网络类加载器</a></h1>
<p>下面将通过一个网络类加载器来说明如何通过类加载器来实现组件的动态更新。即基本的场景是：Java 字节代码（.class）文件存放在服务器上，客户端通过网络的方式获取字节代码并执行。当有版本更新的时候，只需要替换掉服务器上保存的文件即可。通过类加载器可以比较简单的实现这种需求。</p>
<p>类 NetworkClassLoader负责通过网络下载 Java 类字节代码并定义出 Java 类。它的实现与 FileSystemClassLoader类似。在通过 NetworkClassLoader加载了某个版本的类之后，一般有两种做法来使用它。第一种做法是使用 Java 反射 API。另外一种做法是使用接口。需要注意的是，并不能直接在客户端代码中引用从服务器上下载的类，因为客户端代码的类加载器找不到这些类。使用 Java 反射 API 可以直接调用 Java 类的方法。而使用接口的做法则是把接口的类放在客户端中，从服务器上加载实现此接口的不同版本的类。在客户端通过相同的接口来使用这些实现类。网络类加载器的具体代码见 下载。</p>
<h1 id="类加载器与-web-容器"><a class="header" href="#类加载器与-web-容器"><strong>类加载器与 Web 容器</strong></a></h1>
<h2 id="web容器类加载原则"><a class="header" href="#web容器类加载原则">web容器类加载原则</a></h2>
<ul>
<li>对于运行在 Java EE™容器中的 Web 应用来说，类加载器的实现方式与一般的 Java <strong>应用有所不同</strong>。不同的 Web 容器的实现方式也会有所不同。</li>
<li>以 Apache Tomcat 来说，<strong>每个 Web 应用都有一个对应的类加载器实例</strong>。该类加载器也使用代理模式，</li>
<li>所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是<strong>使得 Web 应用自己的类的优先级高于 Web 容器提供的类</strong>。</li>
<li>这种代理模式的一个例外是：<strong>Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。</strong></li>
</ul>
<p>绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则：</p>
<ul>
<li>每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 WEB-INF/classes和 WEB-INF/lib目录下面。</li>
<li>多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。</li>
<li>当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确。</li>
</ul>
<h2 id="tomcat-类加载机制"><a class="header" href="#tomcat-类加载机制">Tomcat 类加载机制</a></h2>
<p><img src="7.jvm_jvm%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD/../../../images/classload_tomcat.png" alt="tomcat类加载器" /></p>
<h1 id="osgi"><a class="header" href="#osgi">OSGI</a></h1>
<p>OSGi™是 Java 上的动态模块系统。它为开发人员提供了面向服务和基于组件的运行环境，并提供标准的方式用来管理软件的生命周期。OSGi 已经被实现和部署在很多产品上，在开源社区也得到了广泛的支持。Eclipse 就是基于 OSGi 技术来构建的。</p>
<p>OSGi 中的每个模块（bundle）都包含 Java 包和类。模块可以声明它所依赖的需要导入（import）的其它模块的 Java 包和类（通过 Import-Package），也可以声明导出（export）自己的包和类，供其它模块使用（通过 Export-Package）。也就是说需要能够隐藏和共享一个模块中的某些 Java 包和类。这是通过 OSGi 特有的类加载器机制来实现的。OSGi 中的每个模块都有对应的一个类加载器。它负责加载模块自己包含的 Java 包和类。当它需要加载 Java 核心库的类时（以 java开头的包和类），它会代理给父类加载器（通常是启动类加载器）来完成。当它需要加载所导入的 Java 类时，它会代理给导出此 Java 类的模块来完成加载。模块也可以显式的声明某些 Java 包和类，必须由父类加载器来加载。只需要设置系统属性
org.osgi.framework.bootdelegation的值即可。</p>
<p>假设有两个模块 bundleA 和 bundleB，它们都有自己对应的类加载器 classLoaderA 和 classLoaderB。在 bundleA 中包含类 com.bundleA.Sample，并且该类被声明为导出的，也就是说可以被其它模块所使用的。bundleB 声明了导入 bundleA 提供的类 com.bundleA.Sample，并包含一个类 com.bundleB.NewSample继承自 com.bundleA.Sample。在 bundleB 启动的时候，其类加载器 classLoaderB 需要加载类 com.bundleB.NewSample，进而需要加载类 com.bundleA.Sample。由于 bundleB 声明了类 com.bundleA.Sample是导入的，classLoaderB 把加载类 com.bundleA.Sample的工作代理给导出该类的 bundleA 的类加载器 classLoaderA。classLoaderA 在其模块内部查找类 com.bundleA.Sample并定义它，所得到的类 com.bundleA.Sample实例就可以被所有声明导入了此类的模块使用。对于以 java开头的类，都是由父类加载器来加载的。如果声明了系统属性
org.osgi.framework.bootdelegation=com.example.core.*，那么对于包 com.example.core中的类，都是由父类加载器来完成的。</p>
<p>OSGi 模块的这种类加载器结构，使得一个类的不同版本可以共存在 Java 虚拟机中，带来了很大的灵活性。不过它的这种不同，也会给开发人员带来一些麻烦，尤其当模块需要使用第三方提供的库的时候。下面提供几条比较好的建议：</p>
<ul>
<li>如果一个类库只有一个模块使用，把该类库的 jar 包放在模块中，在 Bundle-ClassPath中指明即可。</li>
<li>如果一个类库被多个模块共用，可以为这个类库单独的创建一个模块，把其它模块需要用到的 Java 包声明为导出的。其它模块声明导入这些类。</li>
<li>如果类库提供了 SPI 接口，并且利用线程上下文类加载器来加载 SPI 实现的 Java 类，有可能会找不到 Java 类。如果出现了 NoClassDefFoundError异常，首先检查当前线程的上下文类加载器是否正确。通过 Thread.currentThread().getContextClassLoader()就可以得到该类加载器。该类加载器应该是该模块对应的类加载器。如果不是的话，可以首先通过 class.getClassLoader()来得到模块对应的类加载器，再通过 Thread.currentThread().setContextClassLoader()来设置当前线程的上下文类加载器。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类加载过程-1"><a class="header" href="#类加载过程-1">类加载过程</a></h1>
<p><img src="7.jvm_jvm%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD/../../../images/classload_process.png" alt="类加载机制" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线程上下文类加载器"><a class="header" href="#线程上下文类加载器">线程上下文类加载器</a></h1>
<blockquote>
<p>线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。</p>
</blockquote>
<h2 id="api-1"><a class="header" href="#api-1">API</a></h2>
<pre><code class="language-java">//获取线程的上下文类加载器
getContextClassLoader()
//设置线程的上下文类加载器
setContextClassLoader(ClassLoader cl)
</code></pre>
<p>如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。</p>
<p>Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。</p>
<h2 id="为什么要定义线程上下文类加载器"><a class="header" href="#为什么要定义线程上下文类加载器">为什么要定义线程上下文类加载器？</a></h2>
<p><strong>SPI接口</strong></p>
<p>前面提到的类加载器的代理模式并不能解决 Java 应用开发中会遇到的类加载器的全部问题。</p>
<p>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现</p>
<p>常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，而接口实现是由其三方库来实现的</p>
<p><strong>核心库接口与三方库实现的冲突</strong></p>
<p>而问题在于，SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的；SPI 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库</p>
<p><strong>解决办法</strong></p>
<p>线程上下文类加载器正好解决了这个问题。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是系统上下文类加载器。</p>
<p>在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。</p>
<h2 id="线程上下文类加载器的一般模式"><a class="header" href="#线程上下文类加载器的一般模式">线程上下文类加载器的一般模式</a></h2>
<pre><code class="language-java"># 伪代码：
    // 获取
    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
    try {
        // 使用
        Thread.currentThread().setContextClassLoader(targetTccl);
        myMethod();
    } finally {
        // 还原
        Thread.currentThread().setContextClassLoader(classLoader);
    }
</code></pre>
<p>myMethod 里面则调用了 <code>Thread.currentThread().getContextClassLoader()</code>，获取当前线程的上下文类加载器做某些事情。</p>
<p>如果一个类由类加载器A加载，那么这个类的依赖也是由相同的类加载器加载的（如果该依赖类之前没有被加载过的话）</p>
<p>当高层提供了统一的接口让低层去实现，，同时又要在高层加载（或实例化）低层的类时，就必须要通过线程上下文类加载器来帮助高层的 ClassLoader 找到并加载该类。</p>
<p>如果我们没有对线程上下文类加载器做任何设值的话，那么当前线程的上下文类加载器就是&quot;系统类加载器&quot;。</p>
<h2 id="以jdbc-spi为例"><a class="header" href="#以jdbc-spi为例">以JDBC SPI为例</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="mat是什么"><a class="header" href="#mat是什么"><strong>MAT是什么？</strong></a></h2>
<p>​	MAT(Memory Analyzer Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。</p>
<p>​	使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。</p>
<h2 id="如何使用"><a class="header" href="#如何使用"><strong>如何使用</strong></a></h2>
<p>使用的方法将dump文件导入然后进行分析。</p>
<p>1、通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的JMAP命令来生成该文件。</p>
<p>2、 要考虑的是如何打开这个DUMP的堆信息文件，显然一般的Window系统没有这么大的内存，必须借助高配置的Linux。当然我们可以借助X-Window把Linux上的图形导入到Window。我们考虑用下面几种工具打开该文件：</p>
<p>Visual VM、IBM HeapAnalyzer、JDK 自带的Hprof工具。</p>
<pre><code>使用这些工具时为了确保加载速度，建议设置最大内存为6G。使用后发现，这些工具都无法直观地观察到内存泄漏，Visual VM虽能观察到对象大小，但看不到调用堆栈；HeapAnalyzer虽然能看到调用堆栈，却无法正确打开一个3G的文件。可以使用MAT工具直接导入文件，生成图表信息和疑似有问题的JAVA类
</code></pre>
<h2 id="mat内存分析工具具体使用"><a class="header" href="#mat内存分析工具具体使用">MAT内存分析工具具体使用</a></h2>
<h3 id="初识mat"><a class="header" href="#初识mat">初识MAT</a></h3>
<ol>
<li>
<p>单击左上角的“File”菜单下的“Accquire Heap Dump”选项后，会弹出当前Java应用程序列表，选择要分析的应用程序即可，如图所示。</p>
</li>
<li>
<p>除了直接在MAT中导出正在运行的应用程序堆快照外，也可以通过“Open Heap Dump”来打开一个既存的堆快照文件。</p>
</li>
</ol>
<p>右侧界面中，显示了堆快照文件的大小、类、实例和ClassLoader的总数。</p>
<p>在右侧的饼图中，显示了当前堆快照中最大的对象。</p>
<p>将鼠标悬停在饼图中，可以在左侧的Inspector界面中，查看该对象的相应信息。在饼图中单击某对象，可以对选中的对象进行更多的操作。</p>
<p><strong>线程查看</strong></p>
<p>另外一个实用的功能是，可以通过MAT查看系统中的Java线程，如图所示。</p>
<p>当然，这里查看Java层面的应用线程，对于虚拟机的系统线程是无法显示的。</p>
<p>通过线程的堆栈，还可以查看局部变量的信息。如上图所示，带有<code>&lt;local&gt;</code>标记的，就为当前帧栈的局部变量，这部分信息可能存在缺失。</p>
<p><strong>引用穿梭</strong></p>
<p>MAT的另外一个常用功能，是在各个对象的引用列表中穿梭查看。</p>
<p>对于给定一个对象，通过MAT可以找到引用当前对象的对象，即入引用（Incomming References），</p>
<p>以及当前对象引用的对象，即出引用（Outgoing References），如图7.11所示。</p>
<h3 id="浅堆和深堆"><a class="header" href="#浅堆和深堆">浅堆和深堆</a></h3>
<p>浅堆（Shallow Heap）和深堆（Retained Heap）是两个非常重要的概念，它们分别表示一个对象结构所占用的内存大小和一个对象被GC回收后，可以真实释放的内存大小。</p>
<p>浅堆（Shallow Heap）是指一个对象所消耗的内存。在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。</p>
<p>根据堆快照格式不同，对象的大小可能会向8字节进行对齐。以String对象为例，如下图所示，显示了String对象的几个属性。</p>
<p>String</p>
<ul>
<li>value:char[]</li>
<li>offset:int</li>
<li>count:int</li>
<li>hash:int</li>
</ul>
<p>3个int值共占12字节，对象引用占用4字节，对象头8字节，合计24字节。</p>
<p>浅堆的大小只与对象的结构有关，与对象的实际内容无关。也就是说，无论字符串的长度有多少，内容是什么，浅堆的大小始终是24字节。</p>
<p>深堆（Retained Heap）的概念略微复杂。要理解深堆，首先需要了解保留集（Retained Set）。</p>
<p>对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合（包括对象A本身），即对象A的保留集可以被认为是只能通过对象A被直接或间接访问到的所有对象的集合。</p>
<p>通俗地说，<strong>就是指仅被对象A所持有的对象的集合</strong>。</p>
<p><strong>深堆是指对象的保留集中所有的对象的浅堆大小之和。</strong></p>
<blockquote>
<p>注意：浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。</p>
</blockquote>
<p>另外一个常用的概念是<strong>对象的实际大小</strong>。</p>
<p>这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。</p>
<p>与深堆相比，似乎这个在日常开发中更为直观和被人接受，但实际上，这个概念和垃圾回收无关。</p>
<h3 id="支配树dominator-tree"><a class="header" href="#支配树dominator-tree">支配树（Dominator Tree）</a></h3>
<p>MAT提供了一个称为支配树（Dominator Tree）的对象图。</p>
<p>支配树体现了对象实例间的支配关系。在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。</p>
<p>可以理解为：B只被A引用</p>
<p>如果对象A是离对象B最近的一个支配对象，则认为对象A为对象B的直接支配者。</p>
<p>支配树是基于对象间的引用图所建立的，它有以下基本性质：</p>
<ul>
<li>对象A的子树（所有被对象A支配的对象集合）表示对象A的保留集（retained set），即深堆。</li>
<li>如果对象A支配对象B，那么对象A的直接支配者也支配对象B。</li>
<li>支配树的边与对象引用图的边不直接对应。</li>
</ul>
<h3 id="垃圾回收根gc-root"><a class="header" href="#垃圾回收根gc-root">垃圾回收根（GC-ROOT）</a></h3>
<p>在Java系统中，作为垃圾回收的根节点可能是以下对象之一：</p>
<ul>
<li>系统类：被 bootstrap/system ClassLoader加载的类。如在 rt.jar包中的所有类。</li>
<li>JNI局部变量：本地代码中的局部变量。如用户自定义的JNI代码或者JVM内部代码。</li>
<li>JNI全局变量：本地代码中的全局变量。</li>
<li>线程：开始、并且没有停止的线程。</li>
<li>正在使用的锁：作为锁的对象。比如，调用了 wait() 或者 notify() 方法的对象。或者调用了 synchronized(Object)操作的对象。</li>
<li>Java局部变量：如函数的输入参数以及方法中的局部变量。</li>
<li>本地栈：本地代码中的输入输出参数。比如用户自定义的JNI代码或者JVM内部代码。</li>
<li>Finalizer：在等待队列中将要被执行析构函数的对象。</li>
<li>Unfinalized：拥有析构函数，但是没有被析构，且不在析构队列中的对象。</li>
<li>不可达对象：从任何一个根对象，都无法达到的对象。但为了能够在MAT中分析，被MAT标志位根。</li>
<li>未知对象：未知的根类型。用于处理一些特殊的堆格式。</li>
</ul>
<p>通过MAT，可以列出所有的根对象</p>
<h3 id="内存泄漏检测"><a class="header" href="#内存泄漏检测">内存泄漏检测</a></h3>
<p>MAT 提供了自动检测内存泄漏，以及统计堆快照内对象分布情况的工具</p>
<h3 id="最大对象报告"><a class="header" href="#最大对象报告">最大对象报告</a></h3>
<p>系统中占有内存最大的几个对象，往往是解决系统性能问题的关键所在。如果应用程序发生内存泄漏，那么泄漏的对象通常会在堆快照中所占据很大的比重。因此，查看和分析堆快照中最大的对象，具有较高的价值。</p>
<p>在MAT中，可以自动查找并显示消耗内存最多的几个对象，</p>
<h3 id="查找支配者"><a class="header" href="#查找支配者">查找支配者</a></h3>
<p>通过MAT，开发人员还可以很方便地查找某一个对象或者类的支配者。</p>
<p>在参数对话框中，务必正确填写 -skip 参数。查询结果会忽略所有定义在 -skip 参数中的类和实例。</p>
<p>输出结果是不满足 -skip 所指定正则表达式的、所有选中对象或类的直接的支配者。</p>
<h3 id="集合使用情况分析"><a class="header" href="#集合使用情况分析">集合使用情况分析</a></h3>
<p>使用这些工具，可以查看数组、集合的填充率；可以观察集合内的数据；也可以分析哈希表的冲突率。</p>
<h4 id="mat对oql的支持"><a class="header" href="#mat对oql的支持">MAT对OQL的支持</a></h4>
<p>MAT的OQL语法与Visual VM支持的OQL有着很大不同。</p>
<p>MAT支持一种类似于SQL的查询语言OQL（Object Query Language）。</p>
<p>OQL使用类SQL语法，可以在堆中进行对象的查找和筛选。</p>
<p>本节将主要介绍OQL的基本使用方法，帮助读者尽快掌握这种堆文件的查看方式。</p>
<p><strong>Select子句</strong></p>
<p>在MAT中，Select子句的格式与SQL基本一致，用于指定要显示的列。Select子句中可以使用“*”，</p>
<p>查看结果对象的引用实例（相当于outgoing references）。</p>
<pre><code class="language-sql">select * from java.util.ArrayList A
</code></pre>
<p>OQL还可以指定对象的属性进行输出，下例输出所有Vector对象的内部数组，输出结果如图7.31所示。</p>
<p>使用“OBJECTS”关键字，可以将返回结果集中的项以对象的形式显示。</p>
<pre><code class="language-sql">SELECT OBJECTS v.elementData FROM java.util.Vector v 
</code></pre>
<p>在Select子句中，使用“AS RETAINED SET”关键字可以得到所得对象的保留集。</p>
<p>下例得到geym.zbase.ch7.heap.Student对象的保留集。</p>
<pre><code>SELECT AS RETAINED SET * FROM geym.zbase.ch7.heap.Student 
</code></pre>
<p>“DISTINCT”关键字用于在结果集中去除重复对象。</p>
<p>下例的输出结果中只有一条“class java.lang.String”记录。如果没有“DISTINCT”，那么查询将为每个String实例输出其对应的Class信息。</p>
<pre><code>SELECT DISTINCT OBJECTS classof(s) FROM java.lang.String s 
</code></pre>
<h4 id="from子句"><a class="header" href="#from子句">From子句</a></h4>
<p>From子句用于指定查询范围，它可以指定<strong>类名</strong>、<strong>正则表达式</strong>或者<strong>对象地址</strong>。</p>
<pre><code class="language-sql">SELECT * FROM java.lang.String s 
</code></pre>
<p>下例使用正则表达式，限定搜索范围，输出所有java.lang包下所有类的实例，如图所示。</p>
<pre><code class="language-sql">SELECT * FROM &quot;java\.lang\..*&quot; 
</code></pre>
<p>也可以直接使用类的地址进行搜索。使用类的地址的好处是可以区分被不同ClassLoader加载的同一种类型。下例中“0x37a014d8”为类的地址。</p>
<pre><code class="language-sql">select * from 0x37a014d8 
</code></pre>
<p>有多种方法可以获得类的地址，在MAT中，一种最为简单的方法如图所示。</p>
<p><strong>INSTANCEOF</strong></p>
<p>在From子句中，还可以使用“INSTANCEOF”关键字，返回指定类的所有子类实例。</p>
<p>下例的查询返回了当前堆快照中所有的抽象集合实例，包括<em>java.util.Vector</em>、<em>java.util.ArrayList</em>和<em>java.util.HashSet</em>等。</p>
<pre><code>SELECT * FROM INSTANCEOF java.util.AbstractCollection 
</code></pre>
<p><strong>OBJECTS</strong></p>
<p>在From子句中，还可以使用“OBJECTS”关键字。使用“OBJECTS”关键字后，那么原本应该返回类的实例的查询，将返回类的信息。</p>
<pre><code class="language-sql">SELECT * FROM OBJECTS java.lang.String 
</code></pre>
<p>以上查询的返回结果如图所示。它仅返回一条记录，表示java.lang.String的类的信息。</p>
<p>如果不使用“OBJECTS”关键字，这个查询将返回所有的java.lang.String实例。</p>
<p>“OBJECTS”关键字也支持与正则表达式一起使用。下面的查询，返回了所有满足给定正则表达式的所有类，其结果如图所示。</p>
<pre><code class="language-sql">SELECT * FROM OBJECTS &quot;cn\.zyzpp\..*&quot; 
</code></pre>
<p>注意：在From子句中使用OBJECTS关键字，将返回符合条件的类信息，而非实例信息。这与Select子句中的OBJECTS关键字是完全不同的。</p>
<h4 id="where子句"><a class="header" href="#where子句">Where子句</a></h4>
<p>Where子句用于指定OQL的查询条件。</p>
<p>OQL查询将只返回满足Where子句指定条件的对象。</p>
<p>Where子句的格式与传统SQL极为相似。</p>
<p>下例返回长度大于10的char数组。</p>
<pre><code class="language-sql">SELECT * FROM char[] s WHERE s.@length&gt;10 
</code></pre>
<p>下例返回包含“java”子字符串的所有字符串，使用“LIKE”操作符，“LIKE”操作符的操作参数为正则表达式。</p>
<pre><code class="language-sql">SELECT * FROM java.lang.String s WHERE toString(s) LIKE &quot;.*java.*&quot; 
</code></pre>
<p>下例返回所有value域不为null的字符串，使用“=”操作符。</p>
<pre><code class="language-sql">SELECT * FROM java.lang.String s where s.value!=null 
</code></pre>
<p>Where子句支持多个条件的AND、OR运算。下例返回数组长度大于15，并且深堆大于1000字节的所有Vector对象。</p>
<pre><code class="language-sql">SELECT * FROM java.util.Vector v WHERE v.elementData.@length&gt;15 AND v.@retainedHeapSize&gt;1000
</code></pre>
<h4 id="内置对象与方法"><a class="header" href="#内置对象与方法">内置对象与方法</a></h4>
<p>OQL中可以访问堆内对象的属性，也可以访问堆内代理对象的属性。访问堆内对象的属性时，格式如下：</p>
<pre><code class="language-sql">[ &lt;alias&gt;. ] &lt;field&gt; . &lt;field&gt;. &lt;field&gt; 
</code></pre>
<p>其中alias为对象名称。</p>
<p>下例访问java.io.File对象的path属性，并进一步访问path的value属性。</p>
<pre><code class="language-sql">SELECT toString(f.path.value) FROM java.io.File f 
</code></pre>
<p>这些堆内对象的属性与Java对象一致，拥有与Java对象相同的结果。</p>
<p>MAT为了能快捷地获取堆内对象的额外属性（比如对象占用的堆大小、对象地址等），为每种元类型的堆内对象建立了相对应的代理对象，以增强原有的对象功能。访问代理对象的属性时，使用如下格式：</p>
<pre><code class="language-sql">[ &lt;alias&gt;. ] @&lt;attribute&gt; 
</code></pre>
<p>其中，alias为对象名称，attribute为属性名。</p>
<p>下例显示了String对象的内容、objectid和objectAddress。</p>
<pre><code>SELECT s.toString(), s.@objectId, s.@objectAddress FROM java.lang.String s 
</code></pre>
<p>下例显示了File对象的对象ID、对象地址、代理对象的类型、类的类型、对象的浅堆大小以及对象的显示名称。</p>
<pre><code class="language-sql">SELECT f.@objectId, f.@objectAddress, f.@class, f.@clazz, f.@usedHeapSize, f.@displayName FROM java.io.File f 
</code></pre>
<p>下例显示java.util.Vector内部数组的长度。</p>
<pre><code class="language-sql">SELECT v.elementData.@length FROM java.util.Vector v 
</code></pre>
<p>下表整理了MAT代理对象的基本属性。</p>
<table><thead><tr><th>对象类型</th><th>接口</th><th>属性</th><th>功能</th></tr></thead><tbody>
<tr><td>基对象</td><td>IObejct</td><td>objectId</td><td>对象ID</td></tr>
<tr><td></td><td></td><td>objectAddress</td><td>对象地址</td></tr>
<tr><td></td><td></td><td>class</td><td>代理对象类型</td></tr>
<tr><td></td><td></td><td>clazz</td><td>对象类类型</td></tr>
<tr><td></td><td></td><td>usedHeapSize</td><td>浅堆大小</td></tr>
<tr><td></td><td></td><td>retainedHeapSize</td><td>深堆大小</td></tr>
<tr><td></td><td></td><td>displayName</td><td>显示名称</td></tr>
<tr><td>Class对象</td><td>IClass</td><td>classLoaderId</td><td>ClassLoad的ID</td></tr>
<tr><td>数组</td><td>IArray</td><td>length</td><td>数组长度</td></tr>
<tr><td>元类型数组</td><td>IPrimitiveArray</td><td>valueArray</td><td>数组内容</td></tr>
<tr><td>对象数组</td><td>IObjectArray</td><td>referenceArray</td><td>数组内容</td></tr>
</tbody></table>
<p>除了使用代理对象的属性，OQL中还可以使用代理对象的方法，使用格式如下：</p>
<pre><code class="language-sql">[ &lt;alias&gt; . ] @&lt;method&gt;( [ &lt;expression&gt;, &lt;expression&gt; ] ) 
</code></pre>
<p>下例显示int数组中索引下标为2的数据内容。</p>
<pre><code class="language-sql">SELECT s.getValueAt(2) FROM int[] s WHERE (s.@length &gt; 2) 
</code></pre>
<p>下例显示对象数组中索引下标为2的对象。</p>
<pre><code class="language-sql">SELECT OBJECTS s.@referenceArray.get(2) FROM java.lang.Object[] s WHERE (s.@length &gt; 2)
</code></pre>
<p>下例显示了当前堆中所有的类型。</p>
<pre><code class="language-sql">select * from ${snapshot}.getClasses() 
</code></pre>
<p>下例显示了所有的java.util.Vector对象及其子类型，它的输出如图所示。</p>
<pre><code class="language-sql">select * from INSTANCEOF java.util.Vector 
</code></pre>
<p>下例显示当前对象是否是数组。</p>
<pre><code class="language-sql">SELECT c, classof(c).isArrayType() FROM ${snapshot}.getClasses() c 

</code></pre>
<p>代理对象的方法整理如表所示。</p>
<p>表 MAT代理对象的方法</p>
<table><thead><tr><th>对象说明</th><th>对象名</th><th>对象方法</th><th>对象方法说明</th></tr></thead><tbody>
<tr><td>全局快照</td><td>ISnapshot</td><td>getClasses()</td><td>所有实例的集合</td></tr>
<tr><td></td><td></td><td>getClassesByName(String name, boolean includeSubClasses)</td><td>根据名称选取符合条件的实例</td></tr>
<tr><td>类对象</td><td>IClass</td><td>hasSuperClass()</td><td>是否有超类</td></tr>
<tr><td></td><td></td><td>isArrayType()</td><td>是否是数组</td></tr>
<tr><td>基对象</td><td>IObject</td><td>getObjectAddress()</td><td>取得对象地址</td></tr>
<tr><td>元类型数组</td><td>IPrimitiveArray</td><td>getValueAt(int index)</td><td>取得数组中给定索引的数据</td></tr>
<tr><td>元类型数组，对象数组</td><td>[] or List</td><td>get(int index)</td><td>取得数组中给定索引的数据</td></tr>
</tbody></table>
<p>MAT的OQL中还内置一些有用的函数，如表所示。</p>
<p>表 OQL中的内置函数</p>
<table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody>
<tr><td>toHex( number )</td><td>转为16进制</td></tr>
<tr><td>toString( object )</td><td>转为字符串</td></tr>
<tr><td>dominators( object )</td><td>取得直接支配对象</td></tr>
<tr><td>outbounds( object )</td><td>取得给定对象引用的对象</td></tr>
<tr><td>inbounds( object )</td><td>取得引用给定对象的对象</td></tr>
<tr><td>classof( object )</td><td>取得当前对象的类</td></tr>
<tr><td>dominatorof( object )</td><td>取得给定对象的直接支配者</td></tr>
</tbody></table>
<p>下例显示所有长度为15的字符串内容</p>
<pre><code class="language-sql">SELECT toString(s) FROM java.lang.String s WHERE ((s.value.@length = 15) and (s.value != null)) 
</code></pre>
<p>下例显示所有cn.zyzpp.jConsole.HProfTest对象直接支配的 对象。即给定对象回收后，将释放的对象集合。</p>
<pre><code class="language-sql">SELECT objects dominators(s) FROM cn.zyzpp.jConsole.HProfTest s
</code></pre>
<p>函数dominatorof()与dominators()的功能相反，它获取直接支配当前对象的对象。</p>
<pre><code class="language-javascript">SELECT distinct objects dominatorof(s) FROM cn.zyzpp.jConsole.HProfTest s 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="背景"><a class="header" href="#背景">背景</a></h1>
<p>线上系统，Java进程 如果出现 CPU 高负载运行，一直降不下来，导致 无法响应其他任何请求，可以按以下流程排查</p>
<h1 id="定位办法"><a class="header" href="#定位办法">定位办法</a></h1>
<h2 id="采用top命令定位进程"><a class="header" href="#采用top命令定位进程">采用top命令定位进程</a></h2>
<pre><code>top
</code></pre>
<p>默认CPU使用率排序，找出Java进程</p>
<h2 id="使用top--hp命令定位线程"><a class="header" href="#使用top--hp命令定位线程">使用top -Hp命令定位线程</a></h2>
<p><strong>打印线程</strong></p>
<pre><code> top -Hp &lt;pid&gt;
</code></pre>
<p><strong>查看该Java进程内所有线程的资源占用情况</strong></p>
<p><strong>转换成TID</strong></p>
<pre><code>printf “%x\n” 命令（tid指线程的id号）将以上10进制的线程号转换为16进制：
</code></pre>
<h2 id="采用jstack命令导出线程快照"><a class="header" href="#采用jstack命令导出线程快照">采用jstack命令导出线程快照</a></h2>
<pre><code class="language-java">jstack -l 29706 &gt; ./jstack_result.txt 
</code></pre>
<h2 id="根据线程号定位具体代码"><a class="header" href="#根据线程号定位具体代码">根据线程号定位具体代码</a></h2>
<pre><code class="language-shell">jstack  3054|grep -A10 bef
</code></pre>
<h2 id="使用命令直接查找"><a class="header" href="#使用命令直接查找">使用命令直接查找</a></h2>
<pre><code class="language-shell">ps -mp 3054 -o THREAD,tid,time | sort -rn
</code></pre>
<h1 id="日志文件内容分析"><a class="header" href="#日志文件内容分析">日志文件内容分析</a></h1>
<h2 id="线程状态-1"><a class="header" href="#线程状态-1">线程状态</a></h2>
<h3 id="deadlock"><a class="header" href="#deadlock">Deadlock</a></h3>
<blockquote>
<p>死锁线程，一般指多个线程调用间，进入相互资源占用，导致一直等待无法释放的情况。</p>
</blockquote>
<p><strong>案例</strong></p>
<pre><code>Found one Java-level deadlock:
=============================
&quot;Thread-0&quot;:
  waiting to lock monitor 0x00000000266c1cd8 (object 0x0000000715b5f120, a java.lang.Class),
  which is held by &quot;main&quot;
&quot;main&quot;:
  waiting to lock monitor 0x00000000266c0838 (object 0x0000000715b63ca0, a java.lang.Object),
  which is held by &quot;Thread-0&quot;

</code></pre>
<h3 id="runnable"><a class="header" href="#runnable">Runnable</a></h3>
<p>执行中</p>
<h3 id="waiting-on-condition"><a class="header" href="#waiting-on-condition">Waiting on condition</a></h3>
<blockquote>
<p>WAITING，等待资源</p>
</blockquote>
<pre><code>&quot;main&quot; #1 prio=5 os_prio=0 tid=0x0000000002ba3800 nid=0x2ad0 waiting on condition [0x0000000002a9f000]
   java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)
        at TestMain.park(TestMain.java:70)
        at TestMain.main(TestMain.java:6)
</code></pre>
<p><strong>睡眠</strong></p>
<pre><code>&quot;main&quot; #1 prio=5 os_prio=0 tid=0x0000000002db3800 nid=0x5068 waiting on condition [0x0000000002c3f000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
        at java.lang.Thread.sleep(Native Method)
        at TestMain.sleep(TestMain.java:10)
        at TestMain.main(TestMain.java:6)

</code></pre>
<h3 id="waiting-on-monitor-entry"><a class="header" href="#waiting-on-monitor-entry">Waiting on monitor entry</a></h3>
<blockquote>
<p>BLOCKED，等待获取监视器</p>
</blockquote>
<pre><code>&quot;Thread-0&quot; #14 prio=5 os_prio=0 tid=0x0000000029d6f800 nid=0x43a0 waiting for monitor entry [0x000000002a53f000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at TestMain.lambda$deadLock$0(TestMain.java:16)
        - waiting to lock &lt;0x0000000715b5f120&gt; (a java.lang.Class for TestMain)
        - locked &lt;0x0000000715b63ca0&gt; (a java.lang.Object)
        at TestMain$$Lambda$1/1879492184.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:748)

</code></pre>
<h3 id="objectwait-或-timed_waiting"><a class="header" href="#objectwait-或-timed_waiting">Object.wait() 或 TIMED_WAITING</a></h3>
<blockquote>
<p>WAITING，条件等待，也可以认为是一种等待资源</p>
</blockquote>
<pre><code class="language-java">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00000000028a3800 nid=0x40d0 in Object.wait() [0x000000000272f000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on &lt;0x0000000715ad86d0&gt; (a java.lang.Class for TestMain)
        at java.lang.Object.wait(Object.java:502)
        at TestMain.waitOnConditional(TestMain.java:42)
        - locked &lt;0x0000000715ad86d0&gt; (a java.lang.Class for TestMain)
        at TestMain.main(TestMain.java:6)

</code></pre>
<h3 id="suspended"><a class="header" href="#suspended">Suspended</a></h3>
<p>已过时，推荐使用 <em>LockSupport.park</em></p>
<h2 id="waitset与-entryset的区别"><a class="header" href="#waitset与-entryset的区别">waitSet,与 entrySet的区别</a></h2>
<p><img src="8.jvm_jvm%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90//images/jstack_waitting_status.png" alt="" /></p>
<h1 id="通过-jvisualvm可视化"><a class="header" href="#通过-jvisualvm可视化">通过 Jvisualvm可视化</a></h1>
<h2 id="配置jvisualvm"><a class="header" href="#配置jvisualvm">配置JvisualVM</a></h2>
<pre><code>[root@localhost management]# pwd
/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.282.b08-1.el7_9.x86_64/jre/lib/management
[root@localhost management]# ls -l
total 28
-rw-r--r--. 1 root root  3998 Jan 22 10:41 jmxremote.access
-r--r--r--. 1 root root  2856 Jan 22 10:41 jmxremote.password.template
-rw-r--r--. 1 root root 14630 Jan 22 10:41 management.properties
-r--r--r--. 1 root root  3376 Jan 22 10:41 snmp.acl.template
</code></pre>
<p><strong>首先利用jmxremote.password.template 文件创建jmxremote.password文件，并且设置相应的读写权限。</strong></p>
<pre><code>//默认两个角色 monitorRole 密码为 QED，controlRole的密码是 R&amp;D

monitorRole  QED

controlRole   R&amp;D
</code></pre>
<p>接着可以运行本地的  <em>jvisualvm.exe</em> 运行</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-3"><a class="header" href="#前言-3">前言</a></h1>
<p>这篇文章将研究如何处理和调试那些只发生在生产环境（或其他远程环境）而本地开发环境可能没办法重现的“问题”。</p>
<h1 id="tomcat启用远程调试"><a class="header" href="#tomcat启用远程调试">Tomcat启用远程调试</a></h1>
<blockquote>
<p>传递特定的启动参数给 JVM，让它启用远程调试</p>
</blockquote>
<p>JVM 激活远程调试的启动参数有 <em>JPDA_OPTS</em>, <em>CATALINA_OPTS</em> 和 <em>JAVA_OPTS</em></p>
<p>JAVA_OPTS 是通常不建议使用的， 因为基于 JAVA_OPTS 的参数设定会暴露给所有的 JVM 应用， 而 CATALINA_OPTS 定义的设定值限制在Tomcat 内</p>
<h2 id="使用jpda_opts"><a class="header" href="#使用jpda_opts">使用JPDA_OPTS</a></h2>
<h3 id="设置tomcat"><a class="header" href="#设置tomcat">设置Tomcat</a></h3>
<p>在 <em>CATALINA_HOME/bin</em> 目录下创建可执行脚本文件 <em>setenv.sh</em> ( Windows 创建 setenv.bat ），加入内容：</p>
<pre><code class="language-sh">export JPDA_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,address=1043,server=y,suspend=n&quot;
set JPDA_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,address=1043,server=y,suspend=n&quot;
</code></pre>
<p>这些参数要做的事情就是启用远程调试和配置有效的选项：</p>
<ul>
<li>指定运行的被调试应用和调试者之间的通信协议，(ie: <em>transport=dt_socket</em>)</li>
<li>远程被调试应用开通的端口，(ie: address=1043)， 可定义其他端口，比如9999</li>
<li>server=y 表示这个 JVM 即将被调试</li>
<li>suspend=n 用来告知 JVM 立即执行，不要等待未来将要附着上/连上（attached）的调试者。如果设成 y, 则应用将暂停不运行，直到有调试者连接上</li>
</ul>
<p>suspend=y的一个比较适用的场景是，当debug一个会阻止应用成功启动的问题时， 通过suspend=y可以确保调试者连上来之后再启动应用，否则应用已经启动报错了再调试也没意义了。</p>
<h3 id="启动tomcat"><a class="header" href="#启动tomcat">启动Tomcat</a></h3>
<pre><code class="language-sh">$CATALINA_HOME/bin/catalina.sh jpda start
</code></pre>
<h2 id="使用-java_opts--catalina_opts"><a class="header" href="#使用-java_opts--catalina_opts">使用 JAVA_OPTS / CATALINA_OPTS</a></h2>
<p>setenv.sh 中写入</p>
<pre><code>set CATALINA_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,address=1043,server=y,suspend=n&quot;
export CATALINA_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,address=1043,server=y,suspend=n&quot;
</code></pre>
<h3 id="启动方式"><a class="header" href="#启动方式">启动方式</a></h3>
<pre><code class="language-sh">./startup.sh
或者
./catalina.sh start
</code></pre>
<h2 id="使用jpda启动"><a class="header" href="#使用jpda启动">使用JPDA启动</a></h2>
<p>是用 JPDA 切换， 用如下的启动命令将使用默认值自动启用远程调试，</p>
<pre><code class="language-sh">catalina jpda start
</code></pre>
<p>该命令默认使用的设置是</p>
<pre><code class="language-bash">-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n
</code></pre>
<p>修改 Tomcat 需要的这些环境变量</p>
<pre><code class="language-bash">//JPDA_TRANSPORT: 指定 jpda 传输协议
//JPDA_ADDRESS: 指定远程调试端口
//JPDA_SUSPEND: 指定 jvm 启动暂缓

export JPDA_ADDRESS=0.0.0.0:8080
</code></pre>
<h1 id="配置intellj-idea"><a class="header" href="#配置intellj-idea">配置Intellj Idea</a></h1>
<h2 id="remote-tomcat-配置"><a class="header" href="#remote-tomcat-配置">Remote Tomcat 配置</a></h2>
<pre><code>//步骤1
Run ➝ Edit Configurations ➝ **+ **按钮 ➝ Tomcat Server ➝ Remote
//步骤2 填写 主机与IP
remote connection settings
//步骤3 Startup/Connection-&gt; debug
Transport Socket 8000
</code></pre>
<h2 id="使用-remote-配置"><a class="header" href="#使用-remote-配置">使用 Remote 配置</a></h2>
<p>第一个方法有个缺陷，你打开的工程源码必须是编译通过的工程，否则会启动会报错；
而介绍的这第二种方法可以在你的工程目录乱七八糟，不是一个完整的可以部署的工程，甚至是一个解压缩的 war/ jar 的情况下都可以调试。</p>
<p><strong>案例1</strong></p>
<p>我手里有一个可部署的war包，没有源码，在远程已经部署完毕。这时我想调试那个远程应用，怎么做呢？</p>
<p>解压缩war包到一个文件夹，然后用Intellij Idea打开这个文件夹，如图的结构，编译的Class都在 WEB-INF/classes 目录下</p>
<p>找到我要debug的那个class, 这里示例Handler.class, 通过Idea反编译出来的类代码，拷贝到一个新的文件Handler.java</p>
<p>虽然如图可以看到各种的编译错误，但是完全不影响你启动，代码中加断点和调试哦。</p>
<pre><code>remote JVM Debug -&gt; attach to remote JVM -&gt;  socket -&gt; host -&gt; port -&gt; moduleClassPath
</code></pre>
<h1 id="远程jvm调试怎么工作的"><a class="header" href="#远程jvm调试怎么工作的">远程JVM调试怎么工作的</a></h1>
<p>一切源于被称作 Agents 的东西。</p>
<p>运行着各种编译过的 .class 文件的JVM， 有一种特性，可以允许外部的库（Java或C++写的libraries）在运行时注入到 JVM 中。这些外部的库就称作 Agents, 他们有能力修改运行中 .class 文件的内容。</p>
<p>这些 Agents 拥有的这些 JVM 的功能权限， 是在 JVM 内运行的 Java Code 所无法获取的， 他们能用来做一些有趣的事情，比如修改运行中的源码， 性能分析等。 像 JRebel 工具就是用了这些功能达到魔术般的效果。</p>
<p>传递一个 Agent Lib 给 JVM, 通过添加 agentlib:libname[=options] 格式的启动参数即可办到。像上面的远程调试我们用的就是 **-agentlib:jdwp=... **来引入 jdwp 这个 Agent 的。</p>
<p>jdwp 是一个 JVM 特定的 JDWP（Java Debug Wire Protocol） 可选实现，用来定义调试者与运行JVM之间的通讯，它的是通过 JVM 本地库的 jdwp.so 或者 jdwp.dll 支持实现的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addshutdownhook钩子函数"><a class="header" href="#addshutdownhook钩子函数">addShutdownHook钩子函数</a></h1>
<pre><code class="language-java">import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * 体验 Java 优雅停服
 *
 * @author 一猿小讲
 */
public class Application {

    /**
     * 监控服务
     */
    private ScheduledThreadPoolExecutor monitorService;

    public Application() {
        monitorService = new ScheduledThreadPoolExecutor(1);
    }

    /**
     * 启动监控服务，监控一下内存信息
     */
    public void start() {
        System.out.println(String.format(&quot;启动监控服务 %s&quot;, Thread.currentThread().getId()));
        monitorService.scheduleWithFixedDelay(new Runnable() {
            @Override
            public void run() {
                System.out.println(String.format(&quot;最大内存: %dm  已分配内存: %dm  已分配内存中的剩余空间: %dm  最大可用内存: %dm&quot;,
                        Runtime.getRuntime().maxMemory() / 1024 / 1024,
                        Runtime.getRuntime().totalMemory() / 1024 / 1024,
                        Runtime.getRuntime().freeMemory() / 1024 / 1024,
                        (Runtime.getRuntime().maxMemory() - Runtime.getRuntime().totalMemory() +
                                Runtime.getRuntime().freeMemory()) / 1024 / 1024));
            }
        }, 2, 2, TimeUnit.SECONDS);
    }

    /**
     * 释放资源（代码来源于 flume 源码）
     * 主要用于关闭线程池（看不懂的同学莫纠结，当做黑盒去对待）
     */
    public void stop() {
        System.out.println(String.format(&quot;开始关闭线程池 %s&quot;, Thread.currentThread().getId()));
        if (monitorService != null) {
            monitorService.shutdown();
            try {
                monitorService.awaitTermination(10, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                System.err.println(&quot;Interrupted while waiting for monitor service to stop&quot;);
            }
            if (!monitorService.isTerminated()) {
                monitorService.shutdownNow();
                try {
                    while (!monitorService.isTerminated()) {
                        monitorService.awaitTermination(10, TimeUnit.SECONDS);
                    }
                } catch (InterruptedException e) {
                    System.err.println(&quot;Interrupted while waiting for monitor service to stop&quot;);
                }
            }
        }
        System.out.println(String.format(&quot;线程池关闭完成 %s&quot;, Thread.currentThread().getId()));
    }

    /**
     * 应用入口
     */
    public static void main(String[] args) {
        Application application = new Application();
        // 启动服务（每隔一段时间监控输出一下内存信息）
        application.start();

        // 添加钩子，实现优雅停服（主要验证钩子的作用）
        final Application appReference = application;
        Runtime.getRuntime().addShutdownHook(new Thread(&quot;shutdown-hook&quot;) {
            @Override
            public void run() {
                System.out.println(&quot;接收到退出的讯号，开始打扫战场，释放资源，完成优雅停服&quot;);
                appReference.stop();
            }
        });
        System.out.println(&quot;服务启动完成&quot;);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jvm内存区域概览"><a class="header" href="#jvm内存区域概览">JVM内存区域概览</a></h1>
<p>JVM区域总体分两类，heap区和非heap区</p>
<p><strong>Heap区又分为：年轻代（Young Generation）和老年代（Old Generation）。</strong></p>
<p>年轻代是所有新对象产生的地方。当年轻代内存空间被用完时，就会触发垃圾回收。这个垃圾回收叫做Minor GC。</p>
<p>年轻代被分为3个部分—Eden区和两个Survivor区。</p>
<p>老年代内存里包含了长期存活的对象和经过多次Minor GC后依然存活下来的对象，通常会在老年代内存被占满时进行垃圾回收。老年代的垃圾收集叫做Major GC，Major GC通常是跟full GC是等价的，收集整个GC堆。</p>
<ul>
<li>Eden Space（伊甸园）；</li>
<li>Survivor Space(2个幸存者区)；</li>
<li>Old Gen（老年代）；</li>
</ul>
<p>非Heap区又分：</p>
<ul>
<li>Code Cache(代码缓存区)；</li>
<li>Perm Gen（永久代）；JDK1.8之后被元空间替代；Perm Gen全称是Permanent Generation space，称之为永久代，其实指的就是这个方法区。</li>
<li>Jvm Stack(java虚拟机栈)；</li>
<li>Local Method Statck(本地方法栈)；</li>
</ul>
<p><img src="8.jvm_jvm%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90//images/jvm_memory_structure.jpg" alt="" /></p>
<h1 id="查看java堆的详细信息"><a class="header" href="#查看java堆的详细信息">查看java堆的详细信息</a></h1>
<p>jmap是JDK自带的工具软件，主要用于打印指定Java进程(或核心文件、远程调试服务器)的共享对象内存映射或堆内存细节。</p>
<pre><code>jmap -heap &lt;PID&gt;
</code></pre>
<p><strong>输出</strong></p>
<pre><code>Attaching to process ID 8126, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.282-b08

using thread-local object allocation.
Parallel GC with 8 thread(s) //GC 方式

Heap Configuration:  //堆内存初始化配置
   MinHeapFreeRatio         = 0   //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)
   MaxHeapFreeRatio         = 100 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)
   MaxHeapSize              = 2030043136 (1936.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小
   NewSize                  = 42467328 (40.5MB) //对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小
   MaxNewSize               = 676331520 (645.0MB) //对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小
   OldSize                  = 85458944 (81.5MB) //对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小
   NewRatio                 = 2  //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率
   SurvivorRatio            = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值
   MetaspaceSize            = 21807104 (20.796875MB)  //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小
   CompressedClassSpaceSize = 1073741824 (1024.0MB) 
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)

Heap Usage://堆内存使用情况
PS Young Generation
Eden Space: //Eden区内存分布
   capacity = 31981568 (30.5MB) //Eden区总容量
   used     = 639640 (0.6100082397460938MB) //Eden区已使用
   free     = 31341928 (29.889991760253906MB) //Eden区剩余容量
   2.000027015560963% used  //Eden区使用比率
From Space: //其中一个Survivor区的内存分布
   capacity = 5242880 (5.0MB)
   used     = 0 (0.0MB)
   free     = 5242880 (5.0MB)
   0.0% used
To Space:  //另一个Survivor区的内存分布
   capacity = 5242880 (5.0MB)
   used     = 0 (0.0MB)
   free     = 5242880 (5.0MB)
   0.0% used
PS Old Generation //当前的Old区内存分布
   capacity = 85458944 (81.5MB)
   used     = 0 (0.0MB)
   free     = 85458944 (81.5MB)
   0.0% used

710 interned Strings occupying 47296 bytes.
*
</code></pre>
<h1 id="查看堆内存histogram中的对象数量及大小"><a class="header" href="#查看堆内存histogram中的对象数量及大小">查看堆内存(histogram)中的对象数量及大小</a></h1>
<pre><code> jmap -histo 3331
</code></pre>
<p>num #instances #bytes class name</p>
<p>编号 个数 字节 类名</p>
<h1 id="将内存使用的详细情况输出到文件"><a class="header" href="#将内存使用的详细情况输出到文件">将内存使用的详细情况输出到文件</a></h1>
<p><strong>导出</strong></p>
<pre><code> jmap -dump:format=b,live,file=heapDump 6900
</code></pre>
<p><em>live</em> 只导出存活对象 会主动触发一次GC</p>
<p><strong>查看</strong></p>
<pre><code> jhat -port 5000 heapDump 
</code></pre>
<p><a href="https://cloud.tencent.com/developer/article/1408827"><strong>CompressedClassSpace详见</strong></a></p>
<h1 id="使用-matmemoryanalyzertool作为-堆中内存对象分析工具"><a class="header" href="#使用-matmemoryanalyzertool作为-堆中内存对象分析工具">使用 MAT（MemoryAnalyzerTool）作为 堆中内存对象分析工具</a></h1>
<h1 id="后记"><a class="header" href="#后记">后记</a></h1>
<p>可以使用 对象查询语言 对象进行分析</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="快速安装"><a class="header" href="#快速安装">快速安装</a></h3>
<pre><code>curl -O https://arthas.aliyun.com/arthas-boot.jar
java -jar arthas-boot.jar
</code></pre>
<h2 id="一键安装"><a class="header" href="#一键安装">一键安装</a></h2>
<pre><code>curl -L https://arthas.aliyun.com/install.sh | sh
</code></pre>
<h2 id="全量安装"><a class="header" href="#全量安装">全量安装</a></h2>
<pre><code class="language-java">https://archiva-maven-storage-prod.oss-cn-beijing.aliyuncs.com/repository/central/com/taobao/arthas/arthas-packaging/3.6.1/arthas-packaging-3.6.1-bin.zip?Expires=1652839996&amp;OSSAccessKeyId=LTAIfU51SusnnfCC&amp;Signature=DrOrNOwZArUvnI5ljtI14IJfE6c%3D
</code></pre>
<p>解压后，在文件夹里有<code>arthas-boot.jar</code>，直接用<code>java -jar</code>的方式启动：</p>
<h3 id="打印帮助信息"><a class="header" href="#打印帮助信息">打印帮助信息</a></h3>
<pre><code class="language-sh">java -jar arthas-boot.jar -h
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="启动game"><a class="header" href="#启动game">启动Game</a></h2>
<pre><code>curl -O https://arthas.aliyun.com/math-game.jar
java -jar math-game.jar
</code></pre>
<h2 id="启动arthas"><a class="header" href="#启动arthas">启动arthas</a></h2>
<pre><code class="language-java">curl -O https://arthas.aliyun.com/arthas-boot.jar
java -jar arthas-boot.jar
</code></pre>
<ul>
<li>执行该程序的用户需要和目标进程具有相同的权限。比如以<code>admin</code>用户来执行：<code>sudo su admin &amp;&amp; java -jar arthas-boot.jar</code> 或 <code>sudo -u admin -EH java -jar arthas-boot.jar</code>。</li>
<li>如果attach不上目标进程，可以查看<code>~/logs/arthas/</code> 目录下的日志。</li>
<li>如果下载速度比较慢，可以使用aliyun的镜像：<code>java -jar arthas-boot.jar --repo-mirror aliyun --use-http</code></li>
<li><code>java -jar arthas-boot.jar -h</code> 打印更多参数信息。</li>
</ul>
<p>选择java进程</p>
<h2 id="查看dashboard"><a class="header" href="#查看dashboard">查看dashboard</a></h2>
<p>输入<a href="https://arthas.aliyun.com/doc/dashboard.html">dashboard</a>，按<code>回车/enter</code>，会展示当前进程的信息，按<code>ctrl+c</code>可以中断执行。</p>
<h2 id="线程mainclass"><a class="header" href="#线程mainclass">线程MainClass</a></h2>
<p><code>thread 1</code>会打印线程ID 1的栈，通常是main函数的线程。</p>
<pre><code>
$ thread 1 | grep 'main('
    at demo.MathGame.main(MathGame.java:17)
</code></pre>
<h2 id="通过jad来反编译main-class"><a class="header" href="#通过jad来反编译main-class">通过jad来反编译Main Class</a></h2>
<pre><code>jad demo.MathGame
</code></pre>
<h2 id="watch"><a class="header" href="#watch">watch</a></h2>
<pre><code>通过watch命令来查看demo.MathGame#primeFactors函数的返回值：
</code></pre>
<p>更多的功能可以查看<a href="https://arthas.aliyun.com/doc/advanced-use.html">进阶使用</a>。</p>
<h2 id="退出arthas"><a class="header" href="#退出arthas">退出arthas</a></h2>
<p>如果只是退出当前的连接，可以用<code>quit</code>或者<code>exit</code>命令。Attach到目标进程上的arthas还会继续运行，端口会保持开放，下次连接时可以直接连接上。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="基础命令"><a class="header" href="#基础命令">基础命令</a></h2>
<ul>
<li>help——查看命令帮助信息</li>
<li><a href="https://arthas.aliyun.com/doc/cat.html">cat</a>——打印文件内容，和linux里的cat命令类似</li>
<li><a href="https://arthas.aliyun.com/doc/echo.html">echo</a>–打印参数，和linux里的echo命令类似</li>
<li><a href="https://arthas.aliyun.com/doc/grep.html">grep</a>——匹配查找，和linux里的grep命令类似</li>
<li><a href="https://arthas.aliyun.com/doc/base64.html">base64</a>——base64编码转换，和linux里的base64命令类似</li>
<li><a href="https://arthas.aliyun.com/doc/tee.html">tee</a>——复制标准输入到标准输出和指定的文件，和linux里的tee命令类似</li>
<li><a href="https://arthas.aliyun.com/doc/pwd.html">pwd</a>——返回当前的工作目录，和linux命令类似</li>
<li>cls——清空当前屏幕区域</li>
<li>session——查看当前会话的信息</li>
<li><a href="https://arthas.aliyun.com/doc/reset.html">reset</a>——重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端关闭时会重置所有增强过的类</li>
<li>version——输出当前目标 Java 进程所加载的 Arthas 版本号</li>
<li>history——打印命令历史</li>
<li>quit——退出当前 Arthas 客户端，其他 Arthas 客户端不受影响</li>
<li>stop——关闭 Arthas 服务端，所有 Arthas 客户端全部退出</li>
<li><a href="https://arthas.aliyun.com/doc/keymap.html">keymap</a>——Arthas快捷键列表及自定义快捷键</li>
</ul>
<h2 id="jvm相关"><a class="header" href="#jvm相关">jvm相关</a></h2>
<ul>
<li><a href="https://arthas.aliyun.com/doc/dashboard.html">dashboard</a>——当前系统的实时数据面板</li>
<li><a href="https://arthas.aliyun.com/doc/thread.html">thread</a>——查看当前 JVM 的线程堆栈信息</li>
<li><a href="https://arthas.aliyun.com/doc/jvm.html">jvm</a>——查看当前 JVM 的信息</li>
<li><a href="https://arthas.aliyun.com/doc/sysprop.html">sysprop</a>——查看和修改JVM的系统属性</li>
<li><a href="https://arthas.aliyun.com/doc/sysenv.html">sysenv</a>——查看JVM的环境变量</li>
<li><a href="https://arthas.aliyun.com/doc/vmoption.html">vmoption</a>——查看和修改JVM里诊断相关的option</li>
<li><a href="https://arthas.aliyun.com/doc/perfcounter.html">perfcounter</a>——查看当前 JVM 的Perf Counter信息</li>
<li><a href="https://arthas.aliyun.com/doc/logger.html">logger</a>——查看和修改logger</li>
<li><a href="https://arthas.aliyun.com/doc/getstatic.html">getstatic</a>——查看类的静态属性</li>
<li><a href="https://arthas.aliyun.com/doc/ognl.html">ognl</a>——执行ognl表达式</li>
<li><a href="https://arthas.aliyun.com/doc/mbean.html">mbean</a>——查看 Mbean 的信息</li>
<li><a href="https://arthas.aliyun.com/doc/heapdump.html">heapdump</a>——dump java heap, 类似jmap命令的heap dump功能</li>
<li><a href="https://arthas.aliyun.com/doc/vmtool.html">vmtool</a>——从jvm里查询对象，执行forceGc</li>
</ul>
<h2 id="classclassloader相关"><a class="header" href="#classclassloader相关">class/classloader相关</a></h2>
<ul>
<li><a href="https://arthas.aliyun.com/doc/sc.html">sc</a>——查看JVM已加载的类信息</li>
<li><a href="https://arthas.aliyun.com/doc/sm.html">sm</a>——查看已加载类的方法信息</li>
<li><a href="https://arthas.aliyun.com/doc/jad.html">jad</a>——反编译指定已加载类的源码</li>
<li><a href="https://arthas.aliyun.com/doc/mc.html">mc</a>——内存编译器，内存编译<code>.java</code>文件为<code>.class</code>文件</li>
<li><a href="https://arthas.aliyun.com/doc/retransform.html">retransform</a>——加载外部的<code>.class</code>文件，retransform到JVM里</li>
<li><a href="https://arthas.aliyun.com/doc/redefine.html">redefine</a>——加载外部的<code>.class</code>文件，redefine到JVM里</li>
<li><a href="https://arthas.aliyun.com/doc/dump.html">dump</a>——dump 已加载类的 byte code 到特定目录</li>
<li><a href="https://arthas.aliyun.com/doc/classloader.html">classloader</a>——查看classloader的继承树，urls，类加载信息，使用classloader去getResource</li>
</ul>
<h2 id="monitorwatchtrace相关"><a class="header" href="#monitorwatchtrace相关">monitor/watch/trace相关</a></h2>
<blockquote>
<p>请注意，这些命令，都通过字节码增强技术来实现的，会在指定类的方法中插入一些切面来实现数据统计和观测，因此在线上、预发使用时，请尽量明确需要观测的类、方法以及条件，诊断结束要执行 <code>stop</code> 或将增强过的类执行 <code>reset</code> 命令。</p>
</blockquote>
<ul>
<li><a href="https://arthas.aliyun.com/doc/monitor.html">monitor</a>——方法执行监控</li>
<li><a href="https://arthas.aliyun.com/doc/watch.html">watch</a>——方法执行数据观测</li>
<li><a href="https://arthas.aliyun.com/doc/trace.html">trace</a>——方法内部调用路径，并输出方法路径上的每个节点上耗时</li>
<li><a href="https://arthas.aliyun.com/doc/stack.html">stack</a>——输出当前方法被调用的调用路径</li>
<li><a href="https://arthas.aliyun.com/doc/tt.html">tt</a>——方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</li>
</ul>
<h2 id="profiler火焰图"><a class="header" href="#profiler火焰图">profiler/火焰图</a></h2>
<ul>
<li><a href="https://arthas.aliyun.com/doc/profiler.html">profiler</a>–使用<a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a>对应用采样，生成火焰图</li>
</ul>
<h2 id="鉴权"><a class="header" href="#鉴权">鉴权</a></h2>
<ul>
<li><a href="https://arthas.aliyun.com/doc/auth.html">auth</a>–鉴权</li>
</ul>
<h2 id="options"><a class="header" href="#options">options</a></h2>
<ul>
<li><a href="https://arthas.aliyun.com/doc/options.html">options</a>——查看或设置Arthas全局开关</li>
</ul>
<h2 id="管道"><a class="header" href="#管道">管道</a></h2>
<p>Arthas支持使用管道对上述命令的结果进行进一步的处理，如<code>sm java.lang.String * | grep 'index'</code></p>
<ul>
<li>grep——搜索满足条件的结果</li>
<li>plaintext——将命令的结果去除ANSI颜色</li>
<li>wc——按行统计输出结果</li>
</ul>
<h2 id="后台异步任务"><a class="header" href="#后台异步任务">后台异步任务</a></h2>
<p>当线上出现偶发的问题，比如需要watch某个条件，而这个条件一天可能才会出现一次时，异步后台任务就派上用场了，详情请参考<a href="https://arthas.aliyun.com/doc/async.html">这里</a></p>
<ul>
<li>使用 &gt; 将结果重写向到日志文件，使用 &amp; 指定命令是后台运行，session断开不影响任务执行（生命周期默认为1天）</li>
<li>jobs——列出所有job</li>
<li>kill——强制终止任务</li>
<li>fg——将暂停的任务拉到前台执行</li>
<li>bg——将暂停的任务放到后台执行</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="arthas-tunnel"><a class="header" href="#arthas-tunnel">Arthas Tunnel</a></h2>
<p>通过Arthas Tunnel Server/Client 来远程管理/连接多个Agent。</p>
<p>比如，在流式计算里，Java进程可以是在不同的机器启动的，想要使用Arthas去诊断会比较麻烦，因为用户通常没有机器的权限，即使登陆机器也分不清是哪个Java进程。</p>
<p>在这种情况下，可以使用Arthas Tunnel Server/Client。</p>
<h2 id="下载部署arthas-tunnel-server"><a class="header" href="#下载部署arthas-tunnel-server">下载部署arthas tunnel server</a></h2>
<p>https://github.com/alibaba/arthas/releases</p>
<ul>
<li>从Maven仓库下载：<a href="https://arthas.aliyun.com/download/arthas-tunnel-server/latest_version?mirror=aliyun"><img src="https://img.shields.io/maven-central/v/com.taobao.arthas/arthas-packaging.svg?style=flat-square" alt="Arthas" /></a></li>
<li>从Github Releases页下载： https://github.com/alibaba/arthas/releases</li>
</ul>
<p>Arthas tunnel server是一个spring boot fat jar应用，直接<code>java -jar</code>启动：</p>
<pre><code>java -jar  arthas-tunnel-server.jar
</code></pre>
<p>默认情况下，arthas tunnel server的web端口是<code>8080</code>，arthas agent连接的端口是<code>7777</code>。</p>
<p>启动之后，可以访问 http://127.0.0.1:8080/ ，再通过<code>agentId</code>连接到已注册的arthas agent上。</p>
<p>通过Spring Boot的Endpoint，可以查看到具体的连接信息： http://127.0.0.1:8080/actuator/arthas ，登陆用户名是<code>arthas</code>，密码在arthas tunnel server的日志里可以找到，比如：</p>
<pre><code>32851 [main] INFO  o.s.b.a.s.s.UserDetailsServiceAutoConfiguration

Using generated security password: f1dca050-3777-48f4-a577-6367e55a78a2
</code></pre>
<h2 id="启动arthas时连接到tunnel-server"><a class="header" href="#启动arthas时连接到tunnel-server">启动arthas时连接到tunnel server</a></h2>
<p>在启动arthas，可以传递<code>--tunnel-server</code>参数，比如：</p>
<pre><code>as.sh --tunnel-server 'ws://127.0.0.1:7777/ws'
</code></pre>
<pre><code>as.sh --tunnel-server 'ws://47.75.156.201:80/ws'
</code></pre>
<ul>
<li>如果有特殊需求，可以通过<code>--agent-id</code>参数里指定agentId。默认情况下，会生成随机ID。</li>
</ul>
<p>attach成功之后，会打印出agentId，比如：</p>
<p>如果是启动时没有连接到 tunnel server，也可以在后续自动重连成功之后，通过 session命令来获取 agentId：</p>
<p>以上面的为例，在浏览器里访问 http://47.75.156.201/arthas/?port=80 ，输入 <code>agentId</code>，就可以连接到本机上的arthas了。</p>
<h2 id="最佳实践"><a class="header" href="#最佳实践">最佳实践</a></h2>
<blockquote>
<p>注意，agentId要保持唯一，否则会在tunnel server上冲突，不能正常工作。</p>
</blockquote>
<p>如果 arthas agent配置了 <code>appName</code>，则生成的agentId会带上<code>appName</code>的前缀。</p>
<p>比如在加上启动参数：<code>as.sh --tunnel-server 'ws://127.0.0.1:7777/ws' --app-name demoapp</code> ，则生成的agentId可能是<code>demoapp_URJZ5L48RPBR2ALI5K4V</code>。</p>
<p>Tunnel server会以<code>_</code>做分隔符，提取出<code>appName</code>，方便按应用进行管理。</p>
<blockquote>
<p>另外，也可以在解压的arthas目录下的 <code>arthas.properties</code>，或者在spring boot应用的<code>application.properties</code>里配置<code>appName</code>。</p>
</blockquote>
<h2 id="tunnel-server的管理页面"><a class="header" href="#tunnel-server的管理页面">Tunnel Server的管理页面</a></h2>
<p>在本地启动tunnel-server，然后使用<code>as.sh</code> attach，并且指定应用名<code>--app-name test</code>：</p>
<p>http://localhost:8080/apps.html</p>
<h2 id="权限管理"><a class="header" href="#权限管理">权限管理</a></h2>
<p>目前tunnel server没有专门的权限管理，用户需要自行开发，对app name鉴权。</p>
<h2 id="集群方式管理"><a class="header" href="#集群方式管理">集群方式管理</a></h2>
<p>如果希望部署多台 tunnel server，可以通过nginx做转发，redis来保存agent信息。</p>
<ul>
<li>nginx需要配置sticky session，保证用户web socket连接到同一个后端tunnel server上。简单的配置方式是用<code>ip_hash</code>。</li>
</ul>
<h2 id="arthas-tunnel-server的工作原理"><a class="header" href="#arthas-tunnel-server的工作原理">Arthas tunnel server的工作原理</a></h2>
<pre><code>browser &lt;-&gt; arthas tunnel server &lt;-&gt; arthas tunnel client &lt;-&gt; arthas agent
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="idea-plugin"><a class="header" href="#idea-plugin">IDEA Plugin</a></h1>
<h2 id="arthas-idea部分命令可视化"><a class="header" href="#arthas-idea部分命令可视化">Arthas-idea（部分命令可视化）</a></h2>
<ul>
<li>Jetbrains 插件获取地址： https://plugins.jetbrains.com/plugin/13581-arthas-idea</li>
<li>使用文档：https://www.yuque.com/arthas-idea-plugin</li>
<li>源码地址： https://github.com/WangJi92/arthas-idea-plugin</li>
</ul>
<h2 id="alibaba-cloud-toolkit-热部署组件一键retransform"><a class="header" href="#alibaba-cloud-toolkit-热部署组件一键retransform">Alibaba Cloud Toolkit 热部署组件（一键retransform）</a></h2>
<blockquote>
<p>热部署组件支持一键将编辑器中修改的 Java 源码快速编译，并更新到远端应用服务中，免去手动 dump、mc 的过程。此外，也可以一键还原 retransform 的类文件。</p>
</blockquote>
<ul>
<li>Jetbrains 插件获取地址： https://plugins.jetbrains.com/plugin/11386-alibaba-cloud-toolkit</li>
<li>使用文档：https://help.aliyun.com/document_detail/381077.html</li>
<li>联系我们：请加Alibaba Cloud Toolkit (应用观测器) 钉钉用户交流群（群号：<strong>34965379</strong>）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="以java-agent的方式启动"><a class="header" href="#以java-agent的方式启动">以Java Agent的方式启动</a></h1>
<p>通常Arthas是以动态attach的方式来诊断应用，但从<code>3.2.0</code>版本起，Arthas支持直接以 java agent的方式启动。</p>
<p>比如下载全量的arthas zip包，解压之后以 <code>-javaagent</code> 的参数指定<code>arthas-agent.jar</code>来启动：</p>
<h3 id="全量包下载"><a class="header" href="#全量包下载">全量包下载</a></h3>
<pre><code>https://archiva-maven-storage-prod.oss-cn-beijing.aliyuncs.com/repository/central/com/taobao/arthas/arthas-packaging/3.6.1/arthas-packaging-3.6.1-bin.zip?Expires=1652839996&amp;OSSAccessKeyId=LTAIfU51SusnnfCC&amp;Signature=DrOrNOwZArUvnI5ljtI14IJfE6c%3D
</code></pre>
<h4 id="目录结构"><a class="header" href="#目录结构">目录结构</a></h4>
<pre><code>lib               
async-profiler  :
as-service.bat  
arthas-spy.jar     
arthas-core.jar    
arthas-boot.jar   
arthas-tunnel-server.jar
logback.xml    
install-local.sh  
as.sh           
as.bat          
arthas.properties  
arthas-client.jar  
arthas-agent.jar
</code></pre>
<h2 id="idea-remote-target以javaagent启动"><a class="header" href="#idea-remote-target以javaagent启动">IDEA remote target以JavaAgent启动</a></h2>
<p><strong>JVM参数配置如下</strong></p>
<pre><code>-javaagent:&quot;/Users/weisanju/IdeaProjects/QualityCheckServiceCustomerPrivate/extralib/arthas-agent.jar=/root/arthas/arthas-core.jar;&quot; -Darthas.httpPort=8563 -Darthas.ip=127.0.0.1  -Darthas.appName=xjq -Darthas.tunnelServer=ws://t227:7777/ws
</code></pre>
<p>其中</p>
<ol>
<li>/Users/weisanju/IdeaProjects/QualityCheckServiceCustomerPrivate/extralib/arthas-agent.jar 表示本机的 arthas-agent jar地址</li>
<li>=/root/arthas/arthas-core.jar; 表示远程地址core 包地址。注意 arthas-spy.jar     包 也必须要在 此目录</li>
<li>-Darthas.httpPort=8563 -Darthas.ip=127.0.0.1  -Darthas.appName=xjq 配置基本属性</li>
<li>-Darthas.appName=xjq -Darthas.tunnelServer=ws://t227:7777/ws 表示 tunnel server的配置、</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="火焰图"><a class="header" href="#火焰图">火焰图</a></h2>
<p>软件的性能分析，往往需要查看 CPU 耗时，了解瓶颈在哪里。</p>
<p><a href="http://www.brendangregg.com/flamegraphs.html">火焰图</a>（flame graph）是性能分析的利器。本文介绍它的基本用法。</p>
<h3 id="一perf-命令"><a class="header" href="#一perf-命令">一、perf 命令</a></h3>
<p>让我们从 perf 命令（performance 的缩写）讲起，它是 Linux 系统原生提供的性能分析工具，会返回 CPU 正在执行的函数名以及调用栈（stack）。</p>
<p>通常，它的执行频率是 99Hz（每秒99次），如果99次都返回同一个函数名，那就说明 CPU 这一秒钟都在执行同一个函数，可能存在性能问题。</p>
<blockquote>
<pre><code class="language-bash">$ sudo perf record -F 99 -p 13204 -g -- sleep 30
</code></pre>
</blockquote>
<p>上面的代码中，<code>perf record</code>表示记录，<code>-F 99</code>表示每秒99次，<code>-p 13204</code>是进程号，即对哪个进程进行分析，<code>-g</code>表示记录调用栈，<code>sleep 30</code>则是持续30秒。</p>
<p>运行后会产生一个庞大的文本文件。如果一台服务器有16个 CPU，每秒抽样99次，持续30秒，就得到 47,520 个调用栈，长达几十万甚至上百万行。</p>
<p>为了便于阅读，<code>perf record</code>命令可以统计每个调用栈出现的百分比，然后从高到低排列。</p>
<blockquote>
<pre><code class="language-bash">$ sudo perf report -n --stdio
</code></pre>
</blockquote>
<p>这个结果还是不易读，所以才有了火焰图。</p>
<p>火焰图是基于 perf 结果产生的 <a href="http://queue.acm.org/downloads/2016/Gregg4.svg">SVG 图片</a>，用来展示 CPU 的调用栈。</p>
<p>y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p>
<p>x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p>
<p><strong>火焰图就是看顶层的哪个函数占据的宽度最大。只要有&quot;平顶&quot;（plateaus），就表示该函数可能存在性能问题。</strong></p>
<p>颜色没有特殊含义，因为火焰图表示的是 CPU 的繁忙程度，所以一般选择暖色调。</p>
<h3 id="三互动性"><a class="header" href="#三互动性">三、互动性</a></h3>
<p>火焰的每一层都会标注函数名，鼠标悬浮时会显示完整的函数名、抽样抽中的次数、占据总抽样次数的百分比。下面是一个例子。</p>
<blockquote>
<pre><code class="language-javascript">mysqld'JOIN::exec (272,959 samples, 78.34 percent)
</code></pre>
</blockquote>
<p>按下 Ctrl + F 会显示一个搜索框，用户可以输入关键词或正则表达式，所有符合条件的函数名会高亮显示。</p>
<h3 id="火焰图示例"><a class="header" href="#火焰图示例">火焰图示例</a></h3>
<pre><code class="language-javascript">func_c 
func_b 
func_a 
start_thread 

func_d 
func_a 
start_thread 

func_d 
func_a 
start_thread
</code></pre>
<p>上面代码中，<code>start_thread</code>是启动线程，调用了<code>func_a</code>。后者又调用了<code>func_b</code>和<code>func_d</code>，而<code>func_b</code>又调用了<code>func_c</code>。</p>
<p>经过合并处理后，得到了下面的结果，即存在两个调用栈，第一个调用栈抽中1次，第二个抽中2次。</p>
<blockquote>
<pre><code class="language-javascript">start_thread;func_a;func_b;func_c 1 
start_thread;func_a;func_d 2
</code></pre>
</blockquote>
<p><img src="9.jvm_Arthas/../../images/bg2017092504.png" alt="img" /></p>
<pre><code>上面图片中，最顶层的函数`g()`占用 CPU 时间最多。`d()`的宽度最大，但是它直接耗用 CPU 的部分很少。

`b()`和`c()`没有直接消耗 CPU。因此，如果要调查性能问题，首先应该调查`g()`，其次是`i()`。

另外，从图中可知a()有两个分支b()和h()，这表明a()里面可能有一个条件语句，而b()分支消耗的 CPU 大大高于h()。

</code></pre>
<h3 id="局限"><a class="header" href="#局限">局限</a></h3>
<p>两种情况下，无法画出火焰图，需要修正系统行为。</p>
<p><strong>（1）调用栈不完整</strong></p>
<p>当调用栈过深时，某些系统只返回前面的一部分（比如前10层）。</p>
<p><strong>（2）函数名缺失</strong></p>
<p>有些函数没有名字，编译器只用内存地址来表示（比如匿名函数）。</p>
<h3 id="node-应用的火焰图"><a class="header" href="#node-应用的火焰图">Node 应用的火焰图</a></h3>
<p>Node 应用的火焰图就是对 Node 进程进行性能抽样，与其他应用的操作是一样的。</p>
<blockquote>
<pre><code class="language-bash">$ perf record -F 99 -p `pgrep -n node` -g -- sleep 30
</code></pre>
</blockquote>
<h3 id="浏览器的火焰图"><a class="header" href="#浏览器的火焰图">浏览器的火焰图</a></h3>
<p>Chrome 浏览器可以生成页面脚本的火焰图，用来进行 CPU 分析。</p>
<p>打开开发者工具，切换到 Performance 面板。然后，点击&quot;录制&quot;按钮，开始记录数据。这时，可以在页面进行各种操作，然后停止&quot;录制&quot;。</p>
<p>这时，开发者工具会显示一个时间轴。它的下方就是火焰图。</p>
<p>浏览器的火焰图与标准火焰图有两点差异：它是倒置的（即调用栈最顶端的函数在最下方）；x 轴是时间轴，而不是抽样次数。</p>
<h2 id="arthas生成火焰图"><a class="header" href="#arthas生成火焰图">Arthas生成火焰图</a></h2>
<p><code>profiler</code> 命令支持生成应用热点的火焰图。本质上是通过不断的采样，然后把收集到的采样结果生成火焰图。</p>
<h3 id="命令"><a class="header" href="#命令">命令</a></h3>
<pre><code>profiler` 命令基本运行结构是 `profiler action [actionArg]
</code></pre>
<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody>
<tr><td><em>action</em></td><td>要执行的操作</td></tr>
<tr><td><em>actionArg</em></td><td>属性名模式</td></tr>
<tr><td>[i:]</td><td>采样间隔（单位：ns）（默认值：10'000'000，即10 ms）</td></tr>
<tr><td>[f:]</td><td>将输出转储到指定路径</td></tr>
<tr><td>[d:]</td><td>运行评测指定秒</td></tr>
<tr><td>[e:]</td><td>要跟踪哪个事件（cpu, alloc, lock, cache-misses等），默认是cpu</td></tr>
</tbody></table>
<h3 id="启动profiler"><a class="header" href="#启动profiler">启动profiler</a></h3>
<pre><code>$ profiler start
Started [cpu] profiling
</code></pre>
<h3 id="获取已采集的sample的数量"><a class="header" href="#获取已采集的sample的数量">获取已采集的sample的数量</a></h3>
<pre><code>$ profiler getSamples
23
</code></pre>
<h3 id="查看profiler状态"><a class="header" href="#查看profiler状态">查看profiler状态</a></h3>
<pre><code>$ profiler status
[cpu] profiling is running for 4 seconds
</code></pre>
<p>可以查看当前profiler在采样哪种<code>event</code>和采样时间。</p>
<h3 id="停止profiler"><a class="header" href="#停止profiler">停止profiler</a></h3>
<h4 id="生成html格式结果"><a class="header" href="#生成html格式结果">生成html格式结果</a></h4>
<p>默认情况下，结果文件是<code>html</code>格式，也可以用<code>--format</code>参数指定：</p>
<pre><code>$ profiler stop --format html
profiler output file: /tmp/test/arthas-output/20211207-111550.html
OK
</code></pre>
<p>或者在<code>--file</code>参数里用文件名指名格式。比如<code>--file /tmp/result.html</code> 。</p>
<h3 id="通过浏览器查看arthas-output下面的profiler结果"><a class="header" href="#通过浏览器查看arthas-output下面的profiler结果">通过浏览器查看arthas-output下面的profiler结果</a></h3>
<p>默认情况下，arthas使用3658端口，则可以打开： http://localhost:3658/arthas-output/ 查看到<code>arthas-output</code>目录下面的profiler结果：</p>
<h3 id="profiler支持的events"><a class="header" href="#profiler支持的events">profiler支持的events</a></h3>
<p>在不同的平台，不同的OS下面，支持的events各有不同。比如在macos下面：</p>
<pre><code>$ profiler list
Basic events:
  cpu
  alloc
  lock
  wall
  itimer
</code></pre>
<p>在linux下面</p>
<pre><code>$ profiler list
Basic events:
  cpu
  alloc
  lock
  wall
  itimer
Perf events:
  page-faults
  context-switches
  cycles
  instructions
  cache-references
  cache-misses
  branches
  branch-misses
  bus-cycles
  L1-dcache-load-misses
  LLC-load-misses
  dTLB-load-misses
  mem:breakpoint
  trace:tracepoint
</code></pre>
<p>如果遇到OS本身的权限/配置问题，然后缺少部分event，可以参考<code>async-profiler</code>本身文档：<a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a></p>
<p>可以用<code>--event</code>参数指定要采样的事件，比如对<code>alloc</code>事件进入采样：</p>
<pre><code>$ profiler start --event alloc
</code></pre>
<h3 id="恢复采样"><a class="header" href="#恢复采样">恢复采样</a></h3>
<pre><code>$ profiler resume
Started [cpu] profiling
</code></pre>
<p><code>start</code>和<code>resume</code>的区别是：<code>start</code>是新开始采样，<code>resume</code>会保留上次<code>stop</code>时的数据。</p>
<p>通过执行<code>profiler getSamples</code>可以查看samples的数量来验证。</p>
<h3 id="使用execute来执行复杂的命令"><a class="header" href="#使用execute来执行复杂的命令">使用<code>execute</code>来执行复杂的命令</a></h3>
<p>比如开始采样：</p>
<pre><code>profiler execute 'start,framebuf=5000000'
</code></pre>
<p>停止采样，并保存到指定文件里：</p>
<pre><code>profiler execute 'stop,file=/tmp/result.html'
</code></pre>
<p>具体的格式参考： <a href="https://github.com/jvm-profiling-tools/async-profiler/blob/v2.5/src/arguments.cpp#L50">arguments.cpp</a></p>
<h3 id="查看所有支持的action"><a class="header" href="#查看所有支持的action">查看所有支持的action</a></h3>
<pre><code>$ profiler actions
Supported Actions: [resume, dumpCollapsed, getSamples, start, list, execute, version, stop, load, dumpFlat, actions, dumpTraces, status]
</code></pre>
<h3 id="查看版本"><a class="header" href="#查看版本">查看版本</a></h3>
<pre><code>$ profiler version
Async-profiler 1.6 built on Sep  9 2019
Copyright 2019 Andrei Pangin
</code></pre>
<h3 id="配置-framebuf-参数"><a class="header" href="#配置-framebuf-参数">配置 framebuf 参数</a></h3>
<blockquote>
<p>如果遇到生成的火焰图有 <code>[frame_buffer_overflow]</code>，则需要增大 framebuf（默认值是 1’000’000），可以显式配置，比如：</p>
</blockquote>
<pre><code>profiler start --framebuf 5000000
</code></pre>
<h3 id="配置-includeexclude-来过滤数据"><a class="header" href="#配置-includeexclude-来过滤数据">配置 include/exclude 来过滤数据</a></h3>
<p>如果应用比较复杂，生成的内容很多，想只关注部分数据，可以通过 include/exclude 来过滤。比如</p>
<pre><code>profiler start --include 'java/*' --include 'demo/*' --exclude '*Unsafe.park*'
</code></pre>
<h3 id="指定执行时间"><a class="header" href="#指定执行时间">指定执行时间</a></h3>
<p>比如，希望profiler执行 300 秒自动结束，可以用 <code>-d</code>/<code>--duration</code> 参数指定：</p>
<pre><code>profiler start --duration 300
</code></pre>
<h3 id="生成-jfr格式结果"><a class="header" href="#生成-jfr格式结果">生成 jfr格式结果</a></h3>
<blockquote>
<p>注意，jfr只支持在 <code>start</code>时配置。如果是在<code>stop</code>时指定，则不会生效。</p>
</blockquote>
<pre><code>profiler start --file /tmp/test.jfr
</code></pre>
<p><code>file</code>参数支持一些变量：</p>
<ul>
<li>时间戳： <code>--file /tmp/test-%t.jfr</code></li>
<li>进程ID： <code>--file /tmp/test-%p.jfr</code></li>
</ul>
<p>生成的结果可以用支持jfr格式的工具来查看。比如：</p>
<ul>
<li>JDK Mission Control ： https://github.com/openjdk/jmc</li>
<li>JProfiler ： https://github.com/alibaba/arthas/issues/1416</li>
</ul>
<h3 id="生成的火焰图里的-unknown"><a class="header" href="#生成的火焰图里的-unknown">生成的火焰图里的 unknown</a></h3>
<ul>
<li>https://github.com/jvm-profiling-tools/async-profiler/discussions/409</li>
</ul>
<p><a href="https://github.com/brendangregg/FlameGraph">GITHUB</a></p>
<h3 id="参考链接"><a class="header" href="#参考链接">参考链接</a></h3>
<p>https://arthas.aliyun.com/doc/profiler.html#profiler</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="thread"><a class="header" href="#thread">thread</a></h2>
<blockquote>
<p>查看当前线程信息，查看线程的堆栈</p>
</blockquote>
<h2 id="参数说明"><a class="header" href="#参数说明">参数说明</a></h2>
<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody>
<tr><td><em>id</em></td><td>线程id</td></tr>
<tr><td>[n:]</td><td>指定最忙的前N个线程并打印堆栈</td></tr>
<tr><td>[b]</td><td>找出当前阻塞其他线程的线程</td></tr>
<tr><td>[i <code>&lt;value&gt;</code>]</td><td>指定cpu使用率统计的采样间隔，单位为毫秒，默认值为200</td></tr>
<tr><td>[--all]</td><td>显示所有匹配的线程</td></tr>
</tbody></table>
<h2 id="cpu使用率是如何统计出来的"><a class="header" href="#cpu使用率是如何统计出来的">cpu使用率是如何统计出来的？</a></h2>
<p>这里的cpu使用率与linux 命令<code>top -H -p &lt;pid&gt;</code> 的线程<code>%CPU</code>类似，一段采样间隔时间内，当前JVM里各个线程的增量cpu时间与采样间隔时间的比例。</p>
<h3 id="工作原理说明"><a class="header" href="#工作原理说明">工作原理说明：</a></h3>
<ul>
<li>首先第一次采样，获取所有线程的CPU时间(调用的是<code>java.lang.management.ThreadMXBean#getThreadCpuTime()</code>及<code>sun.management.HotspotThreadMBean.getInternalThreadCpuTimes()</code>接口)</li>
<li>然后睡眠等待一个间隔时间（默认为200ms，可以通过<code>-i</code>指定间隔时间）</li>
<li>再次第二次采样，获取所有线程的CPU时间，对比两次采样数据，计算出每个线程的增量CPU时间</li>
<li>线程CPU使用率 = 线程增量CPU时间 / 采样间隔时间 * 100%</li>
</ul>
<blockquote>
<p>注意： 这个统计也会产生一定的开销（JDK这个接口本身开销比较大），因此会看到as的线程占用一定的百分比，为了降低统计自身的开销带来的影响，可以把采样间隔拉长一些，比如5000毫秒。</p>
</blockquote>
<blockquote>
<p>另外一种查看Java进程的线程cpu使用率方法：可以使用<a href="https://github.com/oldratlee/useful-scripts/blob/master/docs/java.md#-show-busy-java-threads">show-busy-java-threads</a>这个脚本</p>
</blockquote>
<ul>
<li>没有线程ID，包含<code>[Internal]</code>表示为JVM内部线程，参考<a href="https://arthas.aliyun.com/doc/dashboard.html">dashboard</a>命令的介绍。</li>
<li><code>cpuUsage</code>为采样间隔时间内线程的CPU使用率，与<a href="https://arthas.aliyun.com/doc/dashboard.html">dashboard</a>命令的数据一致。</li>
<li><code>deltaTime</code>为采样间隔时间内线程的增量CPU时间，小于1ms时被取整显示为0ms。</li>
<li><code>time</code> 线程运行总CPU时间。</li>
</ul>
<p>注意：线程栈为第二采样结束时获取，不能表明采样间隔时间内该线程都是在处理相同的任务。建议间隔时间不要太长，可能间隔时间越大越不准确。 可以根据具体情况尝试指定不同的间隔时间，观察输出结果。</p>
<h3 id="当没有参数时显示第一页线程的信息"><a class="header" href="#当没有参数时显示第一页线程的信息">当没有参数时，显示第一页线程的信息</a></h3>
<p>默认按照CPU增量时间降序排列，只显示第一页数据。</p>
<pre><code>$ thread
Threads Total: 33, NEW: 0, RUNNABLE: 9, BLOCKED: 0, WAITING: 3, TIMED_WAITING: 4, TERMINATED: 0, Internal threads: 17
ID   NAME                           GROUP          PRIORITY  STATE     %CPU      DELTA_TIME TIME      INTERRUPT DAEMON
-1   C2 CompilerThread0             -              -1        -         5.06      0.010      0:0.973   false     true
-1   C1 CompilerThread0             -              -1        -         0.95      0.001      0:0.603   false     true
23   arthas-command-execute         system         5         RUNNABLE  0.17      0.000      0:0.226   false     true
-1   VM Periodic Task Thread        -              -1        -         0.05      0.000      0:0.094   false     true
-1   Sweeper thread                 -              -1        -         0.04      0.000      0:0.011   false     true
-1   G1 Young RemSet Sampling       -              -1        -         0.02      0.000      0:0.025   false     true
12   Attach Listener                system         9         RUNNABLE  0.0       0.000      0:0.022   false     true
11   Common-Cleaner                 InnocuousThrea 8         TIMED_WAI 0.0       0.000      0:0.000   false     true
3    Finalizer                      system         8         WAITING   0.0       0.000      0:0.000   false     true
2    Reference Handler              system         10        RUNNABLE  0.0       0.000      0:0.000   false     true
4    Signal Dispatcher              system         9         RUNNABLE  0.0       0.000      0:0.000   false     true
15   arthas-NettyHttpTelnetBootstra system         5         RUNNABLE  0.0       0.000      0:0.029   false     true
22   arthas-NettyHttpTelnetBootstra system         5         RUNNABLE  0.0       0.000      0:0.196   false     true
24   arthas-NettyHttpTelnetBootstra system         5         RUNNABLE  0.0       0.000      0:0.038   false     true
16   arthas-NettyWebsocketTtyBootst system         5         RUNNABLE  0.0       0.000      0:0.001   false     true
17   arthas-NettyWebsocketTtyBootst system         5         RUNNABLE  0.0       0.000      0:0.001   false     true
</code></pre>
<h3 id="thread-all-显示所有匹配的线程"><a class="header" href="#thread-all-显示所有匹配的线程">thread –all, 显示所有匹配的线程</a></h3>
<p>显示所有匹配线程信息，有时需要获取全部JVM的线程数据进行分析。</p>
<h3 id="thread-id-显示指定线程的运行堆栈"><a class="header" href="#thread-id-显示指定线程的运行堆栈">thread id, 显示指定线程的运行堆栈</a></h3>
<pre><code>$ thread 1
&quot;main&quot; Id=1 WAITING on java.util.concurrent.CountDownLatch$Sync@29fafb28
    at sun.misc.Unsafe.park(Native Method)
    -  waiting on java.util.concurrent.CountDownLatch$Sync@29fafb28
    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)
    at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)
</code></pre>
<h3 id="thread--b-找出当前阻塞其他线程的线程"><a class="header" href="#thread--b-找出当前阻塞其他线程的线程">thread -b, 找出当前阻塞其他线程的线程</a></h3>
<p>有时候我们发现应用卡住了， 通常是由于某个线程拿住了某个锁， 并且其他线程都在等待这把锁造成的。 为了排查这类问题， arthas提供了<code>thread -b</code>， 一键找出那个罪魁祸首。</p>
<blockquote>
<p>注意， 目前只支持找出synchronized关键字阻塞住的线程， 如果是<code>java.util.concurrent.Lock</code>， 目前还不支持。</p>
</blockquote>
<h3 id="thread--i-指定采样时间间隔"><a class="header" href="#thread--i-指定采样时间间隔">thread -i, 指定采样时间间隔</a></h3>
<ul>
<li><code>thread -i 1000</code> : 统计最近1000ms内的线程CPU时间。</li>
<li><code>thread -n 3 -i 1000</code> : 列出1000ms内最忙的3个线程栈</li>
</ul>
<h3 id="thread-state-查看指定状态的线程"><a class="header" href="#thread-state-查看指定状态的线程">thread –state ，查看指定状态的线程</a></h3>
<pre><code>[	arthas@28114]$ thread --state WAITING

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="trace"><a class="header" href="#trace">trace</a></h2>
<blockquote>
<p>方法内部调用路径，并输出方法路径上的每个节点上耗时</p>
</blockquote>
<p><code>trace</code> 命令能主动搜索 <code>class-pattern</code>／<code>method-pattern</code> 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。</p>
<table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody>
<tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr>
<tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr>
<tr><td><em>condition-express</em></td><td>条件表达式</td></tr>
<tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr>
<tr><td><code>[n:]</code></td><td>命令执行次数</td></tr>
<tr><td><code>#cost</code></td><td>方法执行耗时</td></tr>
</tbody></table>
<p>这里重点要说明的是观察表达式，观察表达式的构成主要由 ognl 表达式组成，所以你可以这样写<code>&quot;{params,returnObj}&quot;</code>，只要是一个合法的 ognl 表达式，都能被正常支持。</p>
<p>观察的维度也比较多，主要体现在参数 <code>advice</code> 的数据结构上。<code>Advice</code> 参数最主要是封装了通知节点的所有信息。</p>
<p>请参考<a href="https://arthas.aliyun.com/doc/advice-class.html">表达式核心变量</a>中关于该节点的描述。</p>
<ul>
<li>特殊用法请参考：https://github.com/alibaba/arthas/issues/71</li>
<li>OGNL表达式官网：https://commons.apache.org/proper/commons-ognl/language-guide.html</li>
</ul>
<p>很多时候我们只想看到某个方法的rt大于某个时间之后的trace结果，现在Arthas可以按照方法执行的耗时来进行过滤了，例如<code>trace *StringUtils isBlank '#cost&gt;100'</code>表示当执行时间超过100ms的时候，才会输出trace的结果。</p>
<blockquote>
<p>watch/stack/trace这个三个命令都支持<code>#cost</code></p>
</blockquote>
<h2 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h2>
<p><code>trace</code> 能方便的帮助你定位和发现因 RT 高而导致的性能问题缺陷，但其每次只能跟踪一级方法的调用链路。</p>
<ul>
<li>参考：<a href="https://github.com/alibaba/arthas/issues/597">Trace命令的实现原理</a></li>
<li>3.3.0 版本后，可以使用动态Trace功能，不断增加新的匹配类，参考下面的示例。</li>
<li>目前不支持 <code>trace java.lang.Thread getName</code>，参考issue: <a href="https://github.com/alibaba/arthas/issues/1610">#1610</a> ，考虑到不是非常必要场景，且修复有一定难度，因此当前暂不修复</li>
</ul>
<h2 id="使用参考"><a class="header" href="#使用参考">使用参考</a></h2>
<pre><code>$ trace demo.MathGame run
Press Q or Ctrl+C to abort.
Affect(class-cnt:1 , method-cnt:1) cost in 28 ms.
`---ts=2019-12-04 00:45:08;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69
    `---[0.617465ms] demo.MathGame:run()
        `---[0.078946ms] demo.MathGame:primeFactors() #24 [throws Exception]
 
`---ts=2019-12-04 00:45:09;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69
    `---[1.276874ms] demo.MathGame:run()
        `---[0.03752ms] demo.MathGame:primeFactors() #24 [throws Exception]
</code></pre>
<h3 id="trace次数限制"><a class="header" href="#trace次数限制">trace次数限制</a></h3>
<pre><code>$ trace demo.MathGame run -n 1
Press Q or Ctrl+C to abort.
Affect(class-cnt:1 , method-cnt:1) cost in 20 ms.
`---ts=2019-12-04 00:45:53;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69
    `---[0.549379ms] demo.MathGame:run()
        +---[0.059839ms] demo.MathGame:primeFactors() #24
        `---[0.232887ms] demo.MathGame:print() #25
 
Command execution times exceed limit: 1, so command will exit. You can set it with -n option.
</code></pre>
<h3 id="包含jdk的函数"><a class="header" href="#包含jdk的函数">包含jdk的函数</a></h3>
<ul>
<li><code>--skipJDKMethod &lt;value&gt; </code> skip jdk method trace, default value true.</li>
</ul>
<h3 id="据调用耗时过滤"><a class="header" href="#据调用耗时过滤">据调用耗时过滤</a></h3>
<pre><code>$ trace demo.MathGame run '#cost &gt; 10'
</code></pre>
<blockquote>
<p>只会展示耗时大于10ms的调用路径，有助于在排查问题的时候，只关注异常情况</p>
</blockquote>
<ul>
<li>是不是很眼熟，没错，在 JProfiler 等收费软件中你曾经见识类似的功能，这里你将可以通过命令就能打印出指定调用路径。 友情提醒下，<code>trace</code> 在执行的过程中本身是会有一定的性能开销，在统计的报告中并未像 JProfiler 一样预先减去其自身的统计开销。所以这统计出来有些许的不准，渲染路径上调用的类、方法越多，性能偏差越大。但还是能让你看清一些事情的。</li>
<li>[12.033735ms] 的含义，<code>12.033735</code> 的含义是：当前节点在当前步骤的耗时，单位为毫秒</li>
<li>[0,0,0ms,11]xxx:yyy() [throws Exception]，对该方法中相同的方法调用进行了合并，<code>0,0,0ms,11</code> 表示方法调用耗时，<code>min,max,total,count</code>；<code>throws Exception</code> 表明该方法调用中存在异常返回</li>
<li>这里存在一个统计不准确的问题，就是所有方法耗时加起来可能会小于该监测方法的总耗时，这个是由于 Arthas 本身的逻辑会有一定的耗时</li>
</ul>
<h3 id="trace多个类或者多个函数"><a class="header" href="#trace多个类或者多个函数">trace多个类或者多个函数</a></h3>
<p>trace命令只会trace匹配到的函数里的子调用，并不会向下trace多层。因为trace是代价比较贵的，多层trace可能会导致最终要trace的类和函数非常多。</p>
<p>可以用正则表匹配路径上的多个类和函数，一定程度上达到多层trace的效果。</p>
<pre><code>trace -E com.test.ClassA|org.test.ClassB method1|method2|method3
</code></pre>
<h3 id="排除掉指定的类"><a class="header" href="#排除掉指定的类">排除掉指定的类</a></h3>
<pre><code>trace javax.servlet.Filter * --exclude-class-pattern com.demo.TestFilter
</code></pre>
<h2 id="动态trace"><a class="header" href="#动态trace">动态trace</a></h2>
<p>打开终端1，trace上面demo里的<code>run</code>函数，可以看到打印出 <code>listenerId: 1</code>：</p>
<pre><code>[arthas@59161]$ trace demo.MathGame run
Press Q or Ctrl+C to abort.
Affect(class count: 1 , method count: 1) cost in 112 ms, listenerId: 1
`---ts=2020-07-09 16:48:11;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69
    `---[1.389634ms] demo.MathGame:run()
        `---[0.123934ms] demo.MathGame:primeFactors() #24 [throws Exception]
 
`---ts=2020-07-09 16:48:12;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69
    `---[3.716391ms] demo.MathGame:run()
        +---[3.182813ms] demo.MathGame:primeFactors() #24
        `---[0.167786ms] demo.MathGame:print() #25
</code></pre>
<p>现在想要深入子函数<code>primeFactors</code>，可以打开一个新终端2，使用<code>telnet localhost 3658</code>连接上arthas，再trace <code>primeFactors</code>时，指定<code>listenerId</code>。</p>
<pre><code>[arthas@59161]$ trace demo.MathGame primeFactors --listenerId 1
Press Q or Ctrl+C to abort.
Affect(class count: 1 , method count: 1) cost in 34 ms, listenerId: 1
</code></pre>
<p>这时终端2打印的结果，说明已经增强了一个函数：<code>Affect(class count: 1 , method count: 1)</code>，但不再打印更多的结果。</p>
<p>再查看终端1，可以发现trace的结果增加了一层，打印了<code>primeFactors</code>函数里的内容：</p>
<pre><code>`---ts=2020-07-09 16:49:29;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69
    `---[0.492551ms] demo.MathGame:run()
        `---[0.113929ms] demo.MathGame:primeFactors() #24 [throws Exception]
            `---[0.061462ms] demo.MathGame:primeFactors()
                `---[0.001018ms] throw:java.lang.IllegalArgumentException() #46
 
`---ts=2020-07-09 16:49:30;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69
    `---[0.409446ms] demo.MathGame:run()
        +---[0.232606ms] demo.MathGame:primeFactors() #24
        |   `---[0.1294ms] demo.MathGame:primeFactors()
        `---[0.084025ms] demo.MathGame:print() #25
</code></pre>
<p>通过指定<code>listenerId</code>的方式动态trace，可以不断深入。另外 <code>watch</code>/<code>tt</code>/<code>monitor</code>等命令也支持类似的功能。</p>
<h2 id="trace结果时间不准确问题"><a class="header" href="#trace结果时间不准确问题">trace结果时间不准确问题</a></h2>
<p>比如下面的结果里：<code>0.705196 &gt; (0.152743 + 0.145825)</code></p>
<pre><code>$ trace demo.MathGame run -n 1
Press Q or Ctrl+C to abort.
Affect(class count: 1 , method count: 1) cost in 66 ms, listenerId: 1
`---ts=2021-02-08 11:27:36;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@232204a1
    `---[0.705196ms] demo.MathGame:run()
        +---[0.152743ms] demo.MathGame:primeFactors() #24
        `---[0.145825ms] demo.MathGame:print() #25
</code></pre>
<p>那么其它的时间消耗在哪些地方？</p>
<ol>
<li>
<p>没有被trace到的函数。比如<code>java.*</code> 下的函数调用默认会忽略掉。通过增加<code>--skipJDKMethod false</code>参数可以打印出来。</p>
<pre><code>$ trace demo.MathGame run --skipJDKMethod false
Press Q or Ctrl+C to abort.
Affect(class count: 1 , method count: 1) cost in 35 ms, listenerId: 2
`---ts=2021-02-08 11:27:48;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@232204a1
    `---[0.810591ms] demo.MathGame:run()
        +---[0.034568ms] java.util.Random:nextInt() #23
        +---[0.119367ms] demo.MathGame:primeFactors() #24 [throws Exception]
        +---[0.017407ms] java.lang.StringBuilder:&lt;init&gt;() #28
        +---[0.127922ms] java.lang.String:format() #57
        +---[min=0.01419ms,max=0.020221ms,total=0.034411ms,count=2] java.lang.StringBuilder:append() #57
        +---[0.021911ms] java.lang.Exception:getMessage() #57
        +---[0.015643ms] java.lang.StringBuilder:toString() #57
        `---[0.086622ms] java.io.PrintStream:println() #57
</code></pre>
</li>
<li>
<p>非函数调用的指令消耗。比如 <code>i++</code>, <code>getfield</code>等指令。</p>
</li>
<li>
<p>在代码执行过程中，JVM可能出现停顿，比如GC，进入同步块等。</p>
</li>
</ol>
<h3 id="使用--v-参数打印更多信息"><a class="header" href="#使用--v-参数打印更多信息">使用 -v 参数打印更多信息</a></h3>
<blockquote>
<p>watch/trace/monitor/stack/tt 命令都支持 <code>-v</code> 参数</p>
</blockquote>
<p>当命令执行之后，没有输出结果。有两种可能：</p>
<ol>
<li>匹配到的函数没有被执行</li>
<li>条件表达式结果是 false</li>
</ol>
<p>但用户区分不出是哪种情况。</p>
<p>使用 <code>-v</code>选项，则会打印<code>Condition express</code>的具体值和执行结果，方便确认。</p>
<p><a href="https://arthas.aliyun.com/doc/trace.html">参考链接</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="源码"><a class="header" href="#源码">源码</a></h1>
<pre><code class="language-java">public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      StartupStep contextRefresh = this.applicationStartup.start(&quot;spring.context.refresh&quot;);

      // Prepare this context for refreshing.//为容器初始化做准备
      prepareRefresh();

    // 这步比较重要(解析)，告诉子类去刷新bean工厂，这步完成后配置文件就解析成一个个bean定义，注册到BeanFactory（但是未被初始化，仅将信息写到了beanDefination的map中）
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

    // 设置beanFactory类加载器，添加多个beanPostProcesser
      prepareBeanFactory(beanFactory);

      try {
        // 允许子类上下文中对beanFactory做后期处理
         postProcessBeanFactory(beanFactory);

         StartupStep beanPostProcess = this.applicationStartup.start(&quot;spring.context.beans.post-process&quot;);
         // Invoke factory processors registered as beans in the context.
         /*
				* BeanDefinitionRegistryPostProcessor
				* BeanFactoryPostProcessor
				* 完成对这两个接口的调用
		* */
         invokeBeanFactoryPostProcessors(beanFactory);

// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别
         // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization
         // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化
         registerBeanPostProcessors(beanFactory);
         beanPostProcess.end();

        //初始化ApplicationContext的MessageSource
         initMessageSource();

        //初始化ApplicationContext事件广播器
         initApplicationEventMulticaster();

        // 初始化子类特殊bean（钩子方法）
         onRefresh();
 
        // 注册事件监听器
         registerListeners();

         // Instantiate all remaining (non-lazy-init) singletons.
          /*
				* 1、bean实例化过程
				* 2、依赖注入
				* 3、注解支持
				* 4、BeanPostProcessor的执行
				* 5、Aop的入口
				*
		* */
         finishBeanFactoryInitialization(beanFactory);

        // 广播事件，ApplicationContext初始化完成
         finishRefresh();
      }

      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn(&quot;Exception encountered during context initialization - &quot; +
                  &quot;cancelling refresh attempt: &quot; + ex);
         }

         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();

         // Reset 'active' flag.
         cancelRefresh(ex);

         // Propagate exception to caller.
         throw ex;
      }

      finally {
         // Reset common introspection caches in Spring's core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
         contextRefresh.end();
      }
   }
}
</code></pre>
<h1 id="总结-11"><a class="header" href="#总结-11">总结</a></h1>
<h2 id="spring容器启动主要流程"><a class="header" href="#spring容器启动主要流程">spring容器启动主要流程</a></h2>
<ul>
<li>初始化容器环境：包括启动信息，properties资源，属性校验</li>
<li>初始化 <em>BeanFactory</em> 完成 <em>BeanDefinition</em> 的解析</li>
<li>注册与调用 <em>BeanFactoryPostProcessor</em> </li>
<li>注册<em>BeanFactoryPostProcessor</em> </li>
<li>初始化<em>MessageSource</em></li>
<li>初始化事件广播器组件，注册事件监听</li>
<li>初始化<em>Bean</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实例化流程"><a class="header" href="#实例化流程">实例化流程</a></h1>
<blockquote>
<p>org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization</p>
</blockquote>
<h2 id="实例化-内置bean以及其他-单例非延迟-bean"><a class="header" href="#实例化-内置bean以及其他-单例非延迟-bean"><strong>实例化 内置Bean，以及其他 单例非延迟 bean</strong></a></h2>
<pre><code class="language-java">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
	// 往容器中注入 conversionService的bean
   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;
         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
      beanFactory.setConversionService(
            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
   }

   // Register a default embedded value resolver if no bean post-processor
   // (such as a PropertyPlaceholderConfigurer bean) registered any before:
   // at this point, primarily for resolution in annotation attribute values.
   if (!beanFactory.hasEmbeddedValueResolver()) {
      beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));
   }

   // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
   for (String weaverAwareName : weaverAwareNames) {
      getBean(weaverAwareName);
   }

    // 停止使用临时类加载器进行类型匹配，置null
   beanFactory.setTempClassLoader(null);

    // 冻结(this.configurationFrozen = true;)所有beanDefinition，不让bean继续注册
   beanFactory.freezeConfiguration();

    // 实例化所有剩余的(非延迟-init)单例
   beanFactory.preInstantiateSingletons();
}
</code></pre>
<h2 id="实例化所有单例非延迟bean"><a class="header" href="#实例化所有单例非延迟bean">实例化所有单例非延迟bean</a></h2>
<pre><code class="language-java">public void preInstantiateSingletons() throws BeansException {
   if (logger.isTraceEnabled()) {
      logger.trace(&quot;Pre-instantiating singletons in &quot; + this);
   }

   // Iterate over a copy to allow for init methods which in turn register new bean definitions.
   // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
	// 拿到所有beanName 初始化
   List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);

    // 触发所有非懒加载的singleton bean的初始化
   for (String beanName : beanNames) {
     //将非RootBeanDefinition转换为RootBeanDefinition以方便后续操作，
     //因为Spring上下文包括实例化所有Bean用的AbstractBeanDefinition是RootBeanDefinition
      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
      if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) { //不是抽象类 &amp;&amp; 是单例 &amp;&amp; 不是延迟加载
         if (isFactoryBean(beanName)) { //判断是否factoryBean
            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);//返回一个共享或独立的实例
            if (bean instanceof FactoryBean) {//如果是FactoryBean 且配置了 需要立即加载则立即加载
               FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;
               boolean isEagerInit;
               if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {
                  isEagerInit = AccessController.doPrivileged(
                        (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,
                        getAccessControlContext());
               }
               else {
                  isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;
                        ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
               }
               if (isEagerInit) {
                  getBean(beanName);
               }
            }
         }
         else { //非FactoryBean，直接加载
            getBean(beanName);
         }
      }
   }

    // 为所有实现了 SmartInitializingSingleton 的bean触发初始化后回调
   for (String beanName : beanNames) {
      Object singletonInstance = getSingleton(beanName);//从单例缓存池中 获取单例对象
      if (singletonInstance instanceof SmartInitializingSingleton) {
         StartupStep smartInitialize = this.getApplicationStartup().start(&quot;spring.beans.smart-initialize&quot;)
               .tag(&quot;beanName&quot;, beanName);
         SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
         if (System.getSecurityManager() != null) {
            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
               smartSingleton.afterSingletonsInstantiated();
               return null;
            }, getAccessControlContext());
         }
         else {
            smartSingleton.afterSingletonsInstantiated();
         }
         smartInitialize.end();
      }
   }
}
</code></pre>
<h2 id="dogetbean"><a class="header" href="#dogetbean">doGetBean</a></h2>
<p><strong>整个方法 分为 三部分</strong></p>
<ol>
<li>第一部分是获取<em>bean</em></li>
<li>第二部分是创建<em>bean</em></li>
<li>第三部分是 对bean进行类型转换</li>
</ol>
<pre><code class="language-java">protected &lt;T&gt; T doGetBean(
      String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly)
      throws BeansException {

   String beanName = transformedBeanName(name);
   Object bean;

   // Eagerly check singleton cache for manually registered singletons.
    //检查是否已创建过
   Object sharedInstance = getSingleton(beanName);
    //args为空时是获取bean，不为空是创建bean
   if (sharedInstance != null &amp;&amp; args == null) {
      if (logger.isTraceEnabled()) {
         if (isSingletonCurrentlyInCreation(beanName)) {
            logger.trace(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName +
                  &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;);
         }
         else {
            logger.trace(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;);
         }
      }
      //返回对象bean实例，如果是(beanInstance instanceof FactoryBean)，则调用工厂bean方法获取bean对象，如果 带有&amp;前缀则获取工厂bean本身
      bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
   }

   else {
      // Fail if we're already creating this bean instance:
      // We're assumably within a circular reference.
       //检查当前bean是否已被创建，如果是则认为是 循环引用了
      if (isPrototypeCurrentlyInCreation(beanName)) {
         throw new BeanCurrentlyInCreationException(beanName);
      }

      // 检查bean definition是否在该工厂已创建，如果不在该工厂创建，则使用其父工厂查找
      BeanFactory parentBeanFactory = getParentBeanFactory();
      if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
         // Not found -&gt; check parent.
         String nameToLookup = originalBeanName(name);
         if (parentBeanFactory instanceof AbstractBeanFactory) {
            return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                  nameToLookup, requiredType, args, typeCheckOnly);
         }
         else if (args != null) {//参数不为空，根据带参查找
            // Delegation to parent with explicit args.
            return (T) parentBeanFactory.getBean(nameToLookup, args);
         }
         else if (requiredType != null) {//要求类型不为空，要求类型查找
            // No args -&gt; delegate to standard getBean method.
            return parentBeanFactory.getBean(nameToLookup, requiredType);
         }
         else {//否则只能根据 name查找
            return (T) parentBeanFactory.getBean(nameToLookup);
         }
      }

      if (!typeCheckOnly) {
         markBeanAsCreated(beanName);
      }

      StartupStep beanCreation = this.applicationStartup.start(&quot;spring.beans.instantiate&quot;)
            .tag(&quot;beanName&quot;, name);
      try {
         if (requiredType != null) {
            beanCreation.tag(&quot;beanType&quot;, requiredType::toString);
         }
         RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
        //检查是否Abstract，是则抛异常
         checkMergedBeanDefinition(mbd, beanName, args);

         // Guarantee initialization of beans that the current bean depends on.
         // 获取依赖的所有bean，先加载依赖
         String[] dependsOn = mbd.getDependsOn();
         if (dependsOn != null) {
            for (String dep : dependsOn) {
               if (isDependent(beanName, dep)) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
               }
               registerDependentBean(dep, beanName);
               try {
                  getBean(dep);
               }
               catch (NoSuchBeanDefinitionException ex) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
               }
            }
         }

         // 接下来就到了创建一个bean实例的过程，创建单例/多例
         if (mbd.isSingleton()) {
            ......
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
         }
		//原型
         else if (mbd.isPrototype()) {
          	.....
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
         }
		//其他作用域
         else {
			.....
            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
         }
      }
      catch (BeansException ex) {
         beanCreation.tag(&quot;exception&quot;, ex.getClass().toString());
         beanCreation.tag(&quot;message&quot;, String.valueOf(ex.getMessage()));
         cleanupAfterBeanCreationFailure(beanName);
         throw ex;
      }
      finally {
         beanCreation.end();
      }
   }

   // Check if required type matches the type of the actual bean instance.类型校验与转换
    ...
   return (T) bean;
}
</code></pre>
<h2 id="实例化单例bean"><a class="header" href="#实例化单例bean">实例化单例bean</a></h2>
<h3 id="总方法"><a class="header" href="#总方法">总方法</a></h3>
<pre><code class="language-java">     // 接下来就到了创建一个bean实例的过程，创建单例/多例
if (mbd.isSingleton()) {
    sharedInstance = getSingleton(beanName, () -&gt; {
        try {
            return createBean(beanName, mbd, args);
        }
        catch (BeansException ex) {
            // Explicitly remove instance from singleton cache: It might have been put there
            // eagerly by the creation process, to allow for circular reference resolution.
            // Also remove any beans that received a temporary reference to the bean.
            destroySingleton(beanName);
            throw ex;
        }
    });
    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}


public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
    Assert.notNull(beanName, &quot;Bean name must not be null&quot;);
    synchronized (this.singletonObjects) {
        //尝试从单例池中取，取不到则创建
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null) {
            if (this.singletonsCurrentlyInDestruction) {
                throw new BeanCreationNotAllowedException(beanName,
                                                          &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +
                                                          &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);
            }
            if (logger.isDebugEnabled()) {
                logger.debug(&quot;Creating shared instance of singleton bean '&quot; + beanName + &quot;'&quot;);
            }
            //创建前 先 记录该bean正在创建
            beforeSingletonCreation(beanName);
            boolean newSingleton = false;
            boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
            if (recordSuppressedExceptions) {
                this.suppressedExceptions = new LinkedHashSet&lt;&gt;();
            }
            try {
                //创建bean
                singletonObject = singletonFactory.getObject();
                newSingleton = true;
            }
            catch (IllegalStateException ex) {
                // Has the singleton object implicitly appeared in the meantime -&gt;
                // if yes, proceed with it since the exception indicates that state.
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    throw ex;
                }
            }
            catch (BeanCreationException ex) {
                if (recordSuppressedExceptions) {
                    for (Exception suppressedException : this.suppressedExceptions) {
                        ex.addRelatedCause(suppressedException);
                    }
                }
                throw ex;
            }
            finally {
                if (recordSuppressedExceptions) {
                    this.suppressedExceptions = null;
                }
                 //创建方法结束后 移除该 bean的创建中状态
                afterSingletonCreation(beanName);
            }
            if (newSingleton) {
                //创建成功后加入到 单例缓冲池中，并从二缓三缓中移除
                addSingleton(beanName, singletonObject);
            }
        }
        return singletonObject;
    }
}
</code></pre>
<h2 id="实例化原型bean"><a class="header" href="#实例化原型bean">实例化原型bean</a></h2>
<ul>
<li>维护当前线程创建bean的状态</li>
<li>创建原型</li>
<li>返回实例</li>
</ul>
<pre><code class="language-java">else if (mbd.isPrototype()) {
    // It's a prototype -&gt; create a new instance.
    Object prototypeInstance = null;
    try {
        beforePrototypeCreation(beanName);
        prototypeInstance = createBean(beanName, mbd, args);
    }
    finally {
        afterPrototypeCreation(beanName);
    }
    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
}
</code></pre>
<pre><code class="language-java">protected void beforePrototypeCreation(String beanName) {
   Object curVal = this.prototypesCurrentlyInCreation.get();
   if (curVal == null) {
      this.prototypesCurrentlyInCreation.set(beanName);
   }
   else if (curVal instanceof String) {
      Set&lt;String&gt; beanNameSet = new HashSet&lt;&gt;(2);
      beanNameSet.add((String) curVal);
      beanNameSet.add(beanName);
      this.prototypesCurrentlyInCreation.set(beanNameSet);
   }
   else {
      Set&lt;String&gt; beanNameSet = (Set&lt;String&gt;) curVal;
      beanNameSet.add(beanName);
   }
}
</code></pre>
<h2 id="其他作用域"><a class="header" href="#其他作用域">其他作用域</a></h2>
<ul>
<li>创建前 标明 正在创建</li>
<li>子类实现 创建bean逻辑</li>
<li>创建后 标明 创建结束</li>
</ul>
<pre><code class="language-java">{
   String scopeName = mbd.getScope();
   if (!StringUtils.hasLength(scopeName)) {
      throw new IllegalStateException(&quot;No scope name defined for bean ´&quot; + beanName + &quot;'&quot;);
   }
   Scope scope = this.scopes.get(scopeName);
   if (scope == null) {
      throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;);
   }
   try {
      Object scopedInstance = scope.get(beanName, () -&gt; {
         beforePrototypeCreation(beanName);
         try {
            return createBean(beanName, mbd, args);
         }
         finally {
            afterPrototypeCreation(beanName);
         }
      });
      bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
   }
   catch (IllegalStateException ex) {
      throw new ScopeNotActiveException(beanName, scopeName, ex);
   }
}
</code></pre>
<h2 id="类型校验与转换"><a class="header" href="#类型校验与转换">类型校验与转换</a></h2>
<ul>
<li>如果要求的类型与 bean实际的类型不符</li>
<li>则尝试使用内置的 转换器 转换</li>
</ul>
<pre><code class="language-java">   if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {
      try {
         T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
         if (convertedBean == null) {
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
         }
         return convertedBean;
      }
      catch (TypeMismatchException ex) {
         if (logger.isTraceEnabled()) {
            logger.trace(&quot;Failed to convert bean '&quot; + name + &quot;' to required type '&quot; +
                  ClassUtils.getQualifiedName(requiredType) + &quot;'&quot;, ex);
         }
         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
      }
   }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="createbean"><a class="header" href="#createbean">createBean</a></h1>
<blockquote>
<p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</p>
</blockquote>
<p>主要分以下几个步骤</p>
<ul>
<li>
<h5 id="lookup-method检测"><a class="header" href="#lookup-method检测">lookup-method检测</a></h5>
</li>
<li>
<h5 id="instantiationawarebeanpostprocessor触发"><a class="header" href="#instantiationawarebeanpostprocessor触发">InstantiationAwareBeanPostProcessor触发</a></h5>
<p>此接口用于初始化自定义的bean，主要是在Spring内部使用</p>
<p>如果InstantiationAwareBeanPostProcessor返回的不是空，那么将不会继续执行剩下的Spring初始化流程</p>
</li>
<li>
<p><strong>开始实例化</strong></p>
</li>
</ul>
<pre><code class="language-java">protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
      throws BeanCreationException {

   if (logger.isTraceEnabled()) {
      logger.trace(&quot;Creating instance of bean '&quot; + beanName + &quot;'&quot;);
   }
   RootBeanDefinition mbdToUse = mbd;

   // Make sure bean class is actually resolved at this point, and
   // clone the bean definition in case of a dynamically resolved Class
   // which cannot be stored in the shared merged bean definition.
   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
   if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {
      mbdToUse = new RootBeanDefinition(mbd);
      mbdToUse.setBeanClass(resolvedClass);
   }

   // Prepare method overrides.
   try {
      mbdToUse.prepareMethodOverrides();
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
            beanName, &quot;Validation of method overrides failed&quot;, ex);
   }

   try {
      // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
      if (bean != null) {
         return bean;
      }
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
            &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);
   }

   try {
      Object beanInstance = doCreateBean(beanName, mbdToUse, args);
      if (logger.isTraceEnabled()) {
         logger.trace(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;);
      }
      return beanInstance;
   }
   catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
      // A previously detected exception with proper bean creation context already,
      // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.
      throw ex;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(
            mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);
   }
}
</code></pre>
<h1 id="docreatebean"><a class="header" href="#docreatebean">doCreateBean</a></h1>
<blockquote>
<p>开始实例化</p>
</blockquote>
<pre><code class="language-java">protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
      throws BeanCreationException {

   // Instantiate the bean.
   BeanWrapper instanceWrapper = null;
   if (mbd.isSingleton()) {
      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
   }
   if (instanceWrapper == null) {
      instanceWrapper = createBeanInstance(beanName, mbd, args);
   }
   Object bean = instanceWrapper.getWrappedInstance();
   Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
   if (beanType != NullBean.class) {
      mbd.resolvedTargetType = beanType;
   }

   // Allow post-processors to modify the merged bean definition.
   synchronized (mbd.postProcessingLock) {
      if (!mbd.postProcessed) {
         try {
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  &quot;Post-processing of merged bean definition failed&quot;, ex);
         }
         mbd.postProcessed = true;
      }
   }

   // Eagerly cache singletons to be able to resolve circular references
   // even when triggered by lifecycle interfaces like BeanFactoryAware.
   boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
         isSingletonCurrentlyInCreation(beanName));
   if (earlySingletonExposure) {
      if (logger.isTraceEnabled()) {
         logger.trace(&quot;Eagerly caching bean '&quot; + beanName +
               &quot;' to allow for resolving potential circular references&quot;);
      }
      addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
   }

   // Initialize the bean instance.
   Object exposedObject = bean;
   try {
      populateBean(beanName, mbd, instanceWrapper);
      exposedObject = initializeBean(beanName, exposedObject, mbd);
   }
   catch (Throwable ex) {
      if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
         throw (BeanCreationException) ex;
      }
      else {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
      }
   }

   if (earlySingletonExposure) {
      Object earlySingletonReference = getSingleton(beanName, false);
      if (earlySingletonReference != null) {
         if (exposedObject == bean) {
            exposedObject = earlySingletonReference;
         }
         else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
            String[] dependentBeans = getDependentBeans(beanName);
            Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
            for (String dependentBean : dependentBeans) {
               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                  actualDependentBeans.add(dependentBean);
               }
            }
            if (!actualDependentBeans.isEmpty()) {
               throw new BeanCurrentlyInCreationException(beanName,
                     &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; +
                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                     &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
                     &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
                     &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
                     &quot;'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.&quot;);
            }
         }
      }
   }

   // Register bean as disposable.
   try {
      registerDisposableBeanIfNecessary(beanName, bean, mbd);
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
   }

   return exposedObject;
}
</code></pre>
<h1 id="createbeaninstance"><a class="header" href="#createbeaninstance">createBeanInstance</a></h1>
<blockquote>
<p>真正实例化</p>
</blockquote>
<p>使用工厂方法或者 构造函数 或者 <em>CGLIB</em> 实例化</p>
<pre><code class="language-java">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
   // Make sure bean class is actually resolved at this point.
   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); //获取Class字节码

   if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &quot;Bean class isn't public, and non-public access not allowed: &quot; + beanClass.getName());
   }

   Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();
   if (instanceSupplier != null) {
      return obtainFromSupplier(instanceSupplier, beanName);
   }

   if (mbd.getFactoryMethodName() != null) {
      return instantiateUsingFactoryMethod(beanName, mbd, args);
   }

   // Shortcut when re-creating the same bean...
   boolean resolved = false;
   boolean autowireNecessary = false;
   if (args == null) {
      synchronized (mbd.constructorArgumentLock) {
         if (mbd.resolvedConstructorOrFactoryMethod != null) {
            resolved = true;
            autowireNecessary = mbd.constructorArgumentsResolved;
         }
      }
   }
   if (resolved) {
      if (autowireNecessary) {
         return autowireConstructor(beanName, mbd, null, null);
      }
      else {
         return instantiateBean(beanName, mbd);
      }
   }

   // Candidate constructors for autowiring?
   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
   if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
      return autowireConstructor(beanName, mbd, ctors, args);
   }

   // Preferred constructors for default construction?
   ctors = mbd.getPreferredConstructors();
   if (ctors != null) {
      return autowireConstructor(beanName, mbd, ctors, null);
   }

   // No special handling: simply use no-arg constructor.
   return instantiateBean(beanName, mbd);
}
</code></pre>
<h2 id="使用无参构造-工厂方法路径"><a class="header" href="#使用无参构造-工厂方法路径">使用无参构造 工厂方法路径</a></h2>
<pre><code class="language-java">AbstractBeanFactory#doGetBean
    AbstractAutowireCapableBeanFactory#createBean
        AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation
        AbstractAutowireCapableBeanFactory#doCreateBean
            AbstractAutowireCapableBeanFactory#createBeanInstance
                AbstractAutowireCapableBeanFactory#instantiateUsingFactoryMethod
                    ConstructorResolver#instantiateUsingFactoryMethod
                        ConstructorResolver#instantiate
                            InstantiationStrategy#instantiate
</code></pre>
<h2 id="使用带参工厂方法-调用路径"><a class="header" href="#使用带参工厂方法-调用路径">使用带参工厂方法 调用路径</a></h2>
<pre><code class="language-java">AbstractBeanFactory#doGetBean
    AbstractAutowireCapableBeanFactory#createBean
        AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation
        AbstractAutowireCapableBeanFactory#doCreateBean
            AbstractAutowireCapableBeanFactory#createBeanInstance
                AbstractAutowireCapableBeanFactory#instantiateUsingFactoryMethod
                    ConstructorResolver#instantiateUsingFactoryMethod
                        ConstructorResolver#createArgumentArray
                        ConstructorResolver#instantiate
                            InstantiationStrategy#instantiate
</code></pre>
<h2 id="带参构造函数调用路径"><a class="header" href="#带参构造函数调用路径">带参构造函数调用路径</a></h2>
<pre><code class="language-java">AbstractBeanFactory#doGetBean
    AbstractAutowireCapableBeanFactory#createBean
        AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation
        AbstractAutowireCapableBeanFactory#doCreateBean
            AbstractAutowireCapableBeanFactory#createBeanInstance
                AbstractAutowireCapableBeanFactory#determineConstructorsFromBeanPostProcessors
                    AutowiredAnnotationBeanPostProcessor#determineCandidateConstructors
                AbstractAutowireCapableBeanFactory#autowireConstructor
                    ConstructorResolver#autowireConstructor
                    ConstructorResolver#createArgumentArray
                    ConstructorResolver#instantiate
                        SimpleInstantiationStrategy#instantiate
</code></pre>
<h1 id="总结-12"><a class="header" href="#总结-12">总结</a></h1>
<h2 id="实例化过程每个方法完成的功能"><a class="header" href="#实例化过程每个方法完成的功能">实例化过程每个方法完成的功能</a></h2>
<ul>
<li><em>createBean</em> 方法  可以提前初始化 带有 <em>InstantiationAwareBeanPostProcessor</em> 返回的bean</li>
<li><em>doCreateBean</em> 方法 在创建实例完成后 进行 依赖处理、初始化处理等</li>
<li><em>createBeanInstance</em>  使用 工厂方法或者 构造函数初始化 实例</li>
<li><em>ConstructorResolver</em> 进行 参数依赖获取，以及构造函数选择等</li>
<li><em>InstantiationStrategy</em> 负责实例化</li>
</ul>
<h2 id="实例化过程简述"><a class="header" href="#实例化过程简述">实例化过程简述</a></h2>
<ul>
<li>在容器启动中，会初始化所有单例 非延迟<em>bean</em> </li>
<li>通过 三种方式：<em>FactoryBean</em> 或者 工厂方法，或者 构造函数</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="依赖注入"><a class="header" href="#依赖注入">依赖注入</a></h1>
<h2 id="调用栈"><a class="header" href="#调用栈">调用栈</a></h2>
<pre><code>AbstractBeanFactory#doGetBean
    AbstractAutowireCapableBeanFactory#createBean
        AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation
        AbstractAutowireCapableBeanFactory#doCreateBean
            AbstractAutowireCapableBeanFactory#createBeanInstance
            AbstractAutowireCapableBeanFactory#populateBean
</code></pre>
<h2 id="依赖注入-1"><a class="header" href="#依赖注入-1">依赖注入</a></h2>
<pre><code class="language-java">protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
   if (bw == null) {
      if (mbd.hasPropertyValues()) {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);
      }
      else {
         // Skip property population phase for null instance.
         return;
      }
   }

   // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
   // state of the bean before properties are set. This can be used, for example,
   // to support styles of field injection.
   if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {
      for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
         if (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
            return;
         }
      }
   }

   PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);

   int resolvedAutowireMode = mbd.getResolvedAutowireMode();
   if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
      MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
      // Add property values based on autowire by name if applicable.
      if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
         autowireByName(beanName, mbd, bw, newPvs);
      }
      // Add property values based on autowire by type if applicable.
      if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
         autowireByType(beanName, mbd, bw, newPvs);
      }
      pvs = newPvs;
   }

   boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
   boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

   PropertyDescriptor[] filteredPds = null;
   if (hasInstAwareBpps) {
      if (pvs == null) {
         pvs = mbd.getPropertyValues();
      }
      for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
         PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
         if (pvsToUse == null) {
            if (filteredPds == null) {
               filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }
            pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
               return;
            }
         }
         pvs = pvsToUse;
      }
   }
   if (needsDepCheck) {
      if (filteredPds == null) {
         filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
      }
      checkDependencies(beanName, mbd, filteredPds, pvs);
   }

   if (pvs != null) {
      applyPropertyValues(beanName, mbd, bw, pvs);
   }
}
</code></pre>
<h1 id="初始化-5"><a class="header" href="#初始化-5">初始化</a></h1>
<h2 id="调用栈-1"><a class="header" href="#调用栈-1"><strong>调用栈</strong></a></h2>
<pre><code class="language-java">AbstractBeanFactory#doGetBean
    AbstractAutowireCapableBeanFactory#createBean
        AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation
        AbstractAutowireCapableBeanFactory#doCreateBean
            AbstractAutowireCapableBeanFactory#createBeanInstance
            AbstractAutowireCapableBeanFactory#populateBean
            AbstractAutowireCapableBeanFactory#initializeBean
                AbstractAutowireCapableBeanFactory#invokeAwareMethods //调用 Aware方法
                AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization //调用 postProcess
                    BeanPostProcessor#postProcessBeforeInitialization //beforeInitialization
                AbstractAutowireCapableBeanFactory#invokeInitMethods //调用初始化方法
                    InitializingBean#afterPropertiesSet //InitializingBean类
                    AbstractAutowireCapableBeanFactory#invokeCustomInitMethod //自定义初始化方法
                AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization //afterInitializion
</code></pre>
<h2 id="源码-1"><a class="header" href="#源码-1">源码</a></h2>
<pre><code class="language-java">	protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
		if (System.getSecurityManager() != null) {
			AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
				invokeAwareMethods(beanName, bean);
				return null;
			}, getAccessControlContext());
		}
		else {
			invokeAwareMethods(beanName, bean);
		}

		Object wrappedBean = bean;
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
		}

		try {
			invokeInitMethods(beanName, wrappedBean, mbd);
		}
		catch (Throwable ex) {
			throw new BeanCreationException(
					(mbd != null ? mbd.getResourceDescription() : null),
					beanName, &quot;Invocation of init method failed&quot;, ex);
		}
		if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
		}

		return wrappedBean;
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="示意图-3"><a class="header" href="#示意图-3">示意图</a></h1>
<p><img src="10.spring_SpringFramework/../images/spring_bean_life_cycle.png" alt="" /></p>
<h1 id="生命周期的四个阶段"><a class="header" href="#生命周期的四个阶段">生命周期的四个阶段</a></h1>
<ol>
<li>实例化（Instantiation）</li>
<li>属性赋值（Populate）</li>
<li>初始化（Initialization）</li>
<li>销毁（Destruction）</li>
</ol>
<p><img src="10.spring_SpringFramework/../images/spring_bean_life_cycle_class.png" alt="" /></p>
<ol>
<li>实例化：第 1 步，实例化一个 bean 对象；</li>
<li>属性赋值：第 2 步，为 bean 设置相关属性和依赖；</li>
<li>初始化：第 3~7 步，步骤较多，其中第 5、6 步为初始化操作，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，该阶段结束，才能被用户使用；</li>
<li>销毁：第 8~10步，第8步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 bean 时再执行相应的方法。</li>
</ol>
<h1 id="aware-接口"><a class="header" href="#aware-接口">Aware 接口</a></h1>
<p>若 Spring 检测到 bean 实现了 Aware 接口，则会为其注入相应的依赖。所以通过让bean 实现 Aware 接口，则能在 bean 中获得相应的 Spring 容器资源。</p>
<p>Spring 中提供的 Aware 接口有：</p>
<ol>
<li>BeanNameAware：注入当前 bean 对应 beanName；</li>
<li>BeanClassLoaderAware：注入加载当前 bean 的 ClassLoader；</li>
<li>BeanFactoryAware：注入 当前BeanFactory容器 的引用。</li>
</ol>
<h1 id="docreatebean-1"><a class="header" href="#docreatebean-1">doCreateBean</a></h1>
<blockquote>
<p>生命周期方法</p>
</blockquote>
<ol>
<li>实例化Bean</li>
<li>设置bean属性</li>
<li>初始化bean</li>
<li>销毁bean回调（注册回调）</li>
</ol>
<pre><code class="language-java">protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
      throws BeanCreationException {

   // Instantiate the bean.
   BeanWrapper instanceWrapper = null;
   if (mbd.isSingleton()) {
      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
   }
   //实例化bean
   if (instanceWrapper == null) {
      instanceWrapper = createBeanInstance(beanName, mbd, args);
   }
   Object bean = instanceWrapper.getWrappedInstance();
   Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
   if (beanType != NullBean.class) {
      mbd.resolvedTargetType = beanType;
   }

   // Allow post-processors to modify the merged bean definition.
   synchronized (mbd.postProcessingLock) {
      if (!mbd.postProcessed) {
         try {
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
         }
         catch (Throwable ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                  &quot;Post-processing of merged bean definition failed&quot;, ex);
         }
         mbd.postProcessed = true;
      }
   }

   // Eagerly cache singletons to be able to resolve circular references
   // even when triggered by lifecycle interfaces like BeanFactoryAware.
   boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
         isSingletonCurrentlyInCreation(beanName));
   if (earlySingletonExposure) {
      if (logger.isTraceEnabled()) {
         logger.trace(&quot;Eagerly caching bean '&quot; + beanName +
               &quot;' to allow for resolving potential circular references&quot;);
      }
      addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
   }

   // Initialize the bean instance.
   Object exposedObject = bean;
   try {
       //赋值属性，注入属性
      populateBean(beanName, mbd, instanceWrapper);
      // 初始化bean
      exposedObject = initializeBean(beanName, exposedObject, mbd);
   }
   catch (Throwable ex) {
      if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
         throw (BeanCreationException) ex;
      }
      else {
         throw new BeanCreationException(
               mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
      }
   }

   if (earlySingletonExposure) {
      Object earlySingletonReference = getSingleton(beanName, false);
      if (earlySingletonReference != null) {
         if (exposedObject == bean) {
            exposedObject = earlySingletonReference;
         }
         else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
            String[] dependentBeans = getDependentBeans(beanName);
            Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
            for (String dependentBean : dependentBeans) {
               if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                  actualDependentBeans.add(dependentBean);
               }
            }
            if (!actualDependentBeans.isEmpty()) {
               throw new BeanCurrentlyInCreationException(beanName,
                     &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; +
                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                     &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
                     &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
                     &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
                     &quot;'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.&quot;);
            }
         }
      }
   }

   // Register bean as disposable.
   try { //注册销毁bean的回调
      registerDisposableBeanIfNecessary(beanName, bean, mbd);
   }
   catch (BeanDefinitionValidationException ex) {
      throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
   }

   return exposedObject;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="scheduledannotationbeanpostprocessor"><a class="header" href="#scheduledannotationbeanpostprocessor">ScheduledAnnotationBeanPostProcessor</a></h2>
<h3 id="任务注册完毕后"><a class="header" href="#任务注册完毕后">任务注册完毕后</a></h3>
<pre><code>	public void onApplicationEvent(ContextRefreshedEvent event) {
		if (event.getApplicationContext() == this.applicationContext) {
			// Running in an ApplicationContext -&gt; register tasks this late...
			// giving other ContextRefreshedEvent listeners a chance to perform
			// their work at the same time (e.g. Spring Batch's job registration).
			finishRegistration();
		}
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="扫描类路径"><a class="header" href="#扫描类路径">扫描类路径</a></h3>
<pre><code class="language-java">ClassPathScanningCandidateComponentProvider provider = new ClassPathScanningCandidateComponentProvider(false);
provider.addIncludeFilter(new AssignableTypeFilter(MyClass.class));

// scan in org.example.package
Set&lt;BeanDefinition&gt; components = provider.findCandidateComponents(&quot;org/example/package&quot;);
for (BeanDefinition component : components)
{
    Class cls = Class.forName(component.getBeanClassName());
    // use class cls found
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="propertysource"><a class="header" href="#propertysource">PropertySource</a></h2>
<p>代表名称/值属性对的源的抽象基类。基础源对象可以是封装属性的任何类型T。</p>
<p>示例包括<em>java.util.Properties</em>对象，<em>java.util.Map</em>对象，<em>ServletContext</em>和<em>ServletConfig</em>对象 (用于访问init参数)。探索PropertySource类型层次结构以查看提供的实现。</p>
<p>PropertySource对象通常不是隔离使用，而是通过一个PropertySources对象使用，该对象聚合属性源，并与可以在PropertySources集合中执行基于优先级的搜索的PropertyResolver实现结合使用。</p>
<p>PropertySource标识不是基于封装属性的内容来确定的，而是仅基于PropertySource的名称来确定的。这对于在集合上下文中操纵PropertySource对象很有用。有关详细信息，请参见MutablePropertySources中的操作以及named(String) 和toString() 方法。</p>
<p>请注意，在使用 @ Configuration类时，@ PropertySource注释提供了一种方便且声明性的方式将属性源添加到封闭环境中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring-bean初始化步骤总结"><a class="header" href="#spring-bean初始化步骤总结">spring Bean初始化步骤总结</a></h1>
<h1 id="beanfactory与applicationcontext有什么区别"><a class="header" href="#beanfactory与applicationcontext有什么区别"><a href="10.spring_SpringFramework/applicationContext%E4%B8%8EBeanFactory%E7%9A%84%E5%8C%BA%E5%88%AB.html">BeanFactory与ApplicationContext有什么区别</a></a></h1>
<h1 id="spring是如何实例化单例"><a class="header" href="#spring是如何实例化单例">Spring是如何实例化单例</a></h1>
<h1 id="spring是如何实例化原型"><a class="header" href="#spring是如何实例化原型"><a href="10.spring_SpringFramework/springBeanScope/README.html">Spring是如何实例化原型</a></a></h1>
<h1 id="spring是如何实例化其他作用域"><a class="header" href="#spring是如何实例化其他作用域">Spring是如何实例化其他作用域</a></h1>
<h1 id="spring是如何处理bean之间的依赖"><a class="header" href="#spring是如何处理bean之间的依赖"><a href="10.spring_SpringFramework/spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98.html">Spring是如何处理Bean之间的依赖</a></a></h1>
<h1 id="typecheckonly-是什么作用"><a class="header" href="#typecheckonly-是什么作用"><em>typeCheckOnly</em> 是什么作用</a></h1>
<h1 id="spring是如何进行类型转换的"><a class="header" href="#spring是如何进行类型转换的">Spring是如何进行类型转换的</a></h1>
<h1 id="什么是合成bean"><a class="header" href="#什么是合成bean">什么是合成Bean</a></h1>
<h1 id="spring是如何处理dependson的"><a class="header" href="#spring是如何处理dependson的">Spring是如何处理DependsOn的</a></h1>
<h1 id="spring组合注解的使用"><a class="header" href="#spring组合注解的使用"><a href="10.spring_SpringFramework/spring%E7%BB%84%E5%90%88%E6%B3%A8%E8%A7%A3.html">Spring组合注解的使用</a></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="beanfactory与applicationcontext的区别"><a class="header" href="#beanfactory与applicationcontext的区别">BeanFactory与ApplicationContext的区别</a></h2>
<h3 id="功能范围"><a class="header" href="#功能范围">功能范围</a></h3>
<p><strong>BeanFactory</strong></p>
<p>读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系</p>
<p><strong>ApplicationContext</strong></p>
<ul>
<li>国际化（<em>MessageSource</em>）</li>
<li>统一的资源文件访问方式，如URL和文件（<em>ResourceLoader</em>）</li>
<li>事件机制（<em>ApplicationEventPublisher</em>）</li>
<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层</li>
<li>AOP（拦截器）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring注解与的区别"><a class="header" href="#spring注解与的区别">spring#注解与$的区别</a></h1>
<ol>
<li>#{} springEL表达式</li>
<li>主要有以下作用
<ol>
<li>获取bean的某些属性 <code>@Value(&quot;#dataSource.url&quot;)</code></li>
<li>调用bean的某个方法</li>
<li>表示常量 @Value(&quot;#{1}&quot;) @Value(&quot;#{'springEL'}&quot;)</li>
</ol>
</li>
<li>${} 可以获取对应属性文件的值</li>
</ol>
<h1 id="spring区分开发与生产配置文件"><a class="header" href="#spring区分开发与生产配置文件">spring区分开发与生产配置文件</a></h1>
<ol>
<li>在spring配置文件中配置</li>
</ol>
<pre><code class="language-xml">&lt;beans profile=&quot;local&quot;&gt;
	&lt;context:property-placeholder location=&quot;classpath:/config/&quot; /&gt;
&lt;/beans&gt;

&lt;beans profile=&quot;test&quot;&gt;
	&lt;context:property-placeholder location=&quot;classpath:/config/&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<ol start="2">
<li>在web.xml配置默认值</li>
</ol>
<pre><code class="language-xml">&lt;context-parm&gt;
	&lt;parm-name&gt;spring.profiles.default&lt;/parm-name&gt;
    &lt;parm-value&gt;local&lt;/parm-value&gt;
&lt;/context-parm&gt;
</code></pre>
<ol start="3">
<li>启动时指定配置</li>
</ol>
<pre><code>JAVA_OPTIONS=&quot;-Dspring.profiles.active=test&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java注解"><a class="header" href="#java注解">java注解</a></h1>
<p>详见 <a href="10.spring_SpringFramework/../java%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3.html">java注解</a></p>
<h1 id="spring组合注解"><a class="header" href="#spring组合注解">spring组合注解</a></h1>
<ul>
<li>@AliasFor是用于为注解属性声明别名的注解，从Spring Framework 4.2开始，核心Spring中的几个注释已更新为使用@AliasFor配置其内部属性别名。</li>
<li>通过  @AliasFor 注解 实现了 Spring的组合注解功能</li>
</ul>
<h1 id="别名--aliasfor"><a class="header" href="#别名--aliasfor">别名  <code>@AliasFor</code></a></h1>
<p>在 Spring 中别名可以分为以下几类：</p>
<ul>
<li>
<p>显式别名（xplicit Aliases） </p>
<p>如果一个注解中的两个成员通过 @AliasFor声明后互为别名，那么它们是显式别名</p>
<p><img src="10.spring_SpringFramework//images/xplicit_aliases.png" alt="显示别名" /></p>
</li>
<li>
<p>隐式别名（Implicit Aliases）</p>
<p>如果一个注解中的两个或者更多成员通过@AliasFor声明去覆盖同一个元注解的成员值，它们就是隐式别名</p>
<p><img src="10.spring_SpringFramework//images/implicit_aliaes.png" alt="隐式别名" /></p>
</li>
<li>
<p>传递隐式别名（Transitive Implicit Aliases）</p>
<p>如果一个注解中的两个或者更多成员通过@AliasFor声明去覆盖元注解中的不同成员，但是实际上因为<a href="https://en.wikipedia.org/wiki/Transitive_relation">覆盖的传递性</a>导致最终覆盖的是元注解中的同一个成员，那么它们就是传递隐式别名</p>
<p><img src="10.spring_SpringFramework//images/transitive_Implicit_Aliases.jpg" alt="传递隐式别名" /></p>
</li>
</ul>
<p>以上三类都需要满足以下条件：</p>
<ul>
<li>
<p>属性类型相同</p>
</li>
<li>
<p>属性方法必须存在默认值</p>
</li>
<li>
<p>属性默认值必须相同</p>
</li>
</ul>
<h1 id="属性覆盖原理"><a class="header" href="#属性覆盖原理">属性覆盖原理</a></h1>
<blockquote>
<p>java本身不会执行 @AliasFor语义，通过AnnotatedElementUtils 支持实现</p>
</blockquote>
<ul>
<li>
<p>与Java中的任何注释一样，仅仅是@AliasFor本身的存在不会强制执行别名语义。要强制执行别名语义，必须通过AnnotationUtils等类 中的方法加载注解。</p>
</li>
<li>
<p>在幕后，Spring将通过将注释包装在一个动态代理中来合成注解，该代理透明地为使用@AliasFor注解的注解属性强制执行属性别名语义。</p>
</li>
<li>
<p>类似地，当在注解层次结构中使用@AliasFor时，AnnotatedElementUtils<strong>支持显式元注解属性重写</strong>。</p>
</li>
<li>
<p>通常，您不需要自己手动合成注解，因为当在Spring管理的组件上查找注解时，Spring将透明地为您合成注解。到了Spring5.2则通过MergedAnnotations加载注解。</p>
</li>
</ul>
<pre><code class="language-java">@Test
@GetMapping(value = &quot;/GetMapping&quot;, consumes = MediaType.APPLICATION_JSON_VALUE)
public void test() throws NoSuchMethodException {
    Method method = ReflectUtils.findDeclaredMethod(
            AliasForTest.class, &quot;test&quot;, null);

    // AnnotationUtils 不支持注解属性覆盖
    RequestMapping requestMappingAnn1 = AnnotationUtils.getAnnotation(method, RequestMapping.class);
    Assert.assertEquals(new String[]{}, requestMappingAnn1.value());
    Assert.assertEquals(new String[]{}, requestMappingAnn1.consumes());

    // AnnotatedElementUtils 支持注解属性覆盖
    RequestMapping requestMappingAnn2 = AnnotatedElementUtils.getMergedAnnotation(method, RequestMapping.class);
    Assert.assertEquals(new String[]{&quot;/GetMapping&quot;}, requestMappingAnn2.value());
    Assert.assertEquals(new String[]{MediaType.APPLICATION_JSON_VALUE}, requestMappingAnn2.consumes());
}
</code></pre>
<h1 id="annotationutils-源码分析"><a class="header" href="#annotationutils-源码分析">AnnotationUtils 源码分析</a></h1>
<p>AnnotationUtils 解决 <strong>注解别名</strong>，<strong>包括显式别名</strong>、<strong>隐式别名</strong>、<strong>传递的隐式别名</strong>，还可以查的指定注解的属性信息。AnnotationUtils 底层使用动态代理的方式处理注解别名的问题。</p>
<h3 id="get-系列注解查找"><a class="header" href="#get-系列注解查找">get* 系列注解查找</a></h3>
<blockquote>
<p>get 遵循 JDK 的注解查找语义，只是增加了一级元注解的查找。</p>
</blockquote>
<pre><code class="language-java">public static &lt;A extends Annotation&gt; A getAnnotation(Annotation annotation, Class&lt;A&gt; annotationType) {
    // 1. 直接查找本地注解
    if (annotationType.isInstance(annotation)) {
        return synthesizeAnnotation((A) annotation);
    }
    // 2. 元注解上查找，注意相对于 find* 而言，这里只查找一级元注解
    Class&lt;? extends Annotation&gt; annotatedElement = annotation.annotationType();
    try {
        A metaAnn = annotatedElement.getAnnotation(annotationType);
        return (metaAnn != null ? synthesizeAnnotation(metaAnn, annotatedElement) : null);
    }
    catch (Throwable ex) {
        handleIntrospectionFailure(annotatedElement, ex);
        return null;
    }
}
</code></pre>
<h2 id="find-系列注解查找"><a class="header" href="#find-系列注解查找">find* 系列注解查找</a></h2>
<blockquote>
<p>遵循 JDK 的注解查找语义，只是增加了多级元注解的查找。</p>
</blockquote>
<pre><code class="language-java">// visited 表示已经查找的元素，Spring 的递归很多都用到了这个参数
private static &lt;A extends Annotation&gt; A findAnnotation(
        AnnotatedElement annotatedElement, Class&lt;A&gt; annotationType, Set&lt;Annotation&gt; visited) {
    try {
        // 1. 本地注解查找
        A annotation = annotatedElement.getDeclaredAnnotation(annotationType);
        if (annotation != null) {
            return annotation;
        }
        // 2. 元注解上查找
        for (Annotation declaredAnn : getDeclaredAnnotations(annotatedElement)) {
            Class&lt;? extends Annotation&gt; declaredType = declaredAnn.annotationType();
            if (!isInJavaLangAnnotationPackage(declaredType) &amp;&amp; visited.add(declaredAnn)) {
                // 3. 元注解上递归查找
                annotation = findAnnotation((AnnotatedElement) declaredType, annotationType, visited);
                if (annotation != null) {
                    return annotation;
                }
            }
        }
    }
    catch (Throwable ex) {
        handleIntrospectionFailure(annotatedElement, ex);
    }
    return null;
}
</code></pre>
<h2 id="synthesizeannotation-动态代理解决别名问题"><a class="header" href="#synthesizeannotation-动态代理解决别名问题">synthesizeAnnotation 动态代理解决别名问题</a></h2>
<pre><code class="language-java">static &lt;A extends Annotation&gt; A synthesizeAnnotation(A annotation, @Nullable Object annotatedElement) {
    // 1. SynthesizedAnnotation 为一个标记，表示已经动态代理过了
    //    hasPlainJavaAnnotationsOnly 如果是 java 中的注解不可能有注解别名，直接返回
    if (annotation instanceof SynthesizedAnnotation || hasPlainJavaAnnotationsOnly(annotatedElement)) {
        return annotation;
    }

    // 2. 判断是否需要进行动态代理，即注解中存在别名，包括显示别名、隐式别名、传递的隐式别名
    Class&lt;? extends Annotation&gt; annotationType = annotation.annotationType();
    if (!isSynthesizable(annotationType)) {
        return annotation;
    }

    // 3. AnnotationAttributeExtractor 用于从注解 annotation 中提取属性的值
    DefaultAnnotationAttributeExtractor attributeExtractor =
            new DefaultAnnotationAttributeExtractor(annotation, annotatedElement);
    // 4. SynthesizedAnnotationInvocationHandler 动态代理的类
    InvocationHandler handler = new SynthesizedAnnotationInvocationHandler(attributeExtractor);

    // 5. 接口中有 SynthesizedAnnotation，并返回动态代理的对象
    Class&lt;?&gt;[] exposedInterfaces = new Class&lt;?&gt;[] {annotationType, SynthesizedAnnotation.class};
    return (A) Proxy.newProxyInstance(annotation.getClass().getClassLoader(), exposedInterfaces, handler);
}
</code></pre>
<pre><code class="language-java">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if (ReflectionUtils.isEqualsMethod(method)) {
        return annotationEquals(args[0]);
    }
    if (ReflectionUtils.isHashCodeMethod(method)) {
        return annotationHashCode();
    }
    if (ReflectionUtils.isToStringMethod(method)) {
        return annotationToString();
    }
    // 注解的 annotationType 返回注解的 Class 类型
    if (AnnotationUtils.isAnnotationTypeMethod(method)) {
        return annotationType();
    }
    if (!AnnotationUtils.isAttributeMethod(method)) {
        throw new AnnotationConfigurationException(String.format(
                &quot;Method [%s] is unsupported for synthesized annotation type [%s]&quot;, method, annotationType()));
    }
    // 真正获取注解的属性值
    return getAttributeValue(method);
}
</code></pre>
<h1 id="示例-3"><a class="header" href="#示例-3">示例</a></h1>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE,ElementType.TYPE})
public @interface DemoEnum01 {
    String value() default &quot;111&quot;;

    String name() default &quot;&quot;;
}
</code></pre>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE,ElementType.TYPE})
@DemoEnum01()
public @interface Demo222 {
    @AliasFor(annotation = DemoEnum01.class)
    String value() default &quot;3333&quot;;
    @AliasFor(annotation = DemoEnum01.class)
    String name();
}
</code></pre>
<pre><code class="language-java">public class MainTest {
    public static void main(String[] args) {
        Annotation annotation = AnnotatedElementUtils.getMergedAnnotation(PersonEntity.class, DemoEnum01.class);
        System.out.println(annotation);
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="循环依赖发生的时机"><a class="header" href="#循环依赖发生的时机">循环依赖发生的时机</a></h1>
<ol>
<li>createBeanInstance实例化</li>
<li>populateBean 填充属性</li>
<li>InitializeBean 初始化</li>
</ol>
<p>在1,2过程中会发生</p>
<h1 id="如何解决"><a class="header" href="#如何解决">如何解决</a></h1>
<p>Spring 为了解决单例的循环依赖问题，使用了 <strong>三级缓存</strong></p>
<pre><code class="language-java">/** 一级缓存：用于存放完全初始化好的 bean **/
private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);

/** 二级缓存：存放原始的 bean 对象（尚未填充属性），用于解决循环依赖 */
private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16);

/** 三级级缓存：存放 bean 工厂对象，用于解决循环依赖 */
private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);
</code></pre>
<p>过程</p>
<ul>
<li>A 创建过程中需要 B，于是 <strong>A 将自己放到三级缓里面</strong> ，去实例化 B</li>
<li>B 实例化的时候发现需要 A，于是 B 先查一级缓存，没有，再查二级缓存，还是没有，再查三级缓存，找到了！</li>
<li><strong>然后把三级缓存里面的这个 A 放到二级缓存里面，并删除三级缓存里面的 A</strong></li>
<li>B 顺利初始化完毕，<strong>将自己放到一级缓存里面</strong>（此时B里面的A依然是创建中状态）</li>
<li>然后回来接着创建 A，此时 B 已经创建结束，直接从一级缓存里面拿到 B ，然后完成创建，<strong>并将自己放到一级缓存里面</strong></li>
</ul>
<h1 id="源码分析-1"><a class="header" href="#源码分析-1">源码分析</a></h1>
<pre><code class="language-java">protected Object getSingleton(String beanName, boolean allowEarlyReference) {
   // Quick check for existing instance without full singleton lock
   Object singletonObject = this.singletonObjects.get(beanName); //从一级缓存中取对象
   if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) { //没有取到，且当前对象正在创建中
      singletonObject = this.earlySingletonObjects.get(beanName); //从二级缓存取
      if (singletonObject == null &amp;&amp; allowEarlyReference) { //从二级缓存没取到，且需要早期暴露
         synchronized (this.singletonObjects) {
            // Consistent creation of early reference within full singleton lock
            singletonObject = this.singletonObjects.get(beanName);
            if (singletonObject == null) {
               singletonObject = this.earlySingletonObjects.get(beanName);
               if (singletonObject == null) { //则从三级缓存中取 ObjectFactory 获取实例早期对象，并从三级缓存转移到二级缓存
                  ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
                  if (singletonFactory != null) {
                     singletonObject = singletonFactory.getObject();
                     this.earlySingletonObjects.put(beanName, singletonObject);
                     this.singletonFactories.remove(beanName);
                  }
               }
            }
         }
      }
   }
   return singletonObject;
}
</code></pre>
<h1 id="总结-13"><a class="header" href="#总结-13">总结</a></h1>
<h2 id="为什么要设计三级缓存"><a class="header" href="#为什么要设计三级缓存">为什么要设计三级缓存</a></h2>
<p>一般来说，二级缓存就够用了，但是 Spring 提供了 <em>InstantiationAwareBeanPostProcessor</em> 与 <em>SmartInstantiationAwareBeanPostProcessor</em> 后处理器</p>
<p>用于提前初始化，所以在 循环依赖过程中，如果提早暴露 引用给 其他人，则 需要对 先将 未 调用过<em>InstantiationAwareBeanPostProcessor</em>  的 bean放入 三缓</p>
<p>调用过 <em>InstantiationAwareBeanPostProcessor</em>  的 bean 但正在创建中的 放入 二缓，创建完成的放入一缓</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instantiationawarebeanpostprocessor"><a class="header" href="#instantiationawarebeanpostprocessor">InstantiationAwareBeanPostProcessor</a></h1>
<p>InstantiationAwareBeanPostProcessor接口是BeanPostProcessor的子接口，通过接口字面意思翻译该接口的作用是感知Bean实例话的处理器</p>
<table><thead><tr><th style="text-align: left">方法</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">postProcessBeforeInitialization</td><td style="text-align: left">BeanPostProcessor接口中的方法,在Bean的自定义初始化方法之前执行</td></tr>
<tr><td style="text-align: left">postProcessAfterInitialization</td><td style="text-align: left">BeanPostProcessor接口中的方法 在Bean的自定义初始化方法执行完成之后执行</td></tr>
<tr><td style="text-align: left">postProcessBeforeInstantiation</td><td style="text-align: left">自身方法，是最先执行的方法，它在目标对象实例化之前调用，该方法的返回值类型是Object，我们可以返回任何类型的值。由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(比如代理对象)。如果该方法的返回值代替原本该生成的目标对象，后续只有postProcessAfterInitialization方法会调用，其它方法不再调用；否则按照正常的流程走</td></tr>
<tr><td style="text-align: left">postProcessAfterInstantiation</td><td style="text-align: left">在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置，都是null。因为它的返回值是决定要不要调用postProcessPropertyValues方法的其中一个因素（因为还有一个因素是mbd.getDependencyCheck()）；如果该方法返回false,并且不需要check，那么postProcessPropertyValues就会被忽略不执行；如果返回true，postProcessPropertyValues就会被执行</td></tr>
<tr><td style="text-align: left">postProcessPropertyValues</td><td style="text-align: left">对属性值进行修改，如果postProcessAfterInstantiation方法返回false，该方法可能不会被调用。可以在该方法内对属性值进行修改</td></tr>
</tbody></table>
<h1 id="postprocessbeforeinstantiation"><a class="header" href="#postprocessbeforeinstantiation">postProcessBeforeInstantiation</a></h1>
<p>在目标Bean实例化前执行此方法，返回的 <em>Bean</em> 对象可能是要使用的代理，而不是目标Bean</p>
<p>有效抑制目标Bean的默认实例化</p>
<p>如果通过此方法返回非空对象，则Bean创建过程 短路</p>
<h1 id="postprocessafterinstantiation"><a class="header" href="#postprocessafterinstantiation">postProcessAfterInstantiation</a></h1>
<ul>
<li>在 bean通过构造器或工厂方法初始化后，执行指定的操作</li>
<li>发生于Spring属性填充（依赖注入）（显示属性引用或 自动注入）</li>
<li>对给定bean 执行自定义字段注入,这是一个理想的回调，</li>
<li>在Spring自动注入依赖之前、</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li>如果属性应该设置在豆上， 则返回true</li>
<li>如果属性填充应该被跳过则返回 false</li>
<li>返回<em>false</em> 会阻止后续的 <em>InstantiationAwareBeanPostProcessor</em> 实例调用</li>
</ul>
<h1 id="postprocessproperties"><a class="header" href="#postprocessproperties">postProcessProperties</a></h1>
<p><strong>pvs</strong></p>
<p>工厂即将应用的属性值</p>
<p><strong>bean</strong></p>
<p>已经实例化的bean，但是属性还未设置</p>
<p><strong>beanName</strong> </p>
<p>bean名称</p>
<p><strong>返回</strong></p>
<p>应用与bean的实际属性值</p>
<p>可以返回 <em>PropertyValues</em> 实例传递</p>
<p>或者返回 <em>null</em></p>
<h1 id="smartinstantiationawarebeanpostprocessor"><a class="header" href="#smartinstantiationawarebeanpostprocessor">SmartInstantiationAwareBeanPostProcessor</a></h1>
<ol>
<li>Extension of the InstantiationAwareBeanPostProcessor interface</li>
<li>预测 处理bean的 实际类型 回调</li>
</ol>
<h2 id="predictbeantype"><a class="header" href="#predictbeantype">predictBeanType</a></h2>
<p>预测bean类型，这个类型最终从 <em>postProcessBeforeInstantiation</em> 返回</p>
<p><strong>Params:</strong>
beanClass – the raw class of the bean
beanName – the name of the bean</p>
<p><strong>Returns:</strong>
the type of the bean, or null if not predictable
<strong>Throws:</strong>
BeansException – in case of errors</p>
<h2 id="determinecandidateconstructors"><a class="header" href="#determinecandidateconstructors">determineCandidateConstructors</a></h2>
<p>Determine the candidate constructors to use for the given bean.
The default implementation returns null.
Params:
beanClass – the raw class of the bean (never null)
beanName – the name of the bean
Returns:
the candidate constructors, or null if none specified</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aop-术语"><a class="header" href="#aop-术语">AOP 术语</a></h1>
<p>在我们开始使用 AOP 工作之前，让我们熟悉一下 AOP 概念和术语。这些术语并不特定于 Spring，而是与 AOP 有关的。</p>
<h2 id="aop概念"><a class="header" href="#aop概念">AOP概念</a></h2>
<table><thead><tr><th>项</th><th>描述</th></tr></thead><tbody>
<tr><td>Aspect</td><td>给切点分类（以业务逻辑  划分各个切点的 逻辑实体类,例如事务控制是一个切面, 日志打印也是一个切面）</td></tr>
<tr><td>Join point</td><td>被拦截的方法</td></tr>
<tr><td>Advice</td><td>告诉AOP 在什么时候调用 切入的方法</td></tr>
<tr><td>Pointcut</td><td>被拦截的方法 以一个表达式定义</td></tr>
<tr><td>Introduction</td><td>引用允许你添加新方法或属性到现有的类中。</td></tr>
<tr><td>Target object</td><td>被拦截方法的对象</td></tr>
<tr><td>Weaving</td><td>Weaving 把方面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时，类加载时和运行时完成。</td></tr>
</tbody></table>
<h2 id="通知类型"><a class="header" href="#通知类型">通知类型</a></h2>
<table><thead><tr><th>通知</th><th>描述</th></tr></thead><tbody>
<tr><td>前置通知</td><td>在一个方法执行之前，执行通知。</td></tr>
<tr><td>后置通知</td><td>在一个方法执行之后，不考虑其结果，执行通知。</td></tr>
<tr><td>返回后通知</td><td>在一个方法执行之后，只有在方法成功完成时，才能执行通知。</td></tr>
<tr><td>抛出异常后通知</td><td>在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。</td></tr>
<tr><td>环绕通知</td><td>在建议方法调用之前和之后，执行通知。</td></tr>
</tbody></table>
<h1 id="spring-aop的目标"><a class="header" href="#spring-aop的目标">spring AOP的目标</a></h1>
<p>springAOP的目的不是与AspectJ竞争，提供最全面的AOP实现,而是提供与SpringIOC的无缝集成</p>
<h1 id="aop代理方式"><a class="header" href="#aop代理方式">AOP代理方式</a></h1>
<ul>
<li>默认使用 JDK动态代理,也提供了 基于 CGLIB的 动态代理</li>
<li>JDK动态代理 是基于接口的 代理</li>
<li>CGLIB 基于 继承的代理</li>
</ul>
<h1 id="基于注解的aop的步骤"><a class="header" href="#基于注解的aop的步骤">基于注解的AOP的步骤</a></h1>
<h2 id="启用aop代理功能"><a class="header" href="#启用aop代理功能">启用AOP代理功能</a></h2>
<pre><code class="language-java">@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
}
</code></pre>
<pre><code class="language-xml">&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<h2 id="申明一个切面"><a class="header" href="#申明一个切面">申明一个切面</a></h2>
<pre><code class="language-java">package org.xyz;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class NotVeryUsefulAspect {

}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;myAspect&quot; class=&quot;org.xyz.NotVeryUsefulAspect&quot;&gt;
    &lt;!-- configure properties of the aspect here --&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>注意事项</strong></p>
<ul>
<li>可以在xml中申明 切面类,也可以通过 @Aspect与 @Component 申明切面类</li>
<li>切面类本身不能称为代理的目标对象</li>
</ul>
<h2 id="申明切点"><a class="header" href="#申明切点">申明切点</a></h2>
<pre><code class="language-java">@Pointcut(&quot;execution(* transfer(..))&quot;) // the pointcut expression
private void anyOldTransfer() {} // the pointcut signature
</code></pre>
<p>切入点表达式详见: <a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html">AspectJ Programming Guide</a> </p>
<h1 id="aspectj语法"><a class="header" href="#aspectj语法">aspectJ语法</a></h1>
<h2 id="语法定义"><a class="header" href="#语法定义">语法定义</a></h2>
<pre><code>MethodPattern = 
  [ModifiersPattern] TypePattern 
        [TypePattern . ] IdPattern (TypePattern | &quot;..&quot; , ... ) 
        [ throws ThrowsPattern ]
ConstructorPattern = 
  [ModifiersPattern ] 
        [TypePattern . ] new (TypePattern | &quot;..&quot; , ...) 
        [ throws ThrowsPattern ]
FieldPattern = 
  [ModifiersPattern] TypePattern [TypePattern . ] IdPattern
ThrowsPattern = 
  [ ! ] TypePattern , ...
TypePattern = 
    IdPattern [ + ] [ [] ... ]
    | ! TypePattern
    | TypePattern &amp;&amp; TypePattern
    | TypePattern || TypePattern
    | ( TypePattern )  
IdPattern =
  Sequence of characters, possibly with special * and .. wildcards
ModifiersPattern =
  [ ! ] JavaModifier  ...
</code></pre>
<table><thead><tr><th>指示符</th><th>说明</th></tr></thead><tbody>
<tr><td>execution(<em><code>MethodPattern</code></em>)</td><td>匹配 执行方法 的签名</td></tr>
<tr><td>execution(<em><code>ConstructorPattern</code></em>)</td><td>匹配构造函数</td></tr>
<tr><td>within(<em><code>TypePattern</code></em>)</td><td>Picks out each join point <br />where the executing code is defined in a type matched by <em><code>TypePattern</code></em>.</td></tr>
<tr><td>this(<em><code>Type</code></em> or <em><code>Id</code></em>)</td><td>生成的代理对象 是 Type 或者 id 的一个实例,无法从静态实例对象中匹配</td></tr>
<tr><td>target(<em><code>Type</code></em> or <em><code>Id</code></em>)</td><td>被代理的对象</td></tr>
</tbody></table>
<h2 id="pattern说明"><a class="header" href="#pattern说明">pattern说明</a></h2>
<table><thead><tr><th>pattern</th><th>说明</th></tr></thead><tbody>
<tr><td><em>MethodPattern</em></td><td>方法表达式,匹配方法</td></tr>
<tr><td><em>ConstructorPattern</em></td><td>构造器表达式,匹配构造器</td></tr>
<tr><td><em>TypePattern</em></td><td>类型表达式, 匹配某个类</td></tr>
<tr><td><em>Type</em></td><td>全限定类名</td></tr>
</tbody></table>
<h2 id="指示符定义"><a class="header" href="#指示符定义">指示符定义</a></h2>
<h3 id="withintypepattern"><a class="header" href="#withintypepattern"><em>within(TypePattern)</em></a></h3>
<p>匹配包路径,</p>
<table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody>
<tr><td><code>within(com.learn.all..*)</code></td><td>com.learn.all包及子包下的任何方法执行</td></tr>
<tr><td><code>within(com.learn.service..IHelloService+)</code></td><td>com.learn.service包或所有子包下IHelloService类型及子类型的任何方法</td></tr>
<tr><td><code>within(@com.learn..Secure *)</code></td><td>持有com.learn..Secure注解的类的任何方法，注解必须是在目标对象上声明，对在接口上声明的不起作用</td></tr>
</tbody></table>
<h3 id="executionmethodpattern"><a class="header" href="#executionmethodpattern"><em>execution(MethodPattern)</em></a></h3>
<ul>
<li>拦截一个方法 (spriingAOP中主要用到的)</li>
<li>语法</li>
</ul>
<pre><code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)throws-pattern?)
//说明
访问修饰符 返回值类型 包路径 方法名( 参数名 ) 抛出异常的返回值
//示例
execution(public Integer com.weisanju.xjq.MethodName(*,String)
</code></pre>
<ul>
<li>注意点
<ul>
<li>除了返回值类型, 方法名,参数名 这三者,必选 其他的都可选</li>
<li>星号 表示一个或多个字符</li>
<li>param-pattern 有以下几种模式
<ul>
<li><code>()</code>  表示空参</li>
<li><code>(*)</code> 表示一个任意类型的参数 的方法</li>
<li><code>(*,String)</code> 表示两个参数 ,第一个是任意类型,第二个是 string类型</li>
<li><code>(..)</code> 表示任意多个参数</li>
</ul>
</li>
<li>this,target的作用
<ul>
<li>对 前面被PCD选中的类 进一步的筛选</li>
<li>取得该对象作为入参</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="argstypepattern"><a class="header" href="#argstypepattern"><em>args(typepattern)</em></a></h3>
<p>指定参数类型</p>
<h3 id="thistype"><a class="header" href="#thistype"><em>this(type)</em></a></h3>
<p>用于返回 当前代理对象的 当前类型或者 父类或接口实现</p>
<h3 id="targettype"><a class="header" href="#targettype"><em>target(type)</em></a></h3>
<p>返回 当前被代理的对象</p>
<h3 id="beanbeanid"><a class="header" href="#beanbeanid">bean(beanId)</a></h3>
<p>拦截指定bean的名称的方法</p>
<h3 id="within"><a class="header" href="#within">@within</a></h3>
<p>拦截 带有特定注解的类  的方法</p>
<h3 id="target"><a class="header" href="#target">@target</a></h3>
<p>拦截 目标对象持有指定注解的 方法</p>
<h3 id="args"><a class="header" href="#args">@args</a></h3>
<p>拦截参数持有指定注解的 方法</p>
<h3 id="annotation"><a class="header" href="#annotation">@annotation</a></h3>
<p>拦截方法持有指定注解的 方法</p>
<h3 id="declareparent"><a class="header" href="#declareparent">@declareParent</a></h3>
<p>为某一个类引入一个新的接口 以及接口的实现</p>
<pre><code>    @DeclareParents(value = &quot;com.weisanju.aop.test.TestClass&quot;,defaultImpl = DoSomethingImpl.class )
    private DoSomething doSomething;
    
    DoSomething 必须为接口
    DoSomethingImpl 必须为 DoSomething的实现类
    value为 类型匹配符
</code></pre>
<ul>
<li>在 AOP切面与 引入点 都作用于一个类 </li>
<li>则 引入的实现 是在 代理的对象 上, 即 this 而非target</li>
</ul>
<h2 id="类型匹配的通配符"><a class="header" href="#类型匹配的通配符">类型匹配的通配符</a></h2>
<ul>
<li>
<p>*：匹配任何数量字符；</p>
</li>
<li>
<p>..：匹配任何数量字符的重复，如在类型模式中匹配任何数量子包；而在方法参数模式中匹配任何数量参数。</p>
</li>
<li>
<p>+：匹配指定类型的子类型；仅能作为后缀放在类型模式后边。</p>
</li>
</ul>
<h2 id="切入点表达式组合"><a class="header" href="#切入点表达式组合">切入点表达式组合</a></h2>
<p>AspectJ使用 且（&amp;&amp;）、或（||）、非（！）来组合切入点表达式。</p>
<h1 id="通知参数"><a class="header" href="#通知参数">通知参数</a></h1>
<h2 id="joinpoint"><a class="header" href="#joinpoint">JoinPoint</a></h2>
<pre><code class="language-java">package org.aspectj.lang;  
import org.aspectj.lang.reflect.SourceLocation;  
public interface JoinPoint {  
    String toString();         //连接点所在位置的相关信息  
    String toShortString();     //连接点所在位置的简短相关信息  
    String toLongString();     //连接点所在位置的全部相关信息  
    Object getThis();         //返回AOP代理对象  
    Object getTarget();       //返回目标对象  
    Object[] getArgs();       //返回被通知方法参数列表  
    Signature getSignature();  //返回当前连接点签名  
    SourceLocation getSourceLocation();//返回连接点方法所在类文件中的位置  
    String getKind();        //连接点类型  
    StaticPart getStaticPart(); //返回连接点静态部分  
}  	
</code></pre>
<h2 id="proceedingjoinpoint"><a class="header" href="#proceedingjoinpoint">ProceedingJoinPoint</a></h2>
<blockquote>
<p>用于环绕通知，使用proceed()方法来执行目标方法</p>
</blockquote>
<pre><code class="language-java">public interface ProceedingJoinPoint extends JoinPoint {  
    public Object proceed() throws Throwable;  
    public Object proceed(Object[] args) throws Throwable;  
}
</code></pre>
<h2 id="joinpointstaticpart"><a class="header" href="#joinpointstaticpart">JoinPoint.StaticPart</a></h2>
<blockquote>
<p>提供访问连接点的静态部分，如被通知方法签名、连接点类型等</p>
</blockquote>
<pre><code class="language-java">public interface StaticPart {  
Signature getSignature();    //返回当前连接点签名  
String getKind();          //连接点类型  
    int getId();               //唯一标识  
String toString();         //连接点所在位置的相关信息  
    String toShortString();     //连接点所在位置的简短相关信息  
String toLongString();     //连接点所在位置的全部相关信息  
}  
</code></pre>
<h2 id="参数传递"><a class="header" href="#参数传递">参数传递</a></h2>
<ul>
<li>在Spring AOP中，除了execution和bean指示符不能传递参数给通知方法，其他指示符都可以将匹配的<strong>相应参数或对象自动传递给通知方法。</strong></li>
<li>JoinPoint、ProceedingJoinPoint或JoinPoint.StaticPart类型,这些类型对象会自动传入的，但必须作为第一个参数；</li>
</ul>
<pre><code>@Before(args(param) &amp;&amp; target(bean) &amp;&amp; @annotation(secure)&quot;,   
        argNames=&quot;jp,param,bean,secure&quot;)  
public void before5(JoinPoint jp, String param,
 IPointcutService pointcutService, Secure secure) {  
……  
}  
</code></pre>
<h2 id="参数传递的实例"><a class="header" href="#参数传递的实例">参数传递的实例</a></h2>
<pre><code class="language-java">package com.weisanju.aop.aspect;

import com.weisanju.aop.annotaion.TimeElapse;
import com.weisanju.aop.entity.Person;
import com.weisanju.aop.interfaces.DoSomething;
import com.weisanju.aop.interfaces.impl.DoSomethingImpl;
import com.weisanju.aop.test.TestClass;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

import java.text.MessageFormat;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Aspect
@Component
public class MyAspect {
    @DeclareParents(value = &quot;com.weisanju.aop.test.TestClass&quot;,defaultImpl = DoSomethingImpl.class )
    private DoSomething doSomething;
    @Pointcut(&quot;execution(* *log(..))&quot;)
    public void log(){}

    @Around(&quot;log()&quot;)
    public void doLog(ProceedingJoinPoint joinPoint){
        MessageFormat messageFormat = new MessageFormat(&quot;方法名%s,方法参数%s&quot;);
        System.out.print(&quot;方法开始执行:&quot;);
        Object[] args = joinPoint.getArgs();
        String format = messageFormat.format(joinPoint.getSignature().getName(), Stream.of(args).map(Object::toString).collect(Collectors.joining()));
        System.out.println(format);

        try {
            //joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println(&quot;方法执行完毕&quot;);
    }

    @Around(&quot; @annotation(unit)  &amp;&amp;  args(person) &amp;&amp; this(proxied) &amp;&amp; target(target)&quot;)
    public String timeCount(ProceedingJoinPoint joinPoint, TimeElapse unit, Person person, DoSomething proxied, TestClass target){
        String result = &quot;这是默认值&quot;;
        long start =System.currentTimeMillis();

        try {
            target.runElapse();
            System.out.println(&quot;哈哈原来是这样用的&quot;);

            proxied.doSomething();
            result= (String) joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println(&quot;总耗时:&quot;+(System.currentTimeMillis() - start)/unit.value());
        return result+person.toString();
    }
}

</code></pre>
<h1 id="基于xml的配置"><a class="header" href="#基于xml的配置">基于XML的配置</a></h1>
<ol>
<li>定义一个config</li>
<li>定义一个 切面</li>
<li>定义一个切入点</li>
<li>定义拦截的方法</li>
</ol>
<pre><code class="language-xml">&lt;aop:config&gt;
   &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;
      &lt;aop:pointcut id=&quot;businessService&quot; expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt;
      &lt;aop:before pointcut-ref=&quot;businessService&quot; 
         method=&quot;doRequiredTask&quot;/&gt;
      &lt;!-- an after advice definition --&gt;
      &lt;aop:after pointcut-ref=&quot;businessService&quot; 
         method=&quot;doRequiredTask&quot;/&gt;
      &lt;!-- an after-returning advice definition --&gt;
      &lt;!--The doRequiredTask method must have parameter named retVal --&gt;
      &lt;aop:after-returning pointcut-ref=&quot;businessService&quot;
         returning=&quot;retVal&quot;
         method=&quot;doRequiredTask&quot;/&gt;
      &lt;!-- an after-throwing advice definition --&gt;
      &lt;!--The doRequiredTask method must have parameter named ex --&gt;
      &lt;aop:after-throwing pointcut-ref=&quot;businessService&quot;
         throwing=&quot;ex&quot;
         method=&quot;doRequiredTask&quot;/&gt;
      &lt;!-- an around advice definition --&gt;
      &lt;aop:around pointcut-ref=&quot;businessService&quot; 
         method=&quot;doRequiredTask&quot;/&gt;
   ...
   &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建代理"><a class="header" href="#创建代理">创建代理</a></h1>
<h2 id="核心源代码"><a class="header" href="#核心源代码">核心源代码</a></h2>
<pre><code class="language-java">public Object getProxy(@Nullable ClassLoader classLoader) {

   try {
      Class&lt;?&gt; rootClass = this.advised.getTargetClass();
      Assert.state(rootClass != null, &quot;Target class must be available for creating a CGLIB proxy&quot;);

      Class&lt;?&gt; proxySuperClass = rootClass;
      //如果是代理类
      if (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) {
          //获取父类
         proxySuperClass = rootClass.getSuperclass();
         Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();
         for (Class&lt;?&gt; additionalInterface : additionalInterfaces) {
            this.advised.addInterface(additionalInterface);
         }
      }

      // Validate the class, writing log messages as necessary.
      validateClassIfNecessary(proxySuperClass, classLoader);

      // Configure CGLIB Enhancer...
      Enhancer enhancer = createEnhancer();
      if (classLoader != null) {
         enhancer.setClassLoader(classLoader);
         if (classLoader instanceof SmartClassLoader &amp;&amp;
               ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) {
            enhancer.setUseCache(false);
         }
      }
      //设置代理目标类
      enhancer.setSuperclass(proxySuperClass);
      //设置接口
      enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
      enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
      enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(classLoader));
       //获取回调
      Callback[] callbacks = getCallbacks(rootClass);
      Class&lt;?&gt;[] types = new Class&lt;?&gt;[callbacks.length];
      //缓存回调类
      for (int x = 0; x &lt; types.length; x++) {
         types[x] = callbacks[x].getClass();
      }
       //设置 callbackFilter
      // fixedInterceptorMap only populated at this point, after getCallbacks call above
      enhancer.setCallbackFilter(new ProxyCallbackFilter(
            this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));
       //设置回调的类型
      enhancer.setCallbackTypes(types);
       
      // Generate the proxy class and create a proxy instance.
      return createProxyClassAndInstance(enhancer, callbacks);
   }
   catch (CodeGenerationException | IllegalArgumentException ex) {
      throw new AopConfigException(&quot;Could not generate CGLIB subclass of &quot; + this.advised.getTargetClass() +
            &quot;: Common causes of this problem include using a final class or a non-visible class&quot;,
            ex);
   }
   catch (Throwable ex) {
      // TargetSource.getTarget() failed
      throw new AopConfigException(&quot;Unexpected AOP exception&quot;, ex);
   }
}
</code></pre>
<h2 id="获取回调"><a class="header" href="#获取回调">获取回调</a></h2>
<pre><code class="language-java">private Callback[] getCallbacks(Class&lt;?&gt; rootClass) throws Exception {
   // Parameters used for optimization choices...
    //是否暴露代理类
   boolean exposeProxy = this.advised.isExposeProxy();
    //是否冻结配置
   boolean isFrozen = this.advised.isFrozen();
    //对象是否是可变的
   boolean isStatic = this.advised.getTargetSource().isStatic();

    
   // Choose an &quot;aop&quot; interceptor (used for AOP calls). aop链式调用
   Callback aopInterceptor = new DynamicAdvisedInterceptor(this.advised);

   // Choose a &quot;straight to target&quot; interceptor. (used for calls that are
   // unadvised but can return this). May be required to expose the proxy.
   Callback targetInterceptor; //直接调用目标方法
   if (exposeProxy) {
      targetInterceptor = (isStatic ?
            new StaticUnadvisedExposedInterceptor(this.advised.getTargetSource().getTarget()) :
            new DynamicUnadvisedExposedInterceptor(this.advised.getTargetSource()));
   }
   else {
      targetInterceptor = (isStatic ?
            new StaticUnadvisedInterceptor(this.advised.getTargetSource().getTarget()) :
            new DynamicUnadvisedInterceptor(this.advised.getTargetSource()));
   }

   // Choose a &quot;direct to target&quot; dispatcher (used for
   // unadvised calls to static targets that cannot return this). 直接调用实际 Target的方法
   Callback targetDispatcher = (isStatic ?
         new StaticDispatcher(this.advised.getTargetSource().getTarget()) : new SerializableNoOp());

   Callback[] mainCallbacks = new Callback[] {
         aopInterceptor,  // for normal advice  普通AOP调用  0
         targetInterceptor,  // invoke target without considering advice, if optimized  调用  1
         new SerializableNoOp(),  // no override for methods mapped to this 调用父类的方法   2
         targetDispatcher,//直接 调用target的方法  3
       this.advisedDispatcher, //调用 advised对象中的方法 4
         new EqualsInterceptor(this.advised),  //equals  5
         new HashCodeInterceptor(this.advised) //hashcode  6
   };

   Callback[] callbacks;

   // If the target is a static one and the advice chain is frozen,
   // then we can make some optimizations by sending the AOP calls
   // direct to the target using the fixed chain for that method.
   if (isStatic &amp;&amp; isFrozen) {
       //获取所有 公共方法，每个方法创建FixedChainStaticTargetInterceptor拦截器
      Method[] methods = rootClass.getMethods();
      Callback[] fixedCallbacks = new Callback[methods.length];
      this.fixedInterceptorMap = CollectionUtils.newHashMap(methods.length);

      // TODO: small memory optimization here (can skip creation for methods with no advice)
      for (int x = 0; x &lt; methods.length; x++) {
         Method method = methods[x];
         List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, rootClass);
         fixedCallbacks[x] = new FixedChainStaticTargetInterceptor(
               chain, this.advised.getTargetSource().getTarget(), this.advised.getTargetClass());
         this.fixedInterceptorMap.put(method, x);
      }

      // Now copy both the callbacks from mainCallbacks
      // and fixedCallbacks into the callbacks array.
      callbacks = new Callback[mainCallbacks.length + fixedCallbacks.length];
      System.arraycopy(mainCallbacks, 0, callbacks, 0, mainCallbacks.length);
      System.arraycopy(fixedCallbacks, 0, callbacks, mainCallbacks.length, fixedCallbacks.length);
      this.fixedInterceptorOffset = mainCallbacks.length;
   }
   else {
      callbacks = mainCallbacks;
   }
   return callbacks;
}
</code></pre>
<h2 id="确定每个方法的拦截器"><a class="header" href="#确定每个方法的拦截器">确定每个方法的拦截器</a></h2>
<pre><code class="language-java">//org.springframework.aop.framework.CglibAopProxy.ProxyCallbackFilter#accept
		public int accept(Method method) {
            //finanl方法 直接 调用父类的
			if (AopUtils.isFinalizeMethod(method)) {
				logger.trace(&quot;Found finalize() method - using NO_OVERRIDE&quot;);
				return NO_OVERRIDE;
			}
            //用户透明的、接口、而且是在 Advised类申明的方法
			if (!this.advised.isOpaque() &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;
					method.getDeclaringClass().isAssignableFrom(Advised.class)) {
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Method is declared on Advised interface: &quot; + method);
				}
                //调用 Advised类中的方法
				return DISPATCH_ADVISED;
			}
			// We must always proxy equals, to direct calls to this.调用 Equals方法
			if (AopUtils.isEqualsMethod(method)) {
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Found 'equals' method: &quot; + method);
				}
				return INVOKE_EQUALS;
			}
			// We must always calculate hashCode based on the proxy.  基于proxy计算hashcode
			if (AopUtils.isHashCodeMethod(method)) {
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Found 'hashCode' method: &quot; + method);
				}
				return INVOKE_HASHCODE;
			}
            //非增强方法的处理
            
			Class&lt;?&gt; targetClass = this.advised.getTargetClass();
			// Proxy is not yet available, but that shouldn't matter.
            //获取调用链条
			List&lt;?&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
			boolean haveAdvice = !chain.isEmpty();
			boolean exposeProxy = this.advised.isExposeProxy();
			boolean isStatic = this.advised.getTargetSource().isStatic();
			boolean isFrozen = this.advised.isFrozen();
            //存在调用链、或者非冻结的配置使用 aopInterceptor(该配置在调用时  实时匹配调用)
			if (haveAdvice || !isFrozen) {
				// If exposing the proxy, then AOP_PROXY must be used.
				if (exposeProxy) { //如果需要暴露代理 
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Must expose proxy on advised method: &quot; + method);
					}
                    //
					return AOP_PROXY;
				}
				// Check to see if we have fixed interceptor to serve this method.
				// Else use the AOP_PROXY. 如果是 静态的 、且 配置 冻结 了 而且包含了 此method
				if (isStatic &amp;&amp; isFrozen &amp;&amp; this.fixedInterceptorMap.containsKey(method)) {
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Method has advice and optimizations are enabled: &quot; + method);
					}  //则调用该出索引的Method
					// We know that we are optimizing so we can use the FixedStaticChainInterceptors.
					int index = this.fixedInterceptorMap.get(method);
					return (index + this.fixedInterceptorOffset);
				}
				else {
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Unable to apply any optimizations to advised method: &quot; + method);
					}
                    //否则 还是使用 动态
					return AOP_PROXY;
				}
			}
			else {
				// See if the return type of the method is outside the class hierarchy of the target type.
                // 查看方法的返回类型是否在目标类型的类层次结构之外。
				// 如果在之外，则不需要对返回值进行类型转换，直接静态dispatcher.
				// 如果 代理被暴露, 必须使用拦截器. 
                // 如果目标不是静态的，那么我们不能使用调度器，因为 目标需要在调用后显式释放。
				if (exposeProxy || !isStatic) {
					return INVOKE_TARGET;
				}
				Class&lt;?&gt; returnType = method.getReturnType();
				if (targetClass != null &amp;&amp; returnType.isAssignableFrom(targetClass)) {
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Method return type is assignable from target type and &quot; +
								&quot;may therefore return 'this' - using INVOKE_TARGET: &quot; + method);
					}
					return INVOKE_TARGET;
				}
				else {
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Method return type ensures 'this' cannot be returned - &quot; +
								&quot;using DISPATCH_TARGET: &quot; + method);
					}
					return DISPATCH_TARGET;
				}
			}
		}
</code></pre>
<h1 id="运行逻辑"><a class="header" href="#运行逻辑">运行逻辑</a></h1>
<h2 id="final不覆盖"><a class="header" href="#final不覆盖">final不覆盖</a></h2>
<p>如果是final方法则 NO_OVERRIDE，对应于 <em>NoOp</em> 即：不覆盖方法</p>
<h2 id="如果是advised接口的方法"><a class="header" href="#如果是advised接口的方法">如果是Advised接口的方法</a></h2>
<p>则直接转发到 this.advised对象上</p>
<h2 id="equals-hashcode-调用代理类的方法"><a class="header" href="#equals-hashcode-调用代理类的方法">Equals HashCode 调用代理类的方法</a></h2>
<h2 id="如果没有advice且-不需要暴露代理且是静态-而且不需要返回this"><a class="header" href="#如果没有advice且-不需要暴露代理且是静态-而且不需要返回this">如果没有Advice且 不需要暴露代理且是静态 而且不需要返回this</a></h2>
<p>直接转发到 <em>target</em>的 方法上</p>
<h2 id="如果没有advice且-需要暴露代理或者非静态或者返回值为this"><a class="header" href="#如果没有advice且-需要暴露代理或者非静态或者返回值为this">如果没有Advice且 需要暴露代理或者非静态或者返回值为this</a></h2>
<p>则调用 <em>INVOKE_TARGET</em></p>
<h2 id="存在-advice且静态的冻结配置了的且存在拦截方法"><a class="header" href="#存在-advice且静态的冻结配置了的且存在拦截方法">存在 Advice,且（静态的、冻结配置了的、且存在拦截方法）</a></h2>
<p>使用静态拦截器：在代理的时刻：已经确定好哪些拦截器</p>
<h2 id="存在-advice且需要暴露代理或者非静态或者没有冻结配置或者还不存在拦截方法"><a class="header" href="#存在-advice且需要暴露代理或者非静态或者没有冻结配置或者还不存在拦截方法">存在 Advice,且（需要暴露代理、或者非静态或者没有冻结配置、或者还不存在拦截方法）</a></h2>
<p>使用动态拦截器：在调用时匹配拦截方法</p>
<p><strong>动态拦截逻辑</strong></p>
<pre><code class="language-java">//DynamicAdvisedInterceptor#intercept
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
   Object oldProxy = null;
   boolean setProxyContext = false;
   Object target = null;
    //获取目标类
   TargetSource targetSource = this.advised.getTargetSource();
   try {
       //暴露代理类
      if (this.advised.exposeProxy) {
         // Make invocation available if necessary.
         oldProxy = AopContext.setCurrentProxy(proxy);
         setProxyContext = true;
      }
      // Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...
       //获取目标
      target = targetSource.getTarget();
       //获取目标class
      Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);
       //获取动态拦截器：从spring容器中获取所有Advisor对象并对 method,class一一匹配
      List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
      Object retVal;
      // Check whether we only have one InvokerInterceptor: that is,
      // no real advice, but just reflective invocation of the target.
       //没有代理类，直接调用目标方法
      if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) {
         // We can skip creating a MethodInvocation: just invoke the target directly.
         // Note that the final invoker must be an InvokerInterceptor, so we know
         // it does nothing but a reflective operation on the target, and no hot
         // swapping or fancy proxying.
         Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
         retVal = methodProxy.invoke(target, argsToUse);
      }
      else {
          //生成责任链调用类，进行链式调用
         // We need to create a method invocation...
         retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();
      }
       //处理返回值
      retVal = processReturnType(proxy, target, method, retVal);
      return retVal;
   }
   finally {
       //释放target
      if (target != null &amp;&amp; !targetSource.isStatic()) {
         targetSource.releaseTarget(target);
      }
       //还原代理对象
      if (setProxyContext) {
         // Restore old proxy.
         AopContext.setCurrentProxy(oldProxy);
      }
   }
}
</code></pre>
<p><strong>链式调用</strong></p>
<pre><code class="language-java">private static class CglibMethodInvocation extends ReflectiveMethodInvocation {

   @Nullable
   private final MethodProxy methodProxy;

   public CglibMethodInvocation(Object proxy, @Nullable Object target, Method method,
         Object[] arguments, @Nullable Class&lt;?&gt; targetClass,
         List&lt;Object&gt; interceptorsAndDynamicMethodMatchers, MethodProxy methodProxy) {

      super(proxy, target, method, arguments, targetClass, interceptorsAndDynamicMethodMatchers);

      // Only use method proxy for public methods not derived from java.lang.Object
      this.methodProxy = (Modifier.isPublic(method.getModifiers()) &amp;&amp;
            method.getDeclaringClass() != Object.class &amp;&amp; !AopUtils.isEqualsMethod(method) &amp;&amp;
            !AopUtils.isHashCodeMethod(method) &amp;&amp; !AopUtils.isToStringMethod(method) ?
            methodProxy : null);
   }

   @Override
   @Nullable
   public Object proceed() throws Throwable {
      try {
         return super.proceed();
      }
      catch (RuntimeException ex) {
         throw ex;
      }
      catch (Exception ex) {
         if (ReflectionUtils.declaresException(getMethod(), ex.getClass()) ||
               KotlinDetector.isKotlinType(getMethod().getDeclaringClass())) {
            // Propagate original exception if declared on the target method
            // (with callers expecting it). Always propagate it for Kotlin code
            // since checked exceptions do not have to be explicitly declared there.
            throw ex;
         }
         else {
            // Checked exception thrown in the interceptor but not declared on the
            // target method signature -&gt; apply an UndeclaredThrowableException,
            // aligned with standard JDK dynamic proxy behavior.
            throw new UndeclaredThrowableException(ex);
         }
      }
   }

   /**
    * 直接目标方法调用：通过 方法名称确定调用哪个方法：有略微的性能提升
    * Gives a marginal performance improvement versus using reflection to
    * invoke the target when invoking public methods.
    */
   @Override
   protected Object invokeJoinpoint() throws Throwable {
       //跳过Object的方法
      if (this.methodProxy != null) {
         return this.methodProxy.invoke(this.target, this.arguments);
      }
      else {
		//object方法使用反射调用
         return super.invokeJoinpoint();
      }
   }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jdk动态代理-1"><a class="header" href="#jdk动态代理-1">jdk动态代理</a></h1>
<h2 id="实例化"><a class="header" href="#实例化">实例化</a></h2>
<p>实例化 <em>JdkDynamicAopProxy</em> 时  获取所有需要代理的接口</p>
<pre><code class="language-java">public JdkDynamicAopProxy(AdvisedSupport config) throws AopConfigException {
   Assert.notNull(config, &quot;AdvisedSupport must not be null&quot;);
   if (config.getAdvisorCount() == 0 &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {
      throw new AopConfigException(&quot;No advisors and no TargetSource specified&quot;);
   }
   this.advised = config;
   this.proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);
   findDefinedEqualsAndHashCodeMethods(this.proxiedInterfaces);
}
</code></pre>
<h2 id="获取实例对象"><a class="header" href="#获取实例对象"><strong>获取实例对象</strong></a></h2>
<pre><code class="language-java">public Object getProxy(ClassLoader classLoader) {
	if (logger.isDebugEnabled()) {
		logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());
	}
	// 获取所有需要代理的接口
	Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);
	findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
	// 返回代理对象的实例
	return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
}
</code></pre>
<h2 id="代理对象入口方法"><a class="header" href="#代理对象入口方法">代理对象入口方法</a></h2>
<p>自己作为InvocationHandler注册，看他的invoke方法</p>
<pre><code class="language-java">//org.springframework.aop.framework.JdkDynamicAopProxy#invokes
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		Object oldProxy = null;
		boolean setProxyContext = false;

		TargetSource targetSource = this.advised.targetSource;
		Object target = null;

		try {
	//	没有声明equals方法，调用equals方法时，委托调用。
			if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) {
				// The target does not implement the equals(Object) method itself.
				return equals(args[0]);
			}
			// 没有声明hashCode方法，调用hashCode方法时，委托调用。
			else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) {
				// The target does not implement the hashCode() method itself.
				return hashCode();
			}
			// 如果调用的方法是DecoratingProxy中的方法，因为其中只有一个getDecoratedClass方法，这里直接返回被装饰的Class即可
			else if (method.getDeclaringClass() == DecoratingProxy.class) {
				// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.
				return AopProxyUtils.ultimateTargetClass(this.advised);
			}
			// 代理不是不透明的，且是接口中声明的方法，且是Advised或其父接口的方法，则直接调用构造时传入的advised对象的相应方法
			else if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;
					method.getDeclaringClass().isAssignableFrom(Advised.class)) {
				// Service invocations on ProxyConfig with the proxy config...
				return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
			}

			Object retVal;
 // 如果暴露代理，则用AopContext保存当前代理对象。用于多级代理时获取当前的代理对象，一个有效应用是同类中调用方法，代理拦截器会无效。可以使用AopContext.currentProxy()获得代理对象并调用。
			if (this.advised.exposeProxy) {
				// Make invocation available if necessary.
				oldProxy = AopContext.setCurrentProxy(proxy);
				setProxyContext = true;
			}

			// Get as late as possible to minimize the time we &quot;own&quot; the target,
			// in case it comes from a pool.
			target = targetSource.getTarget();
			Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);

		// 这里是关键，获得拦截链chain，是通过advised对象，即config对象获得的。
			List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

			// Check whether we have any advice. If we don't, we can fallback on direct
			// reflective invocation of the target, and avoid creating a MethodInvocation.
			if (chain.isEmpty()) {
				// We can skip creating a MethodInvocation: just invoke the target directly
				// Note that the final invoker must be an InvokerInterceptor so we know it does
				// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.
				Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);			// 如果链是空，则直接调用被代理对象的方法
				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
			}
			else {
			// 否则创建一个MethodInvocation对象，用于链式调用拦截器链chain中的拦截器。
				// We need to create a method invocation...
				MethodInvocation invocation =
						new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
				// 开始执行链式调用，得到返回结果
				retVal = invocation.proceed();
			}

			// Massage return value if necessary.
			Class&lt;?&gt; returnType = method.getReturnType();
			if (retVal != null &amp;&amp; retVal == target &amp;&amp;
					returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;
					!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {
				// Special case: it returned &quot;this&quot; and the return type of the method
				// is type-compatible. Note that we can't help if the target sets
				// a reference to itself in another returned object.
					// 处理返回值
			// 如果返回结果是this，即原始对象，且方法所在类没有标记为RawTargetAccess(不是RawTargetAccess的实现类或者子接口)，则返回代理对象。
				retVal = proxy;
			}
			else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) {
				throw new AopInvocationException(
						&quot;Null return value from advice does not match primitive return type for: &quot; + method);
			}
			return retVal;
		}
		finally {
			if (target != null &amp;&amp; !targetSource.isStatic()) {
				// Must have come from TargetSource.
				targetSource.releaseTarget(target);
			}
			if (setProxyContext) {
				// Restore old proxy.
				AopContext.setCurrentProxy(oldProxy);
			}
		}
	}
</code></pre>
<h2 id="执行调用链"><a class="header" href="#执行调用链">执行调用链</a></h2>
<pre><code class="language-java">//org.springframework.aop.framework.ReflectiveMethodInvocation#proceed
	public Object proceed() throws Throwable {
		// We start with an index of -1 and increment early.
		if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
            // 链全部执行完，再次调用proceed时，返回原始对象方法调用执行结果。递归的终止。
			return invokeJoinpoint();
		}
// 用currentInterceptorIndex记录当前的interceptor位置，初值-1，先++再获取。当再拦截器中调用invocation.proceed()时，递归进入此方法，索引向下移位，获取下一个拦截器。
		Object interceptorOrInterceptionAdvice =
				this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
         // 如果是InterceptorAndDynamicMethodMatcher则再执行一次动态匹配
		if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
			// Evaluate dynamic method matcher here: static part will already have
			// been evaluated and found to match.
			InterceptorAndDynamicMethodMatcher dm =
					(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
			Class&lt;?&gt; targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass());
			if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) {
                 // 匹配成功，执行
				return dm.interceptor.invoke(this);
			}
			else {
				// Dynamic matching failed.
				// Skip this interceptor and invoke the next in the chain.
                // 匹配失败，跳过该拦截器，递归调用本方法，执行下一个拦截器。
				return proceed();
			}
		}
		else {
			// It's an interceptor, so we just invoke it: The pointcut will have
			// been evaluated statically before this object was constructed.
            // 如果是interceptor，则直接调用invoke。把自己作为invocation，以便在invoke方法中，调用invocation.proceed()来执行递归。或者invoke中也可以不执行invocation.proceed()，强制结束递归，返回指定对象作为结果。
			return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
		}
	}
</code></pre>
<h2 id="获取拦截器"><a class="header" href="#获取拦截器">获取拦截器</a></h2>
<pre><code class="language-java">//org.springframework.aop.framework.DefaultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice
	public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(
			Advised config, Method method, @Nullable Class&lt;?&gt; targetClass) {

		// This is somewhat tricky... We have to process introductions first,
		// but we need to preserve order in the ultimate list.
		AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();
        
        //获取 Advised对象中的 advisors
		Advisor[] advisors = config.getAdvisors();
		List&lt;Object&gt; interceptorList = new ArrayList&lt;&gt;(advisors.length);
		Class&lt;?&gt; actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());
		Boolean hasIntroductions = null;

     	//从 advisor手上 获取 Advice
		for (Advisor advisor : advisors) {
            //如果是带有切面的，则执行切面条件匹配
			if (advisor instanceof PointcutAdvisor) {
				// Add it conditionally.
				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;
                //如果 Class匹配则 继续进行方法匹配
				if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {
					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();
					boolean match;
					if (mm instanceof IntroductionAwareMethodMatcher) {
						if (hasIntroductions == null) {
							hasIntroductions = hasMatchingIntroductions(advisors, actualClass);
						}
						match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);
					}
					else {
						match = mm.matches(method, actualClass);
					}
					if (match) {
                        //匹配成功且 还包含运行时匹配的：则创建 运行时匹配对象
                        //这里从 advisor中获取 advice,包含从spring的 interceptor转换为 aop的interceptor
						MethodInterceptor[] interceptors = registry.getInterceptors(advisor);
						if (mm.isRuntime()) {
							// Creating a new object instance in the getInterceptors() method
							// isn't a problem as we normally cache created chains.
							for (MethodInterceptor interceptor : interceptors) {
								interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));
							}
						}
						else {
							interceptorList.addAll(Arrays.asList(interceptors));
						}
					}
				}
			}
			else if (advisor instanceof IntroductionAdvisor) {
				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;
				if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {
					Interceptor[] interceptors = registry.getInterceptors(advisor);
					interceptorList.addAll(Arrays.asList(interceptors));
				}
			}
			else {
				Interceptor[] interceptors = registry.getInterceptors(advisor);
				interceptorList.addAll(Arrays.asList(interceptors));
			}
		}

		return interceptorList;
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proxyconfig"><a class="header" href="#proxyconfig">ProxyConfig</a></h1>
<p>一个代理对象的配置信息，包括代理的各种属性，如基于接口还是基于类构造代理。</p>
<h2 id="optimize"><a class="header" href="#optimize">optimize</a></h2>
<p>设置代理 是否应该执行 积极的优化</p>
<p>The exact meaning of &quot;aggressive optimizations&quot; will differ between proxies, but there is usually some tradeoff. Default is &quot;false&quot;.</p>
<p>“积极优化”的确切含义因代理而异，但通常会有一些权衡。默认为 false</p>
<p>例如，优化通常意味着在创建代理后通知更改不会生效,因此，默认情况下禁用优化。</p>
<p>如果其他设置阻止优化，则可以忽略“true”的优化值</p>
<p>An optimize value of &quot;true&quot; may be ignored if other settings preclude optimization: for example, 如果“exposeProxy”设置为“true”与 <strong>optimize</strong>  不兼容。</p>
<h2 id="opaque"><a class="header" href="#opaque">opaque</a></h2>
<p>设置是否应防止此配置创建的代理被强制转换为 <strong>Advised</strong> 以查询代理状态</p>
<p>默认是<em>false</em> 意味着任何AOP 代理 能够被转换成 <em>Advised</em></p>
<h2 id="proxytargetclass"><a class="header" href="#proxytargetclass">proxyTargetClass</a></h2>
<p>设置是否直接代理目标类，而不是只代理特定的接口。默认为“false”。</p>
<p>设置为“true”以强制代理 TargetSource 的公开目标类。</p>
<p>如果该目标类是一个接口，则会为给定的接口创建一个 JDK 代理</p>
<p>如果该目标类是任何其他类，则将为给定类创建 CGLIB 代理。</p>
<p>根据具体代理工厂的配置，如果没有指定接口（并且没有激活接口自动检测），也将应用代理目标类行为。</p>
<h2 id="exposeproxy"><a class="header" href="#exposeproxy">exposeProxy</a></h2>
<p>Set whether the proxy should be exposed by the AOP framework as a ThreadLocal for retrieval via the AopContext class.</p>
<p>设置代理是否应由 AOP 框架公开为 ThreadLocal 以通过 AopContext 类进行检索。</p>
<p>如果一个被通知的对象需要对自己调用另一个被通知的方法，这很有用。</p>
<p>(If it uses this, the invocation will not be advised).</p>
<p>默认为“false”，以避免不必要的额外拦截</p>
<p>这意味着不保证 AopContext 访问将在建议对象的任何方法中一致地工作。</p>
<h2 id="frozen"><a class="header" href="#frozen">frozen</a></h2>
<p>设置是否应冻结此配置。</p>
<p>当配置被冻结时，不能进行任何建议更改</p>
<p>这对于优化很有用，当我们不希望调用者在转换为 Advised 后能够操作配置时很有用。</p>
<h1 id="proxyprocessorsupport"><a class="header" href="#proxyprocessorsupport">ProxyProcessorSupport</a></h1>
<blockquote>
<p>继承于 <em>ProxyConfig</em></p>
</blockquote>
<p>具有代理处理器通用功能的基类 特别是 </p>
<ol>
<li>classLoader管理</li>
<li>类的接口查找算法</li>
</ol>
<h1 id="advisoradapter"><a class="header" href="#advisoradapter">AdvisorAdapter</a></h1>
<p>实现对象可以从自定义通知类型创建 AOP Alliance  拦截器，使这些通知类型能够在 Spring AOP 框架中使用，该框架在幕后使用拦截。</p>
<p>大多数 Spring 用户不需要实现这个接口；仅当您需要向 Spring 引入更多 Advisor 或 Advice 类型时才这样做。</p>
<pre><code class="language-java">// 是否支持Advice
boolean supportsAdvice(Advice advice);
// 返回一个 AOP Alliance MethodInterceptor，将给定建议的行为暴露给基于拦截的 AOP 框架。不要担心Advisor 中包含的任何切入点； AOP 框架将负责检查切入点。
MethodInterceptor getInterceptor(Advisor advisor);
</code></pre>
<h1 id="advisoradapterregistry"><a class="header" href="#advisoradapterregistry">AdvisorAdapterRegistry</a></h1>
<blockquote>
<p>advisorAdapter 注册器接口</p>
</blockquote>
<h1 id="abstractautoproxycreator"><a class="header" href="#abstractautoproxycreator">AbstractAutoProxyCreator</a></h1>
<p>使用 AOP 代理包装每个符合条件的 bean，在调用 bean 本身之前委托给指定的拦截器。</p>
<p>此类区分“通用”拦截器（为它创建的所有代理共享），以及“特定”拦截器（每个 bean 实例唯一）</p>
<p>他们不需要任何通用的拦截器。如果有，则使用interceptorNames 属性设置它们</p>
<p>与 org.springframework.aop.framework.ProxyFactoryBean 一样，使用当前工厂中的拦截器名称而不是 bean 引用来允许正确处理原型顾问和拦截器：例如，支持有状态的混合。</p>
<p><code>interceptorNames</code>条目支持任何advice类型。</p>
<p>如果有大量 bean 需要用类似的代理包装，即委托给相同的拦截器，这种自动代理特别有用委托给相同的拦截器。</p>
<p>代替 x 个目标 bean 的 x 个重复代理定义，您可以向 bean 工厂注册一个这样的后处理器以实现相同的效果。</p>
<p>子类可以应用任何策略来决定是否要代理 bean，例如按类型、按名称、按定义详细信息等。</p>
<p>它们还可以返回应仅应用于特定 bean 实例的其他拦截器</p>
<p>一个简单的具体实现是 BeanNameAutoProxyCreator，它通过给定的名称识别要代理的 bean。</p>
<p>可以使用任意数量的 TargetSourceCreator 实现来创建自定义目标源</p>
<p>例如，池化原型对象。</p>
<p>即使没有   <strong>advice</strong>，只要 TargetSourceCreator 指定自定义 TargetSource，就会发生自动代理。</p>
<p>如果没有设置 TargetSourceCreators，或者没有匹配项，默认情况下将使用 SingletonTargetSource 来包装目标 bean 实例。</p>
<h1 id="aopproxyfactory"><a class="header" href="#aopproxyfactory">AopProxyFactory</a></h1>
<p>AopProxy代理工厂类，用于生成代理对象AopProxy</p>
<h1 id="aopproxy"><a class="header" href="#aopproxy">AopProxy</a></h1>
<p>代表一个AopProxy代理对象，可以通过这个对象构造代理对象实例。</p>
<pre><code class="language-java">public interface AopProxy {
 Object getProxy();
 Object getProxy(ClassLoader classLoader);
}
</code></pre>
<h1 id="advised接口"><a class="header" href="#advised接口">Advised接口</a></h1>
<p>代表被Advice增强的对象，包括添加advisor的方法、添加advice等的方法。</p>
<h1 id="advisedsupport类"><a class="header" href="#advisedsupport类">AdvisedSupport类</a></h1>
<p>对Advised的构建提供支持，Advised的实现类以及ProxyConfig的子类。</p>
<ol>
<li>
<p>提供Advisor的 增删改查</p>
</li>
<li>
<p>提供 <em>AdvisorChainFactory</em> 从 Advisor中获取所有 <em>Advice</em></p>
</li>
</ol>
<p><strong>AdvisedSupport对象的作用</strong></p>
<ol>
<li>
<p>获取拦截器</p>
</li>
<li>
<p>提供targetSource</p>
</li>
<li>
<p>提供Advisor的憎删改查</p>
</li>
<li>
<p>代理对象的配置</p>
</li>
<li>
<p>透明与不透明</p>
</li>
<li>
<p>暴露代理</p>
</li>
</ol>
<h1 id="proxycreatorsupport"><a class="header" href="#proxycreatorsupport">ProxyCreatorSupport</a></h1>
<p>AdvisedSupport的子类，创建代理对象的支持类，内部包含<strong>AopProxyFactory</strong>工厂成员，可直接使用工厂成员创建Proxy。</p>
<h1 id="proxyfactory类"><a class="header" href="#proxyfactory类">ProxyFactory类</a></h1>
<p>ProxyCreatorSupport的子类，<strong>用于生成代理对象实例的工厂类</strong></p>
<p>相比 ProxyCreatorSupport 提供了 <em>getProxy</em> 的方法</p>
<h1 id="advisor接口"><a class="header" href="#advisor接口">Advisor接口</a></h1>
<p>代表一个增强器提供者的对象，内部包含getAdvice方法获取增强器。</p>
<h1 id="advisorchainfactory"><a class="header" href="#advisorchainfactory">AdvisorChainFactory</a></h1>
<p>获取增强器链的工厂接口。提供方法返回所有增强器，以数组返回。</p>
<h1 id="pointcut接口"><a class="header" href="#pointcut接口">Pointcut接口</a></h1>
<p>切入点，用于匹配类与方法，满足切入点的条件是才插入advice。相关接口：ClassFilter、MethodMatcher。</p>
<h1 id="annotationmatchingpointcut"><a class="header" href="#annotationmatchingpointcut">AnnotationMatchingPointcut</a></h1>
<p>基于注解的<em>PointCut</em></p>
<p>有三个成员变量</p>
<ol>
<li>基于类的注解 Class：用于类匹配</li>
<li>基于方法的注解 Class：用于方法匹配</li>
<li>是由启用继承</li>
</ol>
<h1 id="abstractbeanfactorypointcutadvisor"><a class="header" href="#abstractbeanfactorypointcutadvisor">AbstractBeanFactoryPointcutAdvisor</a></h1>
<p>基于<em>Beanfactory</em> 的 <em>PointcutAdvisor</em>,从 Beanfactory获取Advice</p>
<p>成员变量</p>
<p><em>adviceBeanName</em></p>
<p><em>beanFactory</em></p>
<p><em>advice</em></p>
<pre><code class="language-java">public Advice getAdvice() {
   Advice advice = this.advice;
   if (advice != null) {
      return advice;
   }

   Assert.state(this.adviceBeanName != null, &quot;'adviceBeanName' must be specified&quot;);
   Assert.state(this.beanFactory != null, &quot;BeanFactory must be set to resolve 'adviceBeanName'&quot;);
	//单例的化从 Bean工厂获取后 缓存
   if (this.beanFactory.isSingleton(this.adviceBeanName)) {
      // Rely on singleton semantics provided by the factory.
      advice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);
      this.advice = advice;
      return advice;
   }
   else {
      // No singleton guarantees from the factory -&gt; let's lock locally but
      // reuse the factory's singleton lock, just in case a lazy dependency
      // of our advice bean happens to trigger the singleton lock implicitly...
       //懒加载、加锁
      synchronized (this.adviceMonitor) {
         advice = this.advice;
         if (advice == null) {
            advice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);
            this.advice = advice;
         }
         return advice;
      }
   }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="总结-14"><a class="header" href="#总结-14">总结</a></h1>
<ol>
<li>所有 手动编程式代理 继承 <em>AbstractBeanFactoryAwareAdvisingPostProcessor</em></li>
<li>并在实现中 赋值  <em>advisor</em> </li>
</ol>
<h1 id="proxyprocessorsupport-1"><a class="header" href="#proxyprocessorsupport-1"><strong>ProxyProcessorSupport</strong></a></h1>
<p>继承自 <em>ProxyConfig</em> 在此基础上添加了 类加载器的管理</p>
<h1 id="abstractadvisingbeanpostprocessor"><a class="header" href="#abstractadvisingbeanpostprocessor">AbstractAdvisingBeanPostProcessor</a></h1>
<p>继承自<em>ProxyProcessorSupport</em> 的抽象类，主要完成以下功能</p>
<ol>
<li>如果是<em>Advised</em>对象则  把当前<em>Advisor</em>加入  到其中</li>
<li>判断 目标bean是否 应该被代理</li>
<li>应该代理的话，则 使用<em>ProxyFactory</em> 进行代理</li>
</ol>
<p><strong>源码</strong></p>
<pre><code class="language-java">	public Object postProcessAfterInitialization(Object bean, String beanName) {
		if (this.advisor == null || bean instanceof AopInfrastructureBean) {
			// Ignore AOP infrastructure such as scoped proxies.
			return bean;
		}
		//如果是 advisedbean  将 其加入到 advised中
		if (bean instanceof Advised) {
			Advised advised = (Advised) bean;
			if (!advised.isFrozen() &amp;&amp; isEligible(AopUtils.getTargetClass(bean))) {
				// Add our local Advisor to the existing proxy's Advisor chain...
				if (this.beforeExistingAdvisors) {
					advised.addAdvisor(0, this.advisor);
				}
				else {
					advised.addAdvisor(this.advisor);
				}
				return bean;
			}
		}
		//bean是否应该进行代理
		if (isEligible(bean, beanName)) {
			ProxyFactory proxyFactory = prepareProxyFactory(bean, beanName);
            //如果是基于接口的代理 则解析接口
			if (!proxyFactory.isProxyTargetClass()) {
				evaluateProxyInterfaces(bean.getClass(), proxyFactory);
			}
			proxyFactory.addAdvisor(this.advisor);
			customizeProxyFactory(proxyFactory);

			// Use original ClassLoader if bean class not locally loaded in overriding class loader
			ClassLoader classLoader = getProxyClassLoader();
			if (classLoader instanceof SmartClassLoader &amp;&amp; classLoader != bean.getClass().getClassLoader()) {
				classLoader = ((SmartClassLoader) classLoader).getOriginalClassLoader();
			}
			return proxyFactory.getProxy(classLoader);
		}

		// No proxy needed.
		return bean;
	}
</code></pre>
<h1 id="abstractbeanfactoryawareadvisingpostprocessor"><a class="header" href="#abstractbeanfactoryawareadvisingpostprocessor">AbstractBeanFactoryAwareAdvisingPostProcessor</a></h1>
<p>持有 <em>BeanFactory</em> 的引用，主要完成了以下功能</p>
<ol>
<li>将targetClass 存入相应Bean定义</li>
<li>判断是否应该 对类进行 代理或者对接口进行代理</li>
</ol>
<pre><code class="language-java">	protected ProxyFactory prepareProxyFactory(Object bean, String beanName) {
		if (this.beanFactory != null) {
			AutoProxyUtils.exposeTargetClass(this.beanFactory, beanName, bean.getClass());
		}

		ProxyFactory proxyFactory = super.prepareProxyFactory(bean, beanName);
		if (!proxyFactory.isProxyTargetClass() &amp;&amp; this.beanFactory != null &amp;&amp;
				AutoProxyUtils.shouldProxyTargetClass(this.beanFactory, beanName)) {
			proxyFactory.setProxyTargetClass(true);
		}
		return proxyFactory;
	}
</code></pre>
<h1 id="示例-4"><a class="header" href="#示例-4">示例</a></h1>
<h2 id="asyncannotationbeanpostprocessor"><a class="header" href="#asyncannotationbeanpostprocessor">AsyncAnnotationBeanPostProcessor</a></h2>
<p>Bean 后处理器，通过将相应的 <em>AsyncAnnotationAdvisor</em> 添加到公开的代理（现有的 AOP 代理或新生成的实现所有目标的代理接口）。</p>
<p>可以提供负责异步执行的 TaskExecutor 以及指示应该异步调用方法的注释类型。如果未指定注释类型，则此后处理器将检测 Spring 的 @Async 注释以及 EJB 3.1 javax.ejb.Asynchronous 注释。</p>
<p>对于具有 void 返回类型的方法，调用者无法访问异步方法调用期间抛出的任何异常。可以指定 AsyncUncaughtExceptionHandler 来处理这些情况。</p>
<p>默认情况下，底层异步<em>Advisor</em>在现有 <em>Advisor</em> 之前应用, 以便在调用链中尽早切换到异步执行。</p>
<p>该类主要完成 Advisor的构建</p>
<p>构建 <em>AsyncAnnotationAdvisor</em> 所需的</p>
<ol>
<li><em>Executors</em></li>
<li><em>BeanFactory</em></li>
<li><em>exceptionHandler</em></li>
<li>且默认是在所有Advisor之前执行</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="总结-15"><a class="header" href="#总结-15">总结</a></h1>
<ol>
<li>自动代理只需要 往容器中 注入<em>Advisor</em></li>
<li>并且在Bean中 标注 <em>@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</em> 即可自动代理
3. 对于JDK 加入接口即可
2. 对于CGLIB，会将之前生成的对象替换掉</li>
</ol>
<h1 id="自动代理"><a class="header" href="#自动代理">自动代理</a></h1>
<h2 id="abstractautoproxycreator-1"><a class="header" href="#abstractautoproxycreator-1">AbstractAutoProxyCreator</a></h2>
<p>继承 <em>ProxyProcessorSupport</em></p>
<p>该类主要实现了</p>
<ol>
<li>不代理 基础设施类</li>
<li>代理类的缓存：不对代理类进行二次代理</li>
<li><em>自定义TargetResource</em> 的处理</li>
<li>代理对象的创建</li>
</ol>
<p>如何判断Bean是否因该被代理，这个功能交给子类，</p>
<h2 id="abstractadvisorautoproxycreator"><a class="header" href="#abstractadvisorautoproxycreator">AbstractAdvisorAutoProxyCreator</a></h2>
<ol>
<li>此类主要负责Advisor的查找</li>
<li>如果没有合适的<em>Advisor</em>则  返回DO_NOT_PROXY</li>
</ol>
<h3 id="查找用于该bean的advisor"><a class="header" href="#查找用于该bean的advisor"><strong>查找用于该Bean的advisor</strong></a></h3>
<pre><code class="language-java">protected Object[] getAdvicesAndAdvisorsForBean(
      Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) {

   List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);
   if (advisors.isEmpty()) {
      return DO_NOT_PROXY;
   }
   return advisors.toArray();
}
</code></pre>
<h3 id="查找可用advisor"><a class="header" href="#查找可用advisor"><strong>查找可用Advisor</strong></a></h3>
<ol>
<li>查找候选者</li>
<li>匹配可用的</li>
<li>子类扩展Advisor</li>
<li>对<em>Advisor</em>排序</li>
</ol>
<pre><code class="language-java">protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {
   List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();
   List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
   extendAdvisors(eligibleAdvisors);
   if (!eligibleAdvisors.isEmpty()) {
      eligibleAdvisors = sortAdvisors(eligibleAdvisors);
   }
   return eligibleAdvisors;
}
</code></pre>
<h3 id="查找候选者advisor"><a class="header" href="#查找候选者advisor"><strong>查找候选者Advisor</strong></a></h3>
<ol>
<li>取bean工厂查找所有Advisor class的 类对象</li>
<li>如果<em>Advisor</em> 能够增强 目标<em>bean</em> 则加入到候选者集合</li>
</ol>
<pre><code class="language-java">//org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper#findAdvisorBeans
	public List&lt;Advisor&gt; findAdvisorBeans() {
		// Determine list of advisor bean names, if not cached already.
		String[] advisorNames = this.cachedAdvisorBeanNames;
		if (advisorNames == null) {
			// Do not initialize FactoryBeans here: We need to leave all regular beans
			// uninitialized to let the auto-proxy creator apply to them!
			advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
					this.beanFactory, Advisor.class, true, false);
			this.cachedAdvisorBeanNames = advisorNames;
		}
		if (advisorNames.length == 0) {
			return new ArrayList&lt;&gt;();
		}

		List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();
		for (String name : advisorNames) {
			if (isEligibleBean(name)) {
				if (this.beanFactory.isCurrentlyInCreation(name)) {
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Skipping currently created advisor '&quot; + name + &quot;'&quot;);
					}
				}
				else {
					try {
						advisors.add(this.beanFactory.getBean(name, Advisor.class));
					}
					catch (BeanCreationException ex) {
						Throwable rootCause = ex.getMostSpecificCause();
						if (rootCause instanceof BeanCurrentlyInCreationException) {
							BeanCreationException bce = (BeanCreationException) rootCause;
							String bceBeanName = bce.getBeanName();
							if (bceBeanName != null &amp;&amp; this.beanFactory.isCurrentlyInCreation(bceBeanName)) {
								if (logger.isTraceEnabled()) {
									logger.trace(&quot;Skipping advisor '&quot; + name +
											&quot;' with dependency on currently created bean: &quot; + ex.getMessage());
								}
								// Ignore: indicates a reference back to the bean we're trying to advise.
								// We want to find advisors other than the currently created bean itself.
								continue;
							}
						}
						throw ex;
					}
				}
			}
		}
		return advisors;
	}
</code></pre>
<h3 id="匹配可用advisor"><a class="header" href="#匹配可用advisor">匹配可用Advisor</a></h3>
<ol>
<li>调用 <em>AopUtils.findAdvisorsThatCanApply</em> 匹配 候选者 advisor与 目标类是否 应该增强</li>
<li>将 <em>IntroductionAdvisor</em> 与其他<em>Advisor</em> 分开匹配</li>
<li><em>IntroductionAdvisor</em> 按类匹配，<em>PointcutAdvisor</em> 按 类匹配、方法匹配</li>
</ol>
<pre><code class="language-java">//调用AopUtils的静态方法进行匹配
protected List&lt;Advisor&gt; findAdvisorsThatCanApply(
      List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName) {

   ProxyCreationContext.setCurrentProxiedBeanName(beanName);
   try {
      return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);
   }
   finally {
      ProxyCreationContext.setCurrentProxiedBeanName(null);
   }
}
//循环匹配
public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) {
		if (candidateAdvisors.isEmpty()) {
			return candidateAdvisors;
		}
		List&lt;Advisor&gt; eligibleAdvisors = new ArrayList&lt;&gt;();
		for (Advisor candidate : candidateAdvisors) {
			if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) {
				eligibleAdvisors.add(candidate);
			}
		}
		boolean hasIntroductions = !eligibleAdvisors.isEmpty();
		for (Advisor candidate : candidateAdvisors) {
			if (candidate instanceof IntroductionAdvisor) {
				// already processed
				continue;
			}
			if (canApply(candidate, clazz, hasIntroductions)) {
				eligibleAdvisors.add(candidate);
			}
		}
		return eligibleAdvisors;
}
//单个匹配
public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) {
    if (advisor instanceof IntroductionAdvisor) {
        return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);
    }
    else if (advisor instanceof PointcutAdvisor) {
        PointcutAdvisor pca = (PointcutAdvisor) advisor;
        return canApply(pca.getPointcut(), targetClass, hasIntroductions);
    }
    else {
        // It doesn't have a pointcut so we assume it applies.
        return true;
    }
}
</code></pre>
<p><strong>执行类与方法的匹配</strong></p>
<pre><code class="language-java">public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) {
   Assert.notNull(pc, &quot;Pointcut must not be null&quot;);
   if (!pc.getClassFilter().matches(targetClass)) {
      return false;
   }

   MethodMatcher methodMatcher = pc.getMethodMatcher();
   if (methodMatcher == MethodMatcher.TRUE) {
      // No need to iterate the methods if we're matching any method anyway...
      return true;
   }
//如果是MethodIntroduction 
   IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;
   if (methodMatcher instanceof IntroductionAwareMethodMatcher) {
      introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;
   }

   Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;&gt;();
   if (!Proxy.isProxyClass(targetClass)) {
      classes.add(ClassUtils.getUserClass(targetClass));
   }
   classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));

   for (Class&lt;?&gt; clazz : classes) {
      Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);
      for (Method method : methods) {
         if (introductionAwareMethodMatcher != null ?
               introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :
               methodMatcher.matches(method, targetClass)) {
            return true;
         }
      }
   }

   return false;
}
</code></pre>
<h2 id="从advisor组织调用链"><a class="header" href="#从advisor组织调用链">从Advisor组织调用链</a></h2>
<pre><code class="language-java">//org.springframework.aop.framework.DefaultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice
	public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(
			Advised config, Method method, @Nullable Class&lt;?&gt; targetClass) {

		// This is somewhat tricky... We have to process introductions first,
		// but we need to preserve order in the ultimate list.
		AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();
		Advisor[] advisors = config.getAdvisors();
		List&lt;Object&gt; interceptorList = new ArrayList&lt;&gt;(advisors.length);
		Class&lt;?&gt; actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());
		Boolean hasIntroductions = null;

		for (Advisor advisor : advisors) {
			if (advisor instanceof PointcutAdvisor) {
				// Add it conditionally.
				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;
				if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {
					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();
					boolean match;
					if (mm instanceof IntroductionAwareMethodMatcher) {
						if (hasIntroductions == null) {
							hasIntroductions = hasMatchingIntroductions(advisors, actualClass);
						}
						match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);
					}
					else {
						match = mm.matches(method, actualClass);
					}
					if (match) {
						MethodInterceptor[] interceptors = registry.getInterceptors(advisor);
						if (mm.isRuntime()) {
							// Creating a new object instance in the getInterceptors() method
							// isn't a problem as we normally cache created chains.
							for (MethodInterceptor interceptor : interceptors) {
								interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));
							}
						}
						else {
							interceptorList.addAll(Arrays.asList(interceptors));
						}
					}
				}
			}
			else if (advisor instanceof IntroductionAdvisor) {
				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;
				if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {
					Interceptor[] interceptors = registry.getInterceptors(advisor);
					interceptorList.addAll(Arrays.asList(interceptors));
				}
			}
			else {
				Interceptor[] interceptors = registry.getInterceptors(advisor);
				interceptorList.addAll(Arrays.asList(interceptors));
			}
		}

		return interceptorList;
	}


	private static boolean hasMatchingIntroductions(Advisor[] advisors, Class&lt;?&gt; actualClass) {
		for (Advisor advisor : advisors) {
			if (advisor instanceof IntroductionAdvisor) {
				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;
				if (ia.getClassFilter().matches(actualClass)) {
					return true;
				}
			}
		}
		return false;
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring是如何选择底层字节码操作框架的"><a class="header" href="#spring是如何选择底层字节码操作框架的">Spring是如何选择底层字节码操作框架的？</a></h1>
<pre><code class="language-java">public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {
	@Override
	public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
		if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
		// 如果是需要优化的代理，或者标记代理目标类，或者代理配置中没有需要代理的接口
			Class&lt;?&gt; targetClass = config.getTargetClass();
			if (targetClass == null) {
				throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
						&quot;Either an interface or a target is required for proxy creation.&quot;);
			}
			if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
			 // 如果目标类是接口，或者已经是Jdk的动态代理类，则创建jdk动态代理
				return new JdkDynamicAopProxy(config);
			}
			// 否则创建Cglib动态代理
			return new ObjenesisCglibAopProxy(config);
		}
		else {
		 // 如果声明创建Jdk动态代理则返回Jdk动态代理
		 return new JdkDynamicAopProxy(config);
		}
	}
}
</code></pre>
<h1 id="springaop进行代理的两大类"><a class="header" href="#springaop进行代理的两大类">SpringAOP进行代理的两大类</a></h1>
<h2 id="继承abstractadvisingbeanpostprocessor"><a class="header" href="#继承abstractadvisingbeanpostprocessor">继承<em>AbstractAdvisingBeanPostProcessor</em></a></h2>
<p>编程式手动进行代理</p>
<h2 id="继承-abstractautoproxycreator"><a class="header" href="#继承-abstractautoproxycreator">继承 <em>AbstractAutoProxyCreator</em></a></h2>
<p>自动从容器中获取 <em>Adviosr</em> 进行代理</p>
<h1 id="springtargetsource是如何工作的"><a class="header" href="#springtargetsource是如何工作的">SpringTargetSource是如何工作的</a></h1>
<h2 id="介绍-8"><a class="header" href="#介绍-8">介绍</a></h2>
<p>TargetSource 用于获取 <em>AOP invocation</em> 的 当前“目标”</p>
<p>如果 TargetSource 是“静态的”，它将始终返回相同的目标，从而允许在 AOP 框架中进行优化。</p>
<p>动态目标源可以支持池化、热插拔等。</p>
<pre><code class="language-java">//返回目标类
Class&lt;?&gt; getTargetClass();
//每次调用是否会返回同一个类，如果为false 则AOP不会进行缓存，为true,AOP会进行缓存
boolean isStatic();
//获取目标类
Object getTarget() throws Exception;
// Release the given target object obtained from the getTarget() method, if any.
void releaseTarget(Object target) throws Exception;	
</code></pre>
<p>普通场景下 包装了 被代理对象</p>
<p>Spring动态获取</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orgaopalliance的拦截体系"><a class="header" href="#orgaopalliance的拦截体系">org.aopalliance的拦截体系</a></h1>
<ol>
<li>该包是AOP组织下的公用包，用于AOP中方法增强和调用。相当于一个jsr标准</li>
<li>只有接口和异常，只有接口和异常</li>
</ol>
<h1 id="包结构图"><a class="header" href="#包结构图">包结构图</a></h1>
<p><img src="10.spring_SpringFramework/spring-aop/../../images/aopalliance-structure.png" alt="" /></p>
<h1 id="解析"><a class="header" href="#解析">解析</a></h1>
<p>AOP主要有两大概念</p>
<ul>
<li>
<p><strong>Advice</strong></p>
</li>
<li>
<p><strong>JointPoint</strong></p>
</li>
</ul>
<p><em>Advice</em> 定义了如何 切面，没有定义相关行为</p>
<p><em>JointPoint</em> 定义了运行时 具体切面的位置</p>
<ol>
<li>在实际编程中 <em>Advice</em> 具象化为  <em>Interceptor</em> 拦截器 分为 <em>ConstrutorInterceptor</em> 与 <em>MethodIntercceptor</em>都是基于方法的拦截</li>
<li>而<em>JointPoint</em> 具象为 <em>Invocation</em>，即每次方法的拦截，就会相应拦截的实例 ，这里将其抽象为 <em>invocation</em> 调用，调用也区分 构造函数调用与 普通方法调用</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tasklist"><a class="header" href="#tasklist">TaskList</a></h1>
<ol>
<li>spring事务  代理弄清楚</li>
<li>shiro 注解 代理弄清楚</li>
<li>缓存 代理 弄清楚</li>
<li>spring如何管理多层代理
<ol>
<li>在调用时 匹配</li>
</ol>
</li>
<li>spring是如何懒加载的</li>
<li>弄清楚 <em>org.springframework.aop.framework.CglibAopProxy.ProxyCallbackFilter</em></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="asyncannotationbeanpostprocessor-1"><a class="header" href="#asyncannotationbeanpostprocessor-1">AsyncAnnotationBeanPostProcessor</a></h2>
<p>Bean 后处理器，通过将相应的 <em>AsyncAnnotationAdvisor</em> 添加到公开的代理（现有的 AOP 代理或新生成的实现所有目标的代理接口）。</p>
<p>可以提供负责异步执行的 TaskExecutor 以及指示应该异步调用方法的注释类型。如果未指定注释类型，则此后处理器将检测 Spring 的 @Async 注释以及 EJB 3.1 javax.ejb.Asynchronous 注释。</p>
<p>对于具有 void 返回类型的方法，调用者无法访问异步方法调用期间抛出的任何异常。可以指定 AsyncUncaughtExceptionHandler 来处理这些情况。</p>
<p>默认情况下，底层异步<em>Advisor</em>在现有 <em>Advisor</em> 之前应用, 以便在调用链中尽早切换到异步执行。</p>
<p>该类主要完成 Advisor的构建</p>
<p>构建 <em>AsyncAnnotationAdvisor</em> 所需的</p>
<ol>
<li><em>Executors</em></li>
<li><em>BeanFactory</em></li>
<li><em>exceptionHandler</em></li>
<li>且默认是在所有Advisor之前执行</li>
</ol>
<h2 id="asyncannotationadvisor"><a class="header" href="#asyncannotationadvisor">AsyncAnnotationAdvisor</a></h2>
<p>完成 PointCut的构建，与代理逻辑的异步核心Advisor类的构建</p>
<ol>
<li>PointCut 由 <em>AnnotationMatchingPointcut</em> 完成对注解的 匹配</li>
<li>多个PointCut使用 <em>ComposablePointcut</em> 支持多注解组合</li>
<li>Advice使用 <em>AnnotationAsyncExecutionInterceptor</em> 完成核心代理逻辑</li>
</ol>
<pre><code class="language-java">	public AsyncAnnotationAdvisor(
			@Nullable Supplier&lt;Executor&gt; executor, @Nullable Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler) {

		Set&lt;Class&lt;? extends Annotation&gt;&gt; asyncAnnotationTypes = new LinkedHashSet&lt;&gt;(2);
		asyncAnnotationTypes.add(Async.class);
		try {
			asyncAnnotationTypes.add((Class&lt;? extends Annotation&gt;)
					ClassUtils.forName(&quot;javax.ejb.Asynchronous&quot;, AsyncAnnotationAdvisor.class.getClassLoader()));
		}
		catch (ClassNotFoundException ex) {
			// If EJB 3.1 API not present, simply ignore.
		}
		this.advice = buildAdvice(executor, exceptionHandler);
		this.pointcut = buildPointcut(asyncAnnotationTypes);
	}

</code></pre>
<p><strong>构建pointcut</strong></p>
<pre><code class="language-java">protected Pointcut buildPointcut(Set&lt;Class&lt;? extends Annotation&gt;&gt; asyncAnnotationTypes) {
	ComposablePointcut result = null;
	for (Class&lt;? extends Annotation&gt; asyncAnnotationType : asyncAnnotationTypes) {
		Pointcut cpc = new AnnotationMatchingPointcut(asyncAnnotationType, true);
		Pointcut mpc = new AnnotationMatchingPointcut(null, asyncAnnotationType, true);
		if (result == null) {
			result = new ComposablePointcut(cpc);
		}
		else {
			result.union(cpc);
		}
		result = result.union(mpc);
	}
	return (result != null ? result : Pointcut.TRUE);
}
</code></pre>
<p><strong>构建Advice</strong></p>
<pre><code class="language-java">protected Advice buildAdvice(
      @Nullable Supplier&lt;Executor&gt; executor, @Nullable Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler) {

   AnnotationAsyncExecutionInterceptor interceptor = new AnnotationAsyncExecutionInterceptor(null);
   interceptor.configure(executor, exceptionHandler);
   return interceptor;
}
</code></pre>
<h3 id="asyncexecutionaspectsupport"><a class="header" href="#asyncexecutionaspectsupport">AsyncExecutionAspectSupport</a></h3>
<ol>
<li>
<p>AnnotationAsyncExecutionInterceptor的基类</p>
</li>
<li>
<p>帮助 <em>AnnotationAsyncExecutionInterceptor</em> 进行</p>
<ol>
<li>线程池查找：默认线程池查找、缓存线程池对象</li>
<li>任务提交</li>
<li>错误处理</li>
</ol>
<p>获取线程池名称的方法没有线程，因为不通子类的获取线程池的名称 途径可能不一致</p>
<ol>
<li>基于注解的线程池 是通过 注解上获取线程池名称的</li>
</ol>
</li>
</ol>
<p><strong>获取默认线程池逻辑</strong></p>
<pre><code class="language-java">	protected Executor getDefaultExecutor(@Nullable BeanFactory beanFactory) {
		if (beanFactory != null) {
			try {
				// Search for TaskExecutor bean... not plain Executor since that would
				// match with ScheduledExecutorService as well, which is unusable for
				// our purposes here. TaskExecutor is more clearly designed for it.
				return beanFactory.getBean(TaskExecutor.class);
			}
			catch (NoUniqueBeanDefinitionException ex) {
				logger.debug(&quot;Could not find unique TaskExecutor bean&quot;, ex);
				try {
					return beanFactory.getBean(DEFAULT_TASK_EXECUTOR_BEAN_NAME, Executor.class);
				}
				catch (NoSuchBeanDefinitionException ex2) {
					if (logger.isInfoEnabled()) {
						logger.info(&quot;More than one TaskExecutor bean found within the context, and none is named &quot; +
								&quot;'taskExecutor'. Mark one of them as primary or name it 'taskExecutor' (possibly &quot; +
								&quot;as an alias) in order to use it for async processing: &quot; + ex.getBeanNamesFound());
					}
				}
			}
			catch (NoSuchBeanDefinitionException ex) {
				logger.debug(&quot;Could not find default TaskExecutor bean&quot;, ex);
				try {
					return beanFactory.getBean(DEFAULT_TASK_EXECUTOR_BEAN_NAME, Executor.class);
				}
				catch (NoSuchBeanDefinitionException ex2) {
					logger.info(&quot;No task executor bean found for async processing: &quot; +
							&quot;no bean of type TaskExecutor and no bean named 'taskExecutor' either&quot;);
				}
				// Giving up -&gt; either using local default executor or none at all...
			}
		}
		return null;
	}
</code></pre>
<p><strong>任务提交逻辑</strong></p>
<pre><code class="language-java">protected Object doSubmit(Callable&lt;Object&gt; task, AsyncTaskExecutor executor, Class&lt;?&gt; returnType) {
   if (CompletableFuture.class.isAssignableFrom(returnType)) {
      return CompletableFuture.supplyAsync(() -&gt; {
         try {
            return task.call();
         }
         catch (Throwable ex) {
            throw new CompletionException(ex);
         }
      }, executor);
   }
   else if (ListenableFuture.class.isAssignableFrom(returnType)) {
      return ((AsyncListenableTaskExecutor) executor).submitListenable(task);
   }
   else if (Future.class.isAssignableFrom(returnType)) {
      return executor.submit(task);
   }
   else {
      executor.submit(task);
      return null;
   }
}
</code></pre>
<p><strong>错误处理逻辑</strong></p>
<pre><code class="language-java">protected void handleError(Throwable ex, Method method, Object... params) throws Exception {
   if (Future.class.isAssignableFrom(method.getReturnType())) {
      ReflectionUtils.rethrowException(ex);
   }
   else {
      // Could not transmit the exception to the caller with default executor
      try {
         this.exceptionHandler.obtain().handleUncaughtException(ex, method, params);
      }
      catch (Throwable ex2) {
         logger.warn(&quot;Exception handler for async method '&quot; + method.toGenericString() +
               &quot;' threw unexpected exception itself&quot;, ex2);
      }
   }
}
</code></pre>
<p><strong>线程池对象缓存</strong></p>
<pre><code class="language-java">protected AsyncTaskExecutor determineAsyncExecutor(Method method) {
   AsyncTaskExecutor executor = this.executors.get(method);
   if (executor == null) {
      Executor targetExecutor;
      String qualifier = getExecutorQualifier(method);
      if (StringUtils.hasLength(qualifier)) {
         targetExecutor = findQualifiedExecutor(this.beanFactory, qualifier);
      }
      else {
         targetExecutor = this.defaultExecutor.get();
      }
      if (targetExecutor == null) {
         return null;
      }
      executor = (targetExecutor instanceof AsyncListenableTaskExecutor ?
            (AsyncListenableTaskExecutor) targetExecutor : new TaskExecutorAdapter(targetExecutor));
      this.executors.put(method, executor);
   }
   return executor;
}
</code></pre>
<h3 id="annotationasyncexecutioninterceptor"><a class="header" href="#annotationasyncexecutioninterceptor">AnnotationAsyncExecutionInterceptor</a></h3>
<p>继承 <em>AsyncExecutionAspectSupport</em></p>
<p>继承 <em>MethodInterceptor</em> 完成方法的拦截</p>
<p><strong>该类主要完成拦截逻辑</strong></p>
<p><strong>拦截逻辑</strong></p>
<pre><code class="language-java">public Object invoke(final MethodInvocation invocation) throws Throwable {
   Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);
   Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);
   final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);
	//在运行时：确认要使用的线程池
   AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod);
   if (executor == null) {
      throw new IllegalStateException(
            &quot;No executor specified and no default executor set on AsyncExecutionInterceptor either&quot;);
   }

    //执行异步任务
   Callable&lt;Object&gt; task = () -&gt; {
      try {
         Object result = invocation.proceed();
         if (result instanceof Future) {
            return ((Future&lt;?&gt;) result).get();
         }
      }
      catch (ExecutionException ex) {
         handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments());
      }
      catch (Throwable ex) {
         handleError(ex, userDeclaredMethod, invocation.getArguments());
      }
      return null;
   };
	//提交，根据不同的返回值，任务提交也会返回不同的返回值
   return doSubmit(task, executor, invocation.getMethod().getReturnType());
}
</code></pre>
<h3 id="annotationasyncexecutioninterceptor-1"><a class="header" href="#annotationasyncexecutioninterceptor-1">AnnotationAsyncExecutionInterceptor</a></h3>
<p>继承 <em>AsyncExecutionInterceptor</em></p>
<p>该类主要完成线程池名称的解析</p>
<pre><code class="language-java">protected String getExecutorQualifier(Method method) {
	// Maintainer's note: changes made here should also be made in
	// AnnotationAsyncExecutionAspect#getExecutorQualifier
	Async async = AnnotatedElementUtils.findMergedAnnotation(method, Async.class);
	if (async == null) {
		async = AnnotatedElementUtils.findMergedAnnotation(method.getDeclaringClass(), Async.class);
	}
	return (async != null ? async.value() : null);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="依赖懒加载"><a class="header" href="#依赖懒加载">依赖懒加载</a></h1>
<ol>
<li>在注入依赖的 过程中,先使用过代理 类来注入依赖</li>
<li>在实际运行时：才从bean工厂中 获取依赖的 <em>bean</em></li>
</ol>
<h1 id="源码分析-2"><a class="header" href="#源码分析-2">源码分析</a></h1>
<h2 id="依赖注入过程"><a class="header" href="#依赖注入过程">依赖注入过程</a></h2>
<pre><code class="language-java">//org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency
public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
      @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

   descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
   if (Optional.class == descriptor.getDependencyType()) {
      return createOptionalDependency(descriptor, requestingBeanName);
   }
   else if (ObjectFactory.class == descriptor.getDependencyType() ||
         ObjectProvider.class == descriptor.getDependencyType()) {
      return new DependencyObjectProvider(descriptor, requestingBeanName);
   }
   else if (javaxInjectProviderClass == descriptor.getDependencyType()) {
      return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);
   }
   else {
       //尝试获取懒加载代理对象
      Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
            descriptor, requestingBeanName);
      if (result == null) {
         result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
      }
      return result;
   }
}
</code></pre>
<h2 id="获取懒加载代理对象"><a class="header" href="#获取懒加载代理对象">获取懒加载代理对象</a></h2>
<pre><code class="language-java">//org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver#buildLazyResolutionProxy
protected Object buildLazyResolutionProxy(final DependencyDescriptor descriptor, final @Nullable String beanName) {
    BeanFactory beanFactory = getBeanFactory();
    Assert.state(beanFactory instanceof DefaultListableBeanFactory,
                 &quot;BeanFactory needs to be a DefaultListableBeanFactory&quot;);
    final DefaultListableBeanFactory dlbf = (DefaultListableBeanFactory) beanFactory;

    //自定义targetSource
    TargetSource ts = new TargetSource() {
        @Override
        public Class&lt;?&gt; getTargetClass() {
            return descriptor.getDependencyType();
        }
        @Override
        public boolean isStatic() {
            return false;
        }
        
        @Override
        public Object getTarget() {
            Set&lt;String&gt; autowiredBeanNames = (beanName != null ? new LinkedHashSet&lt;&gt;(1) : null);
            //调用   org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency  执行实际的依赖注入：返回依赖的对象
            Object target = dlbf.doResolveDependency(descriptor, beanName, autowiredBeanNames, null);
            if (target == null) {
                Class&lt;?&gt; type = getTargetClass();
                if (Map.class == type) {
                    return Collections.emptyMap();
                }
                else if (List.class == type) {
                    return Collections.emptyList();
                }
                else if (Set.class == type || Collection.class == type) {
                    return Collections.emptySet();
                }
                throw new NoSuchBeanDefinitionException(descriptor.getResolvableType(),
                                                        &quot;Optional dependency not present for lazy injection point&quot;);
            }
            if (autowiredBeanNames != null) {
                for (String autowiredBeanName : autowiredBeanNames) {
                    if (dlbf.containsBean(autowiredBeanName)) {
                        dlbf.registerDependentBean(autowiredBeanName, beanName);
                    }
                }
            }
            return target;
        }
        @Override
        public void releaseTarget(Object target) {
        }
    };

    ProxyFactory pf = new ProxyFactory();
    pf.setTargetSource(ts);
    Class&lt;?&gt; dependencyType = descriptor.getDependencyType();
    if (dependencyType.isInterface()) {
        pf.addInterface(dependencyType);
    }
    return pf.getProxy(dlbf.getBeanClassLoader());
}
</code></pre>
<h1 id="总结-16"><a class="header" href="#总结-16">总结</a></h1>
<ol>
<li>在依赖注入的过程中 如果 Bean定义中配置了懒加载，则会自动创建一个代理对象注入</li>
<li>代理对象在每次调用方法时都会 去解析依赖对象</li>
<li>懒加载会存在性能问题：因为使用 <em>DynamicAdvisedInterceptor</em> 以及每次 都需要重新解析依赖 耗费时间</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="注解"><a class="header" href="#注解">注解</a></h1>
<h2 id="cacheable"><a class="header" href="#cacheable">@Cacheable</a></h2>
<blockquote>
<p>配置 是否应该缓存，如何缓存的注解</p>
</blockquote>
<h3 id="缓存名"><a class="header" href="#缓存名"><strong>缓存名</strong></a></h3>
<p><em>value</em> or <em>cacheNames</em></p>
<p>缓存依赖存储，标识应该存在哪个缓存区</p>
<h3 id="缓存key"><a class="header" href="#缓存key">缓存key</a></h3>
<p><em>key</em></p>
<ol>
<li>在缓存区中唯一标识 缓存的数据</li>
<li>支持SpringEL动态计算</li>
<li>默认 为 &quot;&quot; 表示所有方法参数都被视为一个键，除非自定义 keygenerator</li>
<li>springEL默认提供以下几个默认元数据
<ol>
<li>#root.method, #root.target, and #root.caches for references to the method, target object, and affected cache(s) respectively.</li>
<li><em>#root.methodName</em>  方法名，<em>#root.targetClass</em> 目标类 </li>
<li>方法参数可以通过索引访问  <code>#root.args[1], #p1 or #a1</code>   通用能通过参数名访问</li>
</ol>
</li>
</ol>
<h3 id="key生成策略"><a class="header" href="#key生成策略">key生成策略</a></h3>
<p><em>keyGenerator</em></p>
<ol>
<li>要使用的自定义 org.springframework.cache.interceptor.KeyGenerator 的 bean name。</li>
<li>与 key 属性互斥</li>
</ol>
<h3 id="cachemanager"><a class="header" href="#cachemanager">cacheManager</a></h3>
<p><em>cacheManager</em></p>
<ol>
<li>自定义 org.springframework.cache.CacheManager 的 bean name</li>
<li>用于创建默认 org.springframework.cache.interceptor.CacheResolver 如果尚未设置。</li>
</ol>
<h3 id="cacheresolver"><a class="header" href="#cacheresolver">cacheResolver</a></h3>
<p><em>cacheResolver</em></p>
<ol>
<li>要使用的自定义 org.springframework.cache.interceptor.CacheResolver 的 bean name。</li>
</ol>
<h3 id="condition-1"><a class="header" href="#condition-1">condition</a></h3>
<p><em>condition</em></p>
<ol>
<li>有条件的缓存方法返回值</li>
<li>默认为“”，表示方法结果总是被缓存。</li>
<li>支持访问springEL 提供的元数据</li>
</ol>
<h3 id="unless"><a class="header" href="#unless">unless</a></h3>
<p><em>unless</em></p>
<ol>
<li>Spring 表达式语言 (SpEL) 表达式用于否决方法缓存。</li>
<li>与条件不同，该表达式在方法被调用后计算，因此可以引用结果。</li>
<li>默认为 &quot;&quot;，表示永远不会否决缓存。</li>
<li>除了支持上述元数据访问之外，还支持 <em>#result</em> 访问，如果是Optional类则回自动解引用</li>
</ol>
<h3 id="sync"><a class="header" href="#sync">sync</a></h3>
<p><em>sync</em></p>
<p>如果多个线程试图加载同一个键的值，则同步底层方法的调用。</p>
<p>同步会导致一些限制：</p>
<ol>
<li>不支持unless</li>
<li>只能指定一个缓存</li>
<li>不能组合其他缓存相关的操作</li>
</ol>
<p>这实际上是一个提示，您使用的实际缓存提供程序可能不以同步方式支持它。</p>
<h2 id="cacheput"><a class="header" href="#cacheput">@CachePut</a></h2>
<blockquote>
<p>指示触发 PUT 操作 </p>
</blockquote>
<ol>
<li>与@Cacheable 相反，此 操作不会跳过 Advised方法 </li>
<li>它会一直 调用目标方法，根据 <em>condition</em> 和 <em>unless</em> 相应地匹配，将结果缓存</li>
<li>会自动  解包装 java8的<em>Optional</em></li>
<li>该注解 可以支持 组合注解</li>
</ol>
<p>参数同上</p>
<h2 id="cacheevict"><a class="header" href="#cacheevict">@CacheEvict</a></h2>
<blockquote>
<p>指示 方法或类上 触发缓存驱逐操作</p>
</blockquote>
<p>参数同上</p>
<h3 id="allentries"><a class="header" href="#allentries">allEntries</a></h3>
<ol>
<li>
<p>是否删除缓存中的所有条目。</p>
</li>
<li>
<p>默认情况下，仅删除关联键下的值。</p>
</li>
<li>
<p>请注意，不允许将此参数设置为 true 并指定键。</p>
</li>
</ol>
<h3 id="beforeinvocation"><a class="header" href="#beforeinvocation">beforeInvocation</a></h3>
<p>是否应该在调用方法之前发生驱逐</p>
<ol>
<li>将此属性设置为 true，会导致驱逐发生，而不管方法结果如何（即，是否抛出异常）。</li>
<li>默认为 false，意味着缓存驱逐操作将在成功调用建议的方法后发生（即仅当调用没有抛出异常时）。</li>
</ol>
<h2 id="cacheconfig"><a class="header" href="#cacheconfig">@CacheConfig</a></h2>
<p>提供了一种在类级别共享与缓存相关的公共设置的机制。</p>
<p>当此注解出现在给定类上时，它为该类中定义的任何缓存操作提供一组默认设置。</p>
<h3 id="cachenames"><a class="header" href="#cachenames">cacheNames</a></h3>
<p>在被注解类中定义的缓存操作要考虑的默认缓存的名称。</p>
<p>如果在操作级别没有设置，则使用这些而不是默认值。</p>
<p>可用于确定目标缓存（或多个缓存），匹配特定 bean 定义的限定符值或 bean 名称。</p>
<h3 id="keygenerator"><a class="header" href="#keygenerator">keyGenerator</a></h3>
<p>用于类的默认 org.springframework.cache.interceptor.KeyGenerator 的 bean name。</p>
<p>如果在操作级别没有设置，则使用这个而不是默认值。</p>
<p><em>key generator</em>与 自定义 key  互斥</p>
<p>定义了 key之后 则忽略该值</p>
<h3 id="cachemanager-1"><a class="header" href="#cachemanager-1">cacheManager</a></h3>
<ol>
<li><em>cacheManager</em>的bean名 以用来创建默认 <em>CacheResolver</em> </li>
<li>如果没有<em>resolver</em> 没有 <em>cacheManager</em> 设置，则使用这个</li>
</ol>
<h3 id="cacheresolver-1"><a class="header" href="#cacheresolver-1">cacheResolver</a></h3>
<ol>
<li>要使用的自定义 org.springframework.cache.interceptor.CacheResolver 的 bean name。</li>
</ol>
<h2 id="caching"><a class="header" href="#caching">@Caching</a></h2>
<p>缓存注解 的组合形式</p>
<pre><code class="language-java">public @interface Caching {

   Cacheable[] cacheable() default {};

   CachePut[] put() default {};

   CacheEvict[] evict() default {};

}
</code></pre>
<h1 id="缓存流程源码解析"><a class="header" href="#缓存流程源码解析">缓存流程源码解析</a></h1>
<blockquote>
<p>使用bean自动发现 完成代理</p>
</blockquote>
<h2 id="注入advisor"><a class="header" href="#注入advisor">注入Advisor</a></h2>
<ol>
<li><em>注入BeanFactoryCacheOperationSourceAdvisor</em></li>
<li><em>CacheInterceptor</em>  缓存拦截器</li>
</ol>
<pre><code class="language-java">@Configuration
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
public class ProxyCachingConfiguration extends AbstractCachingConfiguration {

   @Bean(name = CacheManagementConfigUtils.CACHE_ADVISOR_BEAN_NAME)
   @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
   public BeanFactoryCacheOperationSourceAdvisor cacheAdvisor() {
      BeanFactoryCacheOperationSourceAdvisor advisor = new BeanFactoryCacheOperationSourceAdvisor();
      advisor.setCacheOperationSource(cacheOperationSource());
      advisor.setAdvice(cacheInterceptor());
      if (this.enableCaching != null) {
         advisor.setOrder(this.enableCaching.&lt;Integer&gt;getNumber(&quot;order&quot;));
      }
      return advisor;
   }

   @Bean
   @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
   public CacheOperationSource cacheOperationSource() {
      return new AnnotationCacheOperationSource();
   }

   @Bean
   @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
   public CacheInterceptor cacheInterceptor() {
      CacheInterceptor interceptor = new CacheInterceptor();
      interceptor.configure(this.errorHandler, this.keyGenerator, this.cacheResolver, this.cacheManager);
      interceptor.setCacheOperationSource(cacheOperationSource());
      return interceptor;
   }

}
</code></pre>
<h2 id="核心拦截器cacheinterceptor"><a class="header" href="#核心拦截器cacheinterceptor">核心拦截器CacheInterceptor</a></h2>
<p>该拦截器的主要完成以下功能</p>
<ol>
<li>包装目标方法 为 <em>CacheOperationInvoker</em> ，为后续 缓存没有命中的情况下 执行目标方法</li>
<li>调用父类 <em>CacheAspectSupport</em> 的execute方法 完成缓存逻辑 </li>
</ol>
<pre><code class="language-java">public Object invoke(final MethodInvocation invocation) throws Throwable {
   Method method = invocation.getMethod();
//包装目标方法的调用
   CacheOperationInvoker aopAllianceInvoker = () -&gt; {
      try {
         return invocation.proceed();
      }
      catch (Throwable ex) {
         throw new CacheOperationInvoker.ThrowableWrapper(ex);
      }
   };
// 
   Object target = invocation.getThis();
   Assert.state(target != null, &quot;Target must not be null&quot;);
   try {
      return execute(aopAllianceInvoker, target, method, invocation.getArguments());
   }
   catch (CacheOperationInvoker.ThrowableWrapper th) {
      throw th.getOriginal();
   }
}
</code></pre>
<h2 id="缓存逻辑类cacheaspectsupport"><a class="header" href="#缓存逻辑类cacheaspectsupport">缓存逻辑类：<em>CacheAspectSupport</em></a></h2>
<h3 id="同步缓存"><a class="header" href="#同步缓存">同步缓存</a></h3>
<blockquote>
<p>同步的保证，主要是通过 <em>Cache</em> 缓冲区的同步操作保证的</p>
<p>具体 <em>ConcurrentMapCache</em> 依赖于 <em>ConcurrentMap</em> <em>computeIfAbsent</em> 且就算调用了目标方法，目标方法的值也可能不被缓存</p>
</blockquote>
<p>主要 完成 以下功能</p>
<ol>
<li>条件测试</li>
<li>尝试缓存命中</li>
<li>没有 命中则调用目标方法获取放回值</li>
</ol>
<h4 id="同步缓存逻辑"><a class="header" href="#同步缓存逻辑">同步缓存逻辑</a></h4>
<pre><code class="language-java">//org.springframework.cache.interceptor.CacheAspectSupport#execute
//如果是同步缓存
if (contexts.isSynchronized()) {
    //则 只会有一个 缓存操作
   CacheOperationContext context = contexts.get(CacheableOperation.class).iterator().next();
    //判断 condition是否条件测试通过
   if (isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) {
       //通过：生成key
      Object key = generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT);
       //同步操作也只能指定一个缓存区
      Cache cache = context.getCaches().iterator().next();
      try {
          //如果缓存命中则 直接返回缓存对象，没有命中则调用目标方法
         return wrapCacheValue(method, handleSynchronizedGet(invoker, key, cache));
      }
      catch (Cache.ValueRetrievalException ex) {
         // Directly propagate ThrowableWrapper from the invoker,
         // or potentially also an IllegalArgumentException etc.
         ReflectionUtils.rethrowRuntimeException(ex.getCause());
      }
   }
   else {
      //没有缓存，则直接调用目标方法
      // No caching required, only call the underlying method
      return invokeOperation(invoker);
   }
}
</code></pre>
<h4 id="如何判定同步"><a class="header" href="#如何判定同步">如何判定同步</a></h4>
<pre><code class="language-java">//org.springframework.cache.interceptor.CacheAspectSupport.CacheOperationContexts#determineSyncFlag
		private boolean determineSyncFlag(Method method) {
			List&lt;CacheOperationContext&gt; cacheOperationContexts = this.contexts.get(CacheableOperation.class);
			if (cacheOperationContexts == null) {  // no @Cacheable operation at all
				return false;
			}
            //判定是否配置 sync属性为true
			boolean syncEnabled = false;
			for (CacheOperationContext cacheOperationContext : cacheOperationContexts) {
				if (((CacheableOperation) cacheOperationContext.getOperation()).isSync()) {
					syncEnabled = true;
					break;
				}
			}
            //如果配置 了则启用校验
			if (syncEnabled) {
                //不能组合注解
				if (this.contexts.size() &gt; 1) {
					throw new IllegalStateException(
							&quot;@Cacheable(sync=true) cannot be combined with other cache operations on '&quot; + method + &quot;'&quot;);
				}
                //
				if (cacheOperationContexts.size() &gt; 1) {
					throw new IllegalStateException(
							&quot;Only one @Cacheable(sync=true) entry is allowed on '&quot; + method + &quot;'&quot;);
				}
				CacheOperationContext cacheOperationContext = cacheOperationContexts.iterator().next();
				CacheableOperation operation = (CacheableOperation) cacheOperationContext.getOperation();
                //缓存区 只能 配置一个
				if (cacheOperationContext.getCaches().size() &gt; 1) {
					throw new IllegalStateException(
							&quot;@Cacheable(sync=true) only allows a single cache on '&quot; + operation + &quot;'&quot;);
				}
                //不能 配置unless
				if (StringUtils.hasText(operation.getUnless())) {
					throw new IllegalStateException(
							&quot;@Cacheable(sync=true) does not support unless attribute on '&quot; + operation + &quot;'&quot;);
				}
				return true;
			}
			return false;
		}

</code></pre>
<h3 id="非同步缓存"><a class="header" href="#非同步缓存">非同步缓存</a></h3>
<h4 id="主流程"><a class="header" href="#主流程">主流程</a></h4>
<p>主要完成以下功能</p>
<ol>
<li>前处理缓存逐出</li>
<li>尝试缓存命中
<ol>
<li>命中缓存，<em>且CachePutOperation</em>没有命中：直接使用 命中的值</li>
<li>没有命中缓存：调用目标方法，更新缓存</li>
</ol>
</li>
<li>后处理缓存逐出</li>
</ol>
<pre><code class="language-java">//org.springframework.cache.interceptor.CacheAspectSupport#execute
......

		// Process any early evictions:前处理缓存逐出
		processCacheEvicts(contexts.get(CacheEvictOperation.class), true,
				CacheOperationExpressionEvaluator.NO_RESULT);

		// Check if we have a cached item matching the conditions,缓存命中
		Cache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation.class));

		// Collect puts from any @Cacheable miss, if no cached item is found
		//没有命中则 收集 CacheableOperation的PUT操作
		List&lt;CachePutRequest&gt; cachePutRequests = new ArrayList&lt;&gt;();
		if (cacheHit == null) {
			collectPutRequests(contexts.get(CacheableOperation.class),
					CacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests);
		}

		Object cacheValue;
		Object returnValue;
		//命中了缓存：且没有命中 CachePutOperation：直接返回命中的缓存
		if (cacheHit != null &amp;&amp; !hasCachePut(contexts)) {
			// If there are no put requests, just use the cache hit
			cacheValue = cacheHit.get();
			returnValue = wrapCacheValue(method, cacheValue);
		}
		else {
			// Invoke the method if we don't have a cache hit
            //没有命中则直接调用目标方法获取返回值
			returnValue = invokeOperation(invoker);
			cacheValue = unwrapReturnValue(returnValue);
		}

		// Collect any explicit @CachePuts 
		// 显式收集CachePutOperation,缓存命中的情况下：还要保证CachePutOperation没有命中
		collectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);

		// Process any collected put requests, either from @CachePut or a @Cacheable miss
		//更新缓存
		for (CachePutRequest cachePutRequest : cachePutRequests) {
			cachePutRequest.apply(cacheValue);
		}

		// Process any late evictions
		//后处理缓存逐出
		processCacheEvicts(contexts.get(CacheEvictOperation.class), false, cacheValue);

		return returnValue;
</code></pre>
<h4 id="如何命中缓存"><a class="header" href="#如何命中缓存">如何命中缓存</a></h4>
<ol>
<li>从组合操作中顺序匹配 第一个 条件满足的缓存操作</li>
<li>生成<em>key</em></li>
<li>根据key查找缓存</li>
<li>命中了直接返回，没有命中继续下一循环</li>
</ol>
<pre><code class="language-java">//org.springframework.cache.interceptor.CacheAspectSupport#findCachedItem
private Cache.ValueWrapper findCachedItem(Collection&lt;CacheOperationContext&gt; contexts) {
   Object result = CacheOperationExpressionEvaluator.NO_RESULT;
   for (CacheOperationContext context : contexts) {
      if (isConditionPassing(context, result)) {
         Object key = generateKey(context, result);
         Cache.ValueWrapper cached = findInCaches(context, key);
         if (cached != null) {
            return cached;
         }
         else {
            if (logger.isTraceEnabled()) {
               logger.trace(&quot;No cache entry for key '&quot; + key + &quot;' in cache(s) &quot; + context.getCacheNames());
            }
         }
      }
   }
   return null;
}
</code></pre>
<h4 id="如何处理缓存逐出"><a class="header" href="#如何处理缓存逐出">如何处理缓存逐出</a></h4>
<ol>
<li>判断是否应该进行缓存逐出</li>
<li>执行缓存逐出</li>
</ol>
<pre><code class="language-java">//org.springframework.cache.interceptor.CacheAspectSupport#processCacheEvicts
private void processCacheEvicts(
      Collection&lt;CacheOperationContext&gt; contexts, boolean beforeInvocation, @Nullable Object result) {

   for (CacheOperationContext context : contexts) {
      CacheEvictOperation operation = (CacheEvictOperation) context.metadata.operation;
      if (beforeInvocation == operation.isBeforeInvocation() &amp;&amp; 
          //判断是否应该进行缓存逐出
          isConditionPassing(context, result)) {
          //
         performCacheEvict(context, operation, result);
      }
   }
}
</code></pre>
<h4 id="具体缓存逐出策略"><a class="header" href="#具体缓存逐出策略">具体缓存逐出策略</a></h4>
<pre><code class="language-java">//org.springframework.cache.interceptor.CacheAspectSupport#performCacheEvict
private void performCacheEvict(
      CacheOperationContext context, CacheEvictOperation operation, @Nullable Object result) {

   Object key = null;
   for (Cache cache : context.getCaches()) {
       //是否全局逐出 allEntries属性
      if (operation.isCacheWide()) {
         logInvalidating(context, operation, null);
         doClear(cache, operation.isBeforeInvocation());
      }
      else {
          //懒加载key
         if (key == null) {
            key = generateKey(context, result);
         }
         logInvalidating(context, operation, key);
          //执行逐出
         doEvict(cache, key, operation.isBeforeInvocation());
      }
   }
}

	protected void doEvict(Cache cache, Object key, boolean immediate) {
		try {
            //立即逐出：如果是 方法调用前的逐出：应该立即逐出
			if (immediate) {
				cache.evictIfPresent(key);
			}
			else {
                //延迟逐出：方法调用后的逐出延迟
				cache.evict(key);
			}
		}
		catch (RuntimeException ex) {
			getErrorHandler().handleCacheEvictError(ex, cache, key);
		}
	}
</code></pre>
<h4 id="如何生成key"><a class="header" href="#如何生成key">如何生成key</a></h4>
<ol>
<li>如果存在 <em>key</em> 则使用 springEL 解析 key并返回</li>
<li>如果不存在key，则使用 <em>keyGenerator</em> 生成</li>
</ol>
<pre><code class="language-java">//org.springframework.cache.interceptor.CacheAspectSupport.CacheOperationContext#generateKey
protected Object generateKey(@Nullable Object result) {
   if (StringUtils.hasText(this.metadata.operation.getKey())) {
      EvaluationContext evaluationContext = createEvaluationContext(result);
      return evaluator.key(this.metadata.operation.getKey(), this.metadata.methodKey, evaluationContext);
   }
   return this.metadata.keyGenerator.generate(this.target, this.metadata.method, this.args);
}
</code></pre>
<h2 id="no_resultresult_unavailableresult_variable"><a class="header" href="#no_resultresult_unavailableresult_variable">NO_RESULT/RESULT_UNAVAILABLE/RESULT_VARIABLE</a></h2>
<p><em>CacheOperationExpressionEvaluator</em> 中的这三个 全局变量</p>
<h3 id="no_result"><a class="header" href="#no_result"><em>NO_RESULT</em></a></h3>
<ol>
<li>没有返回值</li>
<li>不会将<em>result</em> 放到 <em>springEL</em> </li>
</ol>
<h3 id="result_unavailable"><a class="header" href="#result_unavailable">RESULT_UNAVAILABLE</a></h3>
<ol>
<li>没有返回值</li>
<li><em>springEL</em> 会进行 表达式<em>check</em></li>
</ol>
<h3 id="result_variable"><a class="header" href="#result_variable">RESULT_VARIABLE</a></h3>
<ol>
<li>会在<em>springEL context</em> 中 放置 <em>result</em></li>
</ol>
<h1 id="核心类解析"><a class="header" href="#核心类解析">核心类解析</a></h1>
<h2 id="cache"><a class="header" href="#cache">Cache</a></h2>
<h3 id="缓存名-1"><a class="header" href="#缓存名-1">缓存名</a></h3>
<pre><code class="language-java">String getName();
</code></pre>
<h3 id="底层缓存"><a class="header" href="#底层缓存">底层缓存</a></h3>
<pre><code class="language-java">Object getNativeCache();
</code></pre>
<h3 id="缓存命中"><a class="header" href="#缓存命中">缓存命中</a></h3>
<p>允许缓存空值</p>
<ol>
<li>如果没有命中则返回  <em>null</em></li>
<li>值本身可能为空</li>
</ol>
<pre><code class="language-java">@Nullable
ValueWrapper get(Object key);
</code></pre>
<h3 id="缓存命中2"><a class="header" href="#缓存命中2">缓存命中2</a></h3>
<p>不允许返回空值</p>
<ol>
<li>如果可能，实现应确保加载操作是同步的</li>
<li>以便在对同一键进行并发访问的情况下只调用一次指定的 valueLoader。</li>
</ol>
<pre><code class="language-java">&lt;T&gt; T get(Object key, @Nullable Class&lt;T&gt; type);
</code></pre>
<h3 id="缓存数据"><a class="header" href="#缓存数据">缓存数据</a></h3>
<ol>
<li>如果缓存先前包含此键的映射，则旧值将替换为指定值。</li>
<li>实际注册可能以异步或延迟方式执行，随后的查找可能还没有看到该条目。</li>
<li>例如，事务缓存装饰器可能就是这种情况。 使用 putIfAbsent 保证立即注册。</li>
</ol>
<pre><code class="language-java">void put(Object key, @Nullable Object value);
</code></pre>
<h3 id="立即缓存数据"><a class="header" href="#立即缓存数据">立即缓存数据</a></h3>
<ol>
<li>
<p>如果尚未设置，则以原子方式将指定值与此缓存中的指定键相关联。</p>
</li>
<li>
<p>虽然所有开箱即用的 CacheManager 实现都能够以原子方式执行放置，但该操作也可以分两步实现，例如</p>
<p>以非原子方式检查存在并随后放置。</p>
</li>
</ol>
<pre><code class="language-java">default ValueWrapper putIfAbsent(Object key, @Nullable Object value) {
   ValueWrapper existingValue = get(key);
   if (existingValue == null) {
      put(key, value);
   }
   return existingValue;
}
</code></pre>
<h3 id="缓存逐出"><a class="header" href="#缓存逐出">缓存逐出</a></h3>
<p>实际驱逐可能以异步或延迟方式执行，随后的查找可能仍会看到条目。</p>
<p>例如，事务缓存装饰器可能就是这种情况。</p>
<pre><code class="language-java">void evict(Object key);
</code></pre>
<h3 id="立即缓存逐出"><a class="header" href="#立即缓存逐出">立即缓存逐出</a></h3>
<p>如果该键存在，则从该缓存中逐出该键的映射，期望该键在后续查找时立即不可见。</p>
<pre><code class="language-java">default boolean evictIfPresent(Object key) {
   evict(key);
   return false;
}
</code></pre>
<h3 id="清空缓存"><a class="header" href="#清空缓存">清空缓存</a></h3>
<ol>
<li>实际清除可能以异步或延迟方式执行，随后的查找可能仍会看到条目。</li>
<li>例如，事务缓存装饰器可能就是这种情况。</li>
</ol>
<pre><code class="language-java">void clear();
</code></pre>
<h3 id="立即清空缓存"><a class="header" href="#立即清空缓存">立即清空缓存</a></h3>
<pre><code class="language-java">default boolean invalidate() {
   clear();
   return false;
}
</code></pre>
<h3 id="serializationdelegate"><a class="header" href="#serializationdelegate">SerializationDelegate</a></h3>
<p>包装返回值</p>
<ol>
<li>如果允许空返回值：将<em>NULL</em> 解析成 <em>NullValue.INSTANCE</em></li>
</ol>
<h3 id="concurrentmapcache"><a class="header" href="#concurrentmapcache">ConcurrentMapCache</a></h3>
<p>主要实现类 </p>
<ol>
<li>使用 <em>ConcurrentHashMap</em> 作为底层缓存</li>
<li>在存储值时，使用 <em>SerializationDelegate</em>改变值的存储以及取值方式 以 byte数组存取</li>
</ol>
<h2 id="basicoperation"><a class="header" href="#basicoperation">BasicOperation</a></h2>
<p>缓存操作定义类</p>
<h3 id="cacheoperation"><a class="header" href="#cacheoperation">CacheOperation</a></h3>
<p>定义了缓存操作需要的上下文</p>
<p><em>cacheNames</em>：缓存名集合</p>
<p><em>key</em>：操作的key</p>
<p><em>keyGenerator</em>：key生成策略</p>
<p><em>cacheManager</em>：缓存管理者</p>
<p><em>cacheResolver</em>：缓存解析器</p>
<p><em>condition</em>：条件</p>
<p>三个子类</p>
<ol>
<li><em>CacheableOperation</em></li>
<li><em>CacheEvictOperation</em></li>
<li><em>CachePutOperation</em></li>
</ol>
<h2 id="cacheresolver-2"><a class="header" href="#cacheresolver-2">CacheResolver</a></h2>
<blockquote>
<p>用于确定使用的 <em>Cache</em> 集合</p>
</blockquote>
<pre><code class="language-java">public interface CacheResolver {

   /**
    * Return the cache(s) to use for the specified invocation.
    * @param context the context of the particular invocation
    * @return the cache(s) to use (never {@code null})
    * @throws IllegalStateException if cache resolution failed
    */
   Collection&lt;? extends Cache&gt; resolveCaches(CacheOperationInvocationContext&lt;?&gt; context);

}
</code></pre>
<h3 id="abstractcacheresolver"><a class="header" href="#abstractcacheresolver">AbstractCacheResolver</a></h3>
<p>根据  缓存名 从<em>CacheManager</em> 中获取缓存</p>
<pre><code class="language-java">@Override
public Collection&lt;? extends Cache&gt; resolveCaches(CacheOperationInvocationContext&lt;?&gt; context) {
   Collection&lt;String&gt; cacheNames = getCacheNames(context);
   if (cacheNames == null) {
      return Collections.emptyList();
   }
   Collection&lt;Cache&gt; result = new ArrayList&lt;&gt;(cacheNames.size());
   for (String cacheName : cacheNames) {
      Cache cache = getCacheManager().getCache(cacheName);
      if (cache == null) {
         throw new IllegalArgumentException(&quot;Cannot find cache named '&quot; +
               cacheName + &quot;' for &quot; + context.getOperation());
      }
      result.add(cache);
   }
   return result;
}
</code></pre>
<h3 id="simplecacheresolver"><a class="header" href="#simplecacheresolver">SimpleCacheResolver</a></h3>
<p>从 <em>CacheOperationInvocationContext</em> 中获取 Operation上的缓存名</p>
<pre><code class="language-java">protected Collection&lt;String&gt; getCacheNames(CacheOperationInvocationContext&lt;?&gt; context) {
   return context.getOperation().getCacheNames();
}
</code></pre>
<h3 id="namedcacheresolver"><a class="header" href="#namedcacheresolver">NamedCacheResolver</a></h3>
<ol>
<li>默认指定缓存名</li>
</ol>
<pre><code class="language-java">public class NamedCacheResolver extends AbstractCacheResolver {

	@Nullable
	private Collection&lt;String&gt; cacheNames;


	public NamedCacheResolver() {
	}

	public NamedCacheResolver(CacheManager cacheManager, String... cacheNames) {
		super(cacheManager);
		this.cacheNames = new ArrayList&lt;&gt;(Arrays.asList(cacheNames));
	}


	/**
	 * Set the cache name(s) that this resolver should use.
	 */
	public void setCacheNames(Collection&lt;String&gt; cacheNames) {
		this.cacheNames = cacheNames;
	}

	@Override
	protected Collection&lt;String&gt; getCacheNames(CacheOperationInvocationContext&lt;?&gt; context) {
		return this.cacheNames;
	}

}
</code></pre>
<h2 id="cachemanager-2"><a class="header" href="#cachemanager-2">CacheManager</a></h2>
<p>管理缓存类</p>
<h3 id="api-2"><a class="header" href="#api-2">API</a></h3>
<h4 id="根据缓存名获取缓存"><a class="header" href="#根据缓存名获取缓存">根据缓存名获取缓存</a></h4>
<pre><code class="language-java">Cache getCache(String name);
</code></pre>
<h4 id="获取所有的缓存名"><a class="header" href="#获取所有的缓存名">获取所有的缓存名</a></h4>
<pre><code class="language-java">Collection&lt;String&gt; getCacheNames();
</code></pre>
<h3 id="abstractcachemanager"><a class="header" href="#abstractcachemanager">AbstractCacheManager</a></h3>
<p>主要完成以下功能：</p>
<ol>
<li>在Spring启动时初始化缓存</li>
<li>实现了 <em>CacheManager</em> 的 <em>getCache</em>  <em>getCacheNames</em></li>
<li>实现了缓存的增查改：缓存名称的复制使用的同步锁并采用 <code>写时复制</code> 策略</li>
</ol>
<p>其子类只要  实现 载入 缓存对象即可</p>
<h3 id="simplecachemanager"><a class="header" href="#simplecachemanager">SimpleCacheManager</a></h3>
<p>手动维护<em>Caches</em></p>
<h3 id="concurrentmapcachemanager"><a class="header" href="#concurrentmapcachemanager">ConcurrentMapCacheManager</a></h3>
<ol>
<li>基于ConcurrentCache的实现类</li>
<li>自己 会 根据名称 新建 缓存区</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-4"><a class="header" href="#前言-4">前言</a></h1>
<p>Spring对各种实例对象的抽象</p>
<h1 id="beandefinition"><a class="header" href="#beandefinition">BeanDefinition</a></h1>
<p>bean定义</p>
<h1 id="annotatedtypemetadata"><a class="header" href="#annotatedtypemetadata">AnnotatedTypeMetadata</a></h1>
<p>以不一定需要类加载的形式定义对特定类型（类或方法）注解的访问。</p>
<h1 id="mergedannotation"><a class="header" href="#mergedannotation">MergedAnnotation</a></h1>
<p>从合并的注解集返回中 返回单个合并的注解。在属性值可能从不同的源值中&quot;合并&quot;的注释上呈现视图。</p>
<h1 id="mergedannotations"><a class="header" href="#mergedannotations">MergedAnnotations</a></h1>
<p>提供对注解合并 集合访问</p>
<h1 id="aliasregistry"><a class="header" href="#aliasregistry">AliasRegistry</a></h1>
<p>别名注册</p>
<p>给定一个名称，并将相关的别名与之绑定</p>
<h1 id="beandefinitionregistry"><a class="header" href="#beandefinitionregistry">BeanDefinitionRegistry</a></h1>
<ol>
<li>
<p>注册bean定义</p>
</li>
<li>
<p>给定bean名称，并绑定与之相关的bean定义</p>
</li>
<li>
<p>一般实现者是：DefaultListableBeanFactory and GenericApplicationContext</p>
</li>
</ol>
<h1 id="beanmetadataelement"><a class="header" href="#beanmetadataelement">BeanMetadataElement</a></h1>
<p>携带配置源对象的 bean元数据 元素 实现</p>
<h1 id="beandefinitionholder"><a class="header" href="#beandefinitionholder">BeanDefinitionHolder</a></h1>
<p>持有 bean定义，bean名，bean别名的引用</p>
<h1 id="beannamegenerator"><a class="header" href="#beannamegenerator">BeanNameGenerator</a></h1>
<p>根据bean定义 bean定义注册器 生成名称</p>
<h1 id="singletonbeanregistry"><a class="header" href="#singletonbeanregistry">SingletonBeanRegistry</a></h1>
<p>共享bean实例的注册</p>
<p>由BeanFactory 实现 主要用来 以统一的方式暴露他们的单例管理工具</p>
<p>Register the given existing object as singleton in the bean registry, under the given bean name.
The given instance is supposed to be fully initialized; </p>
<p>the registry will not perform any initialization callbacks (in particular, it won't call InitializingBean's afterPropertiesSet method). </p>
<p>The given instance will not receive any destruction callbacks (like DisposableBean's destroy method) either.</p>
<p>When running within a full BeanFactory: Register a bean definition instead of an existing instance if your bean is supposed to receive initialization and/or destruction callbacks.
Typically invoked during registry configuration, but can also be used for runtime registration of singletons. As a consequence, a registry implementation should synchronize singleton access; it will have to do this anyway if it supports a BeanFactory's lazy initialization of singletons.
Params:
beanName – the name of the bean
singletonObject – the existing singleton object</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="beandefinition-1"><a class="header" href="#beandefinition-1">BeanDefinition</a></h1>
<p>BeanDefinition 描述了一个 bean 实例，它具有属性值、构造函数参数值以及由具体实现提供的更多信息。</p>
<p>这只是一个最小的接口：主要目的是允许 BeanFactoryPostProcessor 内省和修改属性值和其他 bean 元数据。</p>
<h2 id="parentname"><a class="header" href="#parentname">parentName</a></h2>
<p>父 <em>definition</em> </p>
<h2 id="beanclassname"><a class="header" href="#beanclassname">beanClassName</a></h2>
<p>bean 类名称</p>
<p>类名可以在 bean factory 后处理期间修改，通常用它的解析变体替换原始类名</p>
<h2 id="scope"><a class="header" href="#scope"><em>scope</em></a></h2>
<p>bean的作用域</p>
<h2 id="lazyinit"><a class="header" href="#lazyinit">lazyInit</a></h2>
<p>懒加载</p>
<h2 id="dependson"><a class="header" href="#dependson">dependsOn</a></h2>
<p>依赖bean名称</p>
<h2 id="autowirecandidate"><a class="header" href="#autowirecandidate">autowireCandidate</a></h2>
<p>设置此 bean 是否是自动装配到其他 bean 的候选者。</p>
<p>此标志旨在仅影响基于类型的自动装配</p>
<p>它不会影响按名称的显式引用，即使指定的 bean 没有被标记为自动装配候选者，也会被解析</p>
<p>因此，如果名称匹配，按名称自动装配仍然会注入一个 bean</p>
<h2 id="primary"><a class="header" href="#primary">primary</a></h2>
<p>设置此 bean 是否是主要的自动装配候选者。</p>
<p>如果这个值对于多个匹配候选中的一个 bean 正好是真的，它将作为一个 <em>tie-breaker.</em></p>
<h2 id="factorybeanname"><a class="header" href="#factorybeanname">factoryBeanName</a></h2>
<p>指定要使用的工厂 bean（如果有）</p>
<h2 id="factorymethodname"><a class="header" href="#factorymethodname">factoryMethodName</a></h2>
<p>此方法将使用构造函数参数调用</p>
<p>该方法将在指定的工厂 bean（如果有）上调用，或者作为本地 bean 类上的静态方法调用。</p>
<h2 id="constructorargumentvalues"><a class="header" href="#constructorargumentvalues">ConstructorArgumentValues</a></h2>
<p>返回的实例可以在 bean factory 后处理期间进行修改</p>
<h2 id="mutablepropertyvalues"><a class="header" href="#mutablepropertyvalues">MutablePropertyValues</a></h2>
<p>返回要应用于 bean 的新实例的属性值</p>
<p>返回的实例可以在 bean factory 后处理期间进行修改</p>
<h2 id="initmethodname"><a class="header" href="#initmethodname">initMethodName</a></h2>
<h2 id="destroymethodname"><a class="header" href="#destroymethodname">destroyMethodName</a></h2>
<h2 id="role"><a class="header" href="#role">role</a></h2>
<p>BeanDefinition 的角色提示。角色提示为框架和工具提供了特定 BeanDefinition 的角色和重要性的指示。</p>
<h2 id="description"><a class="header" href="#description">description</a></h2>
<p>设置此 bean 定义的人类可读描述。</p>
<h2 id="resolvabletype"><a class="header" href="#resolvabletype">ResolvableType</a></h2>
<p>根据 bean 类或其他特定元数据，返回此 bean 定义的可解析类型。</p>
<p>这通常在运行时合并的 bean 定义上完全解决，但不一定在配置时定义实例上解决。</p>
<h2 id="singleton"><a class="header" href="#singleton">singleton</a></h2>
<p>单例</p>
<h2 id="abstract"><a class="header" href="#abstract">abstract</a></h2>
<p>抽象</p>
<h2 id="resourcedescription"><a class="header" href="#resourcedescription">ResourceDescription</a></h2>
<p>返回此 bean 定义来自的资源的描述（为了在出现错误时显示上下文）。</p>
<h2 id="originatingbeandefinition"><a class="header" href="#originatingbeandefinition">OriginatingBeanDefinition</a></h2>
<p>返回原始 BeanDefinition，如果没有则返回 null。允许检索装饰的 bean 定义（如果有）。请注意，此方法返回直接发起者。遍历创建者链以找到用户定义的原始 BeanDefinition。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简述"><a class="header" href="#简述">简述</a></h1>
<ol>
<li><strong>scope</strong> 用来限定 容器中bean对象的存活时间</li>
<li>即对象在进入相应 scope时 容器会自动装配这些对象、在容器不再处于该scope后，容器通常会销毁这些对象</li>
</ol>
<h1 id="预定义的scope"><a class="header" href="#预定义的scope">预定义的Scope</a></h1>
<h2 id="singleton-1"><a class="header" href="#singleton-1">singleton</a></h2>
<ol>
<li>
<p>singleton是容器默认的scope</p>
</li>
<li>
<p>在Spring的IoC容器中只存在一个实例</p>
</li>
</ol>
<h4 id="singleton的bean具有的特性"><a class="header" href="#singleton的bean具有的特性">singleton的bean具有的特性</a></h4>
<ul>
<li><strong>对象实例数量</strong>：singleton类型的bean定义，在一个容器中只存在一个共享实例，所有对该类型bean的依赖都引用这一单一实例</li>
<li><strong>对象存活时间</strong>：singleton类型bean定义，从容器启动，到它第一次被请求而实例化开始，只要容器不销毁或退出，该类型的单一实例就会一直存活</li>
</ul>
<h2 id="prototype"><a class="header" href="#prototype">prototype</a></h2>
<p><strong>每次得到的对象都是重新装配的</strong></p>
<h2 id="requestsessionglobal-session"><a class="header" href="#requestsessionglobal-session">request、session、global session</a></h2>
<p>这三个scope类型是Spring2.0之后新增加的，它们不像上面两个那么通用，它们只适用于Web应用程序，通常是与XmlWebApplicationContext共同使用</p>
<h3 id="request"><a class="header" href="#request">request</a></h3>
<ol>
<li>
<p>在Spring容器中，即XmlWebApplicationContext会为每个HTTP请求创建一个全新的Request-Processor对象供当前请求使用，当请求结束后，该对象实生命周期就结束</p>
</li>
<li>
<p>当同时有10个HTTP请求进来的时候，容器会分别针对这10个请求返回10个全新的RequestProcessor对象实例，且它们之间互不干扰。</p>
</li>
</ol>
<h3 id="session"><a class="header" href="#session">session</a></h3>
<p>放到session中的最普遍的信息就是用户登录信息，Spring容器会为每个独立的session创建属于它们自己全新的UserPreferences对象实例。与request相比，除了拥有session scope的bean比request scope的bean可能更长的存活时间，其他没什么差别</p>
<h3 id="global-session"><a class="header" href="#global-session">global session</a></h3>
<p>global session只有应用在基于portlet的Web应用程序中才有意义，它映射到portlet的global范围的session。</p>
<p>如果在普通的基于servlet的Web应用中使了用这个类型的scope，容器会将其作为普通的session类型的scope来对待</p>
<h5 id="什么是portlet"><a class="header" href="#什么是portlet">什么是portlet</a></h5>
<p>Portlets是一种Web组件－就像servlets－是专为将合成页面里的内容聚集在一起而设计的。通常请求一个portal页面会引发多个portlets被调用。每个portlet都会生成标记段，并与别的portlets生成的标记段组合在一起嵌入到portal页面的标记内。</p>
<h1 id="源码分析-3"><a class="header" href="#源码分析-3">源码分析</a></h1>
<h2 id="scope接口"><a class="header" href="#scope接口">Scope接口</a></h2>
<p><strong>GET接口</strong></p>
<blockquote>
<p>从底层依赖 查找对象，如果查找不到则 使用 Spring自动装配Bean</p>
</blockquote>
<pre><code class="language-java">Object get(String name, ObjectFactory&lt;?&gt; objectFactory);
</code></pre>
<p><strong>REMOVE接口</strong></p>
<ol>
<li>从底层作用域中删除具有给定名称的对象。</li>
<li>如果没有找到对象，则返回 null，否则返回移除的对象。</li>
<li>实现者 还应  移除指定对象的注册销毁回调（如果有）。如果没有，它不需要执行注册的销毁回调，因为对象将被调用者销毁（如果合适）。</li>
<li>这是一个可选的 实现操作 也可以抛出  <strong>UnsupportedOperationException</strong></li>
</ol>
<pre><code class="language-java">Object remove(String name);
</code></pre>
<p><strong>注册回调接口</strong></p>
<ol>
<li>
<p>注册一个回调，以在销毁指定的 scope 内的对象时执行</p>
</li>
<li>
<p>注意：这是一个可选操作。此方法只会为配置了 实际销毁动作的 作用域bean调用</p>
<pre><code>DisposableBean, destroy-method, DestructionAwareBeanPostProcessor
</code></pre>
</li>
<li>
<p>实现应该尽最大努力在适当的时间执行给定的回调，如果底层运行时环境根本不支持这样的回调，则必须忽略回调并记录相应的警告</p>
</li>
</ol>
<pre><code class="language-java">//bean的名称、销毁要执行的回调
void registerDestructionCallback(String name, Runnable callback);
</code></pre>
<p><strong>解析给定key的上下文对象</strong>（如果有）。</p>
<p>例如 key “request” 的 HttpServletRequest 对象。</p>
<pre><code class="language-java">Object resolveContextualObject(String key);
</code></pre>
<p>返回当前基础<strong>scope</strong>的对话 ID（如果有）。</p>
<ol>
<li>对话 ID 的确切含义取决于底层存储机制。</li>
<li>在session scope 对象的情况下，对话ID 通常等于（或派生自）session ID；</li>
<li>对于位于整个会话中的自定义对话，指定 当前对话的ID 将是合适的。</li>
<li>如果底层存储机制没有明显的此类 ID 候选者，则 返回 null 是完全有效的。</li>
</ol>
<pre><code class="language-java">String getConversationId();
</code></pre>
<h2 id="abstractrequestattributesscope"><a class="header" href="#abstractrequestattributesscope">AbstractRequestAttributesScope</a></h2>
<ol>
<li>
<p>scope抽象实现类，基于Web的 Request</p>
</li>
<li>
<p><strong>RequestScope</strong> 与 **SessionScope ** 都是依赖于 <strong>RequestAttributes</strong> 实现的Scope</p>
</li>
</ol>
<h2 id="scope是如何生效的"><a class="header" href="#scope是如何生效的">Scope是如何生效的</a></h2>
<blockquote>
<p>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean 核心方法</p>
</blockquote>
<pre><code class="language-java">//单例
// Create bean instance
if (mbd.isSingleton()) {
    //直接获取单例。具体实例化的方法没有实现
   sharedInstance = getSingleton(beanName, () -&gt; {
      try {
         return createBean(beanName, mbd, args);
      }
      catch (BeansException ex) {
         // Explicitly remove instance from singleton cache: It might have been put there
         // eagerly by the creation process, to allow for circular reference resolution.
         // Also remove any beans that received a temporary reference to the bean.
         destroySingleton(beanName);
         throw ex;
      }
   });
    //处理BeanFactory的情况
   beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}
//原型
else if (mbd.isPrototype()) {
   // It's a prototype -&gt; create a new instance.
   Object prototypeInstance = null;
   try {
      beforePrototypeCreation(beanName);
      prototypeInstance = createBean(beanName, mbd, args);
   }
   finally {
      afterPrototypeCreation(beanName);
   }
   beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
}
//其他scope作用域
else {
   String scopeName = mbd.getScope();
   if (!StringUtils.hasLength(scopeName)) {
      throw new IllegalStateException(&quot;No scope name defined for bean ´&quot; + beanName + &quot;'&quot;);
   }
//获取Scope
   Scope scope = this.scopes.get(scopeName);
   if (scope == null) {
      throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;);
   }
   try {//得到beean实例
      Object scopedInstance = scope.get(beanName, () -&gt; {
         beforePrototypeCreation(beanName);
         try {
            return createBean(beanName, mbd, args);
         }
         finally {
            afterPrototypeCreation(beanName);
         }
      });
       //处理BeanFactory实例
      beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
   }
   catch (IllegalStateException ex) {
      throw new ScopeNotActiveException(beanName, scopeName, ex);
   }
}
</code></pre>
<h2 id="预定义的scope是在哪里注册的"><a class="header" href="#预定义的scope是在哪里注册的">预定义的Scope是在哪里注册的</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="步骤"><a class="header" href="#步骤">步骤</a></h1>
<h2 id="自定义scope注解"><a class="header" href="#自定义scope注解">自定义Scope注解</a></h2>
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Scope(AutoRefreshScope.REFRESH_SCOPE) //指定scopename
@Documented
public @interface RefreshScope {
    // 设置proxyMode的值为ScopedProxyMode.TARGET_CLASS
    // 目的是使用cglib生成一个代理对象，通过这个代理对象来访问目标bean对象
    ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;
}
</code></pre>
<h2 id="自定义springscope处理类"><a class="header" href="#自定义springscope处理类">自定义SpringScope处理类</a></h2>
<pre><code class="language-java">public class AutoRefreshScope implements Scope {
    /**
     * 单例模式，声明一个实例
     */
    private static final AutoRefreshScope instance = new AutoRefreshScope();
    /**
     * 来个map用来缓存bean
     */
    private Map&lt;String, Object&gt; beanMap = new ConcurrentHashMap&lt;&gt;();

    private AutoRefreshScope() {
    }

    /**
     * 获取实例
     *
     * @return
     */
    public static AutoRefreshScope getInstance() {
        return instance;
    }

    /**
     * 清理指定名称的key
     */
    public static void clean(String name) {
        instance.beanMap.remove(name);
    }

    /**
     * 定义作用域名称为：refresh
     */
    public static final String REFRESH_SCOPE = &quot;refresh&quot;;

    @Override
    public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) {
        Object bean = beanMap.get(name);
        if (bean == null) {
            bean = objectFactory.getObject();
            beanMap.put(name, bean);
        }
        return bean;
    }

    
    @Override
    public Object remove(String s) {
        return null;
    }

    @Override
    public void registerDestructionCallback(String s, Runnable runnable) {

    }

    @Override
    public Object resolveContextualObject(String s) {
        return null;
    }

    @Override
    public String getConversationId() {
        return null;
    }
}
</code></pre>
<h2 id="注册scope"><a class="header" href="#注册scope">注册Scope</a></h2>
<pre><code class="language-java">@Configuration
public class CommonConfig {
    @Autowired
    ConfigurableBeanFactory factory;
    @Autowired
    ConfigurableEnvironment environment;
    @Autowired
    PropertiesDataFactory propertiesDataFactory;

    @PostConstruct
    public void init(){
        // 将自定义作用域注册到spring容器中
        factory.registerScope(AutoRefreshScope.REFRESH_SCOPE, AutoRefreshScope.getInstance());

        // 更新配置信息
        propertiesDataFactory.UpdateUserConfig(environment);
    }
}
</code></pre>
<h2 id="配置更新类"><a class="header" href="#配置更新类">配置更新类</a></h2>
<pre><code class="language-java">@Component
public class PropertiesDataFactory {
    /**
     * 获取用户配置信息
     * 为了演示，就模拟一下，真实项目里可能是从数据库，或者其它方式取得配置信息
     *
     * @return map
     */
    public static Map&lt;String, Object&gt; getUserConfig() {
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16);

        // 注意：这里map的key必须要和@Value(&quot;${key}&quot;)中的key相同
        map.put(&quot;user.name&quot;, UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;));
        map.put(&quot;user.sex&quot;, &quot;18&quot;);
        map.put(&quot;user.phone&quot;, &quot;180-0000-0000&quot;);
        map.put(&quot;user.address&quot;, &quot;海底大世界&quot;);

        return map;
    }

    /**
     * 更新配置信息
     */
    public void UpdateUserConfig(ConfigurableEnvironment environment) {
        // 模拟从其它地方获取配置信息，可能是数据库，也可能是其它渠道
        Map&lt;String, Object&gt; userConfig = PropertiesDataFactory.getUserConfig();
        // 创建一个MapPropertySource,将配置信息放到其中，
        // MapPropertySource可以理解为Map&lt;String, PropertySource&gt;
        MapPropertySource propertySource = new MapPropertySource(&quot;user&quot;, userConfig);
        // 将propertySource放到MutablePropertySources里，后面Environment解析时会使用到
        // addFirst是为了放到首位，解析速度更快
        environment.getPropertySources().addFirst(propertySource);
    }
}
</code></pre>
<h2 id="在配置类上使用"><a class="header" href="#在配置类上使用">在配置类上使用</a></h2>
<pre><code class="language-java">@Data
@Component
@RefreshScope
public class UserConfig {
    @Value(&quot;${user.name}&quot;)
    private String name;

    @Value(&quot;${user.sex}&quot;)
    private String sex;

    @Value(&quot;${user.phone}&quot;)
    private String phone;

    @Value(&quot;${user.address}&quot;)
    private String address;

    @Override
    public String toString() {
        return &quot;UserConfig{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, sex='&quot; + sex + '\'' +
                &quot;, phone='&quot; + phone + '\'' +
                &quot;, address='&quot; + address + '\'' +
                '}';
    }

    public UserConfig() {
        System.out.println(1);
    }
}
</code></pre>
<h2 id="更新配置类"><a class="header" href="#更新配置类">更新配置类</a></h2>
<pre><code class="language-java">/**
 * 更新配置信息
 */
public void UpdateUserConfig(ConfigurableEnvironment environment) {
    // 模拟从其它地方获取配置信息，可能是数据库，也可能是其它渠道
    Map&lt;String, Object&gt; userConfig = PropertiesDataFactory.getUserConfig();
    // 创建一个MapPropertySource,将配置信息放到其中，
    // MapPropertySource可以理解为Map&lt;String, PropertySource&gt;
    MapPropertySource propertySource = new MapPropertySource(&quot;user&quot;, userConfig);
    // 将propertySource放到MutablePropertySources里，后面Environment解析时会使用到
    // addFirst是为了放到首位，解析速度更快
    environment.getPropertySources().addFirst(propertySource);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="spring总结"><a class="header" href="#spring总结">spring总结</a></h1>
<h2 id="beanfactory与-applicationcontext-有什么区别"><a class="header" href="#beanfactory与-applicationcontext-有什么区别"><em>beanFactory</em>与 <em>ApplicationContext</em> 有什么区别</a></h2>
<p><em>beanFactory</em>提供了配置框架的基本功能</p>
<ul>
<li>提供 获取bean及其相关信息</li>
</ul>
<p>而<em>ApplicationContext</em>作为它的子类 多了一些企业级的功能</p>
<ul>
<li>AOP集成</li>
<li>消息资源处理</li>
<li>事件发布</li>
<li>应用专用容器,例如 <em>WebApplicationContext</em></li>
</ul>
<p>通过元数据配置, 告诉容器如何</p>
<ul>
<li>初始化 , 实例化 , 组装一个bean</li>
</ul>
<h2 id="配置bean的方式"><a class="header" href="#配置bean的方式">配置bean的方式</a></h2>
<ul>
<li><em>xml</em></li>
<li>注解</li>
<li>java代码</li>
</ul>
<h1 id="配置bean元数据"><a class="header" href="#配置bean元数据">配置Bean元数据</a></h1>
<h2 id="基于xml"><a class="header" href="#基于xml">基于xml</a></h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;  
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;
    &lt;!-- more bean definitions go here --&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="导入其他xml定义"><a class="header" href="#导入其他xml定义">导入其他XML定义</a></h2>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;import resource=&quot;services.xml&quot;/&gt;
    &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt;
    &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt;

    &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt;
    &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h1 id="容器"><a class="header" href="#容器">容器</a></h1>
<h2 id="spring容器类"><a class="header" href="#spring容器类">spring容器类</a></h2>
<ul>
<li><em>ClassPathXmlApplicationContext</em> 基于类路径下的xml装载的容器类</li>
<li><em>FileSystemXmlApplicationContext</em> 基于文件系统下的xml装载的容器类</li>
</ul>
<h3 id="实例化容器"><a class="header" href="#实例化容器">实例化容器</a></h3>
<pre><code class="language-java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
//通用容器对象
ApplicationContext context = new GenericGroovyApplicationContext(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);
//加入xmlbean定义
new XmlBeanDefinitionReader(context).loadBeanDefinitions(&quot;services.xml&quot;, &quot;daos.xml&quot;);
context.refresh();
//加入grouvybean定义
new GroovyBeanDefinitionReader(context).loadBeanDefinitions(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);
context.refresh();

// xml容器对象
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
// retrieve configured instance
PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);
</code></pre>
<h1 id="beandefintion"><a class="header" href="#beandefintion">BeanDefintion</a></h1>
<ul>
<li>
<p>bean定义描述了以何种方式创建bean</p>
</li>
<li>
<p>除了从bean定义创建bean,还可以从外部注册bean</p>
<pre><code class="language-java">getBeanFactory().registerSingleton(..)
getBeanFactory().registerBeanDefinition(..)
</code></pre>
</li>
</ul>
<h3 id="bean属性"><a class="header" href="#bean属性">bean属性</a></h3>
<table><thead><tr><th style="text-align: left">Property</th><th style="text-align: left">Explained in…</th></tr></thead><tbody>
<tr><td style="text-align: left">Class</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-class">Instantiating Beans</a></td></tr>
<tr><td style="text-align: left">Name</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-beanname">Naming Beans</a></td></tr>
<tr><td style="text-align: left">Scope</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes">Bean Scopes</a></td></tr>
<tr><td style="text-align: left">Constructor arguments</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-collaborators">Dependency Injection</a></td></tr>
<tr><td style="text-align: left">Properties</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-collaborators">Dependency Injection</a></td></tr>
<tr><td style="text-align: left">Autowiring mode</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-autowire">Autowiring Collaborators</a></td></tr>
<tr><td style="text-align: left">Lazy initialization mode</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-lazy-init">Lazy-initialized Beans</a></td></tr>
<tr><td style="text-align: left">Initialization method</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean">Initialization Callbacks</a></td></tr>
<tr><td style="text-align: left">Destruction method</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean">Destruction Callbacks</a></td></tr>
</tbody></table>
<h3 id="bean别名"><a class="header" href="#bean别名">bean别名</a></h3>
<p>id唯一,name可以多个,以 空格,逗号,分号,分隔</p>
<pre><code class="language-xml">&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemA-dataSource&quot;/&gt;
</code></pre>
<h3 id="bean实例化"><a class="header" href="#bean实例化">bean实例化</a></h3>
<pre><code class="language-xml">构造方法
&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;/&gt;
静态工厂
&lt;bean id=&quot;clientService&quot;
    class=&quot;examples.ClientService&quot;
    factory-method=&quot;createInstance&quot;/&gt;
实例工厂
&lt;!-- the factory bean, which contains a method called createInstance() --&gt;
&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;
    &lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;!-- the bean to be created via the factory bean --&gt;
&lt;bean id=&quot;clientService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createClientServiceInstance&quot;/&gt;

</code></pre>
<h1 id="依赖注入-2"><a class="header" href="#依赖注入-2">依赖注入</a></h1>
<h2 id="构造注入"><a class="header" href="#构造注入">构造注入</a></h2>
<pre><code>构造注入-引用类型
&lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;
        &lt;constructor-arg ref=&quot;beanTwo&quot;/&gt;
        &lt;constructor-arg ref=&quot;beanThree&quot;/&gt;
&lt;/bean&gt;
构造注入-基本类型
&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;

构造注入-按索引注入
&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
构造注入-按参数名注入-
前提是 jvm开启Debug选项
可以使用 @ConstructorProperties注解给定参数名
&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">    @ConstructorProperties({&quot;years&quot;, &quot;ultimateAnswer&quot;})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
</code></pre>
<h2 id="setter方法注入"><a class="header" href="#setter方法注入">setter方法注入</a></h2>
<pre><code class="language-xml">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;properties name=&quot;ddd&quot; ref=&quot;dd&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>推荐使用构造注入注入必须的变量, 使用setter注入不是必须的变量</strong></p>
<h2 id="被注入的值的写法"><a class="header" href="#被注入的值的写法">被注入的值的写法</a></h2>
<h3 id="字面量"><a class="header" href="#字面量">字面量</a></h3>
<p><strong>字符串和基本数据类型原样写</strong></p>
<h3 id="集合"><a class="header" href="#集合">集合</a></h3>
<p><code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code>, and <code>&lt;props/&gt;</code></p>
<pre><code class="language-xml">&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;
    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;
    &lt;property name=&quot;adminEmails&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt;
            &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt;
            &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeList(java.util.List) call --&gt;
    &lt;property name=&quot;someList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;a list element followed by a reference&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
    &lt;property name=&quot;someMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;
            &lt;entry key =&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
    &lt;property name=&quot;someSet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;just some string&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;

集合合并 merge=true
&lt;beans&gt;
    &lt;bean id=&quot;parent&quot; abstract=&quot;true&quot; class=&quot;example.ComplexObject&quot;&gt;
        &lt;property name=&quot;adminEmails&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;administrator&quot;&gt;administrator@example.com&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;support@example.com&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;child&quot; parent=&quot;parent&quot;&gt;
        &lt;property name=&quot;adminEmails&quot;&gt;
            &lt;!-- the merge is specified on the child collection definition --&gt;
            &lt;props merge=&quot;true&quot;&gt;
                &lt;prop key=&quot;sales&quot;&gt;sales@example.com&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;support@example.co.uk&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;
</code></pre>
<h3 id="空串与null"><a class="header" href="#空串与null">空串与null</a></h3>
<pre><code>等价于 &quot;&quot;
&lt;bean class=&quot;ExampleBean&quot;&gt;
    &lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;
&lt;/bean&gt;


&lt;bean class=&quot;ExampleBean&quot;&gt;
    &lt;property name=&quot;email&quot;&gt;
        &lt;null/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="名称空间注入"><a class="header" href="#名称空间注入">名称空间注入</a></h3>
<pre><code class="language-xml">p名称空间
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;
        destroy-method=&quot;close&quot;
        p:driverClassName=&quot;com.mysql.jdbc.Driver&quot;
        p:url=&quot;jdbc:mysql://localhost:3306/mydb&quot;
        p:username=&quot;root&quot;
        p:password=&quot;masterkaoli&quot;/&gt;

&lt;/beans&gt;
c名称空间
&lt;!-- c-namespace index declaration --&gt;
&lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:_0-ref=&quot;beanTwo&quot; c:_1-ref=&quot;beanThree&quot;
    c:_2=&quot;something@somewhere.com&quot;/&gt;

</code></pre>
<h3 id="嵌套注入"><a class="header" href="#嵌套注入">嵌套注入</a></h3>
<pre><code class="language-xml">&lt;bean id=&quot;something&quot; class=&quot;things.ThingOne&quot;&gt;
    &lt;property name=&quot;fred.bob.sammy&quot; value=&quot;123&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="properties实例注入"><a class="header" href="#properties实例注入">properties实例注入</a></h3>
<pre><code class="language-xml">&lt;bean id=&quot;mappings&quot;
    class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt;

    &lt;!-- typed as a java.util.Properties --&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;value&gt;
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="idref"><a class="header" href="#idref"><em>idref</em></a></h3>
<pre><code class="language-xml">避免 值与引用混淆
&lt;!-- in the child (descendant) context --&gt;
&lt;bean id=&quot;accountService&quot; &lt;!-- bean name is the same as the parent bean --&gt;
    class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;ref parent=&quot;accountService&quot;/&gt; &lt;!-- notice how we refer to the parent bean --&gt;
    &lt;/property&gt;
    &lt;!-- insert other configuration and dependencies as required here --&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="depends-on"><a class="header" href="#depends-on"><em>depends-on</em></a></h3>
<p>在某个bean之前实例化,用于两个不直接依赖的bean</p>
<pre><code>&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager&quot;/&gt;
&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;
</code></pre>
<h3 id="context手动获取"><a class="header" href="#context手动获取">Context手动获取</a></h3>
<p>使用场景: 两个bean的生命周期不一致,使用自动注入只会调用一次,</p>
<p>可以使用 getBean(String name)来获得</p>
<pre><code class="language-java">// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean(&quot;command&quot;, Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
</code></pre>
<h3 id="抽象方法注入"><a class="header" href="#抽象方法注入">抽象方法注入</a></h3>
<pre><code class="language-xml">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;
&lt;bean id=&quot;myCommand&quot; class=&quot;fiona.apple.AsyncCommand&quot; scope=&quot;prototype&quot;&gt;
    &lt;!-- inject dependencies here as required --&gt;
&lt;/bean&gt;

&lt;!-- commandProcessor uses statefulCommandHelper --&gt;
&lt;bean id=&quot;commandManager&quot; class=&quot;fiona.apple.CommandManager&quot;&gt;
    &lt;lookup-method name=&quot;createCommand&quot; bean=&quot;myCommand&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}

或者使用注解
@Lookup(&quot;name&quot;)
    如果不写名称则根据 方法的返回值类型查找,如果不写名字则需要写具体类名
    
​ Spring的Lookup method inject实现原理的是使用CGLIB动态生成一个类去继承CommandManager，重写createCommand方法。然后根据@Lookup中指定的bean Name或者createCommand方法的返回类型判断需要返回的bean。createCommand可以是abstract和可以不是。因为使用的是继承，所以CommandManager类和createCommand方法都不能是final的。

createCommand方法的签名需要满足如下要求

&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);
</code></pre>
<h3 id="方法替换"><a class="header" href="#方法替换">方法替换</a></h3>
<p>待替换的方法</p>
<pre><code class="language-java">public class MyValueCalculator {

    public String computeValue(String input) {
        // some real code...
    }

    // some other methods...
}
</code></pre>
<p>重新实现的方法</p>
<pre><code class="language-java">public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    }
}
</code></pre>
<p>配置</p>
<pre><code>&lt;bean id=&quot;myValueCalculator&quot; class=&quot;x.y.z.MyValueCalculator&quot;&gt;
    &lt;!-- arbitrary method replacement --&gt;
    &lt;replaced-method name=&quot;computeValue&quot; replacer=&quot;replacementComputeValue&quot;&gt;
        &lt;arg-type&gt;String&lt;/arg-type&gt;
    &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id=&quot;replacementComputeValue&quot; class=&quot;a.b.c.ReplacementComputeValue&quot;/&gt;
构造参数类型主要是为了区别 重载的方法
只能配置
</code></pre>
<h1 id="作用域"><a class="header" href="#作用域">作用域</a></h1>
<h3 id="属性列表"><a class="header" href="#属性列表">属性列表</a></h3>
<table><thead><tr><th style="text-align: left">Scope</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton">singleton</a></td><td style="text-align: left">单例</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-prototype">prototype</a></td><td style="text-align: left">多例</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-request">request</a></td><td style="text-align: left">每来一个 Http请求中 就会产生一个</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-session">session</a></td><td style="text-align: left">Httpsession</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-application">application</a></td><td style="text-align: left">Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/web.html#websocket-stomp-websocket-scope">websocket</a></td><td style="text-align: left">Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td></tr>
</tbody></table>
<h3 id="生存周期不一致的bean-访问方式"><a class="header" href="#生存周期不一致的bean-访问方式">生存周期不一致的bean 访问方式</a></h3>
<ul>
<li>单例a依赖注入 prototype的实例b时, 每次访问b, b不会变,就是直接访问,不会去scope中取</li>
<li>如果 proxyMode=ScopedProxyMode.TARGET_CLASS 或者<em>interface</em>,则 会访问b时 会生成一个代理类,里面根据 scope取值</li>
</ul>
<pre><code>package com.weisanju.javaconfig.config;

import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;
import org.springframework.stereotype.Component;

@Component
@Scope(proxyMode=ScopedProxyMode.NO,value = &quot;prototype&quot;)
public class MyValueCalculator {
    public String computeValue(String input) {
        System.out.println(input);
        return input;
    }
}
在被注入的时候指定代理形式
</code></pre>
<h3 id="自定义-scope"><a class="header" href="#自定义-scope">自定义 <em>scope</em></a></h3>
<ol>
<li>
<p>实现 <em>org.springframework.beans.factory.config.Scope</em>接口</p>
<p>基于 时间的作用域</p>
<pre><code class="language-java">/**
 * 首先自定义作用域范围类TimeScope:
 * Scope接口提供了五个方法，只有get()和remove()是必须实现，get()中写获取逻辑，
 * 如果已有存储中没有该名称的bean，则通过objectFactory.getObject()创建实例。
 */
@Slf4j
public class TimeScope implements Scope {

    private static Map&lt;String, Map&lt;Integer, Object&gt;&gt; scopeBeanMap = new HashMap&lt;&gt;();

    @Override
    public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) {
        Integer hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);
        // 当前是一天内的第多少分钟
        Integer minute = hour * 60 + Calendar.getInstance().get(Calendar.MINUTE);
        log.info(&quot;当前是第 {} 分钟&quot;, minute);
        Map&lt;Integer, Object&gt; objectMap = scopeBeanMap.get(name);
        Object object = null;
        if (Objects.isNull(objectMap)) {
            objectMap = new HashMap&lt;&gt;();
            object = objectFactory.getObject();
            objectMap.put(minute, object);
            scopeBeanMap.put(name, objectMap);
        } else {
            object = objectMap.get(minute);
            if (Objects.isNull(object)) {
                object = objectFactory.getObject();
                objectMap.put(minute, object);
                scopeBeanMap.put(name, objectMap);
            }
        }
        return object;
    }

    @Override
    public Object remove(String name) {
        return scopeBeanMap.remove(name);
    }

    @Override
    public void registerDestructionCallback(String name, Runnable callback) {
    }
    @Override
    public Object resolveContextualObject(String key) {
        return null;
    }
    @Override
    public String getConversationId() {
        return null;
    }
}
</code></pre>
</li>
<li>
<p>注册到 <em>org.springframework.beans.factory.config.CustomScopeConfigurer</em> 上</p>
<pre><code class="language-java">@Configuration
@Slf4j
public class BeanScopeConfig {
    @Bean
    public CustomScopeConfigurer customScopeConfigurer() {
        CustomScopeConfigurer customScopeConfigurer = new CustomScopeConfigurer();
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;timeScope&quot;, new TimeScope());
        customScopeConfigurer.setScopes(map);
        return customScopeConfigurer;
    }
    
    @Bean
    @Scope(value = &quot;timeScope&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)
    public TimeScopeBean timeScopeBean() {
        TimeScopeBean timeScopeBean = new TimeScopeBean();
        timeScopeBean.setCurrentTime(System.currentTimeMillis());
        log.info(&quot;time scope bean&quot;);
        return timeScopeBean;
    }
}
</code></pre>
</li>
<li>
<p>使用 </p>
<p><em>@Scope(proxyMode=ScopedProxyMode.TARGET_CLASS,value = &quot;thread&quot;)</em></p>
</li>
</ol>
<h2 id="自定义bean的特性"><a class="header" href="#自定义bean的特性">自定义bean的特性</a></h2>
<h3 id="三类回调形式"><a class="header" href="#三类回调形式">三类回调形式</a></h3>
<p><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle">Lifecycle Callbacks</a> 生命周期回调</p>
<p><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a> bean注入的回调</p>
<p><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#aware-list">Other <code>Aware</code> Interfaces</a> 其他的回调接口</p>
<h3 id="生命周期回调"><a class="header" href="#生命周期回调">生命周期回调</a></h3>
<h4 id="bean生命周期回调"><a class="header" href="#bean生命周期回调">Bean生命周期回调</a></h4>
<ul>
<li>
<p>通过 实现 <em>InitializingBean</em> ,<em>DisposableBean</em></p>
</li>
<li>
<p>推荐使用 @PostConstruct<code>and</code>@PreDestroy ,这可与 spring特定接口 松耦合</p>
</li>
<li>
<p>或者使用 bean定义 init-method<code>and</code>destroy-method 属性</p>
</li>
<li>
<p>spring通过 <em>BeanPostProcessor</em> 接口 进行回调处理,如果需要自定义可以自行实现</p>
</li>
<li>
<p>被管理的bean可以实现 <em>Lifecycle</em> 接口</p>
</li>
</ul>
<p><strong>Initialization Callbacks</strong></p>
<ul>
<li>发生于 容器初始完 所有必须的属性时</li>
<li>推荐使用 * <a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code></a> * 或者使用  Beandefinition 的  init-method<code>and</code>destroy-method 或者java注解的@Bean的属性,initMethod</li>
</ul>
<p><strong>Destruction Callbacks</strong></p>
<ul>
<li>类似于上面</li>
</ul>
<p><strong>Default Initialization and Destroy Methods</strong></p>
<p>或者指定全局默认的 init,destroy方法</p>
<pre><code>&lt;beans default-init-method=&quot;init&quot;&gt;

    &lt;bean id=&quot;blogService&quot; class=&quot;com.something.DefaultBlogService&quot;&gt;
        &lt;property name=&quot;blogDao&quot; ref=&quot;blogDao&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
// destroy-method
</code></pre>
<p><strong>以上各个 回调实现的组合调用顺序</strong></p>
<p>Multiple lifecycle mechanisms configured for the same bean, with different initialization methods, are called as follows:</p>
<ol>
<li>Methods annotated with <code>@PostConstruct</code></li>
<li><code>afterPropertiesSet()</code> as defined by the <code>InitializingBean</code> callback interface</li>
<li>A custom configured <code>init()</code> method</li>
</ol>
<p>Destroy methods are called in the same order:</p>
<ol>
<li>Methods annotated with <code>@PreDestroy</code></li>
<li><code>destroy()</code> as defined by the <code>DisposableBean</code> callback interface</li>
<li>A custom configured <code>destroy()</code> method</li>
</ol>
<h4 id="startup-and-shutdown-callbacks"><a class="header" href="#startup-and-shutdown-callbacks">Startup and Shutdown Callbacks</a></h4>
<ul>
<li>
<p><em>Lifecycle</em> 定义了 bean自己的 生命周期</p>
</li>
<li>
<p>容器会在收到 start stop信号后,将调用所有实现了该接口的方法,容器将委托给 <em>LifecycleProcessor</em> 去处理</p>
</li>
<li>
<p>只会在显示启动,或者显示停止时调用,要更细粒度的控制, 参照<em>SmartLifecycle</em></p>
<pre><code>	Note that the regular org.springframework.context.Lifecycle interface is a plain contract for explicit start and stop notifications and does not imply auto-startup at context refresh time. For fine-grained control over auto-startup of a specific bean (including startup phases), consider implementing org.springframework.context.SmartLifecycle instead.

Also, please note that stop notifications are not guaranteed to come before destruction. On regular shutdown, all Lifecycle beans first receive a stop notification before the general destruction callbacks are being propagated. However, on hot refresh during a context’s lifetime or on aborted refresh attempts, only destroy methods are called.
</code></pre>
</li>
<li>
<p>bean 对象 之间的 start,stop决定于 <em>depends-on</em> 和显示依赖注入,对于 某一类型 与另一类型的顺序 这 在 <em>SmartLifecycle</em> 有实现</p>
<pre><code class="language-java">public interface Phased {
    int getPhase();
}
</code></pre>
</li>
<li>
<p>当启动时, 最小的 <em>phase</em> 先启动, 关闭时 最大的 phase先关闭</p>
</li>
<li>
<p>对于普通的  “normal” <code>Lifecycle</code>  ,他们的 phase为0</p>
</li>
<li>
<p><code>SmartLifecycle</code> 的stop方法有回调,所有实现 <code>SmartLifecycle</code> 接口的 类 必须在 stop完后 回调该 stop方法</p>
<pre><code>	default void stop(Runnable callback) {
		stop();
		callback.run();
	}
</code></pre>
</li>
<li>
<p>processor的默认实现 在各个 bean关闭时的 默认超时时间 30s</p>
<pre><code class="language-java">&lt;bean id=&quot;lifecycleProcessor&quot; class=&quot;org.springframework.context.support.DefaultLifecycleProcessor&quot;&gt;
    &lt;!-- timeout value in milliseconds --&gt;
    &lt;property name=&quot;timeoutPerShutdownPhase&quot; value=&quot;10000&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>processor还提供了  <em>onRefresh</em> 的回调 , 它会判断 <code>SmartLifecycle</code>  的isAutoStart 的标志</p>
</li>
</ul>
<h4 id="优雅的关闭非web的容器"><a class="header" href="#优雅的关闭非web的容器">优雅的关闭非web的容器</a></h4>
<ul>
<li>
<p>springWebmvc的容器已经实现了该特性</p>
</li>
<li>
<p>在jvm那里 注册一个 钩子回调,实际上是 在jvm那里 注册一个 线程用于关闭</p>
<pre><code>        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);

        // add a shutdown hook for the above context...
        ctx.registerShutdownHook();
        
        
{
		if (this.shutdownHook == null) {
			// No shutdown hook registered yet.
			this.shutdownHook = new Thread(SHUTDOWN_HOOK_THREAD_NAME) {
				@Override
				public void run() {
					synchronized (startupShutdownMonitor) {
						doClose();
					}
				}
			};
			Runtime.getRuntime().addShutdownHook(this.shutdownHook);
		}
	}
</code></pre>
</li>
</ul>
<h3 id="applicationcontextaware-and-beannameaware"><a class="header" href="#applicationcontextaware-and-beannameaware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></h3>
<ul>
<li>
<p>用于获取 容器引用或者 bean引用,推荐使用 注解注入</p>
</li>
<li>
<p><code>BeanNameAware</code> 回调 迟于 各种属性填充前, 早于 各种初始化回调前</p>
</li>
</ul>
<h3 id="other-aware-interfaces"><a class="header" href="#other-aware-interfaces">Other <code>Aware</code> Interfaces</a></h3>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Injected Dependency</th><th style="text-align: left">Explained in…</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ApplicationContextAware</code></td><td style="text-align: left">Declaring <code>ApplicationContext</code>.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></td></tr>
<tr><td style="text-align: left"><code>ApplicationEventPublisherAware</code></td><td style="text-align: left">Event publisher of the enclosing <code>ApplicationContext</code>.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#context-introduction">Additional Capabilities of the <code>ApplicationContext</code></a></td></tr>
<tr><td style="text-align: left"><code>BeanClassLoaderAware</code></td><td style="text-align: left">Class loader used to load the bean classes.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-class">Instantiating Beans</a></td></tr>
<tr><td style="text-align: left"><code>BeanFactoryAware</code></td><td style="text-align: left">Declaring <code>BeanFactory</code>.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></td></tr>
<tr><td style="text-align: left"><code>BeanNameAware</code></td><td style="text-align: left">Name of the declaring bean.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></td></tr>
<tr><td style="text-align: left"><code>BootstrapContextAware</code></td><td style="text-align: left">Resource adapter <code>BootstrapContext</code> the container runs in. Typically available only in JCA-aware <code>ApplicationContext</code> instances.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/integration.html#cci">JCA CCI</a></td></tr>
<tr><td style="text-align: left"><code>LoadTimeWeaverAware</code></td><td style="text-align: left">Defined weaver for processing class definition at load time.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#aop-aj-ltw">Load-time Weaving with AspectJ in the Spring Framework</a></td></tr>
<tr><td style="text-align: left"><code>MessageSourceAware</code></td><td style="text-align: left">Configured strategy for resolving messages (with support for parametrization and internationalization).</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#context-introduction">Additional Capabilities of the <code>ApplicationContext</code></a></td></tr>
<tr><td style="text-align: left"><code>NotificationPublisherAware</code></td><td style="text-align: left">Spring JMX notification publisher.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/integration.html#jmx-notifications">Notifications</a></td></tr>
<tr><td style="text-align: left"><code>ResourceLoaderAware</code></td><td style="text-align: left">Configured loader for low-level access to resources.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#resources">Resources</a></td></tr>
<tr><td style="text-align: left"><code>ServletConfigAware</code></td><td style="text-align: left">Current <code>ServletConfig</code> the container runs in. Valid only in a web-aware Spring <code>ApplicationContext</code>.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/web.html#mvc">Spring MVC</a></td></tr>
<tr><td style="text-align: left"><code>ServletContextAware</code></td><td style="text-align: left">Current <code>ServletContext</code> the container runs in. Valid only in a web-aware Spring <code>ApplicationContext</code>.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/web.html#mvc">Spring MVC</a></td></tr>
</tbody></table>
<h2 id="bean-definition-inheritance"><a class="header" href="#bean-definition-inheritance">Bean Definition Inheritance</a></h2>
<p>bean定义继承</p>
<ul>
<li>bean继承以 子类为准</li>
<li>父类可以如果不写 class,必须abstract为true</li>
<li>bean之间的同名属性必须是 兼容的</li>
<li>如果abstract 定义为 true 则该bean定义为模板,不会产生实例</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;inheritedTestBean&quot; abstract=&quot;true&quot;
        class=&quot;org.springframework.beans.TestBean&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;inheritsWithDifferentClass&quot;
        class=&quot;org.springframework.beans.DerivedTestBean&quot;
        parent=&quot;inheritedTestBean&quot; init-method=&quot;initialize&quot;&gt;  
    &lt;property name=&quot;name&quot; value=&quot;override&quot;/&gt;
    &lt;!-- the age property value of 1 will be inherited from parent --&gt;
&lt;/bean&gt;

//不指定class
&lt;bean id=&quot;inheritedTestBeanWithoutClass&quot; abstract=&quot;true&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;inheritsWithClass&quot; class=&quot;org.springframework.beans.DerivedTestBean&quot;
        parent=&quot;inheritedTestBeanWithoutClass&quot; init-method=&quot;initialize&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;override&quot;/&gt;
    &lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;
&lt;/bean&gt;
</code></pre>
<h2 id="container-extension-points"><a class="header" href="#container-extension-points">Container Extension Points</a></h2>
<p>容器扩展点</p>
<p>spring容器提供各种接口 以供开发人员扩展</p>
<h3 id="beanpostprocessor"><a class="header" href="#beanpostprocessor"><code>BeanPostProcessor</code></a></h3>
<ul>
<li><em>BeanPostProcessor</em>  可以设置任意个</li>
<li>通过order属性 排序</li>
<li>作用域是 容器中,容器间得另外注册</li>
<li><em>BeanFactoryPostProcessor</em> 可以改变BeanDefintion</li>
<li>回调发生在每个bean对象 创建后, <em><code>InitializingBean.afterPropertiesSet()</code> or any declared <code>init</code> method</em>  容器初始化完,或者任何申明得初始化方法,在其他bean初始化后</li>
<li>它可以对任何 bean采取行动, 一般用于bean的代理</li>
<li>容器会根据 配置元数据(xml,或java) 注册 这些 beanpostProcessor</li>
<li>beanpostprocessor 的初始化需要早于其他bean的初始化</li>
<li>编程方式 注册
<ul>
<li><em>ConfigurableBeanFactory.addBeanPostProcessor</em>通过这个 手动注册,当你有业务逻辑时</li>
<li>不会遵守 order 顺序,注册的顺序决定 执行顺序</li>
<li>调用发生在 自动检测bean之前</li>
</ul>
</li>
<li><em>AOP auto-proxying</em> 是基于这个接口的 ,所以任何引用该类型的 类都不应该 对其 使用AOP</li>
</ul>
<p><strong>Example</strong></p>
<p><em>RequiredAnnotationBeanPostProcessor</em> 依赖注入时 确保属性的必输项都输入( 现在更推荐 构造器注入)已过期</p>
<h3 id="beanfactorypostprocessor"><a class="header" href="#beanfactorypostprocessor"><code>BeanFactoryPostProcessor</code></a></h3>
<p>Customizing Configuration Metadata with a <code>BeanFactoryPostProcessor</code></p>
<ul>
<li>用来修改bean定义本身,这种改变时不可逆的</li>
<li>通过实现 <em>order</em>接口 来配置  BeanFactoryPostProcessor间的 顺序</li>
<li>作用域时容器范围内</li>
<li>所有的postProcessor会忽略 懒加载</li>
</ul>
<p><strong>Example</strong></p>
<p><code>PropertySourcesPlaceholderConfigurer</code></p>
<p>可以使用<em>PropertySource</em>替代</p>
<ul>
<li>
<p>可以配置多个外部属性配置文件,用来替换  ${}表达式</p>
</li>
<li>
<p>或者手写配置文件</p>
</li>
<li>
<p>如果它失败了则 这时 容器处于 <code>preInstantiateSingletons()</code> phase of an <code>ApplicationContext</code> for a non-lazy-init bean</p>
<p>预加载阶段</p>
</li>
</ul>
<pre><code class="language-xml">&lt;bean class=&quot;org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer&quot;&gt;
    &lt;property name=&quot;locations&quot;&gt;
        &lt;value&gt;classpath:com/something/strategy.properties&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;value&gt;custom.strategy.class=com.something.DefaultStrategy&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;serviceStrategy&quot; class=&quot;${custom.strategy.class}&quot;/&gt;
</code></pre>
<p><strong><code>PropertyOverrideConfigurer</code></strong></p>
<p>替换 Bean定义的 参数属性</p>
<p>使用标签 :<em>&lt;context:property-override location=&quot;classpath:override.properties&quot;/&gt;</em></p>
<pre><code>person.name=大师傅似的
beanname.properteis=value
</code></pre>
<pre><code>@Bean
public PropertyOverrideConfigurer propertyOverrideConfigurer(){
    PropertyOverrideConfigurer propertyOverrideConfigurer = new PropertyOverrideConfigurer();
    propertyOverrideConfigurer.setFileEncoding(&quot;UTF-8&quot;);
    propertyOverrideConfigurer.setLocation(new ClassPathResource(&quot;my.properties&quot;));
    return propertyOverrideConfigurer;
}
</code></pre>
<h3 id="factorybean"><a class="header" href="#factorybean"><code>FactoryBean</code></a></h3>
<p>Customizing Instantiation Logic with a factoryBean</p>
<p>实现自定义 bean定义 逻辑</p>
<h2 id="annotation-based-container-configuration"><a class="header" href="#annotation-based-container-configuration">Annotation-based Container Configuration</a></h2>
<ul>
<li>基于注解的注入 比XML 注入更早执行,所以xml的注入会覆盖注解的注入</li>
<li>基于注解的注入实际上是 一个个beanPostProcessor</li>
<li>隐式注册这些beanPostProcessor :  <a href="context:annotation-config/">context:annotation-config/</a>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"><code>AutowiredAnnotationBeanPostProcessor</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html"><code>CommonAnnotationBeanPostProcessor</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html"><code>PersistenceAnnotationBeanPostProcessor</code></a> </li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html"><code>RequiredAnnotationBeanPostProcessor</code></a></li>
</ul>
</li>
</ul>
<h3 id="required"><a class="header" href="#required">@Required</a></h3>
<p>标识该setter方法的注入必须, 已过期,推荐使用构造器注入</p>
<pre><code>public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
</code></pre>
<h3 id="autowired"><a class="header" href="#autowired">@Autowired</a></h3>
<p>构造方法上(当 只有一个构造方法时,不是很必要)</p>
<pre><code class="language-java">public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }
}
</code></pre>
<p>setter注入</p>
<pre><code>public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
</code></pre>
<p>字段注入</p>
<pre><code class="language-java"> @Autowired
    private MovieCatalog movieCatalog;
</code></pre>
<p>可以注入某一类Bean</p>
<p>可以@Order或者order接口,实现注入的排序,否则顺序以注册顺序为准,@Order也会影响依赖注入顺序</p>
<pre><code class="language-java">public class MovieRecommender {
    @Autowired
    private MovieCatalog[] movieCatalogs;
}
public class MovieRecommender {
    private Set&lt;MovieCatalog&gt; movieCatalogs;
    @Autowired
    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }
}
</code></pre>
<p>Map注入</p>
<p>这回注入所有 beanname,和某一类型的bean</p>
<pre><code class="language-java">public class MovieRecommender {
    private Map&lt;String, MovieCatalog&gt; movieCatalogs;
    @Autowired
    public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }
}
</code></pre>
<p>可以不启用</p>
<pre><code>public class SimpleMovieLister {
    private MovieFinder movieFinder;
    @Autowired(required = false)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
</code></pre>
<p>注入Optional类</p>
<pre><code class="language-java">public class SimpleMovieLister {
    @Autowired
    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) {
    }
}
</code></pre>
<p>可以使用@nullable</p>
<pre><code class="language-java">    @Autowired
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        ...
    }
</code></pre>
<p>可以注入spring相关的bean</p>
<pre><code>BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource
ConfigurableApplicationContext or ResourcePatternResolver
public class MovieRecommender {

    @Autowired
    private ApplicationContext context;

    public MovieRecommender() {
    }
}
</code></pre>
<p><strong>注意事项</strong></p>
<ul>
<li>一个bean可能有多个 构造器, 但只有一个 构造器能 @Autowired(required = true),其他的必须是false</li>
<li>通过 匹配容器中的bean 满足依赖关系最多的 构造器 将会被使用,如果都不满足 使用默认构造器</li>
<li>'@Autowired<code>, </code>@Inject<code>, </code>@Value<code>, and </code>@Resource' 这些注入 不能用于BeanPostProcessor或者BeanFactoryPostProcessor</li>
</ul>
<h3 id="primary-1"><a class="header" href="#primary-1">@Primary</a></h3>
<ul>
<li>通过类型注册可能有多个类型的候选者,可以使用primary指定</li>
</ul>
<pre><code class="language-java">@Configuration
public class MovieConfiguration {

    @Bean
    @Primary
    public MovieCatalog firstMovieCatalog() { ... }

    @Bean
    public MovieCatalog secondMovieCatalog() { ... }

    // ...
}
</code></pre>
<p>xml配置</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot; primary=&quot;true&quot;&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;movieRecommender&quot; class=&quot;example.MovieRecommender&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="qualifiers"><a class="header" href="#qualifiers">@Qualifiers</a></h3>
<ul>
<li>
<p>与id不同,类似于 手动给定bean分类, 类似于某种bean的过滤器</p>
</li>
<li>
<p>这在注入 集合类的时候 作用尤为明显 <code>Set&lt;MovieCatalog&gt;</code></p>
</li>
<li>
<p>如果没有其他指示器(类似primary,qualifier) ,而且存在多个候选者,则spring会根据 注入字段名或参数名匹配bean</p>
</li>
<li>
<p>如果你想通过bean名匹配,最好使用@Resource, @Autowired的语义是:先找同类型的,然后寻找指定的Qualifer</p>
</li>
<li>
<p>可以通过@Resource引用集合</p>
</li>
<li>
<p>qualifier可以自引用,但顺序是最后的</p>
</li>
</ul>
<pre><code class="language-java">public class MovieRecommender {

    @Autowired
    @Qualifier(&quot;main&quot;)
    private MovieCatalog movieCatalog;

    // ...
}


public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(@Qualifier(&quot;main&quot;) MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
</code></pre>
<p>xml配置</p>
<pre><code class="language-hxml"> &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier value=&quot;main&quot;/&gt; 

        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;
</code></pre>
<p><strong>创建自己的qualifier注解</strong>,给qualifier分类</p>
<pre><code class="language-java">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Genre {

    String value();
}
</code></pre>
<p>使用注解</p>
<pre><code class="language-java">public class MovieRecommender {

    @Autowired
    @Genre(&quot;Action&quot;)
    private MovieCatalog actionCatalog;

    private MovieCatalog comedyCatalog;

    @Autowired
    public void setComedyCatalog(@Genre(&quot;Comedy&quot;) MovieCatalog comedyCatalog) {
        this.comedyCatalog = comedyCatalog;
    }

    // ...
}
</code></pre>
<p>可以使用短类名,或者全限定类名</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier type=&quot;Genre&quot; value=&quot;Action&quot;/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier type=&quot;example.Genre&quot; value=&quot;Comedy&quot;/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;movieRecommender&quot; class=&quot;example.MovieRecommender&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p>给qualifier添加类别,属性</p>
<pre><code class="language-java">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface MovieQualifier {

    String genre();

    Format format();
}
public enum Format {
    VHS, DVD, BLURAY
}
</code></pre>
<p>按照分类注入</p>
<pre><code class="language-java">public class MovieRecommender {

    @Autowired
    @MovieQualifier(format=Format.VHS, genre=&quot;Action&quot;)
    private MovieCatalog actionVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.VHS, genre=&quot;Comedy&quot;)
    private MovieCatalog comedyVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.DVD, genre=&quot;Action&quot;)
    private MovieCatalog actionDvdCatalog;

    @Autowired
    @MovieQualifier(format=Format.BLURAY, genre=&quot;Comedy&quot;)
    private MovieCatalog comedyBluRayCatalog;

    // ...
}
</code></pre>
<p>同样可以使用meta标签 简写 qualifier标签,会自动查找该qualifier的值</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier type=&quot;MovieQualifier&quot;&gt;
            &lt;attribute key=&quot;format&quot; value=&quot;VHS&quot;/&gt;
            &lt;attribute key=&quot;genre&quot; value=&quot;Action&quot;/&gt;
        &lt;/qualifier&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier type=&quot;MovieQualifier&quot;&gt;
            &lt;attribute key=&quot;format&quot; value=&quot;VHS&quot;/&gt;
            &lt;attribute key=&quot;genre&quot; value=&quot;Comedy&quot;/&gt;
        &lt;/qualifier&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;meta key=&quot;format&quot; value=&quot;DVD&quot;/&gt;
        &lt;meta key=&quot;genre&quot; value=&quot;Action&quot;/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;meta key=&quot;format&quot; value=&quot;BLURAY&quot;/&gt;
        &lt;meta key=&quot;genre&quot; value=&quot;Comedy&quot;/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="using-generics"><a class="header" href="#using-generics">Using Generics</a></h3>
<p>使用泛型自动注入</p>
<p>假设下面的类 实现了 某个泛型接口</p>
<pre><code class="language-j">Store&lt;String&gt;` and `Store&lt;Integer&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class MyConfiguration {

    @Bean
    public StringStore stringStore() {
        return new StringStore();
    }

    @Bean
    public IntegerStore integerStore() {
        return new IntegerStore();
    }
}


@Autowired
private Store&lt;String&gt; s1; // &lt;String&gt; qualifier, injects the stringStore bean

@Autowired
private Store&lt;Integer&gt; s2; // &lt;Integer&gt; qualifier, injects the integerStore bean
</code></pre>
<p>泛型同样支持 集合类</p>
<pre><code class="language-java">@Autowired
private List&lt;Store&lt;Integer&gt;&gt; s;
</code></pre>
<h3 id="customautowireconfigurer"><a class="header" href="#customautowireconfigurer">CustomAutowireConfigurer</a></h3>
<p><em><code>CustomAutowireConfigurer</code> 是一个 BeanFactoryPostProcessor</em>  可以让你注册自己的 qualifier</p>
<p>xml配置</p>
<pre><code class="language-xml">&lt;bean id=&quot;customAutowireConfigurer&quot;
        class=&quot;org.springframework.beans.factory.annotation.CustomAutowireConfigurer&quot;&gt;
    &lt;property name=&quot;customQualifierTypes&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;example.CustomQualifier&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p><em>AutowireCandidateResolver</em> (QualifierAnnotationAutowireCandidateResolver)选取候选者的方式</p>
<ul>
<li>autowire-candidate 每一个bean的 自动注入候选者</li>
<li>在<code>&lt;beans&gt;</code>中的 default-autowire-candidates</li>
<li>@qualifier的限定类</li>
<li>CustomAutowireConfigurer 中的候选类</li>
</ul>
<h3 id="resource"><a class="header" href="#resource">@Resource</a></h3>
<ul>
<li>如果没有指定名字 取 方法参数名或者 字段名</li>
<li>名称是由 ApplicationContext 提供查找(由CommonAnnotationBeanPostProcessor 注入)</li>
</ul>
<h3 id="value"><a class="header" href="#value">@Value</a></h3>
<p>注入外部属性</p>
<pre><code class="language-java">@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value(&quot;${catalog.name}&quot;) String catalog) {
        this.catalog = catalog;
    }
}

@Configuration
@PropertySource(&quot;classpath:application.properties&quot;)
public class AppConfig { }

catalog.name=MovieCatalog
</code></pre>
<p>如果想要严格控制 不存在的值可以如下申明</p>
<pre><code class="language-java">@Configuration
public class AppConfig {

     @Bean
     public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {
           return new PropertySourcesPlaceholderConfigurer();
     }
}

</code></pre>
<ul>
<li>
<p>当配置这个JavaConfig Bean时,必须是static</p>
</li>
<li>
<p>可以设置前缀后缀 分隔符,setPlaceholderPrefix<code>, </code>setPlaceholderSuffix<code>, or </code>setValueSeparator</p>
</li>
<li>
<p><em>PropertySourcesPlaceholderConfigurer</em> springboot自动带一个,会从 application.properties<code>and</code>application.yml解析</p>
</li>
<li>
<p>值转换的过程 可以自定义ConversionService</p>
<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean
    public ConversionService conversionService() {
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
        conversionService.addConverter(new MyCustomConverter());
        return conversionService;
    }
}
</code></pre>
</li>
<li>
<p>支持 EL表达式</p>
<pre><code class="language-java">@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value(&quot;#{systemProperties['user.catalog'] + 'Catalog' }&quot;) String catalog) {
        this.catalog = catalog;
    }
}

@Component
public class MovieRecommender {

    private final Map&lt;String, Integer&gt; countOfMoviesPerCatalog;

    public MovieRecommender(
            @Value(&quot;#{{'Thriller': 100, 'Comedy': 300}}&quot;) Map&lt;String, Integer&gt; countOfMoviesPerCatalog) {
        this.countOfMoviesPerCatalog = countOfMoviesPerCatalog;
    }
}
</code></pre>
</li>
</ul>
<h3 id="postconstruct-predestroy"><a class="header" href="#postconstruct-predestroy">@PostConstruct @PreDestroy</a></h3>
<ul>
<li>这两个注解也是 <em>CommonAnnotationBeanPostProcessor</em> 实现的</li>
<li><code>@Resource</code>, the <code>@PostConstruct</code> and <code>@PreDestroy</code>  这个在 java9被移包,在11被分离需要手动引入javax.annotation-api</li>
</ul>
<h2 id="类路径扫描容器管理"><a class="header" href="#类路径扫描容器管理">类路径扫描,容器管理</a></h2>
<h3 id="component"><a class="header" href="#component">Component</a></h3>
<p>模板注解,@Repository<code>, </code>@Service<code>, and </code>@Controller是 它的特例,目前没有什么区别,以后可能会增加区别</p>
<h3 id="使用元注解或组合注解"><a class="header" href="#使用元注解或组合注解">使用元注解或组合注解</a></h3>
<p>元注解</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component 
public @interface Service {

    // ...
}

Component 导致 service 跟 component同样对待
</code></pre>
<p>组合注解</p>
<p>@RestController等价于 @Controller<code>and</code>@ResponseBody</p>
<p>元注解可以重新申明 属性自定义属性的值</p>
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Scope(WebApplicationContext.SCOPE_SESSION)
public @interface SessionScope {

    /**
     * Alias for {@link Scope#proxyMode}.
     * &lt;p&gt;Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
     */
    @AliasFor(annotation = Scope.class)
    ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

}

@Service
@SessionScope
public class SessionScopedService {
    // ...
}
</code></pre>
<h3 id="自动注册bean定义"><a class="header" href="#自动注册bean定义">自动注册bean定义</a></h3>
<p>spring会自动注册带有 模板注解component的类,并生成相应的bean定义 在applicationContext中</p>
<pre><code class="language-java">@Service
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
</code></pre>
<p>为了自动注册上面的类型必须 要在 带有 @Configuration的 类中 申明 ,包扫描,包之间可以用 空格, 逗号,冒号</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;)
public class AppConfig  {
    // ...
}

//@ComponentScan(&quot;org.example&quot;)简写形式

//xml 形式
 &lt;context:component-scan base-package=&quot;org.example&quot;/&gt;
 它会激活 &lt;context:annotation-config&gt;注解
</code></pre>
<p>使用Ant编译工程时, you do not activate the files-only switch of the JAR task</p>
<p>同时 AutowiredAnnotationBeanPostProcessor<code>and</code>CommonAnnotationBeanPostProcessor这两个beanPostProcessor也会被注册</p>
<pre><code>You can disable the registration of AutowiredAnnotationBeanPostProcessor and CommonAnnotationBeanPostProcessor by including the annotation-config attribute with a value of false.
</code></pre>
<h3 id="使用过滤器-自定义扫描"><a class="header" href="#使用过滤器-自定义扫描">使用过滤器 自定义扫描</a></h3>
<ul>
<li>
<p>'@Component<code>, </code>@Repository<code>, </code>@Service<code>, </code>@Controller<code>, </code>@Configuration'默认只扫描带有这些注解的类 </p>
</li>
<li>
<p>通过ComponentScan的 includeFilters ,excludeFilters 属性 设定不同类型的过滤器去 取 或者排除 相应的类</p>
</li>
<li>
<p>过滤器的类型</p>
<table><thead><tr><th style="text-align: left">ilter Type</th><th style="text-align: left">Example Expression</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">annotation (default)</td><td style="text-align: left"><code>org.example.SomeAnnotation</code></td><td style="text-align: left">指定  注释类上或者元类上的注解类</td></tr>
<tr><td style="text-align: left">assignable</td><td style="text-align: left"><code>org.example.SomeClass</code></td><td style="text-align: left">A class (or interface) that the target components are assignable to (extend or implement).</td></tr>
<tr><td style="text-align: left">aspectj</td><td style="text-align: left"><code>org.example..*Service+</code></td><td style="text-align: left">使用 aspectj注入语法</td></tr>
<tr><td style="text-align: left">regex</td><td style="text-align: left"><code>org\.example\.Default.*</code></td><td style="text-align: left">使用正则匹配类全限定名</td></tr>
<tr><td style="text-align: left">custom</td><td style="text-align: left"><code>org.example.MyTypeFilter</code></td><td style="text-align: left">A custom implementation of the <code>org.springframework.core.type.TypeFilter</code> interface.</td></tr>
</tbody></table>
</li>
<li>
<p>使用</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;,
        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),
        excludeFilters = @Filter(Repository.class))
public class AppConfig {
    ...
}
</code></pre>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;org.example&quot;&gt;
        &lt;context:include-filter type=&quot;regex&quot;
                expression=&quot;.*Stub.*Repository&quot;/&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot;
                expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;
    &lt;/context:component-scan&gt;
&lt;/beans&gt;

</code></pre>
</li>
<li>
<p>'useDefaultFilters=false use-default-filters=&quot;false&quot;' 可以使得系统不会自动 <em><code>@Component</code>, <code>@Repository</code>, <code>@Service</code>, <code>@Controller</code>, <code>@RestController</code>, or <code>@Configuration</code>.</em> 扫描这些注解</p>
</li>
</ul>
<h3 id="使用component定义元数据"><a class="header" href="#使用component定义元数据">使用component定义元数据</a></h3>
<ul>
<li>可以使用component定义元数据</li>
<li>方法级别的bean定义,类似于 提供一个工厂方法</li>
</ul>
<pre><code class="language-java">@Component
public class FactoryMethodComponent {

    @Bean
    @Qualifier(&quot;public&quot;)
    public TestBean publicInstance() {
        return new TestBean(&quot;publicInstance&quot;);
    }

    public void doWork() {
        // Component method implementation omitted
    }
}
</code></pre>
<pre><code class="language-java">@Component
public class FactoryMethodComponent {

    private static int i;

    @Bean
    @Qualifier(&quot;public&quot;)
    public TestBean publicInstance() {
        return new TestBean(&quot;publicInstance&quot;);
    }

    // use of a custom qualifier and autowiring of method parameters
    @Bean
    protected TestBean protectedInstance(
            @Qualifier(&quot;public&quot;) TestBean spouse,
            @Value(&quot;#{privateInstance.age}&quot;) String country) {
        TestBean tb = new TestBean(&quot;protectedInstance&quot;, 1);
        tb.setSpouse(spouse);
        tb.setCountry(country);
        return tb;
    }

    @Bean
    private TestBean privateInstance() {
        return new TestBean(&quot;privateInstance&quot;, i++);
    }

    @Bean
    @RequestScope
    public TestBean requestScopedInstance() {
        return new TestBean(&quot;requestScopedInstance&quot;, 3);
    }
}
</code></pre>
<pre><code class="language-java">@Component
public class FactoryMethodComponent {

    @Bean @Scope(&quot;prototype&quot;)
    public TestBean prototypeInstance(InjectionPoint injectionPoint) {
        return new TestBean(&quot;prototypeInstance for &quot; + injectionPoint.getMember());
    }
}
</code></pre>
<p>As of Spring Framework 4.3,可以使用 InjectionPoint(DependencyDescriptor更详细的子类) 可以访问到请求注入点,当然这适用于 原型作用域,</p>
<ul>
<li>在普通 component的 @bean与 @configuration的@Bean不同
<ul>
<li>configuration 中 cglib会对其增强, 通过 代理@bean方法的调用来创建元数据引用</li>
<li>component 下的@bean是正常的java语义</li>
<li>由于CGLIB需要继承 该类,所以@bean方法不能是final和 private,可以设置成 static,这样避免spring拦截</li>
</ul>
</li>
</ul>
<h3 id="componet自动命名"><a class="header" href="#componet自动命名">componet自动命名</a></h3>
<ul>
<li>自动命名取 短类名</li>
<li>如果命名重复  <a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html"><code>BeanNameGenerator</code></a> 可以注册这个类实现自定义自动命名它的子类为,FullyQualifiedAnnotationBeanNameGenerator</li>
</ul>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;, nameGenerator = MyNameGenerator.class)
public class AppConfig {
    // ...
}
</code></pre>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;org.example&quot;
        name-generator=&quot;org.example.MyNameGenerator&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="component设置作用域"><a class="header" href="#component设置作用域">component设置作用域</a></h3>
<pre><code class="language-java">@Scope(&quot;prototype&quot;)
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
</code></pre>
<p>扫描特定作用域</p>
<p>实现 <a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html"><code>ScopeMetadataResolver</code></a> </p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;, scopeResolver = MyScopeResolver.class)
public class AppConfig {
    // ...
}
</code></pre>
<p>扫描特定 作用域代理方式</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;, scopedProxy = ScopedProxyMode.INTERFACES)
public class AppConfig {
    // ...
}
</code></pre>
<h3 id="qualifier标注component"><a class="header" href="#qualifier标注component">Qualifier标注Component</a></h3>
<pre><code class="language-java">@Component
@Qualifier(&quot;Action&quot;)
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}
</code></pre>
<h3 id="产生候选组件索引"><a class="header" href="#产生候选组件索引">产生候选组件索引</a></h3>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt;
        &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>在编译期产生 候选者的索引,可以避免在类路径扫描,提升查找速度</p>
<pre><code class="language-kotlin">dependencies {
    compileOnly &quot;org.springframework:spring-context-indexer:5.2.7.RELEASE&quot;
}
</code></pre>
<ul>
<li>会产生  META-INF/spring.components 文件</li>
<li>spring-context-indexer必须要注册到容器中来</li>
<li>如果类路径下 META-INF/spring.components 有这个文件,且有相关依赖,则该特性会被激活,spring.index.ignore可以关闭</li>
</ul>
<h2 id="使用jsr330标准注解"><a class="header" href="#使用jsr330标准注解">使用JSR330标准注解</a></h2>
<ul>
<li>
<p>需要引入</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.inject&lt;/groupId&gt;
    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;
    &lt;version&gt;1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ul>
<h3 id="依赖注入injectnamed"><a class="header" href="#依赖注入injectnamed">依赖注入:Inject,Named</a></h3>
<pre><code class="language-java">import javax.inject.Inject;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.findMovies(...);
        // ...
    }
}
</code></pre>
<h3 id="provider注入"><a class="header" href="#provider注入">provider注入</a></h3>
<p>可以注入 Provider包装的类, 提供懒加载,按需加载</p>
<pre><code class="language-java">import javax.inject.Inject;
import javax.inject.Provider;

public class SimpleMovieLister {

    private Provider&lt;MovieFinder&gt; movieFinder;

    @Inject
    public void setMovieFinder(Provider&lt;MovieFinder&gt; movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.get().findMovies(...);
        // ...
    }
}
</code></pre>
<h3 id="optional注入"><a class="header" href="#optional注入">Optional注入</a></h3>
<p>注入Optional 包装类,或者使用@nullable</p>
<pre><code class="language-jav">public class SimpleMovieLister {

    @Inject
    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) {
        // ...
    }
}
</code></pre>
<h3 id="named注入"><a class="header" href="#named注入">named注入</a></h3>
<p>名称注入named</p>
<pre><code class="language-java">import javax.inject.Inject;
import javax.inject.Named;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(@Named(&quot;main&quot;) MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
</code></pre>
<h3 id="namedmanagedbean"><a class="header" href="#namedmanagedbean">@named,@ManagedBean</a></h3>
<p>与Component相同的 @named,@ManagedBean,二者不可组合</p>
<pre><code class="language-java">import javax.inject.Inject;
import javax.inject.Named;

@Named(&quot;movieListener&quot;)  // @ManagedBean(&quot;movieListener&quot;) could be used as well
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}

import javax.inject.Inject;
import javax.inject.Named;

@Named
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
</code></pre>
<h3 id="jsr330注解限制"><a class="header" href="#jsr330注解限制">JSR330注解限制</a></h3>
<table><thead><tr><th style="text-align: left">Spring</th><th style="text-align: left">javax.inject.*</th><th style="text-align: left">javax.inject restrictions / comments</th></tr></thead><tbody>
<tr><td style="text-align: left">@Autowired</td><td style="text-align: left">@Inject</td><td style="text-align: left"><code>@Inject</code> has no 'required' attribute. Can be used with Java 8’s <code>Optional</code> instead.</td></tr>
<tr><td style="text-align: left">@Component</td><td style="text-align: left">@Named / @ManagedBean</td><td style="text-align: left">JSR-330 does not provide a composable model, only a way to identify named components.</td></tr>
<tr><td style="text-align: left">@Scope(&quot;singleton&quot;)</td><td style="text-align: left">@Singleton</td><td style="text-align: left">The JSR-330 default scope is like Spring’s <code>prototype</code>. However, in order to keep it consistent with Spring’s general defaults, a JSR-330 bean declared in the Spring container is a <code>singleton</code> by default. In order to use a scope other than <code>singleton</code>, you should use Spring’s <code>@Scope</code> annotation. <code>javax.inject</code> also provides a <a href="https://download.oracle.com/javaee/6/api/javax/inject/Scope.html">@Scope</a> annotation. Nevertheless, this one is only intended to be used for creating your own annotations.</td></tr>
<tr><td style="text-align: left">@Qualifier</td><td style="text-align: left">@Qualifier / @Named</td><td style="text-align: left"><code>javax.inject.Qualifier</code> is just a meta-annotation for building custom qualifiers. Concrete <code>String</code> qualifiers (like Spring’s <code>@Qualifier</code> with a value) can be associated through <code>javax.inject.Named</code>.</td></tr>
<tr><td style="text-align: left">@Value</td><td style="text-align: left">-</td><td style="text-align: left">no equivalent</td></tr>
<tr><td style="text-align: left">@Required</td><td style="text-align: left">-</td><td style="text-align: left">no equivalent</td></tr>
<tr><td style="text-align: left">@Lazy</td><td style="text-align: left">-</td><td style="text-align: left">no equivalent</td></tr>
<tr><td style="text-align: left">ObjectFactory</td><td style="text-align: left">Provider</td><td style="text-align: left"><code>javax.inject.Provider</code> is a direct alternative to Spring’s <code>ObjectFactory</code>, only with a shorter <code>get()</code> method name. It can also be used in combination with Spring’s <code>@Autowired</code> or with non-annotated constructors and setter methods.</td></tr>
</tbody></table>
<h2 id="基于java的注解"><a class="header" href="#基于java的注解">基于Java的注解.</a></h2>
<h3 id="实例化-注解配置容器"><a class="header" href="#实例化-注解配置容器">实例化 注解配置容器</a></h3>
<p><code>AnnotationConfigApplicationContext</code> </p>
<ul>
<li>这个通用的applicationContext可以接受@configuration的配置,也可以接受@Component的注解</li>
<li>带有@configuration注解的类被解析成 bean定义,@bean也会被解析成bean定义</li>
</ul>
<p>实例化</p>
<pre><code class="language-java">public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
</code></pre>
<p>编程方式实例化</p>
<pre><code class="language-java">public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(AppConfig.class, OtherConfig.class);
    ctx.register(AdditionalConfig.class);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
</code></pre>
<p>扫描</p>
<pre><code class="language-java">public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.scan(&quot;com.acme&quot;);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
}

@Configuration
@ComponentScan(basePackages = &quot;com.acme&quot;) 
public class AppConfig  {
    ...
}
</code></pre>
<p>web应用 <code>AnnotationConfigWebApplicationContext</code></p>
<ul>
<li>'WebApplicationContext'的变体 <code>AnnotationConfigWebApplicationContext</code> 来配置spring的 ContextLoaderListener servlet</li>
<li>Spring MVC <code>DispatcherServlet</code></li>
</ul>
<pre><code class="language-xml">&lt;web-app&gt;
    &lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
        instead of the default XmlWebApplicationContext --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Configuration locations must consist of one or more comma- or space-delimited
        fully-qualified @Configuration classes. Fully-qualified packages may also be
        specified for component-scanning --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;com.acme.AppConfig&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
            instead of the default XmlWebApplicationContext --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextClass&lt;/param-name&gt;
            &lt;param-value&gt;
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            &lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- Again, config locations must consist of one or more comma- or space-delimited
            and fully-qualified @Configuration classes --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;com.acme.web.MvcConfig&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;

    &lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<h3 id="bean注解"><a class="header" href="#bean注解">@Bean注解</a></h3>
<h4 id="生命周期回调-1"><a class="header" href="#生命周期回调-1">生命周期回调</a></h4>
<ul>
<li>
<p>'@PostConstruct<code>and</code>@PreDestroy' 构造器调用完后,setter注入前,  销毁前</p>
</li>
<li>
<p>支持 spring常规的 回调'InitializingBean<code>, </code>DisposableBean<code>, or </code>Lifecycle' </p>
</li>
<li>
<p><code>*Aware</code> interfaces 注入接口回调</p>
</li>
<li>
<p>支持 init-method<code>and</code>destroy-method 属性</p>
</li>
<li>
<p>关闭生命周期回调</p>
<pre><code class="language-java">@Bean(destroyMethod=&quot;&quot;)
public DataSource dataSource() throws NamingException {
    return (DataSource) jndiTemplate.lookup(&quot;MyDS&quot;);
}
</code></pre>
</li>
</ul>
<h4 id="指定scope域"><a class="header" href="#指定scope域">指定scope域</a></h4>
<pre><code class="language-java">// an HTTP Session-scoped bean exposed as a proxy
@Bean
@SessionScope
public UserPreferences userPreferences() {
    return new UserPreferences();
}

@Bean
public Service userService() {
    UserService service = new SimpleUserService();
    // a reference to the proxied userPreferences bean
    service.setUserPreferences(userPreferences());
    return service;
}
</code></pre>
<h4 id="bean别名-1"><a class="header" href="#bean别名-1">bean别名</a></h4>
<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean({&quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot;})
    public DataSource dataSource() {
        // instantiate, configure and return DataSource bean...
    }
}
</code></pre>
<h4 id="bean描述"><a class="header" href="#bean描述">bean描述</a></h4>
<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean
    @Description(&quot;Provides a basic example of a bean&quot;)
    public Thing thing() {
        return new Thing();
    }
}
</code></pre>
<h3 id="import"><a class="header" href="#import">@import</a></h3>
<pre><code class="language-java">@Configuration
public class ConfigA {

    @Bean
    public A a() {
        return new A();
    }
}

@Configuration
@Import(ConfigA.class)
public class ConfigB {

    @Bean
    public B b() {
        return new B();
    }
}


public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

    // now both beans A and B will be available...
    A a = ctx.getBean(A.class);
    B b = ctx.getBean(B.class);
}
</code></pre>
<p>这样只用引入 ConfigB就可以同时引入ConfigA</p>
<h3 id="条件性的包含bean"><a class="header" href="#条件性的包含bean">条件性的包含bean</a></h3>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code></a>.</p>
<p>实现Conditional接口</p>
<p>@Profile的实现</p>
<pre><code class="language-java">@Override
public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    // Read the @Profile annotation attributes
    MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
    if (attrs != null) {
        for (Object value : attrs.get(&quot;value&quot;)) {
            if (context.getEnvironment().acceptsProfiles(((String[]) value))) {
                return true;
            }
        }
        return false;
    }
    return true;
}
</code></pre>
<p>Condition接口</p>
<pre><code class="language-java">boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);
</code></pre>
<h3 id="java配置与xml配置结合"><a class="header" href="#java配置与xml配置结合">Java配置与XML配置结合</a></h3>
<ul>
<li>以Java为中心的配置 AnnotationConfigApplicationContext and the  @ImportResource 导入xml</li>
</ul>
<pre><code class="language-javascript">@Configuration
@ImportResource(&quot;classpath:/com/acme/properties-config.xml&quot;)
public class AppConfig {

    @Value(&quot;${jdbc.url}&quot;)
    private String url;

    @Value(&quot;${jdbc.username}&quot;)
    private String username;

    @Value(&quot;${jdbc.password}&quot;)
    private String password;

    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(url, username, password);
    }
}
</code></pre>
<h2 id="环境抽象"><a class="header" href="#环境抽象">环境抽象</a></h2>
<p>spring对环境的抽象建模 主要是 两块: properties 和 profile</p>
<ul>
<li>
<p>profile的含义是 条件选择</p>
</li>
<li>
<p>properties (包括配置文件,系统属性,系统环境变量,JNDI,servletContext参数,等等)</p>
</li>
</ul>
<h3 id="profile"><a class="header" href="#profile">profile</a></h3>
<pre><code class="language-java">@Configuration
@Profile(&quot;development&quot;)
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)
            .addScript(&quot;classpath:com/bank/config/sql/test-data.sql&quot;)
            .build();
    }
}
</code></pre>
<p>profile名称支持 如下语法</p>
<ul>
<li><code>!</code>: A logical “not” of the profile</li>
<li><code>&amp;</code>: A logical “and” of the profiles</li>
<li><code>|</code>: A logical “or” of the profiles</li>
</ul>
<p>可以自定义注解</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Profile(&quot;production&quot;)
public @interface Production {
}
</code></pre>
<p>@Profile({&quot;p1&quot;, &quot;!p2&quot;}) {} 标识 或逻辑</p>
<p>基于xml的配置</p>
<pre><code class="language-xml">&lt;beans profile=&quot;development&quot;
    xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
    xsi:schemaLocation=&quot;...&quot;&gt;

    &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;
        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;
        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;
    &lt;/jdbc:embedded-database&gt;
&lt;/beans&gt;

&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;
    xsi:schemaLocation=&quot;...&quot;&gt;

    &lt;!-- other bean definitions --&gt;

    &lt;beans profile=&quot;development&quot;&gt;
        &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;
            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;
            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

    &lt;beans profile=&quot;production&quot;&gt;
        &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;
    &lt;/beans&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="激活profile"><a class="header" href="#激活profile">激活profile</a></h3>
<p>通过编程的方式 ,使用Environment接口 通过容器</p>
<pre><code class="language-java">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles(&quot;development&quot;);
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();
</code></pre>
<p>使用注解 @ActiveProfiles</p>
<p>使用变量名spring.profiles.active</p>
<pre><code>  -Dspring.profiles.active=&quot;profile1,profile2&quot;
</code></pre>
<p>spring.profiles.default设置默认环境变量</p>
<pre><code class="language-java">@Configuration
@Profile(&quot;default&quot;)
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)
            .build();
    }
}
</code></pre>
<h3 id="propertiessource"><a class="header" href="#propertiessource">PropertiesSource</a></h3>
<ul>
<li>
<p>propertiesSource是 spring对环境变量的抽象,基于键值对的抽象</p>
</li>
<li>
<p>standardEnvironment 是包含两个 properties Source </p>
<ul>
<li>JVM system properties (<code>System.getProperties()</code></li>
<li>system environment variables (<code>System.getenv()</code>).</li>
</ul>
</li>
<li>
<p>StandardServletEnvrionment 包含 servletconfig,servletContext参数,可选的JNDIPropertySource</p>
</li>
<li>
<p>环境变量的查找有层级优先级,以StandardServletEnvrionment 为例</p>
<ul>
<li>ServletConfig parameters (if applicable — for example, in case of a <code>DispatcherServlet</code> context)</li>
<li>ServletContext parameters (web.xml context-param entries)</li>
<li>JNDI environment variables (<code>java:comp/env/</code> entries)</li>
<li>JVM system properties (<code>-D</code> command-line arguments)</li>
<li>JVM system environment (operating system environment variables)</li>
</ul>
</li>
<li>
<p>以上查找机制是可配的,可自定义</p>
<pre><code class="language-java">ConfigurableApplicationContext ctx = new GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(new MyPropertySource());
</code></pre>
<p>经过以上配置,可以注册自定义的MypropertySource 并且由先先级是最高</p>
</li>
</ul>
<h3 id="propertysource-1"><a class="header" href="#propertysource-1">@PropertySource</a></h3>
<pre><code class="language-java">@Configuration
@PropertySource(&quot;classpath:/com/myco/app.properties&quot;)
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty(&quot;testbean.name&quot;));
        return testBean;
    }
}
</code></pre>
<pre><code class="language-java">@Configuration
@PropertySource(&quot;classpath:/com/${my.placeholder:default/path}/app.properties&quot;)
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty(&quot;testbean.name&quot;));
        return testBean;
    }
}
</code></pre>
<p>my.placeholder是其他已经定义过的 属性,default/path是找不到数据源使用默认的属性</p>
<h3 id="占位符解析"><a class="header" href="#占位符解析">占位符解析</a></h3>
<p>环境变量贯穿整个容器,只要在定义之前这个变量已经被注册进去就可以</p>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;import resource=&quot;com/bank/service/${customer}-config.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="registering-a-loadtimeweaver"><a class="header" href="#registering-a-loadtimeweaver">Registering a LoadTimeWeaver</a></h2>
<p>当类被装载进虚拟机时,动态的转换类</p>
<pre><code class="language-java">@Configuration
@EnableLoadTimeWeaving
public class AppConfig {
}
</code></pre>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;context:load-time-weaver/&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="applicationcontext额外的功能"><a class="header" href="#applicationcontext额外的功能">ApplicationContext额外的功能</a></h2>
<ul>
<li><em>org.springframework.beans.factory</em> 提供基本的管理和维护bean的功能,org.springframework.context 添加了<a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a>接口不仅扩展了beanFactory接口,也提供了其他功能</li>
<li>大部分应用程序以声明的方式 使用ApplicationContext,例如依赖 ContextLoader的类 </li>
<li>额外的功能如下
<ul>
<li><em>i18n</em> 风格的 消息访问,  MessageSource</li>
<li>访问URL资源: ResourceLoader</li>
<li>时间发布: ApplicationListener,ApplicationEventPublisher</li>
<li>带有层次接口的多上下文,每个applicationContext只关注特定的层, 例如web层, 通过 HierarchicalBeanFactory接口</li>
</ul>
</li>
</ul>
<h3 id="使用-messagesource-国际化"><a class="header" href="#使用-messagesource-国际化">使用 <code>MessageSource</code> 国际化</a></h3>
<pre><code class="language-java">String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale);
</code></pre>
<p>根据Loclae,  code对应的 带参数的message</p>
<ol>
<li>
<p>applicationContext首先会查找当前容器中有没有 messageSource的bean名</p>
</li>
<li>
<p>如果找到了则使用该 bean作为 消息源</p>
</li>
<li>
<p>如果没找到 则往父 bean找,如果还是找不到则 在 messageSource代理类 <em>DelegatingMessageSource</em> 设置空的source</p>
</li>
<li>
<p>spring提供了 两个 messageSource</p>
<ol>
<li>
<p><em>ResourceBundleMessageSource</em></p>
</li>
<li>
<p><em>StaticMessageSource</em></p>
</li>
<li>
<p>都继承于HierarchicalMessageSource(为了处理 嵌套的消息)</p>
</li>
<li>
<p>名称要覆盖messageSource</p>
</li>
<li>
<p>basename,即资源包的名称,会默认去类路径下查找:  classpath:basename.properties, basename-en.properties,等不同地域的文件</p>
</li>
</ol>
</li>
</ol>
<pre><code>    @Bean(&quot;messageSource&quot;)
    public  ResourceBundleMessageSource resourceBundleMessageSource(){
        ResourceBundleMessageSource resourceBundleMessageSource = new ResourceBundleMessageSource();
        resourceBundleMessageSource.setAlwaysUseMessageFormat(true);
        resourceBundleMessageSource.setBasenames(&quot;format&quot;,&quot;exceptions&quot;,&quot;windows&quot;,&quot;messages&quot;);
        return resourceBundleMessageSource;
    }
    
</code></pre>
<ul>
<li>还有可重载的 <em>ResourceBundleMessageSource</em> : ReloadableResourceBundleMessageSource
<ul>
<li>允许从spring 任意的 location 加载文件</li>
<li>支持热加载</li>
</ul>
</li>
</ul>
<h3 id="标准事件和自定义事件"><a class="header" href="#标准事件和自定义事件">标准事件和自定义事件</a></h3>
<h4 id="spring提供的内置事件"><a class="header" href="#spring提供的内置事件">spring提供的内置事件</a></h4>
<table><thead><tr><th style="text-align: left">Event</th><th style="text-align: left">Explanation</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ContextRefreshedEvent</code></td><td style="text-align: left">1. 当<code>ApplicationContext</code>被初始化或者被刷新时(例如调用`refresh) 2. 在容器关闭前,context可以被刷新任意次</td></tr>
<tr><td style="text-align: left"><code>ContextStartedEvent</code></td><td style="text-align: left">Published when the <code>ApplicationContext</code> is started by using the <code>start()</code> method on the <code>ConfigurableApplicationContext</code> interface</td></tr>
<tr><td style="text-align: left"><code>ContextStoppedEvent</code></td><td style="text-align: left">Published when the <code>ApplicationContext</code> is stopped by using the <code>stop()</code> method on the <code>ConfigurableApplicationContext</code> interface. Here, “stopped” means that all <code>Lifecycle</code> beans receive an explicit stop signal. A stopped context may be restarted through a <code>start()</code> call.</td></tr>
<tr><td style="text-align: left"><code>ContextClosedEvent</code></td><td style="text-align: left">Published when the <code>ApplicationContext</code> is being closed by using the <code>close()</code> method on the <code>ConfigurableApplicationContext</code> interface or via a JVM shutdown hook. Here, &quot;closed&quot; means that all singleton beans will be destroyed. Once the context is closed, it reaches its end of life and cannot be refreshed or restarted.</td></tr>
<tr><td style="text-align: left"><code>RequestHandledEvent</code></td><td style="text-align: left">A web-specific event telling all beans that an HTTP request has been serviced. This event is published after the request is complete. This event is only applicable to web applications that use Spring’s <code>DispatcherServlet</code>.</td></tr>
<tr><td style="text-align: left"><code>ServletRequestHandledEvent</code></td><td style="text-align: left">A subclass of <code>RequestHandledEvent</code> that adds Servlet-specific context information</td></tr>
</tbody></table>
<h4 id="自定义事件"><a class="header" href="#自定义事件">自定义事件</a></h4>
<p>通过ApplicationEvent自定义事件发布,ApplicationListener 自定义事件接收, ApplicationEventPublisher在容器bean中发布事件</p>
<pre><code class="language-java">//定义事件
public class BlackListEvent extends ApplicationEvent {

    private final String address;
    private final String content;

    public BlackListEvent(Object source, String address, String content) {
        super(source);
        this.address = address;
        this.content = content;
    }

    // accessor and other methods...
}
//定义 发布事件的服务
public class EmailService implements ApplicationEventPublisherAware {

    private List&lt;String&gt; blackList;
    private ApplicationEventPublisher publisher;

    public void setBlackList(List&lt;String&gt; blackList) {
        this.blackList = blackList;
    }

    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void sendEmail(String address, String content) {
        if (blackList.contains(address)) {
            publisher.publishEvent(new BlackListEvent(this, address, content));
            return;
        }
        // send email...
    }
}
//定义监听该事件的类
public class BlackListNotifier implements ApplicationListener&lt;BlackListEvent&gt; {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(BlackListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}
</code></pre>
<h4 id="注意事项-1"><a class="header" href="#注意事项-1">注意事项</a></h4>
<ul>
<li>
<p>该事件发布是同步的,会等待所有监听者 处理完事件才会返回,比较利于事务</p>
</li>
<li>
<p>另外一个事件发布的策略:异步多播 <a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html"><code>ApplicationEventMulticaster</code></a> interface and <a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/context/event/SimpleApplicationEventMulticaster.html"><code>SimpleApplicationEventMulticaster</code></a></p>
</li>
</ul>
<h4 id="基于注解的事件监听"><a class="header" href="#基于注解的事件监听">基于注解的事件监听</a></h4>
<pre><code class="language-java">public class BlackListNotifier {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    @EventListener
    public void processBlackListEvent(BlackListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}

//多事件 监听
@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})
public void handleContextStart() {
    // ...
}

//运行时对事件 过滤
@EventListener(condition = &quot;#blEvent.content == 'my-event'&quot;)
public void processBlackListEvent(BlackListEvent blEvent) {
    // notify appropriate parties via notificationAddress...
}

//处理完事件后 发布另一事件,可以通过集合发布多个事件
@EventListener
public ListUpdateEvent handleBlackListEvent(BlackListEvent event) {
    // notify appropriate parties via notificationAddress and
    // then publish a ListUpdateEvent...
}

//异步事件处理
@EventListener
@Async
public void processBlackListEvent(BlackListEvent event) {
    // BlackListEvent is processed in a separate thread
}
异步事件的限制
如果异步调用发生异常,不会传给调用者,详见AsyncUncaughtExceptionHandler 
无法通过返回值 发布事件,只能手动 注入ApplicationEventPublisher,发布
    
//可排序的监听器执行    
@EventListener
@Order(42)
public void processBlackListEvent(BlackListEvent event) {
    // notify appropriate parties via notificationAddress...
}    

//基于泛型的 监听器选择
@EventListener
public void onPersonCreated(EntityCreatedEvent&lt;Person&gt; event) {
    // ...
}
只会选择 Person类型的监听器
前提是 此类已将泛型具体化

//可以使用 ResolveableTypeProvider 来让spring自动识别解析类型
public class EntityCreatedEvent&lt;T&gt; extends ApplicationEvent implements ResolvableTypeProvider {

    public EntityCreatedEvent(T entity) {
        super(entity);
    }

    @Override
    public ResolvableType getResolvableType() {
        return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));
    }
}
</code></pre>
<p>el表达式有专门语义环境的变量</p>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Location</th><th style="text-align: left">Description</th><th style="text-align: left">Example</th></tr></thead><tbody>
<tr><td style="text-align: left">Event</td><td style="text-align: left">root object</td><td style="text-align: left">The actual <code>ApplicationEvent</code>.</td><td style="text-align: left"><code>#root.event</code> or <code>event</code></td></tr>
<tr><td style="text-align: left">Arguments array</td><td style="text-align: left">root object</td><td style="text-align: left">The arguments (as an object array) used to invoke the method.</td><td style="text-align: left"><code>#root.args</code> or <code>args</code>; <code>args[0]</code> to access the first argument, etc.</td></tr>
<tr><td style="text-align: left"><em>Argument name</em></td><td style="text-align: left">evaluation context</td><td style="text-align: left">The name of any of the method arguments. If, for some reason, the names are not available (for example, because there is no debug information in the compiled byte code), individual arguments are also available using the <code>#a&lt;#arg&gt;</code> syntax where <code>&lt;#arg&gt;</code> stands for the argument index (starting from 0).</td><td style="text-align: left"><code>#blEvent</code> or <code>#a0</code> (you can also use <code>#p0</code> or <code>#p&lt;#arg&gt;</code> parameter notation as an alias)</td></tr>
</tbody></table>
<h3 id="资源访问"><a class="header" href="#资源访问">资源访问</a></h3>
<ul>
<li>application context 是一个ResourceLoader,可以导入resource对象</li>
<li>resource对象本质上是一个 更加版本丰富的 java.net.URL</li>
<li>Resource对象可以以间接的方式,透明的从大多数路径 下获取资源</li>
<li>包括 类路径,文件系统路径,任何以URL标准形式的路径</li>
<li>如果一个资源 没有指定任何  资源前缀, 则默认是 application context type</li>
<li>提供给 ApplicationContext构造函数的 路径, 以string格式,根据实现的不同会当作不同路径的资源,例如(ClassPathXmlApplicationContext) 类路径下的</li>
<li>通过ResourceLoaderAware 注入 ResourceLoader,直接访问资源文件</li>
</ul>
<h3 id="访问applicationcontext"><a class="header" href="#访问applicationcontext">访问ApplicationContext</a></h3>
<ul>
<li>
<p>通过申明式创建 ApplicationContext</p>
<pre><code class="language-java">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
1. 监听器检测contextConfigLocation  参数下的文件
2. 如果参数不存在,取默认/WEB-INF/applicationContext.xml
3. 文件之间使用 : ; 空格等分隔
4. 支持ANtPath风格
</code></pre>
</li>
</ul>
<h3 id="springcontextrar部署"><a class="header" href="#springcontextrar部署">springContextRAR部署</a></h3>
<p>Deploying a Spring <code>ApplicationContext</code> as a Java EE RAR File</p>
<p>基于RAR的springContext部署</p>
<p>不需要web端</p>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>SpringContextResourceAdapter</code></a></p>
<h2 id="beanfactory"><a class="header" href="#beanfactory"><code>BeanFactory</code></a></h2>
<p><em>BeanFactory</em> 极其相关接口(BeanFactoryAware<code>, </code>InitializingBean<code>, </code>DisposableBean)  是集成第三方组件 的接入点,可以不需要注解或者反射,就能有效的使第三方组件与容器沟通</p>
<h3 id="beanfactory-or-applicationcontext"><a class="header" href="#beanfactory-or-applicationcontext"><code>BeanFactory</code> or <code>ApplicationContext</code></a></h3>
<p>这两者的容器级别 与 对启动的影响</p>
<p><em>ApplicationContext</em> 子类:GenericApplicationContext,AnnotationConfigApplicationContext 主要完成的工作</p>
<ul>
<li>配置文件加载</li>
<li>类路径扫描</li>
<li>注册bean定义</li>
<li>(as of 5.0) registering functional bean definitions.</li>
</ul>
<p><em>ApplicationContext</em>  包含了所有 beanfactory的功能,除非想完全把控bean的处理过程</p>
<ul>
<li><em>简单实现</em> DefaultListableBeanFactory 不会检测到  <a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp"><code>BeanPostProcessor</code></a> </li>
</ul>
<p>beanfactory与applicationContext对比</p>
<table><thead><tr><th style="text-align: left">Feature</th><th style="text-align: left"><code>BeanFactory</code></th><th style="text-align: left"><code>ApplicationContext</code></th></tr></thead><tbody>
<tr><td style="text-align: left">Bean instantiation/wiring</td><td style="text-align: left">Yes</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: left">Integrated lifecycle management</td><td style="text-align: left">No</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: left">Automatic <code>BeanPostProcessor</code> registration</td><td style="text-align: left">No</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: left">Automatic <code>BeanFactoryPostProcessor</code> registration</td><td style="text-align: left">No</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: left">Convenient <code>MessageSource</code> access (for internalization)</td><td style="text-align: left">No</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: left">Built-in <code>ApplicationEvent</code> publication mechanism</td><td style="text-align: left">No</td><td style="text-align: left">Yes</td></tr>
</tbody></table>
<p>{% raw %}</p>
<h1 id="resource-1"><a class="header" href="#resource-1">Resource</a></h1>
<ul>
<li>本章节介绍了spring如何处理资源,如何在spring中使用资源</li>
<li>对Java URL类的封装,提供了更强大的功能 ,推荐在自己代码中使用</li>
</ul>
<h2 id="内置的resource实现"><a class="header" href="#内置的resource实现">内置的Resource实现</a></h2>
<p>UrlResource</p>
<ul>
<li>UrlResource 包装了java.net.URL ,可以用来访问 Http,Ftp,file文件系统的访问</li>
<li>会解析 已知的关键字 classpath</li>
</ul>
<p>ClassPathResource</p>
<ul>
<li>加载类路径的资源文件</li>
<li>要么使用当前线程的类加载器或者给定类加载器,或者 指定类</li>
</ul>
<p>FileSystemResource</p>
<p>ServletContextResource</p>
<ul>
<li>ServletContext*的实现,从web跟目录的相对路径加载文件</li>
</ul>
<h2 id="resourceloader"><a class="header" href="#resourceloader">ResourceLoader</a></h2>
<ul>
<li>
<p>用于加载resource的类</p>
</li>
<li>
<p>所有application context 实现了该接口,对于不同的容器返回不同类型的 Resource</p>
<pre><code class="language-java">Resource template = ctx.getResource(&quot;some/resource/path/myTemplate.txt&quot;);
</code></pre>
<ul>
<li>
<p><em>ClassPathXmlApplicationContext</em> 返回 ClassPathResource</p>
</li>
<li>
<p><em>FileSystemXmlApplicationContext</em> 返回FileSystemResource</p>
</li>
<li>
<p>WebApplicationContext 返回ServletContextResource</p>
</li>
<li>
<p>可以强制返回指定类型的资源</p>
<pre><code class="language-java">//返回类路径下的资源
Resource template = ctx.getResource(&quot;classpath:some/resource/path/myTemplate.txt&quot;);
//返回文件系统下的资源
Resource template = ctx.getResource(&quot;file:///some/resource/path/myTemplate.txt&quot;);
//返回http资源
Resource template = ctx.getResource(&quot;https://myhost.com/resource/path/myTemplate.txt&quot;);
</code></pre>
</li>
</ul>
<p>显示指定前缀</p>
</li>
</ul>
<table><thead><tr><th style="text-align: left">Prefix</th><th style="text-align: left">Example</th><th style="text-align: left">Explanation</th></tr></thead><tbody>
<tr><td style="text-align: left">classpath:</td><td style="text-align: left"><code>classpath:com/myapp/config.xml</code></td><td style="text-align: left">Loaded from the classpath.</td></tr>
<tr><td style="text-align: left">file:</td><td style="text-align: left"><code>file:///data/config.xml</code></td><td style="text-align: left">Loaded as a <code>URL</code> from the filesystem. See also <a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#resources-filesystemresource-caveats"><code>FileSystemResource</code> Caveats</a>.</td></tr>
<tr><td style="text-align: left">http:</td><td style="text-align: left"><code>https://myserver/logo.png</code></td><td style="text-align: left">Loaded as a <code>URL</code>.</td></tr>
<tr><td style="text-align: left">(none)</td><td style="text-align: left"><code>/data/config.xml</code></td><td style="text-align: left">Depends on the underlying <code>ApplicationContext</code>.</td></tr>
</tbody></table>
<h2 id="resourceloaderaware"><a class="header" href="#resourceloaderaware">ResourceLoaderAware</a></h2>
<ul>
<li>申明注入resourceloader的接口</li>
<li>因为所有 ApplicationContext 都实现了resourceloader 所以可以使用他 来加载资源</li>
</ul>
<h2 id="依赖注入资源属性"><a class="header" href="#依赖注入资源属性">依赖注入资源属性</a></h2>
<ul>
<li>
<p>使用PropertyEditor 注入自定义的属性文件,</p>
<pre><code class="language-xml">//注入的路径取决于 你的 applicationContext的类型,可以指定前缀来使用指定资源
&lt;bean id=&quot;myBean&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;template&quot; value=&quot;some/resource/path/myTemplate.txt&quot;/&gt;
&lt;/bean&gt;

</code></pre>
</li>
</ul>
<h2 id="使用resource创建-applicationcontext"><a class="header" href="#使用resource创建-applicationcontext">使用resource创建 applicationContext</a></h2>
<pre><code class="language-java">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;conf/appContext.xml&quot;);

ApplicationContext ctx =
    new FileSystemXmlApplicationContext(&quot;conf/appContext.xml&quot;);
</code></pre>
<pre><code class="language-java">com/
  foo/
    services.xml
    daos.xml
    MessengerService.class
    
使用上述路径的资源加载文件
ApplicationContext ctx = new ClassPathXmlApplicationContext(
    new String[] {&quot;services.xml&quot;, &quot;daos.xml&quot;}, MessengerService.class);
</code></pre>
<p>资源加载中的通配符</p>
<h2 id="文件系统资源使用-警告"><a class="header" href="#文件系统资源使用-警告">文件系统资源使用 警告</a></h2>
<p>为了向后兼容的原因 spring使用 FileSystemApplicationContext 时,会通通当成相对路径,</p>
<pre><code class="language-java">这两个示例 时相等价的
ApplicationContext ctx =
    new FileSystemXmlApplicationContext(&quot;conf/context.xml&quot;);
    
ApplicationContext ctx =
    new FileSystemXmlApplicationContext(&quot;/conf/context.xml&quot;);
</code></pre>
<h1 id="验证数据绑定类型转换"><a class="header" href="#验证数据绑定类型转换">验证,数据绑定,类型转换</a></h1>
<p>Validation, Data Binding, and Type Conversion</p>
<ul>
<li><em>Validator</em> 与 <em>DataBinder</em> 组成 validation 包</li>
<li><em>BeanWrapper</em> 是spring非常基础的概念,在很多地方使用到</li>
<li><em>DataBinder</em> 和BeanWrapper 都使用 PropertyEditorSupport 的实现去 解析和格式化属性值</li>
</ul>
<h2 id="spring-validtor使用示例"><a class="header" href="#spring-validtor使用示例">spring validtor使用示例</a></h2>
<pre><code class="language-java">public class PersonValidator implements Validator {

    /**
     * This Validator validates only Person instances
     */
    public boolean supports(Class clazz) {
        return Person.class.equals(clazz);
    }

    public void validate(Object obj, Errors e) {
        ValidationUtils.rejectIfEmpty(e, &quot;name&quot;, &quot;name.empty&quot;);
        Person p = (Person) obj;
        if (p.getAge() &lt; 0) {
            e.rejectValue(&quot;age&quot;, &quot;negativevalue&quot;);
        } else if (p.getAge() &gt; 110) {
            e.rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;);
        }
    }
}
</code></pre>
<h2 id="resolving-codes-to-error-messages"><a class="header" href="#resolving-codes-to-error-messages">Resolving Codes to Error Messages</a></h2>
<ul>
<li>使用前面的验证器产生的错误消息,可以通过 <em>MessageCodesResolver</em> 解析code</li>
<li>例如默认的实现 DefaultMessageCodesResolver ,调用 rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;) 方法会在resource中注册 <em>too.darn.old</em>  <em>too.darn.old.age</em>,<em>too.darn.old.age.int</em></li>
</ul>
<h2 id="bean-manipulation-and-the-beanwrapper"><a class="header" href="#bean-manipulation-and-the-beanwrapper"><em>Bean Manipulation and the <code>BeanWrapper</code></em></a></h2>
<ul>
<li>BeanWrapper* 和它的实现 BeanWrapperImpl 可以批量设置或者读取 JavaBean属性</li>
<li>支持嵌套属性</li>
<li>能够添加 PropertyChangeListeners,VetoableChangeListeners</li>
<li>支持字段索引</li>
<li>Bean Wrapper通常是 DataBinder和 BeanFactory 使用,不是给应用程序直接使用</li>
</ul>
<h3 id="访问语法"><a class="header" href="#访问语法">访问语法</a></h3>
<table><thead><tr><th style="text-align: left">Expression</th><th style="text-align: left">Explanation</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>name</code></td><td style="text-align: left">javabean的属性名</td></tr>
<tr><td style="text-align: left"><code>account.name</code></td><td style="text-align: left">嵌套的属性名<code>getAccount().setName()</code> or <code>getAccount().getName()</code> methods.</td></tr>
<tr><td style="text-align: left"><code>account[2]</code></td><td style="text-align: left">集合索引Indicates the <em>third</em> element of the indexed property <code>account</code>. Indexed properties can be of type <code>array</code>, <code>list</code>, or other naturally ordered collection.</td></tr>
<tr><td style="text-align: left"><code>account[COMPANYNAME]</code></td><td style="text-align: left">map索引</td></tr>
</tbody></table>
<h3 id="如何使用-beanwrapper"><a class="header" href="#如何使用-beanwrapper">如何使用 beanWrapper</a></h3>
<pre><code class="language-java">public class Company {

    private String name;
    private Employee managingDirector;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Employee getManagingDirector() {
        return this.managingDirector;
    }

    public void setManagingDirector(Employee managingDirector) {
        this.managingDirector = managingDirector;
    }
}


public class Employee {

    private String name;

    private float salary;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public float getSalary() {
        return salary;
    }

    public void setSalary(float salary) {
        this.salary = salary;
    }
}
//使用
BeanWrapper company = new BeanWrapperImpl(new Company());
// setting the company name..
company.setPropertyValue(&quot;name&quot;, &quot;Some Company Inc.&quot;);
// ... can also be done like this:
PropertyValue value = new PropertyValue(&quot;name&quot;, &quot;Some Company Inc.&quot;);
company.setPropertyValue(value);

// ok, let's create the director and tie it to the company:
BeanWrapper jim = new BeanWrapperImpl(new Employee());
jim.setPropertyValue(&quot;name&quot;, &quot;Jim Stravinsky&quot;);
company.setPropertyValue(&quot;managingDirector&quot;, jim.getWrappedInstance());

// retrieving the salary of the managingDirector through the company
Float salary = (Float) company.getPropertyValue(&quot;managingDirector.salary&quot;);
</code></pre>
<h3 id="propertyeditor-内置的beanwrapper的实现"><a class="header" href="#propertyeditor-内置的beanwrapper的实现"><em>PropertyEditor</em> 内置的beanwrapper的实现</a></h3>
<ul>
<li>spring使用 PropertyEditor 在 string名称的属性,与 对象 之间 转换</li>
<li>springBean wrapper有两个使用场景
<ul>
<li>通过使用 PropertyEditor 的实现 来实现 设置 bean,例如基于xml的依赖注入</li>
<li>spring MVC的Http参数解析中绑定,使用各种各样的 PropertyEditor</li>
<li>您可以在CommandController的所有子类中手动绑定这些实现。</li>
</ul>
</li>
<li>spring 有很多 PropertyEditor 在 org.springframework.beans.propertyeditors包中,大部分由 BeanWrapperImpl 默认注册</li>
</ul>
<table><thead><tr><th style="text-align: left">Class</th><th style="text-align: left">Explanation</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ByteArrayPropertyEditor</code></td><td style="text-align: left">Editor for byte arrays. Converts strings to their corresponding byte representations. Registered by default by <code>BeanWrapperImpl</code>.</td></tr>
<tr><td style="text-align: left"><code>ClassEditor</code></td><td style="text-align: left">Parses Strings that represent classes to actual classes and vice-versa. When a class is not found, an <code>IllegalArgumentException</code> is thrown. By default, registered by <code>BeanWrapperImpl</code>.</td></tr>
<tr><td style="text-align: left"><code>CustomBooleanEditor</code></td><td style="text-align: left">Customizable property editor for <code>Boolean</code> properties. By default, registered by <code>BeanWrapperImpl</code> but can be overridden by registering a custom instance of it as a custom editor.</td></tr>
<tr><td style="text-align: left"><code>CustomCollectionEditor</code></td><td style="text-align: left">Property editor for collections, converting any source <code>Collection</code> to a given target <code>Collection</code> type.</td></tr>
<tr><td style="text-align: left"><code>CustomDateEditor</code></td><td style="text-align: left">Customizable property editor for <code>java.util.Date</code>, supporting a custom <code>DateFormat</code>. NOT registered by default. Must be user-registered with the appropriate format as needed.</td></tr>
<tr><td style="text-align: left"><code>CustomNumberEditor</code></td><td style="text-align: left">Customizable property editor for any <code>Number</code> subclass, such as <code>Integer</code>, <code>Long</code>, <code>Float</code>, or <code>Double</code>. By default, registered by <code>BeanWrapperImpl</code> but can be overridden by registering a custom instance of it as a custom editor.</td></tr>
<tr><td style="text-align: left"><code>FileEditor</code></td><td style="text-align: left">Resolves strings to <code>java.io.File</code> objects. By default, registered by <code>BeanWrapperImpl</code>.</td></tr>
<tr><td style="text-align: left"><code>InputStreamEditor</code></td><td style="text-align: left">One-way property editor that can take a string and produce (through an intermediate <code>ResourceEditor</code> and <code>Resource</code>) an <code>InputStream</code> so that <code>InputStream</code> properties may be directly set as strings. Note that the default usage does not close the <code>InputStream</code> for you. By default, registered by <code>BeanWrapperImpl</code>.</td></tr>
<tr><td style="text-align: left"><code>LocaleEditor</code></td><td style="text-align: left">Can resolve strings to <code>Locale</code> objects and vice-versa (the string format is <code>*[country]*[variant]</code>, same as the <code>toString()</code> method of <code>Locale</code>). By default, registered by <code>BeanWrapperImpl</code>.</td></tr>
<tr><td style="text-align: left"><code>PatternEditor</code></td><td style="text-align: left">Can resolve strings to <code>java.util.regex.Pattern</code> objects and vice-versa.</td></tr>
<tr><td style="text-align: left"><code>PropertiesEditor</code></td><td style="text-align: left">Can convert strings (formatted with the format defined in the javadoc of the <code>java.util.Properties</code> class) to <code>Properties</code> objects. By default, registered by <code>BeanWrapperImpl</code>.</td></tr>
<tr><td style="text-align: left"><code>StringTrimmerEditor</code></td><td style="text-align: left">Property editor that trims strings. Optionally allows transforming an empty string into a <code>null</code> value. NOT registered by default — must be user-registered.</td></tr>
<tr><td style="text-align: left"><code>URLEditor</code></td><td style="text-align: left">Can resolve a string representation of a URL to an actual <code>URL</code> object. By default, registered by <code>BeanWrapperImpl</code>.</td></tr>
</tbody></table>
<ul>
<li>通过使用 java.beans.PropertyEditorManager 为  PropertyEditor 设置 搜索路径</li>
<li>搜索路径默认 包括 <em>sun.bean.editors</em> </li>
<li>JavaBean对象 自动发现 与他同名同包的 PropertyEditor 例如 <em>SomethingEditor</em> 与 <em>Something</em></li>
</ul>
<pre><code class="language-java">public class SomethingBeanInfo extends SimpleBeanInfo {

    public PropertyDescriptor[] getPropertyDescriptors() {
        try {
            final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);
            PropertyDescriptor ageDescriptor = new PropertyDescriptor(&quot;age&quot;, Something.class) {
                public PropertyEditor createPropertyEditor(Object bean) {
                    return numberPE;
                };
            };
            return new PropertyDescriptor[] { ageDescriptor };
        }
        catch (IntrospectionException ex) {
            throw new Error(ex.toString());
        }
    }
}
</code></pre>
<p>注册自定义的propertyEditor</p>
<ul>
<li>
<p>spring会自动注册 内置的propertyEditor</p>
</li>
<li>
<p>javabean 框架会自动 发现 与javabean同名同包的 propertyEditor</p>
</li>
<li>
<p>也可以注册自己的propertyeditor</p>
<ul>
<li>
<p>手动注册: ConfigurableBeanFactory.registerCustomEditor.</p>
</li>
<li>
<p>使用 post-processor , CustomEditorConfigurer 来注册</p>
</li>
<li>
<p>使用 e bean factory post-processors  with <code>BeanFactory</code> </p>
</li>
<li>
<p>使用 PropertyEditorRegistrar</p>
</li>
</ul>
<pre><code class="language-java">package com.foo.editors.spring;

public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {

    public void registerCustomEditors(PropertyEditorRegistry registry) {

        // it is expected that new PropertyEditor instances are created
        registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());

        // you could register as many custom property editors as are required here...
    }
}

</code></pre>
<pre><code class="language-xml">&lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt;
    &lt;property name=&quot;propertyEditorRegistrars&quot;&gt;
        &lt;list&gt;
            &lt;ref bean=&quot;customPropertyEditorRegistrar&quot;/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customPropertyEditorRegistrar&quot;
    class=&quot;com.foo.editors.spring.CustomPropertyEditorRegistrar&quot;/&gt;
</code></pre>
<pre><code>继承SimpleFormController 初始化自定义的属性注册
public final class RegisterUserController extends SimpleFormController {

    private final PropertyEditorRegistrar customPropertyEditorRegistrar;

    public RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
        this.customPropertyEditorRegistrar = propertyEditorRegistrar;
    }

    protected void initBinder(HttpServletRequest request,
            ServletRequestDataBinder binder) throws Exception {
        this.customPropertyEditorRegistrar.registerCustomEditors(binder);
    }

    // other methods to do with registering a User
}
</code></pre>
<h2 id="类型转换-1"><a class="header" href="#类型转换-1">类型转换</a></h2>
<pre><code class="language-java">package org.springframework.core.convert.converter;

public interface Converter&lt;S, T&gt; {

    T convert(S source);
}
</code></pre>
<pre><code class="language-java">// 类型转换器 位于 core.convert.support
package org.springframework.core.convert.support;

final class StringToInteger implements Converter&lt;String, Integer&gt; {

    public Integer convert(String source) {
        return Integer.valueOf(source);
    }
}
</code></pre>
<pre><code class="language-java">使用ConverterFactory
package org.springframework.core.convert.converter;

public interface ConverterFactory&lt;S, R&gt; {

    &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);
}

</code></pre>
<pre><code class="language-java">package org.springframework.core.convert.support;

final class StringToEnumConverterFactory implements ConverterFactory&lt;String, Enum&gt; {

    public &lt;T extends Enum&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) {
        return new StringToEnumConverter(targetType);
    }

    private final class StringToEnumConverter&lt;T extends Enum&gt; implements Converter&lt;String, T&gt; {

        private Class&lt;T&gt; enumType;

        public StringToEnumConverter(Class&lt;T&gt; enumType) {
            this.enumType = enumType;
        }

        public T convert(String source) {
            return (T) Enum.valueOf(this.enumType, source.trim());
        }
    }
}
</code></pre>
</li>
</ul>
<p>GenericConverter</p>
<pre><code class="language-java">package org.springframework.core.convert.converter;

public interface GenericConverter {

    public Set&lt;ConvertiblePair&gt; getConvertibleTypes();

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
</code></pre>
<p>ConditionalGenericConverter</p>
<pre><code class="language-java">public interface ConditionalConverter {

    boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);
}

public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {
}
</code></pre>
<p>ConversionService</p>
<pre><code class="language-java">package org.springframework.core.convert;

public interface ConversionService {

    boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);

    &lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType);

    boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

}
</code></pre>
<ul>
<li>配置conversionService</li>
<li>编程方式使用 conversionService</li>
</ul>
<p>Formatt</p>
<p>前面提到的 Type Convert类型转换 , spel,formatter,databinder就是基于 类型转换类 来工作的</p>
<ul>
<li>使用</li>
<li>注解</li>
<li>注册</li>
</ul>
<p><em>Configuring a Global Date and Time Format</em></p>
<p>spring全局默认使用 DateFormat.SHORT </p>
<pre><code class="language-java">org.springframework.format.datetime.standard.DateTimeFormatterRegistrar

org.springframework.format.datetime.DateFormatterRegistrar, or org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar
</code></pre>
<p>注册全局日期格式</p>
<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean
    public FormattingConversionService conversionService() {

        // Use the DefaultFormattingConversionService but do not register defaults
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false);

        // Ensure @NumberFormat is still supported
        conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());

        // Register JSR-310 date conversion with a specific global format
        DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
        registrar.setDateFormatter(DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;));
        registrar.registerFormatters(conversionService);

        // Register date conversion with a specific global format
        DateFormatterRegistrar registrar = new DateFormatterRegistrar();
        registrar.setFormatter(new DateFormatter(&quot;yyyyMMdd&quot;));
        registrar.registerFormatters(conversionService);

        return conversionService;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&gt;

    &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
        &lt;property name=&quot;registerDefaultFormatters&quot; value=&quot;false&quot; /&gt;
        &lt;property name=&quot;formatters&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;org.springframework.format.number.NumberFormatAnnotationFormatterFactory&quot; /&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;property name=&quot;formatterRegistrars&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar&quot;&gt;
                    &lt;property name=&quot;dateFormatter&quot;&gt;
                        &lt;bean class=&quot;org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean&quot;&gt;
                            &lt;property name=&quot;pattern&quot; value=&quot;yyyyMMdd&quot;/&gt;
                        &lt;/bean&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="bean验证"><a class="header" href="#bean验证">Bean验证</a></h2>
<pre><code class="language-java">public class PersonForm {

    @NotNull
    @Size(max=64)
    private String name;

    @Min(0)
    private int age;
}
</code></pre>
<p>注入bean</p>
<pre><code class="language-java">import javax.validation.Validator;

@Service
public class MyService {

    @Autowired
    private Validator validator;
}
</code></pre>
<p>自定义约束</p>
<p>每个自定义约束包含两个部分</p>
<ul>
<li>@Constraint 注解申明约束</li>
<li><em>javax.validation.ConstraintValidator</em>的实现</li>
</ul>
<p>声明注解</p>
<pre><code class="language-java">@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy=MyConstraintValidator.class)
public @interface MyConstraint {
}
</code></pre>
<p>实现validator</p>
<pre><code class="language-java">import javax.validation.ConstraintValidator;

public class MyConstraintValidator implements ConstraintValidator {

    @Autowired;
    private Foo aDependency;

    // ...
}
</code></pre>
<pre><code class="language-java">import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;

@Configuration

public class AppConfig {

    @Bean
    public MethodValidationPostProcessor validationPostProcessor() {
        return new MethodValidationPostProcessor;
    }
}
</code></pre>
<h1 id="spel表达式"><a class="header" href="#spel表达式">SPEL表达式</a></h1>
<p>Spring Expression Language (SpEL)</p>
<h2 id="spel支持的功能"><a class="header" href="#spel支持的功能">SPEL支持的功能</a></h2>
<ul>
<li>Literal expressions 字面量表达式:数学表达式</li>
<li>Boolean and relational operators  布尔运算符,关系运算符</li>
<li>Regular expressions : 正则表达式</li>
<li>Class expressions : 类表达式</li>
<li>Accessing properties, arrays, lists, and maps :访问数组,列表,map</li>
<li>Method invocation:静态方法调用,对象方法调用</li>
<li>Relational operators 关系运算符</li>
<li>Assignment 赋值</li>
<li>Calling constructors 调用构造器</li>
<li>Bean references bean引用</li>
<li>Array construction 数组构建</li>
<li>Inline lists 内联lists</li>
<li>Inline maps 内联 map</li>
<li>Ternary operator  三元运算符</li>
<li>Variables 变量</li>
<li>User-defined functions 用户定义功能</li>
<li>Collection projection 集合投影</li>
<li>Collection selection 集合选择</li>
<li>Templated expressions 模板表达式</li>
</ul>
<h2 id="evaluation"><a class="header" href="#evaluation">Evaluation</a></h2>
<ul>
<li>
<p>spel的包 位于 <em>org.springframework.expression</em> ,它的子包 <em>spel.support</em></p>
</li>
<li>
<p><em>ExpressionParser</em> 接口负责 解析 string类型的 表达式,可能会抛出两个异常,<em>ParseException</em> <em>EvaluationException</em></p>
</li>
<li>
<p>string类型的字面量用 单引号 包裹</p>
</li>
<li>
<p><em>parser.parseExpression<code>and</code>exp.getValue</em> 必须成对的调用</p>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;'Hello World'&quot;); 
String message = (String) exp.getValue();
</code></pre>
</li>
</ul>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<h4 id="调用stringconcat"><a class="header" href="#调用stringconcat">调用string.concat</a></h4>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;'Hello World'.concat('!')&quot;); 
String message = (String) exp.getValue();
</code></pre>
<h4 id="标准的点式调用"><a class="header" href="#标准的点式调用">标准的点式调用</a></h4>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();

// invokes 'getBytes().length'
Expression exp = parser.parseExpression(&quot;'Hello World'.bytes.length&quot;); 
int length = (Integer) exp.getValue();
</code></pre>
<h4 id="按照java语法"><a class="header" href="#按照java语法">按照Java语法</a></h4>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;new String('hello world').toUpperCase()&quot;); 
String message = exp.getValue(String.class);
</code></pre>
<p>从对象示例中取 变量的值</p>
<pre><code class="language-java">// Create and set a calendar
GregorianCalendar c = new GregorianCalendar();
c.set(1856, 7, 9);

// The constructor arguments are name, birthday, and nationality.
Inventor tesla = new Inventor(&quot;Nikola Tesla&quot;, c.getTime(), &quot;Serbian&quot;);

ExpressionParser parser = new SpelExpressionParser();

Expression exp = parser.parseExpression(&quot;name&quot;); // Parse name as an expression
String name = (String) exp.getValue(tesla);
// name == &quot;Nikola Tesla&quot;

exp = parser.parseExpression(&quot;name == 'Nikola Tesla'&quot;);
boolean result = exp.getValue(tesla, Boolean.class);
// result == true
</code></pre>
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<ul>
<li><em>springEL</em> 是一个强大的表达式语言, 支持在运行时查询,修改对象图</li>
<li>与其他 <em>Unified EL</em> 相比提供其他特性,最值得注意的是 方法调用 字符串模板</li>
</ul>
<h1 id="springel的特性"><a class="header" href="#springel的特性">springEL的特性</a></h1>
<ul>
<li>Literal expressions 字面量表达式</li>
<li>Boolean and relational operators 布尔操作</li>
<li>Regular expressions 正则</li>
<li>Class expressions 类表达式</li>
<li>Accessing properties, arrays, lists, and maps 访问 集合。数组，列表，map</li>
<li>Method invocation 方法调用</li>
<li>Relational operators 关联操作</li>
<li>Assignment 赋值</li>
<li>Calling constructors 调用构造</li>
<li>Bean references bean引用</li>
<li>Array construction 数组构造</li>
<li>Inline lists  内联list</li>
<li>Inline maps 内联map</li>
<li>Ternary operator 三目表达式</li>
<li>Variables 变量</li>
<li>User-defined functions 用户定义函数</li>
<li>Collection projection 集合投影</li>
<li>Collection selection 集合选择</li>
<li>Templated expressions 模板表达式</li>
</ul>
<h1 id="evaluation-1"><a class="header" href="#evaluation-1">Evaluation</a></h1>
<h2 id="简介-1"><a class="header" href="#简介-1">简介</a></h2>
<p><strong>解析字符串字面量</strong></p>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;'Hello World'&quot;); 
String message = (String) exp.getValue();
</code></pre>
<ul>
<li>最可能会使用的 SpEL 类与接口 位于 <code>org.springframework.expression</code>  包下</li>
<li><code>ExpressionParser</code> 接口 负责 表达式解析，在上面的例子中，表达式是 一个被单引号引起来的字符串字面量</li>
<li><code>Expression</code>  接口 负责 对定义的表达式 求值，调用 <code>parser.parseExpression</code>  会抛出<code>ParseException</code> ，调用<code>exp.getValue</code>  会抛出<code>EvaluationException</code>,</li>
<li>SpEL支持 很多特性，例如 方法调用，访问属性，调用构造函数</li>
</ul>
<p><strong>字符串的 <em>concat</em></strong></p>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;'Hello World'.concat('!')&quot;); 
String message = (String) exp.getValue();
</code></pre>
<p><strong>字符串 的 <em>getBytes</em></strong></p>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();

// invokes 'getBytes()'
Expression exp = parser.parseExpression(&quot;'Hello World'.bytes&quot;); 
byte[] bytes = (byte[]) exp.getValue();
</code></pre>
<p><strong>bytes.length</strong></p>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();

// invokes 'getBytes().length'
Expression exp = parser.parseExpression(&quot;'Hello World'.bytes.length&quot;); 
int length = (Integer) exp.getValue();
</code></pre>
<p><strong>使用 Class类指定返回值</strong></p>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;new String('hello world').toUpperCase()&quot;); 
String message = exp.getValue(String.class);
</code></pre>
<ul>
<li>
<p>使用泛型方法 求值，<code>public &lt;T&gt; T getValue(Class&lt;T&gt; desiredResultType)</code>，可以自动类型转换</p>
</li>
<li>
<p>使用注册的 Converter ，类型转换仍然失败 会抛出 <code>EvaluationException</code></p>
</li>
<li>
<p>SpEL的更常见用法是提供一个针对特定对象实例（称为根对象）进行求值的表达式字符串。</p>
<p>下面例子展示了如何从示例中 取属性</p>
<pre><code class="language-java">SpelExpressionParser parser = new SpelExpressionParser();
Person person = new Person();
person.age = 10;
person.name = &quot;肖佳权&quot;;
Expression age = parser.parseExpression(&quot;age&quot;);
int value = age.getValue(person, int.class);
System.out.println(value);
</code></pre>
</li>
</ul>
<h2 id="understanding-evaluationcontext"><a class="header" href="#understanding-evaluationcontext">Understanding EvaluationContext</a></h2>
<p><strong>简介</strong></p>
<p>在 对表达式 求值以解析 属性，方法，或字段并帮助执行类型转换时，将使用 <code>EvaluationContext</code>  接口 </p>
<p><strong>有两个实现</strong></p>
<ul>
<li>
<p><code>SimpleEvaluationContext</code>: </p>
<p>针对不需要 完整SpEL语言 语法且 应受到有意义限制的表达式类别，公开了SPEL 基本语言功能和配置选项的子集。示例包括但不限于数据绑定，基于属性的过滤器</p>
</li>
<li>
<p><code>StandardEvaluationContext</code>:</p>
<p>公开了完整的SpEL语言功能和配置选项，您可以使用它来指定默认的跟对象，并配置每个可用的 求值策略</p>
</li>
</ul>
<p><strong>SimpleEvaluationContext</strong></p>
<ul>
<li>
<p>设计为 只提供 SpEL语言语法的子集，它不包括Java类型引用，构造函数和Bean引用</p>
</li>
<li>
<p>它还要求您 显示的 选择 对表达式中的属性和 方法的 支持级别，默认 <em>create</em> 静态工厂方法 仅允许对属性的读取访问</p>
</li>
<li>
<p>你可以获取构建器来配置 准确的支持级别 针对以下一种或某些组合</p>
<ul>
<li>Custom <code>PropertyAccessor</code> only (no reflection) </li>
<li>Data binding properties for read-only access</li>
<li>Data binding properties for read and write</li>
</ul>
</li>
</ul>
<p><strong>Type Conversion</strong></p>
<ul>
<li>默认情况下，SpEL 使用  <code>org.springframework.core.convert.ConversionService</code> 的转换服务</li>
<li>这个服务内置了很多通用类型转换器，同样可扩展，具备泛型</li>
</ul>
<p>使用 <em>setValue</em> 赋值时，会自动将 字符串类型的 <em>string</em> 转成 Boolean</p>
<pre><code class="language-java">    static class Simple {
        public List&lt;Boolean&gt; booleanList = new ArrayList&lt;Boolean&gt;();
    }

    public static void main(String[] args) {
        Simple simple = new Simple();
        simple.booleanList.add(true);

        EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

// &quot;false&quot; is passed in here as a String. SpEL and the conversion service
// will recognize that it needs to be a Boolean and convert it accordingly.
        SpelExpressionParser parser = new SpelExpressionParser();
        parser.parseExpression(&quot;booleanList[0]&quot;).setValue(context, simple, &quot;false&quot;);

// b is false
        Boolean b = simple.booleanList.get(0);
        System.out.println(b);
    }
</code></pre>
<h2 id="parser-configuration"><a class="header" href="#parser-configuration">Parser Configuration</a></h2>
<blockquote>
<p>语法解析配置</p>
</blockquote>
<ul>
<li>可以通过 使用 解析器配置对象 配置 SpEL的 表达式解析 <code>org.springframework.expression.spel.SpelParserConfiguration</code></li>
<li>配置对象控制某些表达式组件的行为
<ul>
<li>例如，使用索引 访问数组或集合 遇到 <em>NULL</em> 值，SpEL可以自动创建元素，这对于链式属性引用很有用</li>
<li>还可以当 集合访问超出容量之后，<em>SpEL</em> 能够自动扩容</li>
<li>往指定索引处放值，使用默认的构造器设置值，如果没有默认的构造器，则填充<em>NULL</em></li>
<li>如果没有 内置的或 自定义的转换器 则会填充 <em>NULL</em> </li>
</ul>
</li>
</ul>
<pre><code class="language-java">class Demo {
    public List&lt;String&gt; list;
}

// Turn on:
// - auto null reference initialization
// - auto collection growing
SpelParserConfiguration config = new SpelParserConfiguration(true,true);

ExpressionParser parser = new SpelExpressionParser(config);

Expression expression = parser.parseExpression(&quot;list[3]&quot;);

Demo demo = new Demo();

Object o = expression.getValue(demo);

// demo.list will now be a real collection of 4 entries
// Each entry is a new empty String
</code></pre>
<h2 id="spel-compilation"><a class="header" href="#spel-compilation">SpEL Compilation</a></h2>
<blockquote>
<p>SpEL表达式编译</p>
</blockquote>
<p><strong>编译执行与解析执行</strong></p>
<p>Spring Framework 4.1 包含一个基本的 表达式编译器。表达式通常是被解析执行，这在求值阶段提供了很大的灵活性，但不会提供最佳性能。偶尔使用表达式 这已经够了，但是与其他组件 （例如 Spring Integration) 性能很重要，并且不需要动态性</p>
<p><strong>编译执行的使用场景</strong></p>
<p>​	SpEL编译器 旨在满足 这一需求：在求值过程中 生成一个Java类，该类在运行时体现了表达式的行为，并使用该类来实现更快的表达式解析</p>
<p>由于缺少在表达式周围 输入的信息，编译器 在执行编译时会使用 在表达式的解释求值过程收集的 信息</p>
<p>例如，它不只是 从表达式中就知道属性引用的类型，而是在第一次解释求值时知道的类型</p>
<p>当然，如果表达式元素的类型 随着时间变化，则基于此类派生信息进行编译会在以后引起麻烦</p>
<p><strong>因此 编译最适合类型信息 在重复求值过程 不会改变的表达式</strong></p>
<pre><code class="language-java">someArray[0].someProperty.someOtherProperty &lt; 0.1
</code></pre>
<p>由于前面的这个例子 涉及数组访问，一些属性的解引用 和数字运算，因此性能提升很明显，在 基准测试中，50000个迭代 ，</p>
<p>解释求值版本：75ms，编译求值版本：3ms</p>
<p><strong>Compiler Configuration</strong></p>
<p>默认情况下不打开编译器，但是您可以通过两种不同的方式之一来打开它。</p>
<ul>
<li>您可以通过使用解析器配置过程来打开它</li>
<li>或者 当SpEL 嵌入到某个组件时，使用 spring属性控制打开它</li>
</ul>
<p><strong>编译模式</strong></p>
<p>定义在枚举 <code>org.springframework.expression.spel.SpelCompilerMode</code></p>
<ul>
<li><code>OFF</code> (default): The compiler is switched off.</li>
<li><code>IMMEDIATE</code>: 尽快编译.通常是在第一次解释求值之后. 如果编译的表达式失败(通常是因为类型变化) 会抛异常</li>
<li><code>MIXED</code>: 在混合模式下，表达式会随着时间静默在解释模式和编译模式之间切换. 经过一些解释后的运行, 他们切换到已编译的表单，如果已编译的表单出了问题（例如，如前面所述的类型更改）表达式自动再次切换回解释形式.</li>
</ul>
<p><code>IMMEDIATE</code> mode exists because <code>MIXED</code> mode could cause issues for expressions that have side effects. If a compiled expression blows up after partially succeeding</p>
<p><strong>存在IMMEDIATE模式的原因</strong></p>
<p>存在IMMEDIATE模式是因为MIXED模式可能会引起具有副作用的表达式问题。如果部分成功后已编译的表达式运行失败，切换到解释模式重新执行，那部分可能会执行两遍</p>
<pre><code class="language-java">SpelParserConfiguration config = new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,
    this.getClass().getClassLoader());

SpelExpressionParser parser = new SpelExpressionParser(config);

Expression expr = parser.parseExpression(&quot;payload&quot;);

MyMessage message = new MyMessage();

Object payload = expr.getValue(message);
</code></pre>
<p>当指定编译器模式时，还可以指定一个类加载器（允许传递null）。</p>
<p>编译表达式是在提供的任何子类加载器中创建的子类加载器中定义的类</p>
<p>重要的是要确保，如果指定了类加载器，则它可以查看表达式求值过程中涉及的所有类型。</p>
<p>如果未指定类加载器，则使用默认的类加载器（通常是在表达式求值期间运行的线程的上下文类加载器）。</p>
<p>第二种配置编译器的方法是将SpEL嵌入到其他组件中，并且可能无法通过配置对象进行配置。
在这种情况下，可以通过JVM系统属性 <code>spring.expression.compiler.mode</code> </p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/appendix.html#appendix-spring-properties"><code>SpringProperties</code></a> 机制 <em>SpelCompilerMode</em> (<code>off</code>, <code>immediate</code>, or <code>mixed</code>)</p>
<p><strong>Compiler Limitations</strong></p>
<p>从Spring Framework 4.1开始，已经有了基本的编译框架</p>
<p>但是，该框架尚不支持编译每种表达式</p>
<p>最初的重点是可能在性能关键型上下文中使用的通用表达式。</p>
<p>目前无法编译以下类型的表达式：</p>
<ul>
<li>Expressions involving assignment：涉及赋值的表达</li>
<li>Expressions relying on the conversion service：依赖转换服务的表达式</li>
<li>Expressions using custom resolvers or accessors：使用自定义解析器或访问器的表达式</li>
<li>Expressions using selection or projection：使用选择或投影的表达式</li>
</ul>
<h1 id="expressions-in-bean-definitions"><a class="header" href="#expressions-in-bean-definitions">Expressions in Bean Definitions</a></h1>
<p>您可以将SpEL表达式与基于XML或基于注释的配置元数据一起使用，用来定义“ BeanDefinition”实例。
在这两种情况下，用于定义表达式的语法均采用“＃{&lt;表达式字符串&gt;}”的形式。</p>
<h2 id="xml-configuration"><a class="header" href="#xml-configuration">XML Configuration</a></h2>
<pre><code class="language-java">&lt;bean id=&quot;numberGuess&quot; class=&quot;org.spring.samples.NumberGuess&quot;&gt;
    &lt;property name=&quot;randomNumber&quot; value=&quot;#{ T(java.lang.Math).random() * 100.0 }&quot;/&gt;
    &lt;!-- other properties --&gt;
&lt;/bean&gt;
</code></pre>
<p><em>ApplicationContext</em> 的所有 bean 都可以通过 bean名引用，包括内置的 bean，例如 访问运行时的环境变量<code>org.springframework.core.env.Environment</code>  以及 <em>systemProperties</em> 和 <em>systemEnvironment</em></p>
<p>通过属性名 访问属性</p>
<pre><code class="language-java">&lt;bean id=&quot;taxCalculator&quot; class=&quot;org.spring.samples.TaxCalculator&quot;&gt;
    &lt;property name=&quot;defaultLocale&quot; value=&quot;#{ systemProperties['user.region'] }&quot;/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">&lt;bean id=&quot;numberGuess&quot; class=&quot;org.spring.samples.NumberGuess&quot;&gt;
    &lt;property name=&quot;randomNumber&quot; value=&quot;#{ T(java.lang.Math).random() * 100.0 }&quot;/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;

&lt;bean id=&quot;shapeGuess&quot; class=&quot;org.spring.samples.ShapeGuess&quot;&gt;
    &lt;property name=&quot;initialShapeSeed&quot; value=&quot;#{ numberGuess.randomNumber }&quot;/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;
</code></pre>
<h2 id="annotation-configuration"><a class="header" href="#annotation-configuration">Annotation Configuration</a></h2>
<p><strong>属性</strong></p>
<pre><code class="language-java">public class FieldValueTestBean {

    @Value(&quot;#{ systemProperties['user.region'] }&quot;)
    private String defaultLocale;

    public void setDefaultLocale(String defaultLocale) {
        this.defaultLocale = defaultLocale;
    }

    public String getDefaultLocale() {
        return this.defaultLocale;
    }
}
</code></pre>
<p><strong>setterMethod</strong></p>
<pre><code class="language-java">public class PropertyValueTestBean {

    private String defaultLocale;

    @Value(&quot;#{ systemProperties['user.region'] }&quot;)
    public void setDefaultLocale(String defaultLocale) {
        this.defaultLocale = defaultLocale;
    }

    public String getDefaultLocale() {
        return this.defaultLocale;
    }
}
</code></pre>
<p>Autowired methods and constructors can also use the <code>@Value</code> annotation</p>
<pre><code class="language-java">public class SimpleMovieLister {

    private MovieFinder movieFinder;
    private String defaultLocale;

    @Autowired
    public void configure(MovieFinder movieFinder,
            @Value(&quot;#{ systemProperties['user.region'] }&quot;) String defaultLocale) {
        this.movieFinder = movieFinder;
        this.defaultLocale = defaultLocale;
    }

    // ...
}
</code></pre>
<pre><code class="language-java">public class MovieRecommender {

    private String defaultLocale;

    private CustomerPreferenceDao customerPreferenceDao;

    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao,
            @Value(&quot;#{systemProperties['user.country']}&quot;) String defaultLocale) {
        this.customerPreferenceDao = customerPreferenceDao;
        this.defaultLocale = defaultLocale;
    }

    // ...
}
</code></pre>
<h1 id="language-reference"><a class="header" href="#language-reference">Language Reference</a></h1>
<blockquote>
<p>语法参考</p>
</blockquote>
<h2 id="literal-expressions"><a class="header" href="#literal-expressions">Literal Expressions</a></h2>
<p>字面量包括：字符串单引号包裹，数值类型：整数，实数，十六进制，boolean，的</p>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();

// evals to &quot;Hello World&quot;
String helloWorld = (String) parser.parseExpression(&quot;'Hello World'&quot;).getValue();

double avogadrosNumber = (Double) parser.parseExpression(&quot;6.0221415E+23&quot;).getValue();

// evals to 2147483647
int maxValue = (Integer) parser.parseExpression(&quot;0x7FFFFFFF&quot;).getValue();

boolean trueValue = (Boolean) parser.parseExpression(&quot;true&quot;).getValue();

Object nullValue = parser.parseExpression(&quot;null&quot;).getValue();
</code></pre>
<p>数字支持使用负号，指数符号和小数点。
默认情况下，使用Double.parseDouble（）解析实数。</p>
<h2 id="properties-arrays-lists-maps-and-indexers"><a class="header" href="#properties-arrays-lists-maps-and-indexers">Properties, Arrays, Lists, Maps, and Indexers</a></h2>
<h3 id="使用属性名访问属性"><a class="header" href="#使用属性名访问属性">使用属性名访问属性</a></h3>
<pre><code class="language-java">// evals to 1856
int year = (Integer) parser.parseExpression(&quot;birthdate.year + 1900&quot;).getValue(context);

String city = (String) parser.parseExpression(&quot;placeOfBirth.city&quot;).getValue(context);
</code></pre>
<ul>
<li>属性名称的首字母允许不区分大小写</li>
<li>上述的表达式 可以写作 <code>Birthdate.Year + 1900</code> and <code>PlaceOfBirth.City</code></li>
<li>属性的访问 也可能通过方法调用 ``getPlaceOfBirth().getCity()<code>instead of</code>placeOfBirth.city`</li>
</ul>
<h3 id="使用方括号访问数组"><a class="header" href="#使用方括号访问数组">使用方括号访问数组</a></h3>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

// Inventions Array

// evaluates to &quot;Induction motor&quot;
String invention = parser.parseExpression(&quot;inventions[3]&quot;).getValue(
        context, tesla, String.class);

// Members List

// evaluates to &quot;Nikola Tesla&quot;
String name = parser.parseExpression(&quot;members[0].name&quot;).getValue(
        context, ieee, String.class);

// List and Array navigation
// evaluates to &quot;Wireless communication&quot;
String invention = parser.parseExpression(&quot;members[0].inventions[6]&quot;).getValue(
        context, ieee, String.class);
</code></pre>
<h3 id="访问map"><a class="header" href="#访问map">访问Map</a></h3>
<pre><code class="language-java">// Officer's Dictionary

Inventor pupin = parser.parseExpression(&quot;officers['president']&quot;).getValue(
        societyContext, Inventor.class);

// evaluates to &quot;Idvor&quot;
String city = parser.parseExpression(&quot;officers['president'].placeOfBirth.city&quot;).getValue(
        societyContext, String.class);

// setting values
parser.parseExpression(&quot;officers['advisors'][0].placeOfBirth.country&quot;).setValue(
        societyContext, &quot;Croatia&quot;);
</code></pre>
<h2 id="内联list"><a class="header" href="#内联list">内联List</a></h2>
<pre><code class="language-java">// evaluates to a Java list containing the four numbers
List numbers = (List) parser.parseExpression(&quot;{1,2,3,4}&quot;).getValue(context);

List listOfLists = (List) parser.parseExpression(&quot;{{'a','b'},{'x','y'}}&quot;).getValue(context);
</code></pre>
<p>{}本身表示一个空列表。
出于性能原因，如果列表本身完全由固定文字组成，则会创建一个常量列表来表示该表达式（而不是在每次求值时都构建一个新列表）。</p>
<h2 id="inline-maps"><a class="header" href="#inline-maps">Inline Maps</a></h2>
<p><code>{key:value}</code></p>
<pre><code class="language-java">// evaluates to a Java map containing the two entries
Map inventorInfo = (Map) parser.parseExpression(&quot;{name:'Nikola',dob:'10-July-1856'}&quot;).getValue(context);

Map mapOfMaps = (Map) parser.parseExpression(&quot;{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',year:1856}}&quot;).getValue(context);
</code></pre>
<p><code>{：}</code>表示一个空的map
出于性能原因，如果映射表本身由固定的文字或其他嵌套的常量结构（列表或映射表）组成，则会创建一个常量映射表来表示该表达式（而不是在每次求值时都构建一个新的映射表）。映射键的引号是可选的。</p>
<h2 id="array-construction"><a class="header" href="#array-construction">Array Construction</a></h2>
<p>您可以使用熟悉的Java语法来构建数组，可以选择提供一个初始化以在构造时填充该数组。
以下示例显示了如何执行此操作：</p>
<pre><code class="language-java">int[] numbers1 = (int[]) parser.parseExpression(&quot;new int[4]&quot;).getValue(context);

// Array with initializer
int[] numbers2 = (int[]) parser.parseExpression(&quot;new int[]{1,2,3}&quot;).getValue(context);

// Multi dimensional array
int[][] numbers3 = (int[][]) parser.parseExpression(&quot;new int[4][5]&quot;).getValue(context);
</code></pre>
<p>构造多维数组时，当前无法提供初始化</p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<pre><code class="language-java">// string literal, evaluates to &quot;bc&quot;
String bc = parser.parseExpression(&quot;'abc'.substring(1, 3)&quot;).getValue(String.class);

// evaluates to true
boolean isMember = parser.parseExpression(&quot;isMember('Mihajlo Pupin')&quot;).getValue(
        societyContext, Boolean.class);
</code></pre>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<blockquote>
<p>操作符
<strong>支持四种运算符</strong></p>
</blockquote>
<ul>
<li>Relational Operators 关系运算符</li>
<li>Logical Operators 逻辑运算符</li>
<li>Mathematical Operators 数学运算符</li>
<li>The Assignment Operator 赋值运算符</li>
</ul>
<h3 id="relational-operators"><a class="header" href="#relational-operators">Relational Operators</a></h3>
<p>支持 equal, not equal, less than, less than or equal, greater than, and greater than or equal  这几种 关系运算符</p>
<pre><code class="language-java">// evaluates to true
boolean trueValue = parser.parseExpression(&quot;2 == 2&quot;).getValue(Boolean.class);

// evaluates to false
boolean falseValue = parser.parseExpression(&quot;2 &lt; -5.0&quot;).getValue(Boolean.class);

// evaluates to true
boolean trueValue = parser.parseExpression(&quot;'black' &lt; 'block'&quot;).getValue(Boolean.class);
</code></pre>
<p><strong>对于NULL值的处理</strong></p>
<p><code>X &gt; null</code> is always <code>true</code> </p>
<p><code>X &lt; null</code> is always <code>false</code></p>
<p><strong>InstanceOf与Match</strong></p>
<pre><code class="language-java">// evaluates to false
boolean falseValue = parser.parseExpression(
        &quot;'xyz' instanceof T(Integer)&quot;).getValue(Boolean.class);

// evaluates to true
boolean trueValue = parser.parseExpression(
        &quot;'5.00' matches '^-?\\d+(\\.\\d{2})?$'&quot;).getValue(Boolean.class);

//evaluates to false
boolean falseValue = parser.parseExpression(
        &quot;'5.0067' matches '^-?\\d+(\\.\\d{2})?$'&quot;).getValue(Boolean.class);
</code></pre>
<p>请注意基本类型，因为它们会立即被包装为包装类型，因此，如预期的那样，1 instanceof T（int）的计算结果为false，而1 instanceofT（Integer）的计算结果为true。</p>
<p><strong>支持字母的运算符</strong></p>
<ul>
<li><code>lt</code> (<code>&lt;</code>)</li>
<li><code>gt</code> (<code>&gt;</code>)</li>
<li><code>le</code> (<code>&lt;=</code>)</li>
<li><code>ge</code> (<code>&gt;=</code>)</li>
<li><code>eq</code> (<code>==</code>)</li>
<li><code>ne</code> (<code>!=</code>)</li>
<li><code>div</code> (<code>/</code>)</li>
<li><code>mod</code> (<code>%</code>)</li>
<li><code>not</code> (<code>!</code>).</li>
</ul>
<h3 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h3>
<p>SpEL supports the following logical operators:</p>
<ul>
<li><code>and</code> (<code>&amp;&amp;</code>)</li>
<li><code>or</code> (<code>||</code>)</li>
<li><code>not</code> (<code>!</code>)</li>
</ul>
<pre><code class="language-java">// -- AND --

// evaluates to false
boolean falseValue = parser.parseExpression(&quot;true and false&quot;).getValue(Boolean.class);

// evaluates to true
String expression = &quot;isMember('Nikola Tesla') and isMember('Mihajlo Pupin')&quot;;
boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);

// -- OR --

// evaluates to true
boolean trueValue = parser.parseExpression(&quot;true or false&quot;).getValue(Boolean.class);

// evaluates to true
String expression = &quot;isMember('Nikola Tesla') or isMember('Albert Einstein')&quot;;
boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);

// -- NOT --

// evaluates to false
boolean falseValue = parser.parseExpression(&quot;!true&quot;).getValue(Boolean.class);

// -- AND and NOT --
String expression = &quot;isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')&quot;;
boolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);
</code></pre>
<h3 id="mathematical-operators"><a class="header" href="#mathematical-operators">Mathematical Operators</a></h3>
<pre><code class="language-java">// Addition
int two = parser.parseExpression(&quot;1 + 1&quot;).getValue(Integer.class);  // 2

String testString = parser.parseExpression(
        &quot;'test' + ' ' + 'string'&quot;).getValue(String.class);  // 'test string'

// Subtraction
int four = parser.parseExpression(&quot;1 - -3&quot;).getValue(Integer.class);  // 4

double d = parser.parseExpression(&quot;1000.00 - 1e4&quot;).getValue(Double.class);  // -9000

// Multiplication
int six = parser.parseExpression(&quot;-2 * -3&quot;).getValue(Integer.class);  // 6

double twentyFour = parser.parseExpression(&quot;2.0 * 3e0 * 4&quot;).getValue(Double.class);  // 24.0

// Division
int minusTwo = parser.parseExpression(&quot;6 / -3&quot;).getValue(Integer.class);  // -2

double one = parser.parseExpression(&quot;8.0 / 4e0 / 2&quot;).getValue(Double.class);  // 1.0

// Modulus
int three = parser.parseExpression(&quot;7 % 4&quot;).getValue(Integer.class);  // 3

int one = parser.parseExpression(&quot;8 / 5 % 2&quot;).getValue(Integer.class);  // 1

// Operator precedence
int minusTwentyOne = parser.parseExpression(&quot;1+2-3*8&quot;).getValue(Integer.class);  // -21
</code></pre>
<h3 id="the-assignment-operator"><a class="header" href="#the-assignment-operator">The Assignment Operator</a></h3>
<p>要设置属性，请使用赋值运算符（=）。 这通常在对 <code>setValue</code>的调用内完成，但也可以在对getValue的调用内完成。
下面的清单显示了使用赋值运算符的两种方法：</p>
<pre><code class="language-java">Inventor inventor = new Inventor();
EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();

parser.parseExpression(&quot;name&quot;).setValue(context, inventor, &quot;Aleksandar Seovic&quot;);

// alternatively
String aleks = parser.parseExpression(
        &quot;name = 'Aleksandar Seovic'&quot;).getValue(context, inventor, String.class);
</code></pre>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<ul>
<li>你可以使用 特殊的 T运算符 来执行 <code>java.lang.Class</code> 类示例</li>
<li>也可以通过此运算符 来调用 静态方法</li>
<li><code>StandardEvaluationContext</code>  使用  <code>TypeLocator</code>  查找类型， <code>StandardTypeLocator</code>  （可以替换） 会自动查找 Java.lang包，不需要全限定类名，而其他包需要</li>
</ul>
<pre><code class="language-java">Class dateClass = parser.parseExpression(&quot;T(java.util.Date)&quot;).getValue(Class.class);

Class stringClass = parser.parseExpression(&quot;T(String)&quot;).getValue(Class.class);

boolean trueValue = parser.parseExpression(
        &quot;T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR&quot;)
        .getValue(Boolean.class);
</code></pre>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>您可以使用<code>new</code>运算符来调用构造函数。
除了基本类型（<code>int</code>，<code>float</code>等）和String之外，您都应使用完全限定的类名。
以下示例显示了如何使用<code>new</code>运算符来调用构造函数：</p>
<pre><code class="language-java">Inventor einstein = p.parseExpression(
        &quot;new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')&quot;)
        .getValue(Inventor.class);

//create new inventor instance within add method of List
p.parseExpression(
        &quot;Members.add(new org.spring.samples.spel.inventor.Inventor(
            'Albert Einstein', 'German'))&quot;).getValue(societyContext);
</code></pre>
<h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<ul>
<li>您可以使用 <code>#variableName</code> 语法在表达式中引用变量。</li>
<li>通过在EvaluationContext实现上使用setVariable方法设置变量。</li>
</ul>
<h3 id="合法变量名"><a class="header" href="#合法变量名">合法变量名：</a></h3>
<p><code>A</code> to <code>Z</code> and <code>a</code> to <code>z</code>digits: <code>0</code> to <code>9</code>underscore: <code>_</code>dollar sign: <code>$</code></p>
<pre><code class="language-java">Inventor tesla = new Inventor(&quot;Nikola Tesla&quot;, &quot;Serbian&quot;);

EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();
context.setVariable(&quot;newName&quot;, &quot;Mike Tesla&quot;);

parser.parseExpression(&quot;name = #newName&quot;).getValue(context, tesla);
System.out.println(tesla.getName())  // &quot;Mike Tesla&quot;
</code></pre>
<h3 id="the-this-and-root-variables"><a class="header" href="#the-this-and-root-variables">The <code>#this</code> and <code>#root</code> Variables</a></h3>
<ul>
<li><code>#this</code> 变量始终 定义，引用当前解析对象（不会解析不满足的变量） </li>
<li><code>#root</code> 始终指向 root context object <code>#this</code> 随着 表达式组件部分 求值 的变化而变化</li>
</ul>
<pre><code class="language-java">// create an array of integers
List&lt;Integer&gt; primes = new ArrayList&lt;Integer&gt;();
primes.addAll(Arrays.asList(2,3,5,7,11,13,17));

// create parser and set variable 'primes' as the array of integers
ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataAccess();
context.setVariable(&quot;primes&quot;, primes);

// all prime numbers &gt; 10 from the list (using selection ?{...})
// evaluates to [11, 13, 17]
List&lt;Integer&gt; primesGreaterThanTen = (List&lt;Integer&gt;) parser.parseExpression(
        &quot;#primes.?[#this&gt;10]&quot;).getValue(context);
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>您可以通过注册可以在表达式字符串中调用的用户定义函数来扩展SpEL。
该函数通过EvaluationContext注册。
以下示例显示了如何注册用户定义的函数：</p>
<pre><code class="language-java">Method method = ...;

EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
context.setVariable(&quot;myFunction&quot;, method);
</code></pre>
<pre><code class="language-java">public abstract class StringUtils {

    public static String reverseString(String input) {
        StringBuilder backwards = new StringBuilder(input.length());
        for (int i = 0; i &lt; input.length(); i++) {
            backwards.append(input.charAt(input.length() - 1 - i));
        }
        return backwards.toString();
    }
}

ExpressionParser parser = new SpelExpressionParser();

EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
context.setVariable(&quot;reverseString&quot;,
        StringUtils.class.getDeclaredMethod(&quot;reverseString&quot;, String.class));

String helloWorldReversed = parser.parseExpression(
        &quot;#reverseString('hello')&quot;).getValue(context, String.class);
</code></pre>
<h2 id="bean-references"><a class="header" href="#bean-references">Bean References</a></h2>
<p>如果 EvaluationContext 已使用bean解析器配置，则可以使用@符号从表达式中查找bean。
以下示例显示了如何执行此操作：</p>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();
StandardEvaluationContext context = new StandardEvaluationContext();
context.setBeanResolver(new MyBeanResolver());

// This will end up calling resolve(context,&quot;something&quot;) on MyBeanResolver during evaluation
Object bean = parser.parseExpression(&quot;@something&quot;).getValue(context);
</code></pre>
<p>要访问工厂bean本身，您应该在bean名称前加上＆符号。
以下示例显示了如何执行此操作：</p>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();
StandardEvaluationContext context = new StandardEvaluationContext();
context.setBeanResolver(new MyBeanResolver());

// This will end up calling resolve(context,&quot;&amp;foo&quot;) on MyBeanResolver during evaluation
Object bean = parser.parseExpression(&quot;&amp;foo&quot;).getValue(context);
</code></pre>
<h2 id="ternary-operator-if-then-else"><a class="header" href="#ternary-operator-if-then-else">Ternary Operator (If-Then-Else)</a></h2>
<pre><code class="language-java">String falseString = parser.parseExpression(
        &quot;false ? 'trueExp' : 'falseExp'&quot;).getValue(String.class);
</code></pre>
<pre><code class="language-java">parser.parseExpression(&quot;name&quot;).setValue(societyContext, &quot;IEEE&quot;);
societyContext.setVariable(&quot;queryName&quot;, &quot;Nikola Tesla&quot;);

expression = &quot;isMember(#queryName)? #queryName + ' is a member of the ' &quot; +
        &quot;+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'&quot;;

String queryResultString = parser.parseExpression(expression)
        .getValue(societyContext, String.class);
// queryResultString = &quot;Nikola Tesla is a member of the IEEE Society&quot;
</code></pre>
<h2 id="the-elvis-operator"><a class="header" href="#the-elvis-operator">The Elvis Operator</a></h2>
<p>Elvis运算符是三元运算符语法的简化，并且在Groovy语言中使用。
使用三元运算符语法，通常必须将变量重复两次，如以下示例所示：</p>
<pre><code class="language-java">String name = &quot;Elvis Presley&quot;;
String displayName = (name != null ? name : &quot;Unknown&quot;);
</code></pre>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();

String name = parser.parseExpression(&quot;name?:'Unknown'&quot;).getValue(new Inventor(), String.class);
System.out.println(name);  // 'Unknown'
</code></pre>
<pre><code class="language-java">@Value(&quot;#{systemProperties['pop3.port'] ?: 25}&quot;)
</code></pre>
<h2 id="safe-navigation-operator"><a class="header" href="#safe-navigation-operator">Safe Navigation Operator</a></h2>
<p>安全导航运算符用于避免NullPointerException，它来自Groovy语言。
通常，当您引用对象时，可能需要在访问对象的方法或属性之前验证其是否为null。
为了避免这种情况，安全导航运算符返回null而不是引发异常。
以下示例显示如何使用安全导航操作符：</p>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

Inventor tesla = new Inventor(&quot;Nikola Tesla&quot;, &quot;Serbian&quot;);
tesla.setPlaceOfBirth(new PlaceOfBirth(&quot;Smiljan&quot;));

String city = parser.parseExpression(&quot;placeOfBirth?.city&quot;).getValue(context, tesla, String.class);
System.out.println(city);  // Smiljan

tesla.setPlaceOfBirth(null);
city = parser.parseExpression(&quot;placeOfBirth?.city&quot;).getValue(context, tesla, String.class);
System.out.println(city);  // null - does not throw NullPointerException!!!
</code></pre>
<h2 id="collection-selection"><a class="header" href="#collection-selection">Collection Selection</a></h2>
<p>选择是一种强大的表达语言功能，可让您通过从源集合中选择条目来将其转换为另一个集合。</p>
<p>选择使用。<code>？[selectionExpression] </code> 的语法。
它过滤该集合并返回一个包含原始元素子集的新集合。</p>
<pre><code class="language-java">List&lt;Inventor&gt; list = (List&lt;Inventor&gt;) parser.parseExpression(
        &quot;members.?[nationality == 'Serbian']&quot;).getValue(societyContext);
</code></pre>
<p>在List和Map上都可以选择。
对于List，将针对每个单独的列表元素评估选择标准。
针对Map，针对每个Map Entry（Java类型Map.Entry的对象）评估选择标准。
每个Map Entry都有其键和值，可作为属性进行访问，以供在选择中使用。</p>
<pre><code class="language-java">Map newMap = parser.parseExpression(&quot;map.?[value&lt;27]&quot;).getValue();
</code></pre>
<p>除了返回所有选定的元素外，您只能检索第一个或最后一个值。
为了获得与选择匹配的第一个条目，语法为。<code>^ [selectionExpression]</code>。
要获得最后的匹配选择，语法为。<code>$ [selectionExpression]</code>。</p>
<h2 id="collection-projection"><a class="header" href="#collection-projection">Collection Projection</a></h2>
<p>投影使集合可以驱动子表达式的求值，结果是一个新的集合。
投影的语法为。<code>！[projectionExpression]</code>。</p>
<pre><code class="language-java">// returns ['Smiljan', 'Idvor' ]
List placesOfBirth = (List)parser.parseExpression(&quot;members.![placeOfBirth.city]&quot;);
</code></pre>
<p>使用map 投影的结果也是 <em>list</em></p>
<h2 id="expression-templating"><a class="header" href="#expression-templating">Expression templating</a></h2>
<p>表达式模板允许将文字文本与一个或多个求值块混合。
每个求值块均由您可以定义的前缀和后缀字符定界。
常见的选择是使用＃{}作为分隔符，如以下示例所示：</p>
<pre><code class="language-java">String randomPhrase = parser.parseExpression(
        &quot;random number is #{T(java.lang.Math).random()}&quot;,
        new TemplateParserContext()).getValue(String.class);

// evaluates to &quot;random number is 0.7038186818312008&quot;
</code></pre>
<pre><code class="language-java">    public static void main(String[] args) {
        SpelParserConfiguration configuration = new SpelParserConfiguration(true,true);
        SpelExpressionParser parser = new SpelExpressionParser(configuration);
        Expression expression = parser.parseExpression(&quot;12#{list[0]}12&quot;, new TemplateParserContext());
        Demo demo = new Demo();
        demo.list = new ArrayList&lt;&gt;();
        demo.list.add(&quot;sdfdsf&quot;);
        Object o = expression.getValue(demo,String.class);
        System.out.println(o);
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>org.springframework.core.io.support.PathMatchingResourcePatternResolver.PatternVirtualFileVisitor</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="路径匹配"><a class="header" href="#路径匹配">路径匹配</a></h1>
<blockquote>
<p>基于字符串的路径匹配的策略接口</p>
</blockquote>
<h2 id="类图"><a class="header" href="#类图">类图</a></h2>
<pre><code class="language-mermaid">classDiagram
PathMatcher --|&gt; AntPathMatcher:基于Ant风格的路径匹配
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatterspi"><a class="header" href="#formatterspi">FormatterSPI</a></h1>
<ul>
<li><em>core.convert</em>提供的是强类型的 通用转换 <code>SPI</code>, <em>SpringEL</em> <em>DataBinder</em> 都使用这个转换系统绑定字段值</li>
<li>例如在web环境 将 <em>string</em> 转换为客户端能处理的, 或者将对象转换成<em>string</em> 渲染,这就需要 <em>Formatter</em> SPI 提供简单可用的 <code>PropertyEditor</code>  实现</li>
<li>要使用<em>FormatterSPI</em> 则 要实现 通用的转换逻辑 例如 在  <code>Date-&gt;Long</code> 做类型转换,统一由 <code>ConversionService</code>  提供类型转换<em>API</em></li>
</ul>
<h1 id="spi接口"><a class="header" href="#spi接口">SPI接口</a></h1>
<pre><code class="language-java">package org.springframework.format;

public interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; {
}

public interface Printer&lt;T&gt; {

    String print(T fieldValue, Locale locale);
}


import java.text.ParseException;

public interface Parser&lt;T&gt; {

    T parse(String clientValue, Locale locale) throws ParseException;
}
</code></pre>
<p><strong>注意事项</strong></p>
<ul>
<li>根据不同Locale得到不同的<em>String</em></li>
<li>可以抛出 <code>ParseException</code>, <code>IllegalArgumentException</code>    解析错误或者参数异常错误</li>
<li>确保线程安全</li>
<li>已经提供了几个便利的 实现类
<ul>
<li><em>number</em> 包: <code>NumberStyleFormatter</code>, <code>CurrencyStyleFormatter</code> <code>PercentStyleFormatter</code>   <code>java.text.NumberFormat</code></li>
<li><em>datetime</em>包  提供 <em>Number</em> <code>java.text.DateFormat</code></li>
</ul>
</li>
</ul>
<p><strong>实现</strong></p>
<pre><code class="language-java">package org.springframework.format.datetime;

public final class DateFormatter implements Formatter&lt;Date&gt; {
    private String pattern;
    public DateFormatter(String pattern) {
        this.pattern = pattern;
    }
    public String print(Date date, Locale locale) {
        if (date == null) {
            return &quot;&quot;;
        }
        return getDateFormat(locale).format(date);
    }
    public Date parse(String formatted, Locale locale) throws ParseException {
        if (formatted.length() == 0) {
            return null;
        }
        return getDateFormat(locale).parse(formatted);
    }
    protected DateFormat getDateFormat(Locale locale) {
        DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale);
        dateFormat.setLenient(false);
        return dateFormat;
    }
}
</code></pre>
<h1 id="基于注解的formatter"><a class="header" href="#基于注解的formatter">基于注解的Formatter</a></h1>
<p><strong>绑定注解 与 <em>Formatter</em> 类</strong></p>
<p><em>通过AnnotationFormatterFactory</em></p>
<pre><code class="language-java">package org.springframework.format;
//A表示关联的注解类型 `org.springframework.format.annotation.DateTimeFormat`
public interface AnnotationFormatterFactory&lt;A extends Annotation&gt; {
	//注解能够处理的类型
    Set&lt;Class&lt;?&gt;&gt; getFieldTypes();
    Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);
    Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);
}
</code></pre>
<p><strong>范例实现</strong></p>
<blockquote>
<p><code>@NumberFormat</code></p>
</blockquote>
<pre><code class="language-java">public final class NumberFormatAnnotationFormatterFactory
        implements AnnotationFormatterFactory&lt;NumberFormat&gt; {

    public Set&lt;Class&lt;?&gt;&gt; getFieldTypes() {
        return new HashSet&lt;Class&lt;?&gt;&gt;(asList(new Class&lt;?&gt;[] {
            Short.class, Integer.class, Long.class, Float.class,
            Double.class, BigDecimal.class, BigInteger.class }));
    }

    public Printer&lt;Number&gt; getPrinter(NumberFormat annotation, Class&lt;?&gt; fieldType) {
        return configureFormatterFrom(annotation, fieldType);
    }

    public Parser&lt;Number&gt; getParser(NumberFormat annotation, Class&lt;?&gt; fieldType) {
        return configureFormatterFrom(annotation, fieldType);
    }

    private Formatter&lt;Number&gt; configureFormatterFrom(NumberFormat annotation, Class&lt;?&gt; fieldType) {
        if (!annotation.pattern().isEmpty()) {
            return new NumberStyleFormatter(annotation.pattern());
        } else {
            Style style = annotation.style();
            if (style == Style.PERCENT) {
                return new PercentStyleFormatter();
            } else if (style == Style.CURRENCY) {
                return new CurrencyStyleFormatter();
            } else {
                return new NumberStyleFormatter();
            }
        }
    }
}

//使用示例1
public class MyModel {
    @NumberFormat(style=Style.CURRENCY)
    private BigDecimal decimal;
}
//使用示例2
public class MyModel {
    @DateTimeFormat(iso=ISO.DATE)
    private Date date;
}
</code></pre>
<h1 id="formatter注册spi"><a class="header" href="#formatter注册spi">Formatter注册SPI</a></h1>
<ul>
<li><code>FormatterRegistry</code> 是一个 注册<em>Formatters</em> <em>converters</em>  的SPI ,   <code>FormattingConversionService</code> 是一个通用实现</li>
<li>通过使用<code>FormattingConversionServiceFactoryBean</code>  可以编程式或者 声明式配置其他注册变体, 同样也是 <em>ConversionService</em>的实现类,在数据绑定,<em>SPringEL</em>中也可以使用</li>
</ul>
<pre><code class="language-java">package org.springframework.format;

public interface FormatterRegistry extends ConverterRegistry {

    void addFormatterForFieldType(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser);

    void addFormatterForFieldType(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter);

    void addFormatterForFieldType(Formatter&lt;?&gt; formatter);

    void addFormatterForAnnotation(AnnotationFormatterFactory&lt;?&gt; factory);
}
</code></pre>
<h1 id="formatterregistrar"><a class="header" href="#formatterregistrar">FormatterRegistrar</a></h1>
<p><strong>注册 注册类的 SPI</strong></p>
<pre><code class="language-java">package org.springframework.format;

public interface FormatterRegistrar {

    void registerFormatters(FormatterRegistry registry);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="环境抽象-1"><a class="header" href="#环境抽象-1">环境抽象</a></h1>
<ul>
<li>
<p><em>Environment</em> 接口是 对   程序两个关键的环境: </p>
<ul>
<li><em>profile</em></li>
<li><em>properties</em></li>
</ul>
<p>进行的抽象</p>
</li>
<li>
<p><em>profile</em> 是一系列 bean定义的 逻辑分组, 只有当指定的<em>profile</em> 激活才会把加入到容器管理</p>
</li>
<li>
<p><em>properties</em> 管理者 很多属性资源, 例如  JVM系统属性, 环境变量, JNDI, 容器参数,  临时<em>properties</em>, <em>objects</em>, <em>map</em> </p>
</li>
</ul>
<h1 id="profile-1"><a class="header" href="#profile-1">Profile</a></h1>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<h3 id="与或非使用逻辑"><a class="header" href="#与或非使用逻辑">与或非使用逻辑</a></h3>
<pre><code>!: A logical “not” of the profile

&amp;: A logical “and” of the profiles

|: A logical “or” of the profiles
</code></pre>
<h3 id="标注配置类上"><a class="header" href="#标注配置类上">标注配置类上</a></h3>
<pre><code class="language-java">//标注配置类上
@Configuration
@Profile(&quot;development&quot;)
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)
            .addScript(&quot;classpath:com/bank/config/sql/test-data.sql&quot;)
            .build();
    }
}

//多环境
@Profile({&quot;p1&quot;, &quot;p2&quot;})
</code></pre>
<h3 id="xml配置"><a class="header" href="#xml配置">XML配置</a></h3>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;
    xsi:schemaLocation=&quot;...&quot;&gt;

    &lt;!-- other bean definitions --&gt;

    &lt;beans profile=&quot;development&quot;&gt;
        &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;
            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;
            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

    &lt;beans profile=&quot;production&quot;&gt;
        &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;
    &lt;/beans&gt;
&lt;/beans&gt;
//嵌套
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;
    xsi:schemaLocation=&quot;...&quot;&gt;

    &lt;!-- other bean definitions --&gt;

    &lt;beans profile=&quot;production&quot;&gt;
        &lt;beans profile=&quot;us-east&quot;&gt;
            &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;
        &lt;/beans&gt;
    &lt;/beans&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="激活profile的方式"><a class="header" href="#激活profile的方式">激活Profile的方式</a></h2>
<p><strong>编码方式</strong></p>
<pre><code class="language-java">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles(&quot;development&quot;);
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();
</code></pre>
<p><strong>命令行</strong></p>
<pre><code> -Dspring.profiles.active=&quot;profile1,profile2&quot;
</code></pre>
<p><strong>默认环境</strong></p>
<pre><code class="language-java">@Configuration
@Profile(&quot;default&quot;)
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)
            .build();
    }
}
</code></pre>
<h1 id="属性源"><a class="header" href="#属性源">属性源</a></h1>
<h2 id="属性查找的优先级"><a class="header" href="#属性查找的优先级">属性查找的优先级</a></h2>
<ul>
<li>
<p><em>Environment</em> 的查找是可继承的</p>
</li>
<li>
<p><em>StandardEnvironment</em> 包含了 系统变量和环境变量</p>
</li>
<li>
<p><em>StandardServletEnvironment</em>包含以下，　越排在上面优先级越高</p>
<ul>
<li>ServletConfig parameters (if applicable — for example, in case of a <code>DispatcherServlet</code> context)</li>
<li>ServletContext parameters (web.xml context-param entries)</li>
<li>JNDI environment variables (<code>java:comp/env/</code> entries)</li>
<li>JVM system properties (<code>-D</code> command-line arguments)</li>
<li>JVM system environment (operating system environment variables)</li>
</ul>
</li>
</ul>
<h2 id="属性源在spring中的使用"><a class="header" href="#属性源在spring中的使用">属性源在spring中的使用</a></h2>
<pre><code class="language-java">@Configuration
@PropertySource(&quot;classpath:/com/myco/app.properties&quot;)
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty(&quot;testbean.name&quot;));
        return testBean;
    }
}
</code></pre>
<p><strong>占位符会从当前环境已加载的属性中取</strong></p>
<pre><code class="language-java">@Configuration
@PropertySource(&quot;classpath:/com/${my.placeholder:default/path}/app.properties&quot;)
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty(&quot;testbean.name&quot;));
        return testBean;
    }
}
</code></pre>
<h1 id="属性与资源环境"><a class="header" href="#属性与资源环境">属性与资源环境</a></h1>
<h2 id="资源属性"><a class="header" href="#资源属性">资源属性</a></h2>
<blockquote>
<p>PropertySource：对 key value键值对的封装</p>
</blockquote>
<h3 id="类图-1"><a class="header" href="#类图-1">类图</a></h3>
<pre><code class="language-mermaid">classDiagram
  PropertySource &lt;|-- EnumerablePropertySource:可枚举的
  PropertySource &lt;|-- StubPropertySource:存根
  EnumerablePropertySource &lt;|-- MapPropertySource:基于map的实现
  MapPropertySource &lt;|-- PropertiesPropertySource:基于Properties的实现
  MapPropertySource &lt;|-- SystemEnvironmentPropertySource:兼容bash 的a_b,a.b,a-b等
  PropertiesPropertySource &lt;|-- ResourcePropertySource:基于类路径资源
  PropertiesPropertySource &lt;|-- MockPropertySource:数据模拟
</code></pre>
<h3 id="propertysource-2"><a class="header" href="#propertysource-2">PropertySource</a></h3>
<h3 id="简述-1"><a class="header" href="#简述-1">简述</a></h3>
<p>PropertySource 对象通常不会单独使用，而是通过 PropertySources 对象使用，该对象聚合属性源并与 PropertyResolver 实现结合使用，该实现可以跨 PropertySource 集执行基于优先级的搜索。 
PropertySource 标识不是根据封装的属性的内容来确定的，而是仅根据 PropertySource 的名称来确定的。</p>
<h3 id="局部变量"><a class="header" href="#局部变量">局部变量</a></h3>
<p><strong>属性源的名称</strong></p>
<pre><code class="language-java">protected final String name;
</code></pre>
<p>属性源<strong>backend</strong></p>
<pre><code class="language-java">protected final T source;
</code></pre>
<h3 id="stubpropertysource"><a class="header" href="#stubpropertysource">StubPropertySource</a></h3>
<ol>
<li>
<p>在创建应用程序上下文时无法急切初始化实际属性源的情况下，PropertySource 用作占位符。</p>
</li>
<li>
<p>例如，基于 ServletContext 的属性源必须等待 ServletContext 对象可用于其封闭的 ApplicationContext。</p>
</li>
<li>
<p>在这种情况下，应使用存根来保存属性源的预期默认位置/顺序，然后在上下文刷新期间替换。</p>
</li>
</ol>
<pre><code class="language-java">public static class StubPropertySource extends PropertySource&lt;Object&gt; {

   public StubPropertySource(String name) {
      super(name, new Object());
   }

   /**
    * Always returns {@code null}.
    */
   @Override
   @Nullable
   public String getProperty(String name) {
      return null;
   }
}
</code></pre>
<h3 id="comparisonpropertysource"><a class="header" href="#comparisonpropertysource">ComparisonPropertySource</a></h3>
<blockquote>
<p>用于集合比较目的的 PropertySource 实现。</p>
</blockquote>
<pre><code class="language-java">static class ComparisonPropertySource extends StubPropertySource {

   private static final String USAGE_ERROR =
         &quot;ComparisonPropertySource instances are for use with collection comparison only&quot;;

   public ComparisonPropertySource(String name) {
      super(name);
   }

   @Override
   public Object getSource() {
      throw new UnsupportedOperationException(USAGE_ERROR);
   }

   @Override
   public boolean containsProperty(String name) {
      throw new UnsupportedOperationException(USAGE_ERROR);
   }

   @Override
   @Nullable
   public String getProperty(String name) {
      throw new UnsupportedOperationException(USAGE_ERROR);
   }
}
</code></pre>
<h3 id="enumerablepropertysource"><a class="header" href="#enumerablepropertysource">EnumerablePropertySource</a></h3>
<blockquote>
<p>能够查询其底层源对象以枚举所有可能的属性名称/值对的 PropertySource 实现。</p>
</blockquote>
<p>公开 getPropertyNames() 方法以允许调用者内省可用属性</p>
<pre><code class="language-java">public abstract String[] getPropertyNames();
</code></pre>
<h3 id="compositepropertysource"><a class="header" href="#compositepropertysource">CompositePropertySource</a></h3>
<blockquote>
<p>一些列PropertySource的集合组合实现</p>
</blockquote>
<pre><code class="language-java">private final Set&lt;PropertySource&lt;?&gt;&gt; propertySources = new LinkedHashSet&lt;&gt;();
</code></pre>
<h3 id="commandlinepropertysource"><a class="header" href="#commandlinepropertysource">CommandLinePropertySource</a></h3>
<ol>
<li>
<p>基于命令行的属性源</p>
</li>
<li>
<p>有两个实现类，一个是基于 <code>--opt=xjq</code> 的简单命令行</p>
<p><em>CommandLinePropertySource</em></p>
<p>一个是基于Jopt的命令行属性源 <em>CommandLinePropertySource</em></p>
</li>
</ol>
<h3 id="resourcepropertysource"><a class="header" href="#resourcepropertysource">ResourcePropertySource</a></h3>
<blockquote>
<p><strong>基于<em>Resource</em> 的 属性源</strong></p>
</blockquote>
<p><strong>初始化</strong></p>
<pre><code class="language-java">//将Resource 转化成Properties
//从resource从获取 resourcename
public ResourcePropertySource(String name, EncodedResource resource) throws IOException {
   super(name, PropertiesLoaderUtils.loadProperties(resource));
   this.resourceName = getNameForResource(resource.getResource());
}
</code></pre>
<p><strong>getNameForResource</strong></p>
<pre><code class="language-java">private static String getNameForResource(Resource resource) {
   String name = resource.getDescription();
   if (!StringUtils.hasText(name)) {
      name = resource.getClass().getSimpleName() + &quot;@&quot; + System.identityHashCode(resource);
   }
   return name;
}
</code></pre>
<h2 id="属性占位符解析"><a class="header" href="#属性占位符解析">属性占位符解析</a></h2>
<h3 id="类图-2"><a class="header" href="#类图-2">类图</a></h3>
<pre><code class="language-mermaid">classDiagram
	PropertyResolver --|&gt; ConfigurablePropertyResolver:设置属性解析器的一些配置包括占位符、默认值分隔符、无法解析时是否忽略
	ConfigurablePropertyResolver --|&gt; AbstractPropertyResolver:大部分内容的实现：1.ConfigurablePropertyResolver的大部分实现
	AbstractPropertyResolver --|&gt; PropertySourcesPropertyResolver:使用PropertySource实现属性源获取功能
	AbstractPropertyResolver ..&gt; PropertyPlaceholderHelper:1.通过它完成占位符替换功能
</code></pre>
<h3 id="propertyresolver"><a class="header" href="#propertyresolver">PropertyResolver</a></h3>
<blockquote>
<p>用于针对任何基础源 <strong>解析属性</strong>的接口</p>
</blockquote>
<p><strong>获取属性</strong></p>
<pre><code class="language-java">//返回给定的属性键是否可用于解析，即给定键的值不为空
boolean containsProperty(String key);
//返回与给定键关联的属性值，如果无法解析键，则返回 null。
String getProperty(String key);
String getProperty(String key, String defaultValue);
//返回与给定键关联的属性值，如果无法解析键，则返回 null。
&lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType);
//返回与给定键关联的属性值，如果键不能被返回，则返回 defaultValue
&lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType, T defaultValue);
String getRequiredProperty(String key) throws IllegalStateException;
	&lt;T&gt; T getRequiredProperty(String key, Class&lt;T&gt; targetType) throws IllegalStateException;
</code></pre>
<p><strong>解析占位符</strong></p>
<pre><code class="language-java">// 解析给定文本中的 ${...} 占位符，将它们替换为由 getProperty 解析的相应属性值。没有默认值的无法解析的占位符将被忽略并保持不变
String resolvePlaceholders(String text);
String resolveRequiredPlaceholders(String text) throws IllegalArgumentException;
</code></pre>
<h3 id="configurablepropertyresolver"><a class="header" href="#configurablepropertyresolver">ConfigurablePropertyResolver</a></h3>
<p><strong>API</strong></p>
<ol>
<li>提供 <em>ConversionService</em> 转换服务：不通类型之间的转换</li>
<li>设置 占位符前缀、后缀</li>
<li>默认值与占位符之间的分隔符 默认为 冒号</li>
<li>遇到无法解析的占位符时是否抛出异常。</li>
<li>校验属性值</li>
</ol>
<h3 id="abstractpropertyresolver"><a class="header" href="#abstractpropertyresolver">AbstractPropertyResolver</a></h3>
<h4 id="成员变量"><a class="header" href="#成员变量">成员变量</a></h4>
<pre><code class="language-java">//必输属性
private final Set&lt;String&gt; requiredProperties = new LinkedHashSet&lt;&gt;();
//默认值分割符
private String valueSeparator =  SystemPropertyUtils.VALUE_SEPARATOR;

//前缀
public static final String PLACEHOLDER_PREFIX = &quot;${&quot;;

//后缀
	/** Suffix for system property placeholders: &quot;}&quot;. */
public static final String PLACEHOLDER_SUFFIX = &quot;}&quot;;

//默认值分割符
	/** Value separator for system property placeholders: &quot;:&quot;. */
public static final String VALUE_SEPARATOR = &quot;:&quot;;

//遇到无法解析的 占用符时是否忽略
private boolean ignoreUnresolvableNestedPlaceholders = false;

</code></pre>
<pre><code class="language-java">//类型转换
private volatile ConfigurableConversionService conversionService;

//placeHolder解析器：非严格
private PropertyPlaceholderHelper nonStrictHelper;
//placeHolder解析器：严格
private PropertyPlaceholderHelper strictHelper;
</code></pre>
<h2 id="环境"><a class="header" href="#环境">环境</a></h2>
<blockquote>
<p>不同的 <em>PropertySource</em> 构成不同的 <em>Environment</em></p>
</blockquote>
<h3 id="environment"><a class="header" href="#environment">Environment</a></h3>
<ol>
<li>当前应用程序运行环境的接口</li>
<li>对应用程序环境的两个关键方面进行抽象：（<em>profile</em>）配置文件和（<em>properties</em>）属性。</li>
<li>与属性访问相关的方法通过 <em>PropertyResolver</em> 接口公开。</li>
</ol>
<p><strong>主要用来查询 当前环境激活的环境变量</strong></p>
<p>配置文件是一个命名的、逻辑的 bean 定义组，仅当给定的配置文件处于活动状态时才向容器注册</p>
<p>Bean 可以分配给配置文件，无论是在 XML 中定义还是通过注解</p>
<p>在 <em>ApplicationContext</em>  管理的Bean 可以通过   <em>EnvironmentAware</em>  接口注入环境变量 或者 <code>@Inject</code></p>
<p>大多数情况下、应用程序级的 <em>bean</em> 不需要直接与  <em>Environment</em>  交互</p>
<p>而是 通过 占位符 属性 <code>${...}</code> 替换来 访问</p>
<p>默认情况下 </p>
<p><em>PropertySourcesPlaceholderConfigurer</em> 是默认注册进Spring容器 中</p>
<p>并处理这些 变量替换</p>
<p><em>environment</em> 对象的配置必须通过 <em>ConfigurableEnvironment</em> 接口完成</p>
<p>从所有 AbstractApplicationContext 子类 getEnvironment() 方法返回</p>
<pre><code class="language-java">//所有已激活的环境变量
String[] getActiveProfiles();
//获取默认环境变量
String[] getDefaultProfiles();

//返回一个或多个给定的配置文件是否处于活动状态，或者在没有明确的活动配置文件的情况下，一个或多个给定的配置文件是否包含在一组默认配置文件中。如果配置文件以 '!' 开头 逻辑被反转，即如果给定的配置文件未激活，该方法将返回 true。 例如， env.acceptsProfiles(&quot;p1&quot;, &quot;!p2&quot;) 如果配置文件 'p1' 处于活动状态或 'p2' 未处于活动状态，则将返回 true。
boolean acceptsProfiles(Profiles profiles);
</code></pre>
<h3 id="configurableenvironment"><a class="header" href="#configurableenvironment">ConfigurableEnvironment</a></h3>
<p><strong>配置profile</strong></p>
<pre><code>void setActiveProfiles(String... profiles);
void addActiveProfile(String profile);
void setDefaultProfiles(String... profiles);
</code></pre>
<p><strong>返回系统环境属性</strong></p>
<pre><code class="language-java">//由jvm设置
Map&lt;String, Object&gt; getSystemProperties();
//环境变量：由外部进程设置
Map&lt;String, Object&gt; getSystemEnvironment();
</code></pre>
<p><strong>合并</strong></p>
<pre><code class="language-java">//将给定的父环境的活动配置文件、默认配置文件和属性源附加到此（子）环境各自的集合中。
void merge(ConfigurableEnvironment parent);
</code></pre>
<ol>
<li>对于存在于父和子中的任何同名 PropertySource 实例，将保留子实例并丢弃父实例。</li>
<li>活动和默认配置文件名称也过滤重复，以避免混淆和冗余存储。</li>
<li>.在任何情况下，父环境都保持不变。请注意，在调用合并之后发生的对父环境的任何更改都不会反映在子环境中。因此，在调用merge之前应注意配置父属性源和配置文件信息</li>
</ol>
<h3 id="abstractenvironment"><a class="header" href="#abstractenvironment">AbstractEnvironment</a></h3>
<h3 id="简介-2"><a class="header" href="#简介-2">简介</a></h3>
<ol>
<li>环境实现的抽象基类</li>
<li>允许通过 ACTIVE_PROFILES_PROPERTY_NAME 和 DEFAULT_PROFILES_PROPERTY_NAME 属性指定活动和默认配置文件</li>
<li>具体子类的不同主要在于它们默认添加的 PropertySource 对象</li>
<li>AbstractEnvironment 不添加任何内容。</li>
<li>子类通过 <em>customPropertySources(MutablePropertySources)</em> 构造<em>PropertySources</em></li>
</ol>
<h3 id="成员变量-1"><a class="header" href="#成员变量-1">成员变量</a></h3>
<p><strong>profile属性</strong></p>
<pre><code class="language-java">private final Set&lt;String&gt; activeProfiles = new LinkedHashSet&lt;&gt;();
protected static final String RESERVED_DEFAULT_PROFILE_NAME = &quot;default&quot;;
private final Set&lt;String&gt; defaultProfiles = new LinkedHashSet&lt;&gt;(getReservedDefaultProfiles());

// ProfileParser：profile解析类
org.springframework.core.env.ProfilesParser
</code></pre>
<p><strong>占位符解析器</strong></p>
<pre><code class="language-java">private final ConfigurablePropertyResolver propertyResolver =
      new PropertySourcesPropertyResolver(this.propertySources);
</code></pre>
<p><strong>资源集合</strong></p>
<pre><code class="language-java">private final MutablePropertySources propertySources = new MutablePropertySources();
</code></pre>
<p>主要实现了 <em>profile</em>的 增删改查</p>
<h3 id="standardenvironment"><a class="header" href="#standardenvironment">StandardEnvironment</a></h3>
<blockquote>
<p>适用于“标准”（即非网络）应用程序的环境实现</p>
</blockquote>
<p>除了 <em>ConfigurableEnvironment</em> 的常用功能</p>
<ul>
<li>例如属性解析和</li>
<li>与<strong>profile</strong>相关的操作）之外</li>
</ul>
<p>此实现还配置了两个默认属性源，按以下顺序搜索：</p>
<ul>
<li>system properties</li>
<li>system environment variables</li>
</ul>
<h3 id="configurablewebenvironment"><a class="header" href="#configurablewebenvironment">ConfigurableWebEnvironment</a></h3>
<p>在 <em>ServletContext</em>  早期：<em>ServletConfig</em> 可用的时候，来初始化相关的<em>PropertySource</em></p>
<pre><code class="language-java">void initPropertySources(@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig);
</code></pre>
<h3 id="standardservletenvironment"><a class="header" href="#standardservletenvironment">StandardServletEnvironment</a></h3>
<pre><code>extends StandardEnvironment implements ConfigurableWebEnvironment
</code></pre>
<p><em>ServletContext</em> <strong>初始化属性源</strong></p>
<p>初始化两个属性源</p>
<ol>
<li><em>ServletContextPropertySource</em></li>
<li><em>ServletConfigPropertySource</em></li>
</ol>
<pre><code class="language-java">	@Override
public void initPropertySources(@Nullable ServletContext servletContext, @Nullable ServletConfig servletConfig) {
WebApplicationContextUtils.initServletPropertySources(getPropertySources(), servletContext, servletConfig);
	}
</code></pre>
<h3 id="mockenvironment"><a class="header" href="#mockenvironment">MockEnvironment</a></h3>
<p>伪造 属性环境</p>
<h1 id="spring资源环境自动加载机制"><a class="header" href="#spring资源环境自动加载机制">spring资源环境自动加载机制</a></h1>
<h2 id="类图-3"><a class="header" href="#类图-3">类图</a></h2>
<pre><code class="language-mermaid">classDiagram
    class PropertiesLoaderSupport{
    	localProperties:本地变量
    	locations:拥有资源
    	fileEncoding:编码
    	localOverride:是否使用本地变量覆盖
    }
   
	PropertiesLoaderSupport --|&gt; PropertiesFactoryBean:返回 内置的属性资源对象
	PropertiesLoaderSupport --|&gt; PropertyResourceConfigurer:在BeanFactoryPostProcessor后置处理器
	PropertyResourceConfigurer --|&gt; PropertyOverrideConfigurer: 使用这种格式覆盖beanName.property=value
	PropertyResourceConfigurer --|&gt; PlaceholderConfigurerSupport:帮助在bean定义中的placeHolder替换
	PlaceholderConfigurerSupport --|&gt; PropertySourcesPlaceholderConfigurer:完成真正的逻辑加载
	PlaceholderConfigurerSupport --|&gt; PropertyPlaceholderConfigurer:已过时
</code></pre>
<h2 id="propertyplaceholderconfigurer逻辑"><a class="header" href="#propertyplaceholderconfigurer逻辑">PropertyPlaceholderConfigurer逻辑</a></h2>
<ol>
<li>获取配置的本地资源 数据</li>
<li>自定义转换逻辑：覆盖properties的值</li>
<li>对bean定义 遍历 <em>BeanDefinitionVisitor</em>  进行 占位符替换 </li>
</ol>
<h2 id="propertysourcesplaceholderconfigurer逻辑"><a class="header" href="#propertysourcesplaceholderconfigurer逻辑">PropertySourcesPlaceholderConfigurer逻辑</a></h2>
<ol>
<li>
<p><strong>将默认环境资源加入到资源管理中</strong></p>
<pre><code class="language-java">				this.propertySources.addLast(
					new PropertySource&lt;Environment&gt;(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, this.environment) {
						@Override
						@Nullable
						public String getProperty(String key) {
							return this.source.getProperty(key);
						}
					}
				);
</code></pre>
</li>
<li>
<p><strong>将本地资源属性加入到资源管理中</strong></p>
<pre><code class="language-java">PropertySource&lt;?&gt; localPropertySource =
      new PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());
if (this.localOverride) {
   this.propertySources.addFirst(localPropertySource);
}
else {
   this.propertySources.addLast(localPropertySource);
}
</code></pre>
</li>
<li>
<p><strong>配置 占位符解析器</strong></p>
</li>
</ol>
<pre><code class="language-java">	protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess,
			final ConfigurablePropertyResolver propertyResolver) throws BeansException {

		propertyResolver.setPlaceholderPrefix(this.placeholderPrefix);
		propertyResolver.setPlaceholderSuffix(this.placeholderSuffix);
		propertyResolver.setValueSeparator(this.valueSeparator);

		StringValueResolver valueResolver = strVal -&gt; {
			String resolved = (this.ignoreUnresolvablePlaceholders ?
					propertyResolver.resolvePlaceholders(strVal) :
					propertyResolver.resolveRequiredPlaceholders(strVal));
			if (this.trimValues) {
				resolved = resolved.trim();
			}
			return (resolved.equals(this.nullValue) ? null : resolved);
		};

		doProcessProperties(beanFactoryToProcess, valueResolver);
	}
</code></pre>
<ol start="4">
<li><strong>bean定义 占位符替换</strong></li>
</ol>
<pre><code class="language-java">protected void doProcessProperties(ConfigurableListableBeanFactory beanFactoryToProcess,
      StringValueResolver valueResolver) {

   BeanDefinitionVisitor visitor = new BeanDefinitionVisitor(valueResolver);

   String[] beanNames = beanFactoryToProcess.getBeanDefinitionNames();
   for (String curName : beanNames) {
      // Check that we're not parsing our own bean definition,
      // to avoid failing on unresolvable placeholders in properties file locations.
      if (!(curName.equals(this.beanName) &amp;&amp; beanFactoryToProcess.equals(this.beanFactory))) {
         BeanDefinition bd = beanFactoryToProcess.getBeanDefinition(curName);
         try {
            visitor.visitBeanDefinition(bd);
         }
         catch (Exception ex) {
            throw new BeanDefinitionStoreException(bd.getResourceDescription(), curName, ex.getMessage(), ex);
         }
      }
   }

   // New in Spring 2.5: resolve placeholders in alias target names and aliases as well.
   beanFactoryToProcess.resolveAliases(valueResolver);

   // New in Spring 3.0: resolve placeholders in embedded values such as annotation attributes.
   beanFactoryToProcess.addEmbeddedValueResolver(valueResolver);
}
</code></pre>
<h2 id="propertysource逻辑"><a class="header" href="#propertysource逻辑">@PropertySource逻辑</a></h2>
<p><code>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass</code></p>
<p><strong>解析<em>ConfigClass</em> 时 解析PropertySource</strong></p>
<pre><code class="language-java">// Process any @PropertySource annotations
for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
      sourceClass.getMetadata(), PropertySources.class,
      org.springframework.context.annotation.PropertySource.class)) {
   if (this.environment instanceof ConfigurableEnvironment) {
      processPropertySource(propertySource);
   }
   else {
      logger.info(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +
            &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);
   }
}
</code></pre>
<p><strong>针对@PropertySource注解逻辑处理</strong></p>
<pre><code class="language-java">{
//属性源名称
   String name = propertySource.getString(&quot;name&quot;);
   if (!StringUtils.hasLength(name)) {
      name = null;
   }
//属性源编码
   String encoding = propertySource.getString(&quot;encoding&quot;);
   if (!StringUtils.hasLength(encoding)) {
      encoding = null;
   }
  //属性源值
   String[] locations = propertySource.getStringArray(&quot;value&quot;);
   Assert.isTrue(locations.length &gt; 0, &quot;At least one @PropertySource(value) location is required&quot;);
    //not found时的处理逻辑
   boolean ignoreResourceNotFound = propertySource.getBoolean(&quot;ignoreResourceNotFound&quot;);
   //PropertySourceFactory工厂处理类
   Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass(&quot;factory&quot;);
   PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ?
         DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass));

    //解析处理 locations
   for (String location : locations) {
      try {
          //针对location上的变量进行占位符替换
         String resolvedLocation = this.environment.resolveRequiredPlaceholders(location);
          //加载资源
         Resource resource = this.resourceLoader.getResource(resolvedLocation);
          //将资源计入到Environment
         addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding)));
      }
      catch (IllegalArgumentException | FileNotFoundException | UnknownHostException ex) {
          //处理找不到资源的情况
         // Placeholders not resolvable or resource not found when trying to open it
         if (ignoreResourceNotFound) {
            if (logger.isInfoEnabled()) {
               logger.info(&quot;Properties location [&quot; + location + &quot;] not resolvable: &quot; + ex.getMessage());
            }
         }
         else {
            throw ex;
         }
      }
   }
}
</code></pre>
<p><strong>将解析的资源加入到Environment</strong></p>
<pre><code class="language-java">{
   String name = propertySource.getName();
   MutablePropertySources propertySources = ((ConfigurableEnvironment) this.environment).getPropertySources();
//如果已经加载过：将 sourcename作为 name替换
   if (this.propertySourceNames.contains(name)) {
      // We've already added a version, we need to extend it
      PropertySource&lt;?&gt; existing = propertySources.get(name);
      // 
      if (existing != null) {
         PropertySource&lt;?&gt; newSource = (propertySource instanceof ResourcePropertySource ?
               ((ResourcePropertySource) propertySource).withResourceName() : propertySource);
         if (existing instanceof CompositePropertySource) {
            ((CompositePropertySource) existing).addFirstPropertySource(newSource);
         }
         else {
            if (existing instanceof ResourcePropertySource) {
               existing = ((ResourcePropertySource) existing).withResourceName();
            }
             //新旧版本 一起组合
            CompositePropertySource composite = new CompositePropertySource(name);
            composite.addPropertySource(newSource);
            composite.addPropertySource(existing);
            propertySources.replace(name, composite);
         }
         return;
      }
   }

   if (this.propertySourceNames.isEmpty()) {
      propertySources.addLast(propertySource);
   }
   else {
      String firstProcessed = this.propertySourceNames.get(this.propertySourceNames.size() - 1);
      propertySources.addBefore(firstProcessed, propertySource);
   }
   this.propertySourceNames.add(name);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-3"><a class="header" href="#简介-3">简介</a></h1>
<p><em>spring3</em> 引入了一个 <em>core.convert</em> 包,提供了 一个通用类型转换系统</p>
<h1 id="接口定义"><a class="header" href="#接口定义">接口定义</a></h1>
<p><strong>1对1转换</strong></p>
<pre><code class="language-java">package org.springframework.core.convert.converter;

public interface Converter&lt;S, T&gt; {

    T convert(S source);
}
</code></pre>
<p><strong>实现范例</strong></p>
<pre><code class="language-java">package org.springframework.core.convert.support;

final class StringToInteger implements Converter&lt;String, Integer&gt; {

    public Integer convert(String source) {
        return Integer.valueOf(source);
    }

</code></pre>
<h1 id="注意事项-2"><a class="header" href="#注意事项-2">注意事项</a></h1>
<ul>
<li>对每一个  <code>convert(S)</code> 的调用  ,入参 要保证不为空</li>
<li>如果转换失败,可能会抛出任何未检查的异常</li>
<li>如果参数不正确则 抛出<code>IllegalArgumentException</code> </li>
<li>请确保 转换线程安全的</li>
<li>内置实现 在 <em>core.convert.support</em> 包中</li>
</ul>
<h1 id="使用-converterfactory"><a class="header" href="#使用-converterfactory">使用 <code>ConverterFactory</code></a></h1>
<p><strong>1 对 多 转换</strong></p>
<blockquote>
<p>当你需要集中你的转换逻辑 转换某一类的所有继承子类 例如 ( <em>String</em> To <em>Enum</em> )</p>
</blockquote>
<pre><code class="language-java">package org.springframework.core.convert.converter;

public interface ConverterFactory&lt;S, R&gt; {

    &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);
}
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-java">package org.springframework.core.convert.support;

final class StringToEnumConverterFactory implements ConverterFactory&lt;String, Enum&gt; {

    public &lt;T extends Enum&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) {
        return new StringToEnumConverter(targetType);
    }

    private final class StringToEnumConverter&lt;T extends Enum&gt; implements Converter&lt;String, T&gt; {

        private Class&lt;T&gt; enumType;

        public StringToEnumConverter(Class&lt;T&gt; enumType) {
            this.enumType = enumType;
        }

        public T convert(String source) {
            return (T) Enum.valueOf(this.enumType, source.trim());
        }
    }
}
</code></pre>
<h1 id="使用-genericconverter"><a class="header" href="#使用-genericconverter">使用 <code>GenericConverter</code></a></h1>
<p>N:N 的转化</p>
<p>When you require a sophisticated <code>Converter</code> implementation, consider using the <code>GenericConverter</code> interface. </p>
<blockquote>
<p>当你需要复杂的转换,可以实现<code>GenericConverter</code> ,允许在转换时获取 字段注解,签名,等上下文</p>
</blockquote>
<pre><code class="language-java">package org.springframework.core.convert.converter;

public interface GenericConverter {
    // 支持的 source -&gt; target 对
    public Set&lt;ConvertiblePair&gt; getConvertibleTypes();

    // 转换逻辑, TypeDescriptor 字段上下文
    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
//很好的实例是 `ArrayToCollectionConverter`
</code></pre>
<h1 id="条件转换conditionalgenericconverter"><a class="header" href="#条件转换conditionalgenericconverter"><em>条件转换<code>ConditionalGenericConverter</code></em></a></h1>
<blockquote>
<p>只有当满足特定条件时,才会转换</p>
</blockquote>
<h1 id="conversionservice"><a class="header" href="#conversionservice"><code>ConversionService</code></a></h1>
<p><strong>Conversion Service提供统一的外观界面 ,在运行时执行类型转换</strong></p>
<pre><code class="language-java">package org.springframework.core.convert;

public interface ConversionService {

    boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);

    &lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType);

    boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

}
</code></pre>
<ul>
<li>
<p>大多数实现了 <em>ConversionService</em> 也实现了 <em>ConverterRegistry</em>  ,提供注册<em>converters</em>的SPI, <em>conversionService</em> 将转换逻辑 委托给注册的转换器</p>
</li>
<li>
<p><em>core.convert.support</em>下 <code>GenericConversionService</code>  是一个通用实现</p>
</li>
<li>
<p><code>ConversionServiceFactory</code>  提供<code>ConversionService</code> 的配置化构建</p>
</li>
</ul>
<h1 id="配置genericservice"><a class="header" href="#配置genericservice">配置<em>GenericService</em></a></h1>
<blockquote>
<p>ConversionService 是一个 无状态对象，在应用启动时初始化，多线程共享，可以手动注入</p>
<p>If no <code>ConversionService</code> is registered with Spring, the original <code>PropertyEditor</code>-based system is used.</p>
</blockquote>
<h2 id="通过-factorybean-创建"><a class="header" href="#通过-factorybean-创建">通过 <em>factoryBean</em> 创建</a></h2>
<pre><code class="language-xml">&lt;bean id=&quot;conversionService&quot;
    class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;/&gt;

// 配置converters,值可以是任何实现了 Converter, ConverterFactory, or GenericConverter的类
&lt;bean id=&quot;conversionService&quot;
        class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;
    &lt;property name=&quot;converters&quot;&gt;
        &lt;set&gt;
            &lt;bean class=&quot;example.MyCustomConverter&quot;/&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;

</code></pre>
<h2 id="conversionservicefactorybean-完成的功能"><a class="header" href="#conversionservicefactorybean-完成的功能">ConversionServiceFactoryBean 完成的功能</a></h2>
<ul>
<li>
<p>创建 <em>DefaultConversionService</em></p>
</li>
<li>
<p>注册自定义 <em>Converters</em></p>
<pre><code class="language-java">if (converter instanceof GenericConverter) {
					registry.addConverter((GenericConverter) converter);
				}
				else if (converter instanceof Converter&lt;?, ?&gt;) {
					registry.addConverter((Converter&lt;?, ?&gt;) converter);
				}
				else if (converter instanceof ConverterFactory&lt;?, ?&gt;) {
					registry.addConverterFactory((ConverterFactory&lt;?, ?&gt;) converter);
				}
</code></pre>
</li>
</ul>
<h2 id="编程式方式使用conversionservice"><a class="header" href="#编程式方式使用conversionservice">编程式方式使用<em>ConversionService</em></a></h2>
<pre><code class="language-java">@Service
public class MyService {

    public MyService(ConversionService conversionService) {
        this.conversionService = conversionService;
    }

    public void doIt() {
        this.conversionService.convert(...)
    }
}
</code></pre>
<p><strong>泛型集合转换</strong></p>
<pre><code class="language-java">DefaultConversionService cs = new DefaultConversionService();

List&lt;Integer&gt; input = ...
cs.convert(input,
    TypeDescriptor.forObject(input), // List&lt;Integer&gt; type descriptor
    TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));
</code></pre>
<ul>
<li><code>DefaultConversionService</code> 会自动注册内置<em>converters</em> 适合大部分环境, 包括 集合转换,基本类型转换,<em>ObjectToString</em> <em>converters</em> </li>
<li>可以在 <code>DefaultConversionService.addDefaultConverters</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="资源抽象"><a class="header" href="#资源抽象">资源抽象</a></h1>
<h2 id="类图-4"><a class="header" href="#类图-4">类图</a></h2>
<pre><code class="language-mermaid">classDiagram
class InputStreamSource{
	InputStream getInputStream()
}

InputStreamSource --|&gt; EncodedResource:带字符集指定的Resource

class Resource{
	isOpen
	isFile
	URL
	URI
	filename
	description
	boolean exists();
    long contentLength()
    long lastModified()
    Resource createRelative(String relativePath)
}

class ContextResource{
	String getPathWithinContext();
}

InputStreamSource --|&gt; Resource

Resource --|&gt; ContextResource:基于上下文的资源
Resource --|&gt; AbstractResource:实现基本的 exists contentLength lastModified
Resource --|&gt; WritableResource:可写的资源


AbstractResource --|&gt; DescriptiveResource:占位符，不用于实际读取
AbstractResource --|&gt; AbstractFileResolvingResource: 基于File
AbstractResource --|&gt; InputStreamResource:基于InputStream的Resource
AbstractResource --|&gt; FileSystemResource:基于文件系统的
AbstractResource --|&gt; ByteArrayResource:基于字节数组的
AbstractResource --|&gt; PathResource:基于Path对象的Resource

AbstractFileResolvingResource --|&gt; UrlResource:基于URL，URI的实现
AbstractFileResolvingResource --|&gt; ClassPathResource:基于classPath下的实现
AbstractFileResolvingResource  --|&gt; ServletContextResource:基于ServletContext的实现

</code></pre>
<h1 id="资源载入"><a class="header" href="#资源载入">资源载入</a></h1>
<ol>
<li>方便 载入resource </li>
<li>支持 通配符匹配</li>
</ol>
<h2 id="类图-5"><a class="header" href="#类图-5">类图</a></h2>
<pre><code class="language-mermaid">classDiagram
class ResourceLoader{
	ClassLoader getClassLoader();	
    Resource getResource(String location);	
}

class ResourcePatternResolver{
	Resource[] getResources(String locationPattern)
}

ResourceLoader--|&gt; ResourcePatternResolver:classpath*
ResourcePatternResolver --|&gt; PathMatchingResourcePatternResolver:路径匹配
PathMatchingResourcePatternResolver --|&gt; ServletContextResourcePatternResolver:基于ServletContext的路径匹配
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全局日期格式化"><a class="header" href="#全局日期格式化">全局日期格式化</a></h1>
<p>默认 使用<code>@DateTimeFormat</code> 注解的字段 ,,默认使用<code>DateFormat.SHORT</code> 风格, 可以修改全局默认</p>
<p>使用以下API 确保spring 不会自动注册默认</p>
<ul>
<li><code>org.springframework.format.datetime.standard.DateTimeFormatterRegistrar</code></li>
<li><code>org.springframework.format.datetime.DateFormatterRegistrar</code></li>
</ul>
<h1 id="示例-5"><a class="header" href="#示例-5">示例</a></h1>
<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean
    public FormattingConversionService conversionService() {

        // Use the DefaultFormattingConversionService but do not register defaults
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false);

        // Ensure @NumberFormat is still supported
        conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());

        // Register JSR-310 date conversion with a specific global format
        DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
        registrar.setDateFormatter(DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;));
        registrar.registerFormatters(conversionService);

        // Register date conversion with a specific global format
        DateFormatterRegistrar registrar = new DateFormatterRegistrar();
        registrar.setFormatter(new DateFormatter(&quot;yyyyMMdd&quot;));
        registrar.registerFormatters(conversionService);

        return conversionService;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&gt;

    &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
        &lt;property name=&quot;registerDefaultFormatters&quot; value=&quot;false&quot; /&gt;
        &lt;property name=&quot;formatters&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;org.springframework.format.number.NumberFormatAnnotationFormatterFactory&quot; /&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;property name=&quot;formatterRegistrars&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;org.springframework.format.datetime.standard.DateTimeFormatterRegistrar&quot;&gt;
                    &lt;property name=&quot;dateFormatter&quot;&gt;
                        &lt;bean class=&quot;org.springframework.format.datetime.standard.DateTimeFormatterFactoryBean&quot;&gt;
                            &lt;property name=&quot;pattern&quot; value=&quot;yyyyMMdd&quot;/&gt;
                        &lt;/bean&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-5"><a class="header" href="#前言-5">前言</a></h1>
<p>Enable注解原理 是通过 <em>@Import</em> 或者  <em>ImportSelector</em> 实现的自动注入相关类</p>
<h1 id="import注解"><a class="header" href="#import注解"><code>@Import</code>注解</a></h1>
<ul>
<li>
<p><code>@Import</code> 是<code>Spring</code>基于 Java 注解配置的主要组成部分</p>
</li>
<li>
<p><code>@Import</code>注解提供了<code>@Bean</code>注解的功能，同时还有原来<code>Spring</code>基于 xml 配置文件里的 <code>&lt;import&gt;</code>  标签组织多个分散的xml文件的功能，当然在这里是组织多个分散的<code>@Configuration</code>的类</p>
</li>
</ul>
<h1 id="import注解的功能"><a class="header" href="#import注解的功能"><code>@Import</code>注解的功能</a></h1>
<h2 id="引入其他的configuration"><a class="header" href="#引入其他的configuration">引入其他的<code>@Configuration</code></a></h2>
<pre><code class="language-java">package com.test
//载入ConfigB类：且ConfigB优先于  ConfigA
@Import(ConfigB.class)
@Configuration
class ConfigA {
    @Bean
    @ConditionalOnMissingBean
    public ServiceInterface getServiceA() {
        return new ServiceA();
    }
}

@Configuration
class ConfigB {
    @Bean
    @ConditionalOnMissingBean
    public ServiceInterface getServiceB() {
        return new ServiceB();
    }
}
</code></pre>
<h2 id="直接初始化其他类的bean"><a class="header" href="#直接初始化其他类的bean">直接初始化其他类的<code>Bean</code></a></h2>
<p><code>@Import</code>可以直接指定实体类，加载这个类定义到<code>context</code>中</p>
<pre><code class="language-java">//就会生成ServiceB的Bean到容器上下文中
@Import(ServiceB.class)
@Configuration
class ConfigA {
    @Bean
    @ConditionalOnMissingBean
    public ServiceInterface getServiceA() {
        return new ServiceA();
    }
}
</code></pre>
<h2 id="个性化加载"><a class="header" href="#个性化加载">个性化加载</a></h2>
<p>指定实现<code>ImportSelector</code>(以及<code>DefferredServiceImportSelector</code>)的类，用于个性化加载</p>
<p>Enable就是利用如此 特性实现 的</p>
<pre><code class="language-javascript">package com.test;

@Retention(RetentionPolicy.RUNTIME)
@Documented
@Target(ElementType.TYPE)
@Import(ServiceImportSelector.class)
@interface EnableService {
    String name();
}
//返回类的全限定类名
class ServiceImportSelector implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        //这里的importingClassMetadata针对的是使用@EnableService的非注解类
        //因为`AnnotationMetadata`是`Import`注解所在的类属性，如果所在类是注解类，则延伸至应用这个注解类的非注解类为止
        Map&lt;String , Object&gt; map = importingClassMetadata.getAnnotationAttributes(EnableService.class.getName(), true);
        String name = (String) map.get(&quot;name&quot;);
        if (Objects.equals(name, &quot;B&quot;)) {
            return new String[]{&quot;com.test.ConfigB&quot;};
        }
        return new String[0];
    }
}

package com.test;
@EnableService(name = &quot;B&quot;)
@Configuration
class ConfigA {
    @Bean
    @ConditionalOnMissingBean
    public ServiceInterface getServiceA() {
        return new ServiceA();
    }
}
</code></pre>
<p><em>DeferredImportSelector</em>  与selector的区别就是 是否延迟于当前注解类加载</p>
<h2 id="个性化定制bean"><a class="header" href="#个性化定制bean">个性化定制bean</a></h2>
<blockquote>
<p>手动构建bean定义</p>
</blockquote>
<pre><code class="language-java">package com.test;

@Retention(RetentionPolicy.RUNTIME)
@Documented
@Target(ElementType.TYPE)
@Import(ServiceImportBeanDefinitionRegistrar.class)
@interface EnableService {
    String name();
}

class ServiceImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        Map&lt;String, Object&gt; map = importingClassMetadata.getAnnotationAttributes(EnableService.class.getName(), true);
        String name = (String) map.get(&quot;name&quot;);
        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.rootBeanDefinition(ServiceC.class)
                //增加构造参数
                .addConstructorArgValue(name);
        //注册Bean
        registry.registerBeanDefinition(&quot;serviceC&quot;, beanDefinitionBuilder.getBeanDefinition());
    }
}
</code></pre>
<h1 id="源码分析-4"><a class="header" href="#源码分析-4">源码分析</a></h1>
<p>加载解析<code>@Import</code>注解位于<code>BeanFactoryPostProcessor</code>处理的时候：</p>
<p><strong>调用链</strong></p>
<pre><code class="language-java">AbstractApplicationContext.refresh
--&gt;
invokeBeanFactoryPostProcessors(beanFactory)
--&gt;
PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
--&gt;
(ConfigurationClassPostProcessor)registryProcessor.postProcessBeanDefinitionRegistry(registry);
--&gt;
processConfigBeanDefinitions(registry)
</code></pre>
<p><strong>核心处理流程</strong></p>
<pre><code class="language-java">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {
   List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();
   String[] candidateNames = registry.getBeanDefinitionNames();

   for (String beanName : candidateNames) {
      BeanDefinition beanDef = registry.getBeanDefinition(beanName);
      if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {
         if (logger.isDebugEnabled()) {
            logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);
         }
      }
      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
      }
   }

   // Return immediately if no @Configuration classes were found
   if (configCandidates.isEmpty()) {
      return;
   }
    //根据@Order注解，排序所有的@Configuration类
   // Sort by previously determined @Order value, if applicable
   configCandidates.sort((bd1, bd2) -&gt; {
      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());
      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());
      return Integer.compare(i1, i2);
   });

   // Detect any custom bean name generation strategy supplied through the enclosing application context
   SingletonBeanRegistry sbr = null;
   if (registry instanceof SingletonBeanRegistry) {
      sbr = (SingletonBeanRegistry) registry;
      if (!this.localBeanNameGeneratorSet) {
         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(
               AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);
         if (generator != null) {
            this.componentScanBeanNameGenerator = generator;
            this.importBeanNameGenerator = generator;
         }
      }
   }

   if (this.environment == null) {
      this.environment = new StandardEnvironment();
   }

    //创建ConfigurationClassParser解析@Configuration类
   // Parse each @Configuration class
   ConfigurationClassParser parser = new ConfigurationClassParser(
         this.metadataReaderFactory, this.problemReporter, this.environment,
         this.resourceLoader, this.componentScanBeanNameGenerator, registry);

   Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates);
   Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size());
   do {
      parser.parse(candidates);
      parser.validate();

      Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());
      configClasses.removeAll(alreadyParsed);

      // Read the model and create bean definitions based on its content
      if (this.reader == null) {
         this.reader = new ConfigurationClassBeanDefinitionReader(
               registry, this.sourceExtractor, this.resourceLoader, this.environment,
               this.importBeanNameGenerator, parser.getImportRegistry());
      }
      this.reader.loadBeanDefinitions(configClasses);
      alreadyParsed.addAll(configClasses);

      candidates.clear();
      if (registry.getBeanDefinitionCount() &gt; candidateNames.length) {
         String[] newCandidateNames = registry.getBeanDefinitionNames();
         Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames));
         Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;();
         for (ConfigurationClass configurationClass : alreadyParsed) {
            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());
         }
         for (String candidateName : newCandidateNames) {
            if (!oldCandidateNames.contains(candidateName)) {
               BeanDefinition bd = registry.getBeanDefinition(candidateName);
               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;
                     !alreadyParsedClasses.contains(bd.getBeanClassName())) {
                  candidates.add(new BeanDefinitionHolder(bd, candidateName));
               }
            }
         }
         candidateNames = newCandidateNames;
      }
   }
   while (!candidates.isEmpty());

   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes
   if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {
      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());
   }

   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {
      // Clear cache in externally provided MetadataReaderFactory; this is a no-op
      // for a shared cache since it'll be cleared by the ApplicationContext.
      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();
   }
}
</code></pre>
<h1 id="importaware"><a class="header" href="#importaware">@ImportAware</a></h1>
<ol>
<li>通过 <em>Import</em> 接口 注入的类 都可以接收到 注解的信息 <em>AnnotationMetadata</em></li>
<li>Import注入 的<em>Configuration</em> 后产生的类无法 注入ImportAware，只能是 一手类</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-6"><a class="header" href="#前言-6">前言</a></h1>
<p>基于代理的 自动注册类 都继承于 <em>AdviceModeImportSelector</em> 抽象类</p>
<h1 id="源码-2"><a class="header" href="#源码-2">源码</a></h1>
<pre><code class="language-java">public final String[] selectImports(AnnotationMetadata importingClassMetadata) {
    //获取实际泛型类
   Class&lt;?&gt; annType = GenericTypeResolver.resolveTypeArgument(getClass(), AdviceModeImportSelector.class);
   Assert.state(annType != null, &quot;Unresolvable type argument for AdviceModeImportSelector&quot;);

    //获取泛型属性对象
   AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);
   if (attributes == null) {
      throw new IllegalArgumentException(String.format(
            &quot;@%s is not present on importing class '%s' as expected&quot;,
            annType.getSimpleName(), importingClassMetadata.getClassName()));
   }
	//获取代理模式
   AdviceMode adviceMode = attributes.getEnum(getAdviceModeAttributeName());
    //子类根据不同代理模式：返回不同注入类
   String[] imports = selectImports(adviceMode);
   if (imports == null) {
      throw new IllegalArgumentException(&quot;Unknown AdviceMode: &quot; + adviceMode);
   }
   return imports;
}
</code></pre>
<h1 id="启用异步调用"><a class="header" href="#启用异步调用">启用异步调用</a></h1>
<p><strong>类选中逻辑</strong></p>
<pre><code class="language-java">public String[] selectImports(AdviceMode adviceMode) {
   switch (adviceMode) {
      case PROXY:
           //返回 异步配置Configuration类
         return new String[] {ProxyAsyncConfiguration.class.getName()};
      case ASPECTJ:
           //返回AspectJ代理类
         return new String[] {ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME};
      default:
         return null;
   }
}
</code></pre>
<p><strong>类注入逻辑</strong></p>
<pre><code class="language-java">//ProxyAsyncConfiguration
@Configuration
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
public class ProxyAsyncConfiguration extends AbstractAsyncConfiguration {

	@Bean(name = TaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME)
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
    //注入 异步注解后置处理器
	public AsyncAnnotationBeanPostProcessor asyncAdvisor() {
		Assert.notNull(this.enableAsync, &quot;@EnableAsync annotation metadata was not injected&quot;);
		AsyncAnnotationBeanPostProcessor bpp = new AsyncAnnotationBeanPostProcessor();
		bpp.configure(this.executor, this.exceptionHandler);
		Class&lt;? extends Annotation&gt; customAsyncAnnotation = this.enableAsync.getClass(&quot;annotation&quot;);
		if (customAsyncAnnotation != AnnotationUtils.getDefaultValue(EnableAsync.class, &quot;annotation&quot;)) {
			bpp.setAsyncAnnotationType(customAsyncAnnotation);
		}
		bpp.setProxyTargetClass(this.enableAsync.getBoolean(&quot;proxyTargetClass&quot;));
		bpp.setOrder(this.enableAsync.&lt;Integer&gt;getNumber(&quot;order&quot;));
		return bpp;
	}
}

//抽象类：
@Configuration
public abstract class AbstractAsyncConfiguration implements ImportAware {

	@Nullable
	protected AnnotationAttributes enableAsync;

	@Nullable
	protected Supplier&lt;Executor&gt; executor;

	@Nullable
	protected Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler;


	@Override
	public void setImportMetadata(AnnotationMetadata importMetadata) {
		this.enableAsync = AnnotationAttributes.fromMap(
				importMetadata.getAnnotationAttributes(EnableAsync.class.getName(), false));
		if (this.enableAsync == null) {
			throw new IllegalArgumentException(
					&quot;@EnableAsync is not present on importing class &quot; + importMetadata.getClassName());
		}
	}

	/**
	 * Collect any {@link AsyncConfigurer} beans through autowiring.
	 */
	@Autowired(required = false)
    //注入异步配置
	void setConfigurers(Collection&lt;AsyncConfigurer&gt; configurers) {
		if (CollectionUtils.isEmpty(configurers)) {
			return;
		}
		if (configurers.size() &gt; 1) {
			throw new IllegalStateException(&quot;Only one AsyncConfigurer may exist&quot;);
		}
		AsyncConfigurer configurer = configurers.iterator().next();
		this.executor = configurer::getAsyncExecutor;
		this.exceptionHandler = configurer::getAsyncUncaughtExceptionHandler;
	}
}
</code></pre>
<h1 id="启用缓存"><a class="header" href="#启用缓存">启用缓存</a></h1>
<p><strong>类选中逻辑</strong></p>
<pre><code class="language-java">//org.springframework.cache.annotation.CachingConfigurationSelector

	@Override
	public String[] selectImports(AdviceMode adviceMode) {
		switch (adviceMode) {
			case PROXY: //基于spring的代理
				return getProxyImports();
			case ASPECTJ://基于aspectj的代理
				return getAspectJImports();
			default:
				return null;
		}
	}

//spring代理
	private String[] getProxyImports() {
		List&lt;String&gt; result = new ArrayList&lt;&gt;(3);
        //注入 自动代理注册器：注册自动代理的类 org.springframework.aop.framework.autoproxy.InfrastructureAdvisorAutoProxyCreator
		result.add(AutoProxyRegistrar.class.getName());
        //注入缓存代理配置
		result.add(ProxyCachingConfiguration.class.getName());
		if (jsr107Present &amp;&amp; jcacheImplPresent) {
			result.add(PROXY_JCACHE_CONFIGURATION_CLASS);
		}
		return StringUtils.toStringArray(result);
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dispatcherservlet"><a class="header" href="#dispatcherservlet">DispatcherServlet</a></h1>
<ul>
<li>
<p>Spring MVC, 与其他Web框架一样,基于  central <code>Servlet</code>的控制器模式， the <code>DispatcherServlet</code>, 提供了一个共享的 请求处理算法，实际工作交给 其他配置配置的组件执行，这个模型是可弹性的，可划分工作流的</p>
</li>
<li>
<p>The <code>DispatcherServlet</code>, as any <code>Servlet</code>, 需要被申明，要么通过 Java配置指定，要么通过 web.xml 申明，然后, the <code>DispatcherServlet</code> </p>
<p>使用spring注解，发现实际处理请求的 组件, 例如 视图解析器, 异常处理以及其他</p>
</li>
<li>
<p>下面的Java配置注册，并实例化一个 <code>DispatcherServlet</code> ，被<em>ServletContainer</em> 自动 发现(see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-container-config">Servlet Config</a>):</p>
</li>
</ul>
<pre><code class="language-java">public class MyWebApplicationInitializer implements WebApplicationInitializer {
    @Override
    public void onStartup(ServletContext servletContext) {
        // Load Spring web application configuration,实例化容器
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        context.register(AppConfig.class);

        // Create and register the DispatcherServlet
        DispatcherServlet servlet = new DispatcherServlet(context); //注册servlet
        ServletRegistration.Dynamic registration = servletContext.addServlet(&quot;app&quot;, servlet);
        registration.setLoadOnStartup(1);
        registration.addMapping(&quot;/app/*&quot;);
    }
}
</code></pre>
<p>在 <em>Servlet3.0</em> 环境中，编程式配置 <em>ServletContext</em> 所要实现的接口 （与 <em>web.xml</em> 配置 相反）</p>
<p>这个 <em>SPI</em> 的实现类都会被 <em>SpringServletContainerInitializer</em> 自动检测到</p>
<h1 id="contexthierarchy"><a class="header" href="#contexthierarchy">ContextHierarchy</a></h1>
<h2 id="介绍-9"><a class="header" href="#介绍-9">介绍</a></h2>
<ul>
<li><em>DispatcherServlet</em> 需要 <em>WebApplicationContext</em> 作为配置来源</li>
<li>一般 一个 <em>WebApplicationContext</em>  对应一个 <em>Servlet</em> </li>
<li>多个Servlet 对应 多个 <em>WebApplicationContext</em>  ，且共享 一个 <em>RootWebApplicationContext</em> ，共享一些基础设施的 Bean对象，例如 数据访问，通用业务服务</li>
</ul>
<p><img src="11.spring_SpringWebMvc/../images/mvc-context-hierarchy.png" alt="servletContext继承图" /></p>
<h2 id="配置contexthierarchy"><a class="header" href="#配置contexthierarchy">配置<em>ContextHierarchy</em></a></h2>
<pre><code class="language-java">public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return new Class&lt;?&gt;[] { RootConfig.class };
    }

    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class&lt;?&gt;[] { App1Config.class };
    }

    @Override
    protected String[] getServletMappings() {
        return new String[] { &quot;/app1/*&quot; };
    }
}
</code></pre>
<p><strong>相对应的XML配置</strong></p>
<pre><code class="language-xml">&lt;web-app&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/root-context.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;app1&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;/WEB-INF/app1-context.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;app1&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/app1/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;

</code></pre>
<h1 id="special-bean-types"><a class="header" href="#special-bean-types">Special Bean Types</a></h1>
<ul>
<li><code>DispatcherServlet</code> 委托各个不同的bean处理 不同的请求，渲染合适的响应</li>
<li><code>special beans</code> 意思是 spring管理的 对象</li>
<li>以下表格列出的 被 <code>DispatcherServlet</code> 检测到的   special beans </li>
</ul>
<table><thead><tr><th style="text-align: left">Bean type</th><th style="text-align: left">Explanation</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>HandlerMapping</code></td><td style="text-align: left">通过一系列 拦截器 将请求映射给 <em>handler</em> <br />不通的 <em>handleMapping</em> 映射逻辑各有不同<br />有两个主要的 实现 <br /><code>RequestMappingHandlerMapping</code> (支持@RequestMapping注解) <br /><code>SimpleUrlHandlerMapping</code> (维护 显示的 URLPattern To Handler的 注册)</td></tr>
<tr><td style="text-align: left"><code>HandlerAdapter</code></td><td style="text-align: left">Help the <code>DispatcherServlet</code> to invoke a handler mapped to a request,</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-exceptionhandlers"><code>HandlerExceptionResolver</code></a></td><td style="text-align: left">异常处理策略, 通常把 异常 映射到 handler，HTML error views, or other targets. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-exceptionhandlers">Exceptions</a>.</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-viewresolver"><code>ViewResolver</code></a></td><td style="text-align: left">Resolve logical <code>String</code>-based view names returned from a handler to an actual <code>View</code> with which to render to the response. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-viewresolver">View Resolution</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-view">View Technologies</a>.</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-localeresolver"><code>LocaleResolver</code></a>, <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-timezone">LocaleContextResolver</a></td><td style="text-align: left">解决客户端国际化问题</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-themeresolver"><code>ThemeResolver</code></a></td><td style="text-align: left">Resolve themes your web application can use — for example, to offer personalized layouts. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-themeresolver">Themes</a>.</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart"><code>MultipartResolver</code></a></td><td style="text-align: left">Abstraction for parsing a multi-part request (for example, browser form file upload) with the help of some multipart parsing library. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart">Multipart Resolver</a>.</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-flash-attributes"><code>FlashMapManager</code></a></td><td style="text-align: left">Store and retrieve the “input” and the “output” <code>FlashMap</code> that can be used to pass attributes from one request to another, usually across a redirect. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-flash-attributes">Flash Attributes</a>.</td></tr>
</tbody></table>
<p>核心功能包括 handler映射，handler方法执行，handler异常处理，handler返回视图解析，</p>
<p>其他功能包括 客户端国际化，主题，文件上传，跨请求数据共享</p>
<h1 id="web-mvc-config"><a class="header" href="#web-mvc-config">Web MVC Config</a></h1>
<blockquote>
<p>配置 sepcial beans</p>
</blockquote>
<p>可以在容器中申明 以上提到的 <em>special beans</em> ,<code>DispatcherServlet</code>  会检查容器中的 <em>special bean</em> 如果不存在则使用声明在 <code>DispatcherServlet.properties</code> 的默认实现，</p>
<h1 id="servlet-config"><a class="header" href="#servlet-config">Servlet Config</a></h1>
<p><em>Servlet3.0</em>+ 环境中，你可以选择以 编程方式申明 Servlet容器，或者 结合 <em>web.xml</em>，以下配置 注册了一个 <code>DispatcherServlet</code></p>
<pre><code class="language-java">import org.springframework.web.WebApplicationInitializer;

public class MyWebApplicationInitializer implements WebApplicationInitializer {

    @Override
    public void onStartup(ServletContext container) {
        XmlWebApplicationContext appContext = new XmlWebApplicationContext();
        appContext.setConfigLocation(&quot;/WEB-INF/spring/dispatcher-config.xml&quot;);
        
        ServletRegistration.Dynamic registration = container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(appContext));
        registration.setLoadOnStartup(1);
        registration.addMapping(&quot;/&quot;);
    }
}
</code></pre>
<p><code>WebApplicationInitializer</code> 由springMVC提供的接口，确保你的实现能够被自动 使用，用来初始化 任何 <em>Servlet3</em> 容器，</p>
<p>抽象基类  <code>AbstractDispatcherServletInitializer</code> 使之更简单的 注册一个 <code>DispatcherServlet</code>  ，只要指定 servletMapping,和 <code>DispatcherServlet</code>  的 配置文件的位置，当然更推荐用以下方式 配置</p>
<p><strong>基于Java的Servlet配置</strong></p>
<pre><code class="language-java">public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return null;
    }

    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class&lt;?&gt;[] { MyWebConfig.class };
    }

    @Override
    protected String[] getServletMappings() {
        return new String[] { &quot;/&quot; };
    }
}
</code></pre>
<p><strong>使用XML配置的方式</strong></p>
<pre><code class="language-java">public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

    @Override
    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }

    @Override
    protected WebApplicationContext createServletApplicationContext() {
        XmlWebApplicationContext cxt = new XmlWebApplicationContext();
        cxt.setConfigLocation(&quot;/WEB-INF/spring/dispatcher-config.xml&quot;);
        return cxt;
    }

    @Override
    protected String[] getServletMappings() {
        return new String[] { &quot;/&quot; };
    }
}
</code></pre>
<p><strong>给<em>Servlet</em>注册 <em>Filter</em></strong></p>
<pre><code class="language-java">public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

    // ...

    @Override
    protected Filter[] getServletFilters() {
        return new Filter[] {
            new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };
    }
}
</code></pre>
<p>每一个<em>Filter</em> 会使用 具体类名进行命名，自动映射到 <code>DispatcherServlet</code></p>
<p>The <code>isAsyncSupported</code> protected method of <code>AbstractDispatcherServletInitializer</code>提供了一个 地方 在 <code>DispatcherServlet</code> 和所有映射到它身上的 <em>filters</em> 异步支持</p>
<p>默认为 <em>true</em></p>
<p>如果你需要 更加定制化，则 <code>createDispatcherServlet</code>  方法</p>
<h1 id="processing"><a class="header" href="#processing">Processing</a></h1>
<p>The <code>DispatcherServlet</code> 请求处理过程</p>
<ul>
<li>查询 <code>WebApplicationContext</code>  ，并绑定在 请求中，作为一个属性，供<em>Controller</em> 和其他元素使用，默认 绑定的Key是   <code>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</code> </li>
<li>给请求绑定 <em>locale resolver</em>  ，以便 让 元素 在处理过程中， 解析 locale</li>
<li>theme resolver 绑定主题解析器 给请求，  能构让 视图呈现不通的布局样式</li>
<li>如果你指定了 multipart file resolver, 就会检查请求是否 是<em>multipart</em>. 如果是<em>multipart</em> ，将会以<code>MultipartHttpServletRequest</code> 包装. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart">Multipart Resolver</a> for further information about multipart handling.</li>
<li>查找 指定的 <em>Handler</em>. 如果找到 ，跟执行链相关的 handler（预处理器，后处理器，控制器等）会被执行以渲染 视图响应，对于基础注解的控制器，响应能够被在 <code>HandlerAdapter</code> 中渲染，而不需要返回一个视图</li>
<li>如果 <em>model</em> 返回，则渲染视图，如果没有model返回，则不渲染视图，因为请求可能已经被 处理了</li>
</ul>
<p><code>HandlerExceptionResolver</code>  是为了处理异常，</p>
<p><code>DispatcherServlet</code> 同样支持 指定返回的  <code>last-modification-date</code> 通过Servlet API提供</p>
<p>确定特定请求的 上次修改日期 很简单，<code>DispatcherServlet</code>查找合适的 <em>handler</em>时，会判断它是否 实现了<code>LastModified</code> 接口，如果实现了则返回给 客户端</p>
<p>你能够自定义 独立的<code>DispatcherServlet</code>  实例，通过 向 <code>web.xml</code> servlet申明中，添加  Servlet initialization parameters</p>
<p>以下是支持的参数：</p>
<table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Explanation</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>contextClass</code></td><td style="text-align: left">spring容器的类，必须要实现 <code>ConfigurableWebApplicationContext</code>，由该 <em>Servlet</em>实例化<br />默认使用 <em>XmlWebApplicationContext</em></td></tr>
<tr><td style="text-align: left">`contextConfigLocation</td><td style="text-align: left">XML配置路径<br />逗号分隔支持的多个Context. 重复定义的bean，最近优先</td></tr>
<tr><td style="text-align: left"><code>namespace</code></td><td style="text-align: left">Namespace of the <code>WebApplicationContext</code>. Defaults to <code>[servlet-name]-servlet</code>.</td></tr>
<tr><td style="text-align: left"><code>throwExceptionIfNoHandlerFound</code></td><td style="text-align: left">如果没有handler找到，要不要抛  <code>NoHandlerFoundException</code> <br />这个异常可以被 <code>HandlerExceptionResolver</code>捕获<br />(例如, by using an <code>@ExceptionHandler</code> controller method) <br />默认false, <br /> 如果false,<code>DispatcherServlet</code> sets the response status to 404 (NOT_FOUND) without raising an exception.<br />Note that, if <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-default-servlet-handler">default servlet handling</a> is also configured, unresolved requests are always forwarded to the default servlet and a 404 is never raised.</td></tr>
</tbody></table>
<h1 id="interception"><a class="header" href="#interception">Interception</a></h1>
<p>所有 <code>HandlerMapping</code> 的实现都支持 拦截器，例如 身份检查。</p>
<p>拦截器实现 <code>HandlerInterceptor</code>   <code>org.springframework.web.servlet</code> 包下。</p>
<ul>
<li><code>preHandle(..)</code>: Before the actual handler is run
<ul>
<li>返回true才能继续执行</li>
<li>返回true，<code>DispatcherServlet</code> 认为 拦截器本身已处理了请求，然后渲染合适的视图</li>
</ul>
</li>
<li><code>postHandle(..)</code>: After the handler is run</li>
<li><code>afterCompletion(..)</code>: After the complete request has finished</li>
</ul>
<p>See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-interceptors">Interceptors</a> in the section on MVC configuration for examples of how to configure interceptors. </p>
<p>你可以在 各自<code>HandlerMapping</code>  实现里 使用 setters 直接注册 </p>
<p><strong>注意</strong> <code>postHandle</code> 和  <code>@ResponseBody</code> and <code>ResponseEntity</code> 方法一起使用用处不大，因为响应已经在 <em>posthandler</em> 执行前 被 写入，提交</p>
<p>，无法对 响应做改变。例如添加额外的头，对于这种场景，建议使用  <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-controller-advice">Controller Advice</a> ，要么实现 <code>ResponseBodyAdvice</code>  要么申明为 <em>ControllerAdvice</em> 要么 直接配置在 <code>RequestMappingHandlerAdapter</code></p>
<h1 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h1>
<h2 id="异常实现类"><a class="header" href="#异常实现类">异常实现类</a></h2>
<p>如果在执行请求处理过程中发生异常，<code>DispatcherServlet</code> 将它 交给 <code>HandlerExceptionResolver</code>  bean做处理，</p>
<p>以下表列出了 <code>HandlerExceptionResolver</code> implementations:</p>
<table><thead><tr><th style="text-align: left"><code>HandlerExceptionResolver</code></th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>SimpleMappingExceptionResolver</code></td><td style="text-align: left">异常类与 错误视图的映射处理器</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html"><code>DefaultHandlerExceptionResolver</code></a></td><td style="text-align: left">Resolves exceptions raised by Spring MVC and maps them to HTTP status codes. See also alternative <code>ResponseEntityExceptionHandler</code> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-rest-exceptions">REST API exceptions</a>.</td></tr>
<tr><td style="text-align: left"><code>ResponseStatusExceptionResolver</code></td><td style="text-align: left">Resolves exceptions with the <code>@ResponseStatus</code> annotation and maps them to HTTP status codes based on the value in the annotation.</td></tr>
<tr><td style="text-align: left"><code>ExceptionHandlerExceptionResolver</code></td><td style="text-align: left">Resolves exceptions by invoking an <code>@ExceptionHandler</code> method in a <code>@Controller</code> or a <code>@ControllerAdvice</code> class. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-exceptionhandler">@ExceptionHandler methods</a>.</td></tr>
</tbody></table>
<h2 id="chain-of-resolvers"><a class="header" href="#chain-of-resolvers">Chain of Resolvers</a></h2>
<p>You can form an exception resolver chain by declaring multiple <code>HandlerExceptionResolver</code> beans in your Spring configuration</p>
<p>您可以通过在Spring配置中声明多个<code>HandlerExceptionResolver</code> bean来形成异常解析器链。必要时可以设置顺序，顺序越高，链中的位置越后</p>
<p><code>HandlerExceptionResolver</code>接口的返回值</p>
<ul>
<li>a <code>ModelAndView</code> that points to an error view.</li>
<li>An empty <code>ModelAndView</code> if the exception was handled within the resolver.</li>
<li><code>null</code> if the exception remains unresolved, for subsequent resolvers to try, and, if the exception remains at the end, it is allowed to bubble up to the Servlet container.</li>
</ul>
<p>The <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config">MVC Config</a> automatically declares built-in resolvers for default Spring MVC exceptions, for <code>@ResponseStatus</code> annotated exceptions, and for support of <code>@ExceptionHandler</code> methods. You can customize that list or replace it.</p>
<h2 id="container-error-page"><a class="header" href="#container-error-page">Container Error Page</a></h2>
<p>If an exception remains unresolved by any <code>HandlerExceptionResolver</code> and is,</p>
<p>如果任何 异常处理 都没有解决异常，则让它继续传播，Servlet containers能够渲染 默认的HTML错误视图，自定义容器默认错误页，可以在 <em>web.xml</em> 指定错误页</p>
<pre><code class="language-xml">&lt;error-page&gt;
    &lt;location&gt;/error&lt;/location&gt;
&lt;/error-page&gt;
</code></pre>
<p>Given the preceding example, when an exception bubbles up or the response has an error status, </p>
<p>the Servlet container makes an ERROR dispatch within the container to the configured URL (for example, <code>/error</code>). This is then processed by the <code>DispatcherServlet</code>, possibly mapping it to a <code>@Controller</code>, which could be implemented to return an error view name with a model or to render a JSON response, as the following example shows:</p>
<p>基于前面的示例，当异常冒出或响应具有错误状态时，Servlet容器在容器内向配置的URL（例如，/ error）进行ERROR调度。
然后由DispatcherServlet处理，可能将其映射到@Controller，可以实现返回错误视图名称或呈现JSON响应，如以下示例所示：</p>
<pre><code class="language-java">@RestController
public class ErrorController {

    @RequestMapping(path = &quot;/error&quot;)
    public Map&lt;String, Object&gt; handle(HttpServletRequest request) {
        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put(&quot;status&quot;, request.getAttribute(&quot;javax.servlet.error.status_code&quot;));
        map.put(&quot;reason&quot;, request.getAttribute(&quot;javax.servlet.error.message&quot;));
        return map;
    }
}
</code></pre>
<blockquote>
<p>The Servlet API does not provide a way to create error page mappings in Java. You can, however, use both a <code>WebApplicationInitializer</code> and a minimal <code>web.xml</code>.</p>
</blockquote>
<h1 id="view-resolution"><a class="header" href="#view-resolution">View Resolution</a></h1>
<h2 id="viewresolver"><a class="header" href="#viewresolver">ViewResolver</a></h2>
<p><code>ViewResolver</code> 提供 view 名称与 实际 view的映射关系</p>
<p>在移交给特定的视图渲染技术之前。  <code>View</code> 主要是用来准备数据 </p>
<p>以下是 <code>ViewResolver</code>的继承结构</p>
<table><thead><tr><th style="text-align: left">ViewResolver</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>AbstractCachingViewResolver</code></td><td style="text-align: left">视图缓存</td></tr>
<tr><td style="text-align: left"><code>UrlBasedViewResolver</code></td><td style="text-align: left">将URL直接映射到 视图.</td></tr>
<tr><td style="text-align: left"><code>InternalResourceViewResolver</code></td><td style="text-align: left">Convenient subclass of <code>UrlBasedViewResolver</code> that supports <code>InternalResourceView</code> (in effect, Servlets and JSPs) and subclasses such as <code>JstlView</code> and <code>TilesView</code>. You can specify the view class for all views generated by this resolver by using <code>setViewClass(..)</code>.</td></tr>
<tr><td style="text-align: left"><code>FreeMarkerViewResolver</code></td><td style="text-align: left">Convenient subclass of <code>UrlBasedViewResolver</code> that supports <code>FreeMarkerView</code> and custom subclasses of them.</td></tr>
<tr><td style="text-align: left"><code>ContentNegotiatingViewResolver</code></td><td style="text-align: left">Implementation of the <code>ViewResolver</code> interface that resolves a view based on the request file name or <code>Accept</code> header. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multiple-representations">Content Negotiation</a>.</td></tr>
<tr><td style="text-align: left"><code>BeanNameViewResolver</code></td><td style="text-align: left">Implementation of the <code>ViewResolver</code> interface that interprets a view name as a bean name in the current application context. This is a very flexible variant which allows for mixing and matching different view types based on distinct view names. Each such <code>View</code> can be defined as a bean e.g. in XML or in configuration classes.</td></tr>
</tbody></table>
<h1 id="locale"><a class="header" href="#locale">Locale</a></h1>
<p>spring大部分 架构支持国际化，springMVC也支持</p>
<p><code>DispatcherServlet</code> 根据 客户端的 <em>locale</em> 自动解析消息，通过 <code>LocaleResolver</code>  实现</p>
<p>当请求过来时，<code>DispatcherServlet</code> 查找 <em>locale resolver</em>  ，一旦找到一个，则尝试设置 <em>locale</em></p>
<p>使用  <code>RequestContext.getLocale()</code> 可也始终获得  locale resolve 解析的 <em>locale</em></p>
<p>另外，为了自动 locale解析，可以给 <em>handlerMapping</em> 添加 locale解析器，这适用于 根据 请求参数 改变<em>locale</em></p>
<p>以下类是常见的 locale解析实现， 定义在 org.springframework.web.servlet.i18n 包下，</p>
<ul>
<li>Time Zone</li>
</ul>
<p>In addition to obtaining the client’s locale, it is often useful to know its time zone. The <code>LocaleContextResolver</code> interface offers an extension to <code>LocaleResolver</code> that lets resolvers provide a richer <code>LocaleContext</code>, which may include time zone information.</p>
<p>When available, the user’s <code>TimeZone</code> can be obtained by using the <code>RequestContext.getTimeZone()</code> method. Time zone information is automatically used by any Date/Time <code>Converter</code> and <code>Formatter</code> objects that are registered with Spring’s <code>ConversionService</code>.</p>
<ul>
<li>Header Resolver</li>
</ul>
<p>解析客户端传过来的  <code>accept-language</code> 请求头，不支持时区信息</p>
<ul>
<li>
<p>Cookie Resolver</p>
<ul>
<li>检查 <em>Cookie</em> 钟可能会存在的   <code>Locale</code> or <code>TimeZone</code></li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;localeResolver&quot; class=&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;&gt;

    &lt;property name=&quot;cookieName&quot; value=&quot;clientlanguage&quot;/&gt;

    &lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;
    &lt;property name=&quot;cookieMaxAge&quot; value=&quot;100000&quot;/&gt;

&lt;/bean&gt;
</code></pre>
<p>| Property       | Default                   | Description                                                  |
| :------------- | :------------------------ | :----------------------------------------------------------- |
| <code>cookieName</code>   | classname + LOCALE        | The name of the cookie                                       |
| <code>cookieMaxAge</code> | Servlet container default | The maximum time a cookie persists on the client. If <code>-1</code> is specified, the cookie will not be persisted. It is available only until the client shuts down the browser. |
| <code>cookiePath</code>   | /                         | Limits the visibility of the cookie to a certain part of your site. When <code>cookiePath</code> is specified, the cookie is visible only to that path and the paths below it. |</p>
</li>
<li>
<p>Session Resolver</p>
</li>
</ul>
<p>从<em>session</em> 中取 <em>Locale and TimeZone</em> ，将本地请求的语言环境，设置在 <em>Session</em></p>
<ul>
<li>Locale Interceptor</li>
</ul>
<p>可以给 任何<code>HandlerMapping</code>  定义 应用 该 拦截器，</p>
<p>它检查请求中的参数，并改变<em>locale</em> ，以下是实例</p>
<pre><code class="language-xml">&lt;bean id=&quot;localeChangeInterceptor&quot;
        class=&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;&gt;
    &lt;property name=&quot;paramName&quot; value=&quot;siteLanguage&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;localeResolver&quot;
        class=&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;/&gt;

&lt;bean id=&quot;urlMapping&quot;
        class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
    &lt;property name=&quot;interceptors&quot;&gt;
        &lt;list&gt;
            &lt;ref bean=&quot;localeChangeInterceptor&quot;/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;mappings&quot;&gt;
        &lt;value&gt;/**/*.view=someController&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h1 id="themes"><a class="header" href="#themes">Themes</a></h1>
<p>您可以应用Spring Web MVC框架主题来设置应用程序的整体外观</p>
<p>主题是 静态资源的集合，包括样式表，图片等等</p>
<h2 id="defining-a-theme"><a class="header" href="#defining-a-theme">Defining a theme</a></h2>
<p>首先实现 <code>org.springframework.ui.context.ThemeSource</code> 接口</p>
<p><code>WebApplicationContext</code>  实现了 <code>ThemeSource</code>接口，但它的实现委托给了特定的实现，默认是  <code>org.springframework.ui.context.support.ResourceBundleThemeSource</code> 这个实现，从 <em>classpath</em> 根路径加载资源</p>
<p>自定义实现，需要主动往容器中 注入 一个 themeSource</p>
<p>当您使用<code>ResourceBundleThemeSource</code>时，将在一个简单的属性文件中定义一个主题。
属性文件列出了组成主题的资源，如以下示例所示：</p>
<pre><code>styleSheet=/themes/cool/style.css
background=/themes/cool/img/coolBg.jpg
</code></pre>
<p>属性的键是从 视图 引用主题元素的名称。</p>
<p>对于  JSP 使用 <code>spring:theme</code>  标签</p>
<pre><code class="language-html">&lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot;%&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;spring:theme code='styleSheet'/&gt;&quot; type=&quot;text/css&quot;/&gt;
    &lt;/head&gt;
    &lt;body style=&quot;background=&lt;spring:theme code='background'/&gt;&quot;&gt;
        ...
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>默认的，<code>ResourceBundleThemeSource</code> 使用空 前缀，从 <em>classpath</em> 加载<em>properties files</em></p>
<h2 id="resolving-themes"><a class="header" href="#resolving-themes">Resolving Themes</a></h2>
<p>定义完之后，要使用，<code>DispatcherServlet</code>查找 名为 <code>themeResolver</code> 的bean，以下是已有的实现</p>
<table><thead><tr><th style="text-align: left">Class</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>FixedThemeResolver</code></td><td style="text-align: left">Selects a fixed theme, set by using the <code>defaultThemeName</code> property.</td></tr>
<tr><td style="text-align: left"><code>SessionThemeResolver</code></td><td style="text-align: left">The theme is maintained in the user’s HTTP session. It needs to be set only once for each session but is not persisted between sessions.</td></tr>
<tr><td style="text-align: left"><code>CookieThemeResolver</code></td><td style="text-align: left">The selected theme is stored in a cookie on the client.</td></tr>
</tbody></table>
<p>Spring also provides a <code>ThemeChangeInterceptor</code> that lets theme changes on every request with a simple request parameter.</p>
<h1 id="multipart-resolver"><a class="header" href="#multipart-resolver">Multipart Resolver</a></h1>
<p><code>MultipartResolver</code>  属于  <code>org.springframework.web.multipart</code>  包，是 解析 多部件请求包括文件上传 的 策略类</p>
<p>有一个实现类是 基于 <a href="https://jakarta.apache.org/commons/fileupload">Commons FileUpload</a>   有一个是 基于  Servlet 3.0 multipart request parsing</p>
<p>要启用 多部件解析，需要声明 <code>MultipartResolver</code>  ，且bean名 为 <code>multipartResolver</code></p>
<p>When a POST with content-type of <code>multipart/form-data</code> is received，<code>HttpServletRequest</code> 会被包装成<code>MultipartHttpServletRequest</code> </p>
<h5 id="apache-commons-fileupload"><a class="header" href="#apache-commons-fileupload">Apache Commons <code>FileUpload</code></a></h5>
<p>使用  Apache Commons <code>FileUpload</code>，需要配置bean名为   <code>multipartResolver</code>  的  <code>CommonsMultipartResolver</code> </p>
<p>需要引入 <code>commons-fileupload</code>依赖</p>
<h5 id="servlet-30"><a class="header" href="#servlet-30">Servlet 3.0</a></h5>
<p>Servlet 3.0 multipart parsing needs to be enabled through Servlet container configuration. To do so:</p>
<ul>
<li>In Java, set a <code>MultipartConfigElement</code> on the Servlet registration.注册<em>MultipartConfigElement</em> </li>
</ul>
<pre><code class="language-java">public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    // ...

    @Override
    protected void customizeRegistration(ServletRegistration.Dynamic registration) {

        // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold
        registration.setMultipartConfig(new MultipartConfigElement(&quot;/tmp&quot;));
    }

}
</code></pre>
<ul>
<li>In <code>web.xml</code>, add a <code>&quot;&lt;multipart-config&gt;&quot;</code> section to the servlet declaration.</li>
</ul>
<p>一旦 Servlet3.0配置好之后, you can add a bean of type <code>StandardServletMultipartResolver</code> with a name of <code>multipartResolver</code>.</p>
<h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>Spring MVC中的DEBUG级别的日志记录旨在紧凑，最少且人性化</p>
<p><strong>Sensitive Data</strong></p>
<p>DEBUG and TRACE logging may log sensitive information. </p>
<p>需要启用 <code>DispatcherServlet</code> 的 <code>enableLoggingRequestDetails</code> 属性</p>
<pre><code class="language-java">public class MyInitializer
        extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return ... ;
    }

    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return ... ;
    }

    @Override
    protected String[] getServletMappings() {
        return ... ;
    }

    @Override
    protected void customizeRegistration(ServletRegistration.Dynamic registration) {
        registration.setInitParameter(&quot;enableLoggingRequestDetails&quot;, &quot;true&quot;);
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-4"><a class="header" href="#简介-4">简介</a></h1>
<p>本部分介绍了Spring框架中可用于URI的各种选项。</p>
<h1 id="uricomponents"><a class="header" href="#uricomponents">UriComponents</a></h1>
<p>UriComponentsBuilder有助于从具有变量的URI模板中构建URI，如以下示例所示：</p>
<pre><code class="language-java">UriComponents uriComponents = UriComponentsBuilder
        .fromUriString(&quot;https://example.com/hotels/{hotel}&quot;)  
        .queryParam(&quot;q&quot;, &quot;{q}&quot;)  
        .encode() 
        .build(); 

URI uri = uriComponents.expand(&quot;Westin&quot;, &quot;123&quot;).toUri();  
</code></pre>
<p>可以将前面的示例合并为一个链，并通过buildAndExpand进行缩短，如以下示例所示：</p>
<pre><code>URI uri = UriComponentsBuilder
        .fromUriString(&quot;https://example.com/hotels/{hotel}&quot;)
        .queryParam(&quot;q&quot;, &quot;{q}&quot;)
        .encode()
        .buildAndExpand(&quot;Westin&quot;, &quot;123&quot;)
        .toUri();
</code></pre>
<p>您可以通过直接转到URI（这意味着编码）来进一步缩短它，如以下示例所示：</p>
<pre><code class="language-java">URI uri = UriComponentsBuilder
        .fromUriString(&quot;https://example.com/hotels/{hotel}&quot;)
        .queryParam(&quot;q&quot;, &quot;{q}&quot;)
        .build(&quot;Westin&quot;, &quot;123&quot;);
</code></pre>
<p>您可以使用完整的URI模板进一步缩短它，如以下示例所示：</p>
<pre><code class="language-java">URI uri = UriComponentsBuilder
        .fromUriString(&quot;https://example.com/hotels/{hotel}?q={q}&quot;)
        .build(&quot;Westin&quot;, &quot;123&quot;);
</code></pre>
<h1 id="uribuilder"><a class="header" href="#uribuilder">UriBuilder</a></h1>
<ul>
<li>UriComponentsBuilder实现UriBuilder。</li>
<li>您可以依次使用UriBuilderFactory创建UriBuilder。 </li>
<li>UriBuilderFactory和UriBuilder一起提供了一种可插入的机制，</li>
<li>可以基于共享配置（例如基本URL，编码首选项和其他详细信息）从URI模板构建URI。</li>
<li>您可以使用UriBuilderFactory配置RestTemplate和WebClient以自定义URI的准备。 </li>
<li>DefaultUriBuilderFactory是UriBuilderFactory的默认实现，该实现在内部使用UriComponentsBuilder并公开共享的配置选项。
以下示例显示如何配置RestTemplate：</li>
</ul>
<pre><code class="language-java">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;

String baseUrl = &quot;https://example.org&quot;;
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

RestTemplate restTemplate = new RestTemplate();
restTemplate.setUriTemplateHandler(factory);
</code></pre>
<p>The following example configures a <code>WebClient</code>:</p>
<pre><code class="language-java">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;

String baseUrl = &quot;https://example.org&quot;;
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

WebClient client = WebClient.builder().uriBuilderFactory(factory).build();
</code></pre>
<p>此外，您也可以直接使用DefaultUriBuilderFactory。
它类似于使用UriComponentsBuilder，但不是静态工厂方法，它是一个包含配置和首选项的实际实例，如以下示例所示：</p>
<pre><code class="language-java">String baseUrl = &quot;https://example.com&quot;;
DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl);

URI uri = uriBuilderFactory.uriString(&quot;/hotels/{hotel}&quot;)
        .queryParam(&quot;q&quot;, &quot;{q}&quot;)
        .build(&quot;Westin&quot;, &quot;123&quot;);
</code></pre>
<h1 id="uri-encoding"><a class="header" href="#uri-encoding">URI Encoding</a></h1>
<p><code>UriComponentsBuilder</code> exposes encoding options at two levels:</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html#encode--">UriComponentsBuilder#encode()</a>: Pre-encodes the URI template first and then strictly encodes URI variables when expanded.</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">UriComponents#encode()</a>: Encodes URI components <em>after</em> URI variables are expanded.</li>
</ul>
<p>这两个选项都使用转义的八位字节替换非ASCII和非法字符。
但是，第一个选项还会替换出现在URI变量中的具有保留含义的字符。</p>
<p>思考 “;&quot; 这在路径上是合法的，但具有保留的含义。
第一个选项代替“;”  URI变量中带有“％3B”，但URI模板中没有。 相比之下，第二个选项永远不会替换“;”，因为它是路径中的合法字符。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-5"><a class="header" href="#简介-5">简介</a></h1>
<ul>
<li>
<p>Spring Web MVC包含WebMvc.fn，这是一个轻量级的函数编程模型，其中的函数用于路由和处理请求，而接口则是为不变性而设计的。
它是基于注解的编程模型的替代方案，但可以在同一DispatcherServlet上运行。</p>
</li>
<li>
<p>在WebMvc.fn中，HTTP请求由HandlerFunction处理：该函数接受ServerRequest并返回ServerResponse。
请求和响应对象都具有不可变的约定，这些约定为JDK 8提供了对HTTP请求和响应的友好访问。 
<em>HandlerFunction</em> 等效于基于注解的编程模型中@RequestMapping方法的主体。</p>
</li>
<li>
<p>即将到来的请求通过RouterFunction路由到处理程序函数：此函数接受ServerRequest并返回可选的HandlerFunction（即Optional ）。
当路由器功能匹配时，返回处理程序功能。
否则为空的Optional。 
RouterFunction等效于@RequestMapping批注，但主要区别在于路由器功能不仅提供数据，还提供行为。</p>
</li>
</ul>
<p>RouterFunctions.route（）提供了一个路由器构建器，可简化路由器的创建过程，如以下示例所示：</p>
<pre><code class="language-java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.servlet.function.RequestPredicates.*;
import static org.springframework.web.servlet.function.RouterFunctions.route;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; route = route()
    .GET(&quot;/person/{id}&quot;, accept(APPLICATION_JSON), handler::getPerson)
    .GET(&quot;/person&quot;, accept(APPLICATION_JSON), handler::listPeople)
    .POST(&quot;/person&quot;, handler::createPerson)
    .build();


public class PersonHandler {

    // ...

    public ServerResponse listPeople(ServerRequest request) {
        // ...
    }

    public ServerResponse createPerson(ServerRequest request) {
        // ...
    }

    public ServerResponse getPerson(ServerRequest request) {
        // ...
    }
}
</code></pre>
<h1 id="handlerfunction"><a class="header" href="#handlerfunction">HandlerFunction</a></h1>
<p>ServerRequest和ServerResponse是不可变的接口，它们提供JDK 8友好的HTTP请求和响应访问，包括请求头，正文，方法和状态代码。</p>
<h2 id="serverrequest"><a class="header" href="#serverrequest">ServerRequest</a></h2>
<p>ServerRequest提供对HTTP方法，URI，标头和查询参数的访问，而通过body方法提供对 请求体的访问。</p>
<p><strong>下面的示例将请求正文提取为String：</strong></p>
<pre><code class="language-java">String string = request.body(String.class);
</code></pre>
<p><strong>以下示例将主体提取到List ，其中Person对象从序列化形式（例如JSON或XML）解码：</strong></p>
<pre><code class="language-java">List&lt;Person&gt; people = request.body(new ParameterizedTypeReference&lt;List&lt;Person&gt;&gt;() {});
</code></pre>
<p><strong>访问请求参数</strong></p>
<pre><code class="language-java">MultiValueMap&lt;String, String&gt; params = request.params();
</code></pre>
<h2 id="serverresponse"><a class="header" href="#serverresponse">ServerResponse</a></h2>
<p>ServerResponse提供对HTTP响应的访问，并且由于它是不可变的，因此您可以使用构建方法来创建它。
您可以使用构建器来设置响应状态，添加响应标题或提供正文。
以下示例使用JSON内容创建200（确定）响应：</p>
<pre><code class="language-java">Person person = ...
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);
</code></pre>
<p><strong>下面的示例演示如何构建一个具有Location标头且没有正文的201（已创建）响应：</strong></p>
<pre><code class="language-java">URI location = ...
ServerResponse.created(location).build();
</code></pre>
<p>您还可以将异步结果用作主体，形式为CompletableFuture，Publisher或ReactiveAdapterRegistry支持的任何其他类型。
例如：</p>
<pre><code class="language-java">Mono&lt;Person&gt; person = webClient.get().retrieve().bodyToMono(Person.class);
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);
</code></pre>
<p>如果不仅正文，而且状态或标头都基于异步类型，则可以在ServerResponse上使用静态异步方法，该方法接受CompletableFuture ，Publisher 或ReactiveAdapterRegistry支持的任何其他异步类型</p>
<pre><code>Mono&lt;ServerResponse&gt; asyncResponse = webClient.get().retrieve().bodyToMono(Person.class)
  .map(p -&gt; ServerResponse.ok().header(&quot;Name&quot;, p.name()).body(p));
ServerResponse.async(asyncResponse);
</code></pre>
<p>可以通过ServerResponse上的静态sse方法提供服务器发送的事件。<a href="https://www.w3.org/TR/eventsource/">Server-Sent Events</a> 
该方法提供的构建器允许您将字符串或其他对象作为JSON发送。例如：</p>
<pre><code class="language-java">public RouterFunction&lt;ServerResponse&gt; sse() {
    return route(GET(&quot;/sse&quot;), request -&gt; ServerResponse.sse(sseBuilder -&gt; {
                // Save the sseBuilder object somewhere..
            }));
}

// In some other thread, sending a String
sseBuilder.send(&quot;Hello world&quot;);

// Or an object, which will be transformed into JSON
Person person = ...
sseBuilder.send(person);

// Customize the event by using the other methods
sseBuilder.id(&quot;42&quot;)
        .event(&quot;sse event&quot;)
        .data(person);

// and done at some point
sseBuilder.complete();
</code></pre>
<h2 id="handler-classes"><a class="header" href="#handler-classes">Handler Classes</a></h2>
<p>我们可以将处理程序函数编写为lambda，如以下示例所示：</p>
<pre><code class="language-java">HandlerFunction&lt;ServerResponse&gt; helloWorld =
  request -&gt; ServerResponse.ok().body(&quot;Hello World&quot;);
</code></pre>
<p>这很方便，但是在应用程序中我们需要多个功能，并且多个内联lambda可能会变得凌乱。因此，将相关的处理程序功能分组到一个处理程序类中很有用，该类的作用与基于 注解的应用程序中的@Controller相似。
例如，以下类公开了反应型Person存储库：</p>
<pre><code class="language-java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.ServerResponse.ok;

public class PersonHandler {

    private final PersonRepository repository;

    public PersonHandler(PersonRepository repository) {
        this.repository = repository;
    }

    public ServerResponse listPeople(ServerRequest request) { 
        List&lt;Person&gt; people = repository.allPeople();
        return ok().contentType(APPLICATION_JSON).body(people);
    }

    public ServerResponse createPerson(ServerRequest request) throws Exception { 
        Person person = request.body(Person.class);
        repository.savePerson(person);
        return ok().build();
    }

    public ServerResponse getPerson(ServerRequest request) { 
        int personId = Integer.parseInt(request.pathVariable(&quot;id&quot;));
        Person person = repository.getPerson(personId);
        if (person != null) {
            return ok().contentType(APPLICATION_JSON).body(person);
        }
        else {
            return ServerResponse.notFound().build();
        }
    }

}
</code></pre>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>功能端点可以使用Spring的验证工具将验证应用于请求正文。例如，给定Person的自定义Spring Validator实现：</p>
<pre><code class="language-java">public class PersonHandler {

    private final Validator validator = new PersonValidator(); 

    // ...

    public ServerResponse createPerson(ServerRequest request) {
        Person person = request.body(Person.class);
        validate(person); 
        repository.savePerson(person);
        return ok().build();
    }

    private void validate(Person person) {
        Errors errors = new BeanPropertyBindingResult(person, &quot;person&quot;);
        validator.validate(person, errors);
        if (errors.hasErrors()) {
            throw new ServerWebInputException(errors.toString()); 
        }
    }
}
</code></pre>
<h1 id="routerfunction"><a class="header" href="#routerfunction">RouterFunction</a></h1>
<ul>
<li>
<p>路由器功能用于将请求路由到相应的HandlerFunction。</p>
</li>
<li>
<p>通常，您不是自己编写路由器功能，而是使用RouterFunctions实用工具类上的方法创建一个。 
RouterFunctions.route（）（无参数）为您提供了一个流畅的生成器来创建路由器功能，而RouterFunctions.route（RequestPredicate，HandlerFunction）提供了直接创建路由器的方法。</p>
</li>
<li>
<p>除了基于HTTP方法的映射外，路由构建器还提供了一种在映射到请求时引入其他谓词的方法。
对于每个HTTP方法，都有一个以RequestPredicate作为参数的重载变体，尽管可以表达其他约束。</p>
</li>
<li>
<p>您可以编写自己的RequestPredicate，但是RequestPredicates实用程序类根据请求路径，HTTP方法，内容类型等提供常用的实现。
以下示例使用请求谓词基于Accept头创建约束：</p>
</li>
</ul>
<pre><code class="language-java">RouterFunction&lt;ServerResponse&gt; route = RouterFunctions.route()
    .GET(&quot;/hello-world&quot;, accept(MediaType.TEXT_PLAIN),
        request -&gt; ServerResponse.ok().body(&quot;Hello World&quot;)).build();
</code></pre>
<h2 id="谓词"><a class="header" href="#谓词">谓词</a></h2>
<p>您可以使用以下命令将多个请求谓词组合在一起</p>
<ul>
<li><code>RequestPredicate.and(RequestPredicate)</code> — both must match.</li>
<li><code>RequestPredicate.or(RequestPredicate)</code> — either can match.</li>
</ul>
<p>RequestPredicates中的许多谓词都是组成的。
例如，RequestPredicates.GET（String）由RequestPredicates.method（HttpMethod）和RequestPredicates.path（String）组成。
上面显示的示例还使用了两个请求谓词，因为构建器在内部使用RequestPredicates.GET并将其与接受谓词组合在一起</p>
<ul>
<li>路由器功能按顺序评估：如果第一个路由不匹配，则评估第二个路由，依此类推。
因此，在通用路由之前声明更具体的路由是有意义的。
请注意，此行为不同于基于注释的编程模型，在该模型中，将自动选择“最特定”的控制器方法。</li>
<li>使用路由器功能生成器时，所有定义的路由都组成一个RouterFunction，从build（）返回。
还有其他方法可以将多个路由器功能组合在一起：
<ul>
<li><code>add(RouterFunction)</code> on the <code>RouterFunctions.route()</code> builder</li>
<li><code>RouterFunction.and(RouterFunction)</code></li>
<li><code>RouterFunction.andRoute(RequestPredicate, HandlerFunction)</code> — shortcut for <code>RouterFunction.and()</code> with nested <code>RouterFunctions.route()</code>.</li>
</ul>
</li>
</ul>
<pre><code class="language-java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.servlet.function.RequestPredicates.*;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; otherRoute = ...

RouterFunction&lt;ServerResponse&gt; route = route()
    .GET(&quot;/person/{id}&quot;, accept(APPLICATION_JSON), handler::getPerson) 
    .GET(&quot;/person&quot;, accept(APPLICATION_JSON), handler::listPeople) 
    .POST(&quot;/person&quot;, handler::createPerson) 
    .add(otherRoute) 
    .build();
</code></pre>
<h2 id="nested-routes"><a class="header" href="#nested-routes">Nested Routes</a></h2>
<ul>
<li>一组路由器功能通常具有共享谓词，例如共享路径。</li>
<li>在上面的示例中，共享谓词将是与/ person匹配的路径谓词，由三个路由使用。</li>
<li>使用注释时，您可以通过使用映射到/ person的类型级别@RequestMapping注释来删除此重复项。</li>
<li>在WebMvc.fn中，可以通过路由器功能构建器上的path方法共享路径谓词。例如，可以通过使用嵌套路由以以下方式改进上面示例的最后几行：</li>
</ul>
<pre><code class="language-java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path(&quot;/person&quot;, builder -&gt; builder 
        .GET(&quot;/{id}&quot;, accept(APPLICATION_JSON), handler::getPerson)
        .GET(accept(APPLICATION_JSON), handler::listPeople)
        .POST(&quot;/person&quot;, handler::createPerson))
    .build();
</code></pre>
<pre><code class="language-java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path(&quot;/person&quot;, b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET(&quot;/{id}&quot;, handler::getPerson)
            .GET(handler::listPeople))
        .POST(&quot;/person&quot;, handler::createPerson))
    .build();
</code></pre>
<h1 id="running-a-server"><a class="header" href="#running-a-server">Running a Server</a></h1>
<p>通常，您可以通过MVC Config在基于DispatcherHandler的设置中运行路由器功能，该配置使用Spring配置来声明处理请求所需的组件。 
MVC Java配置声明以下基础结构组件以支持 functional endpoints</p>
<ul>
<li><code>RouterFunctionMapping</code>:在spring配置中 检测到一个或多个 <code>RouterFunction&lt;?&gt;</code> beans ,通过 <code>RouterFunction.andOther</code>,组合 并将请求路由到组成的“RouterFunction”。</li>
<li><code>HandlerFunctionAdapter</code>:  lets <code>DispatcherHandler</code> invoke a <code>HandlerFunction</code> that was mapped to a request.</li>
</ul>
<p>前面的组件使 <em>functional endpoints</em> 适合于DispatcherServlet请求处理生命周期，并且（可能）与带注释的控制器并排运行。
这也是Spring Boot Web启动程序如何启用 <em>functional endpoints</em> 的方式。</p>
<p>以下示例显示了WebFlux Java配置：</p>
<pre><code class="language-java">@Configuration
@EnableMvc
public class WebConfig implements WebMvcConfigurer {

    @Bean
    public RouterFunction&lt;?&gt; routerFunctionA() {
        // ...
    }

    @Bean
    public RouterFunction&lt;?&gt; routerFunctionB() {
        // ...
    }

    // ...

    @Override
    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
        // configure message conversion...
    }

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // configure CORS...
    }

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        // configure view resolution for HTML rendering...
    }
}
</code></pre>
<h1 id="filtering-handler-functions"><a class="header" href="#filtering-handler-functions">Filtering Handler Functions</a></h1>
<ul>
<li>
<p>您可以使用路由功能构建器上的before，after或filter方法来过滤处理程序函数。</p>
</li>
<li>
<p>使用注解，可以通过使用@ ControllerAdvice，ServletFilter或同时使用两者来实现类似的功能。</p>
</li>
<li>
<p>该过滤器将应用于构建器构建的所有路由。 这意味着在嵌套路由中定义的过滤器不适用于“顶级”路由。例如，考虑以下示例：</p>
</li>
</ul>
<pre><code class="language-java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path(&quot;/person&quot;, b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET(&quot;/{id}&quot;, handler::getPerson)
            .GET(handler::listPeople)
            .before(request -&gt; ServerRequest.from(request) 
                .header(&quot;X-RequestHeader&quot;, &quot;Value&quot;)
                .build()))
        .POST(&quot;/person&quot;, handler::createPerson))
    .after((request, response) -&gt; logResponse(response)) 
    .build();
</code></pre>
<p>The <code>before</code> filter that adds a custom request header is only applied to the two GET routes.</p>
<p>The <code>after</code> filter that logs the response is applied to all routes, including the nested ones.</p>
<pre><code class="language-java">SecurityManager securityManager = ...

RouterFunction&lt;ServerResponse&gt; route = route()
    .path(&quot;/person&quot;, b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET(&quot;/{id}&quot;, handler::getPerson)
            .GET(handler::listPeople))
        .POST(&quot;/person&quot;, handler::createPerson))
    .filter((request, next) -&gt; {
        if (securityManager.allowAccessTo(request.path())) {
            return next.handle(request);
        }
        else {
            return ServerResponse.status(UNAUTHORIZED).build();
        }
    })
    .build();
</code></pre>
<p>除了在路由器功能构建器上使用filter方法之外，还可以通过RouterFunction.filter（HandlerFilterFunction）将过滤器应用于现有路由器功能。</p>
<div style="break-before: page; page-break-before: always;"></div><p><code>&lt;mvc:annotation-driven&gt;</code></p>
<ul>
<li>
<p>会自动注册 <em>RequestMappingHandlerMapping</em> 与 <em>RequestMappingHandlerAdapter</em> 两个Bean,这是Spring MVC为@Controller分发请求所必需的</p>
</li>
<li>
<p>并且提供了数据绑定支持，@<em>NumberFormatannotation</em>支持，@<em>DateTimeFormat</em>支持,@Valid支持</p>
</li>
<li>
<p>读写XML的支持（JAXB）</p>
<pre><code>JAXB能够使用Jackson对JAXB注解的支持实现(jackson-module-jaxb-annotations)，既方便生成XML，也方便生成JSON，这样一来可以更好的标志可以转换为JSON对象的JAVA类。JAXB允许JAVA人员将JAVA类映射为XML表示方式，常用的注解包括：@XmlRootElement,@XmlElement等等。

    JAXB（Java Architecture for XML Binding) 是一个业界的标准，是一项可以根据XML Schema产生Java类的技术。该过程中，JAXB也提供了将XML实例文档反向生成Java对象树的方法，并能将Java对象树的内容重新写到XML实例文档。从另一方面来讲，JAXB提供了快速而简便的方法将XML模式绑定到Java表示，从而使得Java开发者在Java应用程序中能方便地结合XML数据和处理函数。
</code></pre>
</li>
<li>
<p>读写JSON的支持（默认Jackson）等功能。</p>
</li>
</ul>
<p>使用该注解后的springmvc-config.xml:</p>
<pre><code class="language-xml">&lt;!--  spring 可以自动去扫描 base-package下面的包或子包下面的Java文件，如果扫描到有Spring的相关注解的类，则把这些类注册为Spring的bean --&gt;
&lt;!--设置配置方案 --&gt;
&lt;context:component-scan base-package=&quot;org.fkit.controller&quot;/&gt;
&lt;mvc:annotation-driven/&gt;

&lt;!--使用默认的Servlet来响应静态文件--&gt;

&lt;mvc:default-servlet-handler/&gt;

&lt;!-- 视图解析器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
&lt;!-- 前缀 --&gt;
&lt;property name=&quot;prefix&quot;&gt;
&lt;value&gt;/WEB-INF/content/&lt;/value&gt;
&lt;/property&gt;
&lt;!-- 后缀 --&gt;
&lt;property name=&quot;suffix&quot;&gt;
&lt;value&gt;.jsp&lt;/value&gt;
&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="springwebmvc"><a class="header" href="#springwebmvc">SpringWebMVC</a></h1>
<p>Spring Web 模型-视图-控制（MVC）框架是围绕 <em>DispatcherServlet</em> 设计的</p>
<ol>
<li>DispatchServlet 收到 Http请求后，根据 <em>HandlerMapping</em> 来选择并且调用适当的<em>控制器</em></li>
<li>控制器接受请求，调用适当的service，service设置适当的模型数据，返回视图名到DispatchServlet</li>
<li><em>DispatcherServlet</em> 会从 <em>ViewResolver</em> 获取帮助，为请求检取定义视图</li>
<li>一旦确定视图，<em>DispatcherServlet</em> 将把模型数据传递给视图</li>
</ol>
<p>HandlerMapping、Controller 和 ViewResolver 是 <em>WebApplicationContext</em> 的一部分</p>
<h2 id="handlermapping映射配置"><a class="header" href="#handlermapping映射配置">HandlerMapping映射配置</a></h2>
<p>DispatchServlet配置在web.xml 中</p>
<pre><code>&lt;servlet&gt;
      &lt;servlet-name&gt;HelloWeb&lt;/servlet-name&gt;
      &lt;servlet-class&gt;
         org.springframework.web.servlet.DispatcherServlet
      &lt;/servlet-class&gt;
      &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</code></pre>
<p>该框架将尝试加载位于该应用程序的 <em>WebContent/WEB-INF</em> 目录中文件名为 <code>[servlet-name]-servlet.xml</code> 的应用程序内容</p>
<p>想要改变默认位置,不使用默认名,配置在web.xml中</p>
<pre><code class="language-xml">&lt;context-param&gt;
   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
   &lt;param-value&gt;/WEB-INF/HelloWeb-servlet.xml&lt;/param-value&gt;
&lt;/context-param&gt;
&lt;listener&gt;
   &lt;listener-class&gt;
      org.springframework.web.context.ContextLoaderListener
   &lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<p><strong>HelloWeb-servlet.xml</strong> 文件的请求配置</p>
<pre><code class="language-xml">   &lt;context:component-scan base-package=&quot;com.tutorialspoint&quot; /&gt;

   &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
      &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
      &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
   &lt;/bean&gt;
</code></pre>
<p><strong>HelloWeb-servlet.xml</strong> 文件的一些要点：</p>
<ul>
<li>用于创建 bean 定义，重新定义在全局范围内具有相同名称的任何已定义的 bean</li>
<li>context:component-scan: 激活 Spring MVC 注释扫描功能，该功能允许使用注释，如 @Controller 和 @RequestMapping</li>
<li><em>InternalResourceViewResolver</em> :将使用定义的规则来解决视图名称</li>
<li>按照上述定义的规则，一个名称为 <strong>hello</strong> 的逻辑视图将发送给位于 <code>/WEB-INF/jsp/hello.jsp</code> 中实现的视图</li>
</ul>
<h2 id="定义控制器"><a class="header" href="#定义控制器">定义控制器</a></h2>
<p><strong>@Controller</strong> 注释表明一个特定类是一个控制器的作用。</p>
<p><strong>@RequestMapping</strong> 注释用于映射 URL 到整个类或一个特定的处理方法。</p>
<h2 id="创建-jsp-视图"><a class="header" href="#创建-jsp-视图">创建 JSP 视图</a></h2>
<p>Spring MVC 支持许多类型的视图</p>
<p>包括 JSP、HTML、PDF、Excel 工作表、XML、Velocity 模板、XSLT、JSON、Atom 和 RSS 提要、JasperReports </p>
<p>@ModelAttribute：解析表单变量</p>
<p>重定向：return &quot;redirect:finalPage&quot;;</p>
<h2 id="web-静态页面"><a class="header" href="#web-静态页面">Web 静态页面</a></h2>
<p>标签被用来映射静态页面</p>
<p><code>&lt;mvc:resources mapping=&quot;/pages/**&quot; location=&quot;/WEB-INF/pages/&quot; /&gt;</code></p>
<h2 id="异常处理"><a class="header" href="#异常处理">异常处理</a></h2>
<pre><code class="language-xml">&lt;bean class=&quot;org.springframework.web.servlet.handler.
      SimpleMappingExceptionResolver&quot;&gt;
   &lt;property name=&quot;exceptionMappings&quot;&gt;
      &lt;props&gt;
         &lt;prop key=&quot;com.tutorialspoint.SpringException&quot;&gt;
            ExceptionPage
         &lt;/prop&gt;
      &lt;/props&gt;
   &lt;/property&gt;
   &lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot;/&gt;
&lt;/bean&gt;

</code></pre>
<p>${exception}  可以访问异常对象</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义参数解析器"><a class="header" href="#自定义参数解析器">自定义参数解析器</a></h1>
<h2 id="自定义注解"><a class="header" href="#自定义注解">自定义注解</a></h2>
<pre><code class="language-java">@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
public @interface JsonParam {
    String value();
}
</code></pre>
<h2 id="controller"><a class="header" href="#controller">Controller</a></h2>
<pre><code class="language-java">@Controller
public class UserController {
    @RequestMapping(&quot;/users/add&quot;)
    @ResponseBody
    public Map&lt;String, Object&gt; addUser(Integer userid, @JsonParam(&quot;dept&quot;) Dept userDept) {
        Map&lt;String, Object&gt; data = new HashMap&lt;&gt;(2);
        data.put(&quot;userId&quot;, userid);
        data.put(&quot;userDept&quot;, userDept);
        return data;
    }
}
</code></pre>
<h2 id="自定义参数解析器-1"><a class="header" href="#自定义参数解析器-1">自定义参数解析器</a></h2>
<pre><code class="language-java">public class JsonParamProvider implements HandlerMethodArgumentResolver {
    /**
     * 判断是否是需要我们解析的参数类型
     */
    @Override
    public boolean supportsParameter(MethodParameter methodParameter) {
        return methodParameter.hasParameterAnnotation(JsonParam.class);
    }

    /**
     * 真正解析的方法
     */
    @Override
    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {
        HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.class);
        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();

        JsonParam jsonParam = methodParameter.getParameterAnnotation(JsonParam.class);
        String paramName = jsonParam.value();
        //注解没有给定参数名字，默认取参数类型的小写
        if (StringUtils.isEmpty(paramName)) {
            String parmTypeName = methodParameter.getParameterType().getSimpleName();
            paramName = parmTypeName.substring(0, 1).toLowerCase() + parmTypeName.substring(1);
        }

        //从request中能拿到参数值
        if (parameterMap.containsKey(paramName)) {
            String paramVal = parameterMap.get(paramName)[0];
            //解析json
            ObjectMapper objectMapper = new ObjectMapper();
            Dept dept = objectMapper.readValue(paramVal.getBytes(&quot;UTF-8&quot;), Dept.class);
            return dept;
        } else {
            return new Dept();
        }
    }
}
</code></pre>
<h1 id="配置自定义参数解析器"><a class="header" href="#配置自定义参数解析器">配置自定义参数解析器</a></h1>
<h2 id="xml方式"><a class="header" href="#xml方式">XML方式</a></h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

	&lt;context:component-scan base-package=&quot;com.demo&quot; /&gt;
	
	&lt;mvc:annotation-driven&gt;
		&lt;mvc:argument-resolvers&gt;
			&lt;bean class=&quot;com.demo.JsonParamProvider&quot;/&gt;
		&lt;/mvc:argument-resolvers&gt;
	&lt;/mvc:annotation-driven&gt;
&lt;/beans&gt;  
</code></pre>
<h2 id="注解方式配置"><a class="header" href="#注解方式配置">注解方式配置</a></h2>
<h3 id="xml"><a class="header" href="#xml">xml</a></h3>
<pre><code class="language-xml">spring-mvc.xml内容
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

	&lt;context:component-scan base-package=&quot;com.demo&quot; /&gt;
	
	&lt;!--不能添加该标签，否则注解类不生效--&gt;
	&lt;!--&lt;mvc:annotation-driven/&gt;--&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="java配置"><a class="header" href="#java配置">Java配置</a></h3>
<pre><code class="language-java">@Configuration
@EnableWebMvc
public class MyConfiguration extends WebMvcConfigurerAdapter {
    @Override
    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {
        argumentResolvers.add(new JsonParamProvider());
        }
}
</code></pre>
<h2 id="springboot配置"><a class="header" href="#springboot配置">springBoot配置</a></h2>
<pre><code class="language-java">@Configuration
public class MyConfiguration extends WebMvcConfigurationSupport {
    @Override
    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {
        argumentResolvers.add(new JsonParamProvider());
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="springmvc-有着多种不同风格的-路径映射方式"><a class="header" href="#springmvc-有着多种不同风格的-路径映射方式">springMVC 有着多种不同风格的 路径映射方式</a></h1>
<h2 id="ant风格的映射"><a class="header" href="#ant风格的映射"><strong>Ant风格的映射</strong></a></h2>
<pre><code class="language-java">@RequestMapping(&quot;/a?/aaa&quot;) //?代表一个字符
@RequestMapping(&quot;/a*/aaa&quot;) //*代表多个字符
@RequestMapping(&quot;/**/aaa&quot;) //**代表多个路径
</code></pre>
<h2 id="占位符映射风格"><a class="header" href="#占位符映射风格">占位符映射风格</a></h2>
<pre><code class="language-java">@RequestMapping(&quot;/show/{name}&quot;)
public ModelAndView test(@PathVariable(&quot;name&quot;)String name){

}
</code></pre>
<h1 id="请求限制"><a class="header" href="#请求限制">请求限制</a></h1>
<h2 id="限制请求的方法"><a class="header" href="#限制请求的方法">限制请求的方法</a></h2>
<p>略</p>
<h2 id="限定请求参数的映射"><a class="header" href="#限定请求参数的映射"><strong>限定请求参数的映射</strong></a></h2>
<pre><code>@RequestMapping(value=””,params=””)

①params=”id”

//请求参数中必须有id，如果没有id会报错。

//与之相反的是：如果params=”!id”表示请求参数中不能包含id，如果有id会报错。

②params=”id=1”

//请求参数中id必须为1，如果不为1会报错。

//与之相反的是：如果params=”id!=1”表示请求参数中id必须不为1，如果等于1会报错。

③params={“name”, ”age”}

//请求参数中必须有name，age参数，当然有多余的其它参数也行，但这两个必须要有。
</code></pre>
<h1 id="混合注解"><a class="header" href="#混合注解"><strong>混合注解</strong></a></h1>
<pre><code>@GetMapping
@PostMapping
@PostMapping、@PutMapping、@DeleteMapping
</code></pre>
<h1 id="获取cookie"><a class="header" href="#获取cookie">获取<em>Cookie</em></a></h1>
<pre><code>@CookieValue
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><strong>springMVC返回后 所作的事情</strong></p>
<pre><code class="language-java">	public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,
			Object... providedArgs) throws Exception {

		Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
		setResponseStatus(webRequest);

		if (returnValue == null) {
			if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {
				disableContentCachingIfNecessary(webRequest);
				mavContainer.setRequestHandled(true);
				return;
			}
		}
		else if (StringUtils.hasText(getResponseStatusReason())) {
			mavContainer.setRequestHandled(true);
			return;
		}

		mavContainer.setRequestHandled(false);
		Assert.state(this.returnValueHandlers != null, &quot;No return value handlers&quot;);
		try {
			this.returnValueHandlers.handleReturnValue(
					returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
		}
		catch (Exception ex) {
			if (logger.isTraceEnabled()) {
				logger.trace(formatErrorForReturnValue(returnValue), ex);
			}
			throw ex;
		}
	}
</code></pre>
<p><strong>springMVC内容协商</strong></p>
<pre><code class="language-java">protected &lt;T&gt; void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,
			ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)
			throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {

		Object body;
		Class&lt;?&gt; valueType;
		Type targetType;

		if (value instanceof CharSequence) {
			body = value.toString();
			valueType = String.class;
			targetType = String.class;
		}
		else {
			body = value;
			valueType = getReturnValueType(body, returnType);
			targetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());
		}

		if (isResourceType(value, returnType)) {
			outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, &quot;bytes&quot;);
			if (value != null &amp;&amp; inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null &amp;&amp;
					outputMessage.getServletResponse().getStatus() == 200) {
				Resource resource = (Resource) value;
				try {
					List&lt;HttpRange&gt; httpRanges = inputMessage.getHeaders().getRange();
					outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());
					body = HttpRange.toResourceRegions(httpRanges, resource);
					valueType = body.getClass();
					targetType = RESOURCE_REGION_LIST_TYPE;
				}
				catch (IllegalArgumentException ex) {
					outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, &quot;bytes */&quot; + resource.contentLength());
					outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());
				}
			}
		}

		MediaType selectedMediaType = null;
		MediaType contentType = outputMessage.getHeaders().getContentType();
		boolean isContentTypePreset = contentType != null &amp;&amp; contentType.isConcrete();
		if (isContentTypePreset) {
			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Found 'Content-Type:&quot; + contentType + &quot;' in response&quot;);
			}
			selectedMediaType = contentType;
		}
		else {
			HttpServletRequest request = inputMessage.getServletRequest();
			List&lt;MediaType&gt; acceptableTypes;
			try {
				acceptableTypes = getAcceptableMediaTypes(request);
			}
			catch (HttpMediaTypeNotAcceptableException ex) {
				int series = outputMessage.getServletResponse().getStatus() / 100;
				if (body == null || series == 4 || series == 5) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Ignoring error response content (if any). &quot; + ex);
					}
					return;
				}
				throw ex;
			}
			List&lt;MediaType&gt; producibleTypes = getProducibleMediaTypes(request, valueType, targetType);

			if (body != null &amp;&amp; producibleTypes.isEmpty()) {
				throw new HttpMessageNotWritableException(
						&quot;No converter found for return value of type: &quot; + valueType);
			}
			List&lt;MediaType&gt; mediaTypesToUse = new ArrayList&lt;&gt;();
			for (MediaType requestedType : acceptableTypes) {
				for (MediaType producibleType : producibleTypes) {
					if (requestedType.isCompatibleWith(producibleType)) {
						mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));
					}
				}
			}
			if (mediaTypesToUse.isEmpty()) {
				if (body != null) {
					throw new HttpMediaTypeNotAcceptableException(producibleTypes);
				}
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;No match for &quot; + acceptableTypes + &quot;, supported: &quot; + producibleTypes);
				}
				return;
			}

			MediaType.sortBySpecificityAndQuality(mediaTypesToUse);

			for (MediaType mediaType : mediaTypesToUse) {
				if (mediaType.isConcrete()) {
					selectedMediaType = mediaType;
					break;
				}
				else if (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) {
					selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;
					break;
				}
			}

			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Using '&quot; + selectedMediaType + &quot;', given &quot; +
						acceptableTypes + &quot; and supported &quot; + producibleTypes);
			}
		}

		if (selectedMediaType != null) {
			selectedMediaType = selectedMediaType.removeQualityValue();
			for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) {
				GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ?
						(GenericHttpMessageConverter&lt;?&gt;) converter : null);
				if (genericConverter != null ?
						((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :
						converter.canWrite(valueType, selectedMediaType)) {
					body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,
							(Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(),
							inputMessage, outputMessage);
					if (body != null) {
						Object theBody = body;
						LogFormatUtils.traceDebug(logger, traceOn -&gt;
								&quot;Writing [&quot; + LogFormatUtils.formatValue(theBody, !traceOn) + &quot;]&quot;);
						addContentDispositionHeader(inputMessage, outputMessage);
						if (genericConverter != null) {
							genericConverter.write(body, targetType, selectedMediaType, outputMessage);
						}
						else {
							((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);
						}
					}
					else {
						if (logger.isDebugEnabled()) {
							logger.debug(&quot;Nothing to write: null body&quot;);
						}
					}
					return;
				}
			}
		}

		if (body != null) {
			Set&lt;MediaType&gt; producibleMediaTypes =
					(Set&lt;MediaType&gt;) inputMessage.getServletRequest()
							.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);

			if (isContentTypePreset || !CollectionUtils.isEmpty(producibleMediaTypes)) {
				throw new HttpMessageNotWritableException(
						&quot;No converter for [&quot; + valueType + &quot;] with preset Content-Type '&quot; + contentType + &quot;'&quot;);
			}
			throw new HttpMediaTypeNotAcceptableException(getSupportedMediaTypes(body.getClass()));
		}
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring配置文件写法"><a class="header" href="#spring配置文件写法">spring配置文件写法</a></h1>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.lzzcms&quot; &gt;
&lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;&gt;&lt;/context:exclude-filter&gt;
&lt;/context:component-scan&gt;
</code></pre>
<h1 id="springmvc配置文件写法"><a class="header" href="#springmvc配置文件写法">springMVC配置文件写法</a></h1>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.lzzcms&quot; use-default-filters=&quot;false&quot;&gt;
&lt;context:include-filter type=&quot;annotation&quot;  expression=&quot;org.springframework.stereotype.Controller&quot;&gt;&lt;/context:include-filter&gt;
&lt;/context:component-scan&gt;
</code></pre>
<p>默认情况下 context:component-scan  会扫描 一下注解</p>
<pre><code>@Component, @Repository, @Service,
@Controller, @RestController, @ControllerAdvice, and @Configuration
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>The <code>spring-web</code> module 提供了以下 有用的 过滤器</p>
<ul>
<li>Form Data</li>
<li>Forwarded Headers</li>
<li>Shallow ETag</li>
<li>CORS</li>
</ul>
<h1 id="form-data"><a class="header" href="#form-data">Form Data</a></h1>
<p>Servlet API要求 ServletRequest.getParameter *（）方法来仅支持HTTP POST的表单字段访问。</p>
<p><code>spring-web</code> 模块 提供了 <code>FormContentFilter</code>  过滤器 去 拦截  content type 为 <em>application/x-www-form-urlencoded</em> 的 <em>HTTP PUT, PATCH, and DELETE</em> 请求</p>
<p>将 <em>ServletRequest</em> 包装使得 <em>ServletRequest.getParameter</em>()* 可用于获取表单数据</p>
<h1 id="forwarded-headers"><a class="header" href="#forwarded-headers">Forwarded Headers</a></h1>
<p>一个请求可能会 经过多层代理，很难获取用户的真正IP</p>
<p><a href="https://tools.ietf.org/html/rfc7239">RFC 7239</a> 定义了 the <code>Forwarded</code> HTTP header ，代理服务器可以提供 原始 请求的信息</p>
<p>还有非标准的 头，包括<code>X-Forwarded-Host</code>, <code>X-Forwarded-Port</code>, <code>X-Forwarded-Proto</code>, <code>X-Forwarded-Ssl</code>, and <code>X-Forwarded-Prefix</code></p>
<p><code>ForwardedHeaderFilter</code>  是一个 <em>Servlet</em> <em>Filter</em> ，基于  <code>Forwarded</code> headers 改变 host, port, and scheme </p>
<p>它必须位于 所有 过滤器的前面</p>
<p>对于转发的标头，出于安全方面的考虑，因为应用程序无法知道标头是由代理添加的，还是由恶意客户端添加的</p>
<p>这就是为什么代理 应该 在 信任边界处的  删除来自外部的不受信任的“转发”标头的原因。</p>
<p><code>ForwardedHeaderFilter</code> with <code>removeOnly=true</code>  会移除不受信任的 转发 头，</p>
<p>为了支持 asynchronous requests ，此过滤器应映射为DispatcherType.ASYNC和DispatcherType.ERROR。</p>
<p>如果使用 spring 框架的 <code>AbstractAnnotationConfigDispatcherServletInitializer</code>  ，所有 filters 自动注册 所有 dispatch types</p>
<p>However if registering the filter via <code>web.xml</code> or in Spring Boot via a <code>FilterRegistrationBean</code> be sure to include <code>DispatcherType.ASYNC</code> and <code>DispatcherType.ERROR</code> in addition to <code>DispatcherType.REQUEST</code>.</p>
<h1 id="shallow-etag"><a class="header" href="#shallow-etag">Shallow ETag</a></h1>
<ul>
<li>
<p>The <code>ShallowEtagHeaderFilter</code> filter creates a “shallow” ETag by caching the content written to the response and computing an MD5 hash from it. </p>
</li>
<li>
<p>下一次请求，同样的计算 ，计算返回的值的 MD5 跟之前缓存的是否一样，则返回304</p>
</li>
<li>
<p>这个策略节省 了网络带宽，但没有节省 CPU </p>
</li>
<li>
<p>另外一种  策略基于  控制器 级别，可以避免计算 See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-caching">HTTP Caching</a>.</p>
</li>
</ul>
<p>这个 过滤器 有一个 <code>writeWeakETag</code> 参数  that configures the filter to write weak ETags similar to the following: <code>W/&quot;02a2d595e6ed9a0b24f027f2b63b134d6&quot;</code> (as defined in <a href="https://tools.ietf.org/html/rfc7232#section-2.3">RFC 7232 Section 2.3</a>).</p>
<p>In order to support <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">asynchronous requests</a> this filter must be mapped with <code>DispatcherType.ASYNC</code> so that the filter can delay and successfully generate an ETag to the end of the last async dispatch. If using Spring Framework’s <code>AbstractAnnotationConfigDispatcherServletInitializer</code> (see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-container-config">Servlet Config</a>) all filters are automatically registered for all dispatch types. However if registering the filter via <code>web.xml</code> or in Spring Boot via a <code>FilterRegistrationBean</code> be sure to include <code>DispatcherType.ASYNC</code>.</p>
<h1 id="cors"><a class="header" href="#cors">CORS</a></h1>
<p>Spring MVC provides fine-grained support for CORS configuration through annotations on controllers. However, when used with Spring Security, we advise relying on the built-in <code>CorsFilter</code> that must be ordered ahead of Spring Security’s chain of filters.</p>
<p>See the sections on <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-cors">CORS</a> and the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-cors-filter">CORS Filter</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-6"><a class="header" href="#简介-6">简介</a></h1>
<p>SpringMVC提供了 基于注解的编程模型  <code>@Controller</code> and <code>@RestController</code>，用来 请求映射，请求解析，异常处理等等</p>
<h1 id="申明"><a class="header" href="#申明">申明</a></h1>
<p>You can define controller beans by using a standard Spring bean definition in the. </p>
<p>可以使用 标准 spring bean定义  方式  在 Servlet’s <code>WebApplicationContext</code>中   定义 Controller bean </p>
<p><code>@Controller</code> 能自动检测，</p>
<p>To enable auto-detection of such <code>@Controller</code> beans, </p>
<p>为了能自动 检测 <em>Controller</em> <em>bean</em> ，通过java配置自动扫描</p>
<p>Java</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;org.example.web&quot;)
public class WebConfig {

    // ...
}
</code></pre>
<p>等价的 XML配置</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;org.example.web&quot;/&gt;

    &lt;!-- ... --&gt;

&lt;/beans&gt;
</code></pre>
<h2 id="aop-proxies"><a class="header" href="#aop-proxies">AOP Proxies</a></h2>
<p>在某些时候，你可能需要 对 <em>Controller</em> 使用 Aop 代理</p>
<p>例如 <code>@Transactional</code> ，在这种情况，最好使用基于 类的 代理</p>
<p>For example, with <code>&lt;tx:annotation-driven/&gt;</code> you can change to <code>&lt;tx:annotation-driven proxy-target-class=&quot;true&quot;/&gt;</code>, and with <code>@EnableTransactionManagement</code> you can change to <code>@EnableTransactionManagement(proxyTargetClass = true)</code>.</p>
<h1 id="request-mapping"><a class="header" href="#request-mapping">Request Mapping</a></h1>
<p>There are also HTTP method specific shortcut variants of <code>@RequestMapping</code>:</p>
<ul>
<li><code>@GetMapping</code></li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
<p>The shortcuts are <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-composed">Custom Annotations</a> that are provided because, arguably, most controller methods should be mapped to a specific HTTP method versus using <code>@RequestMapping</code>, which, by default, matches to all HTTP methods. At the same, a <code>@RequestMapping</code> is still needed at the class level to express shared mappings.</p>
<h2 id="uri-patterns"><a class="header" href="#uri-patterns">URI patterns</a></h2>
<p><code>@RequestMapping</code> 使用以下两种方式是进行映射</p>
<ul>
<li><code>PathPattern</code> — 直接路径匹配</li>
<li><code>AntPathMatcher</code> — 基于Ant风格</li>
</ul>
<p>Some example patterns:</p>
<ul>
<li><code>&quot;/resources/ima?e.png&quot;</code> - match one character in a path segment</li>
<li><code>&quot;/resources/*.png&quot;</code> - match zero or more characters in a path segment</li>
<li><code>&quot;/resources/**&quot;</code> - match multiple path segments</li>
<li><code>&quot;/projects/{project}/versions&quot;</code> - match a path segment and capture it as a variable URL捕获</li>
<li><code>&quot;/projects/{project:[a-z]+}/versions&quot;</code> - match and capture a variable with a regex</li>
</ul>
<p>Captured URI variables can be accessed with <code>@PathVariable</code>. </p>
<pre><code class="language-java">@GetMapping(&quot;/owners/{ownerId}/pets/{petId}&quot;)
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
    // ...
}
</code></pre>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/owners/{ownerId}&quot;)
public class OwnerController {

    @GetMapping(&quot;/pets/{petId}&quot;)
    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
        // ...
    }
}
</code></pre>
<p><strong>基于正则的匹配与捕获</strong></p>
<pre><code class="language-java">@GetMapping(&quot;/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}&quot;)
public void handle(@PathVariable String name, @PathVariable String version, @PathVariable String ext) {
    // ...
}
</code></pre>
<h2 id="pattern-comparison"><a class="header" href="#pattern-comparison">Pattern Comparison</a></h2>
<p>多个pattern匹配时，会选择最佳匹配</p>
<p>This is done with one of the following depending on whether parsed `PathPattern’s are enabled for use or not:</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/web/util/pattern/PathPattern.html#SPECIFICITY_COMPARATOR"><code>PathPattern.SPECIFICITY_COMPARATOR</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/util/AntPathMatcher.html#getPatternComparator-java.lang.String-"><code>AntPathMatcher.getPatternComparator(String path)</code></a></li>
</ul>
<p><strong>计分规则</strong></p>
<ul>
<li>
<p>URI 变量 计分为1，单 wildcard 计分为1，双wildcard 计分为2</p>
</li>
<li>
<p>分数相等，越长的优先，长度分数一致，更多的 URI变量 优先于 通配符</p>
</li>
<li>
<p>默认映射模式（<code>/ **</code>）被排除在评分之外，并且始终排在最后。</p>
</li>
<li>
<p>另外，前缀模式（例如<code>/ public / **</code> 比 /public/ 更具体 ）被认为比其他没有双通配符的模式更具体。</p>
</li>
</ul>
<h2 id="suffix-match后缀匹配"><a class="header" href="#suffix-match后缀匹配">Suffix Match后缀匹配</a></h2>
<p>从 Spring5.3，默认Spring MVC 不再支持 后缀 匹配模式， 例如 <code>/person</code>  -&gt; <code>/person.*</code></p>
<p>浏览器过去发送难以一致解释的<code>Accept</code>标头时，以这种方式使用文件扩展名是必要的。</p>
<p>随着时间的流逝，文件扩展名的使用已被证明有各种问题</p>
<p>To completely disable the use of path extensions in versions prior to 5.3, set the following:</p>
<ul>
<li><code>useSuffixPatternMatching(false)</code>, see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-path-matching">PathMatchConfigurer</a></li>
<li><code>favorPathExtension(false)</code>, see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-content-negotiation">ContentNegotiationConfigurer</a></li>
</ul>
<p>If you must use file extensions, consider restricting them to a list of explicitly registered extensions through the <code>mediaTypes</code> property of <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-content-negotiation">ContentNegotiationConfigurer</a>.</p>
<h2 id="suffix-match-and-rfd"><a class="header" href="#suffix-match-and-rfd">Suffix Match and RFD</a></h2>
<p>A reflected file download (RFD) attack is similar to XSS in that it relies on request input (for example, a query parameter and a URI variable) being reflected in the response. However, instead of inserting JavaScript into HTML, an RFD attack relies on the browser switching to perform a download and treating the response as an executable script when double-clicked later.</p>
<p>In Spring MVC, <code>@ResponseBody</code> and <code>ResponseEntity</code> methods are at risk, because they can render different content types, which clients can request through URL path extensions. Disabling suffix pattern matching and using path extensions for content negotiation lower the risk but are not sufficient to prevent RFD attacks.</p>
<p>To prevent RFD attacks, prior to rendering the response body, Spring MVC adds a <code>Content-Disposition:inline;filename=f.txt</code> header to suggest a fixed and safe download file. This is done only if the URL path contains a file extension that is neither allowed as safe nor explicitly registered for content negotiation. However, it can potentially have side effects when URLs are typed directly into a browser.</p>
<p>Many common path extensions are allowed as safe by default. Applications with custom <code>HttpMessageConverter</code> implementations can explicitly register file extensions for content negotiation to avoid having a <code>Content-Disposition</code> header added for those extensions. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-content-negotiation">Content Types</a>.</p>
<p>See <a href="https://pivotal.io/security/cve-2015-5211">CVE-2015-5211</a> for additional recommendations related to RFD.</p>
<h2 id="consumable-media-types"><a class="header" href="#consumable-media-types">Consumable Media Types</a></h2>
<pre><code class="language-java">@PostMapping(path = &quot;/pets&quot;, consumes = &quot;application/json&quot;) 
public void addPet(@RequestBody Pet pet) {
    // ...
}
</code></pre>
<p><strong>可以取反</strong></p>
<pre><code class="language-java">@PostMapping(path = &quot;/pets&quot;, consumes = &quot;!application/json&quot;) 
public void addPet(@RequestBody Pet pet) {
    // ...
}
</code></pre>
<h2 id="producible-media-types"><a class="header" href="#producible-media-types">Producible Media Types</a></h2>
<pre><code class="language-java">@GetMapping(path = &quot;/pets/{petId}&quot;, produces = &quot;application/json&quot;) 
@ResponseBody
public Pet getPet(@PathVariable String petId) {
    // ...
}
</code></pre>
<h2 id="parameters-headers"><a class="header" href="#parameters-headers">Parameters, headers</a></h2>
<p>You can narrow request mappings based on request parameter conditions. You can test for the presence of a request parameter (<code>myParam</code>), for the absence of one (<code>!myParam</code>), or for a specific value (<code>myParam=myValue</code>). The following example shows how to test for a specific value:</p>
<pre><code class="language-java">@GetMapping(path = &quot;/pets/{petId}&quot;, params = &quot;myParam=myValue&quot;) 
public void findPet(@PathVariable String petId) {
    // ...
}
</code></pre>
<h2 id="handler-methods"><a class="header" href="#handler-methods">Handler Methods</a></h2>
<p><strong>方法可以设置的参数</strong></p>
<table><thead><tr><th style="text-align: left">Controller method argument</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>WebRequest</code>, <code>NativeWebRequest</code></td><td style="text-align: left">Generic access to request parameters and request and session attributes, without direct use of the Servlet API.</td></tr>
<tr><td style="text-align: left"><code>javax.servlet.ServletRequest</code>, <code>javax.servlet.ServletResponse</code></td><td style="text-align: left">Choose any specific request or response type — for example, <code>ServletRequest</code>, <code>HttpServletRequest</code>, or Spring’s <code>MultipartRequest</code>, <code>MultipartHttpServletRequest</code>.</td></tr>
<tr><td style="text-align: left"><code>javax.servlet.http.HttpSession</code></td><td style="text-align: left">Enforces the presence of a session. As a consequence, such an argument is never <code>null</code>. Note that session access is not thread-safe. Consider setting the <code>RequestMappingHandlerAdapter</code> instance’s <code>synchronizeOnSession</code> flag to <code>true</code> if multiple requests are allowed to concurrently access a session.</td></tr>
<tr><td style="text-align: left"><code>javax.servlet.http.PushBuilder</code></td><td style="text-align: left">Servlet 4.0 push builder API for programmatic HTTP/2 resource pushes. Note that, per the Servlet specification, the injected <code>PushBuilder</code> instance can be null if the client does not support that HTTP/2 feature.</td></tr>
<tr><td style="text-align: left"><code>java.security.Principal</code></td><td style="text-align: left">Currently authenticated user — possibly a specific <code>Principal</code> implementation class if known.</td></tr>
<tr><td style="text-align: left"><code>HttpMethod</code></td><td style="text-align: left">The HTTP method of the request.</td></tr>
<tr><td style="text-align: left"><code>java.util.Locale</code></td><td style="text-align: left">The current request locale, determined by the most specific <code>LocaleResolver</code> available (in effect, the configured <code>LocaleResolver</code> or <code>LocaleContextResolver</code>).</td></tr>
<tr><td style="text-align: left"><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></td><td style="text-align: left">The time zone associated with the current request, as determined by a <code>LocaleContextResolver</code>.</td></tr>
<tr><td style="text-align: left"><code>java.io.InputStream</code>, <code>java.io.Reader</code></td><td style="text-align: left">For access to the raw request body as exposed by the Servlet API.</td></tr>
<tr><td style="text-align: left"><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td style="text-align: left">For access to the raw response body as exposed by the Servlet API.</td></tr>
<tr><td style="text-align: left"><code>@PathVariable</code></td><td style="text-align: left">For access to URI template variables. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-uri-templates">URI patterns</a>.</td></tr>
<tr><td style="text-align: left"><code>@MatrixVariable</code></td><td style="text-align: left">For access to name-value pairs in URI path segments. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-matrix-variables">Matrix Variables</a>.</td></tr>
<tr><td style="text-align: left"><code>@RequestParam</code></td><td style="text-align: left">For access to the Servlet request parameters, including multipart files. Parameter values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestparam"><code>@RequestParam</code></a> as well as <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart-forms">Multipart</a>.Note that use of <code>@RequestParam</code> is optional for simple parameter values. See “Any other argument”, at the end of this table.</td></tr>
<tr><td style="text-align: left"><code>@RequestHeader</code></td><td style="text-align: left">For access to request headers. Header values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestheader"><code>@RequestHeader</code></a>.</td></tr>
<tr><td style="text-align: left"><code>@CookieValue</code></td><td style="text-align: left">For access to cookies. Cookies values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-cookievalue"><code>@CookieValue</code></a>.</td></tr>
<tr><td style="text-align: left"><code>@RequestBody</code></td><td style="text-align: left">For access to the HTTP request body. Body content is converted to the declared method argument type by using <code>HttpMessageConverter</code> implementations. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestbody"><code>@RequestBody</code></a>.</td></tr>
<tr><td style="text-align: left"><code>HttpEntity&lt;B&gt;</code></td><td style="text-align: left">For access to request headers and body. The body is converted with an <code>HttpMessageConverter</code>. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-httpentity">HttpEntity</a>.</td></tr>
<tr><td style="text-align: left"><code>@RequestPart</code></td><td style="text-align: left">For access to a part in a <code>multipart/form-data</code> request, converting the part’s body with an <code>HttpMessageConverter</code>. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart-forms">Multipart</a>.</td></tr>
<tr><td style="text-align: left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td style="text-align: left">For access to the model that is used in HTML controllers and exposed to templates as part of view rendering.</td></tr>
<tr><td style="text-align: left"><code>RedirectAttributes</code></td><td style="text-align: left">Specify attributes to use in case of a redirect (that is, to be appended to the query string) and flash attributes to be stored temporarily until the request after redirect. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-redirecting-passing-data">Redirect Attributes</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-flash-attributes">Flash Attributes</a>.</td></tr>
<tr><td style="text-align: left"><code>@ModelAttribute</code></td><td style="text-align: left">For access to an existing attribute in the model (instantiated if not present) with data binding and validation applied. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-modelattrib-method-args"><code>@ModelAttribute</code></a> as well as <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-modelattrib-methods">Model</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-initbinder"><code>DataBinder</code></a>.Note that use of <code>@ModelAttribute</code> is optional (for example, to set its attributes). See “Any other argument” at the end of this table.</td></tr>
<tr><td style="text-align: left"><code>Errors</code>, <code>BindingResult</code></td><td style="text-align: left">For access to errors from validation and data binding for a command object (that is, a <code>@ModelAttribute</code> argument) or errors from the validation of a <code>@RequestBody</code> or <code>@RequestPart</code> arguments. You must declare an <code>Errors</code>, or <code>BindingResult</code> argument immediately after the validated method argument.</td></tr>
<tr><td style="text-align: left"><code>SessionStatus</code> + class-level <code>@SessionAttributes</code></td><td style="text-align: left">For marking form processing complete, which triggers cleanup of session attributes declared through a class-level <code>@SessionAttributes</code> annotation. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a> for more details.</td></tr>
<tr><td style="text-align: left"><code>UriComponentsBuilder</code></td><td style="text-align: left">For preparing a URL relative to the current request’s host, port, scheme, context path, and the literal part of the servlet mapping. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-uri-building">URI Links</a>.</td></tr>
<tr><td style="text-align: left"><code>@SessionAttribute</code></td><td style="text-align: left">For access to any session attribute, in contrast to model attributes stored in the session as a result of a class-level <code>@SessionAttributes</code> declaration. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-sessionattribute"><code>@SessionAttribute</code></a> for more details.</td></tr>
<tr><td style="text-align: left"><code>@RequestAttribute</code></td><td style="text-align: left">For access to request attributes. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestattrib"><code>@RequestAttribute</code></a> for more details.</td></tr>
<tr><td style="text-align: left">Any other argument</td><td style="text-align: left">If a method argument is not matched to any of the earlier values in this table and it is a simple type (as determined by <a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>, it is a resolved as a <code>@RequestParam</code>. Otherwise, it is resolved as a <code>@ModelAttribute</code>.</td></tr>
</tbody></table>
<h3 id="返回值"><a class="header" href="#返回值">返回值</a></h3>
<table><thead><tr><th style="text-align: left">Controller method return value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>@ResponseBody</code></td><td style="text-align: left">The return value is converted through <code>HttpMessageConverter</code> implementations and written to the response. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-responsebody"><code>@ResponseBody</code></a>.</td></tr>
<tr><td style="text-align: left"><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></td><td style="text-align: left">The return value that specifies the full response (including HTTP headers and body) is to be converted through <code>HttpMessageConverter</code> implementations and written to the response. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-responseentity">ResponseEntity</a>.</td></tr>
<tr><td style="text-align: left"><code>HttpHeaders</code></td><td style="text-align: left">For returning a response with headers and no body.</td></tr>
<tr><td style="text-align: left"><code>String</code></td><td style="text-align: left">A view name to be resolved with <code>ViewResolver</code> implementations and used together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method can also programmatically enrich the model by declaring a <code>Model</code> argument (see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-registration">Explicit Registrations</a>).</td></tr>
<tr><td style="text-align: left"><code>View</code></td><td style="text-align: left">A <code>View</code> instance to use for rendering together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method can also programmatically enrich the model by declaring a <code>Model</code> argument (see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-registration">Explicit Registrations</a>).</td></tr>
<tr><td style="text-align: left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></td><td style="text-align: left">Attributes to be added to the implicit model, with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>.</td></tr>
<tr><td style="text-align: left"><code>@ModelAttribute</code></td><td style="text-align: left">An attribute to be added to the model, with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>.Note that <code>@ModelAttribute</code> is optional. See &quot;Any other return value&quot; at the end of this table.</td></tr>
<tr><td style="text-align: left"><code>ModelAndView</code> object</td><td style="text-align: left">The view and model attributes to use and, optionally, a response status.</td></tr>
<tr><td style="text-align: left"><code>void</code></td><td style="text-align: left">A method with a <code>void</code> return type (or <code>null</code> return value) is considered to have fully handled the response if it also has a <code>ServletResponse</code>, an <code>OutputStream</code> argument, or an <code>@ResponseStatus</code> annotation. The same is also true if the controller has made a positive <code>ETag</code> or <code>lastModified</code> timestamp check (see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-caching-etag-lastmodified">Controllers</a> for details).If none of the above is true, a <code>void</code> return type can also indicate “no response body” for REST controllers or a default view name selection for HTML controllers.</td></tr>
<tr><td style="text-align: left"><code>DeferredResult&lt;V&gt;</code></td><td style="text-align: left">Produce any of the preceding return values asynchronously from any thread — for example, as a result of some event or callback. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-deferredresult"><code>DeferredResult</code></a>.</td></tr>
<tr><td style="text-align: left"><code>Callable&lt;V&gt;</code></td><td style="text-align: left">Produce any of the above return values asynchronously in a Spring MVC-managed thread. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-callable"><code>Callable</code></a>.</td></tr>
<tr><td style="text-align: left"><code>ListenableFuture&lt;V&gt;</code>, <code>java.util.concurrent.CompletionStage&lt;V&gt;</code>, <code>java.util.concurrent.CompletableFuture&lt;V&gt;</code></td><td style="text-align: left">Alternative to <code>DeferredResult</code>, as a convenience (for example, when an underlying service returns one of those).</td></tr>
<tr><td style="text-align: left"><code>ResponseBodyEmitter</code>, <code>SseEmitter</code></td><td style="text-align: left">Emit a stream of objects asynchronously to be written to the response with <code>HttpMessageConverter</code> implementations. Also supported as the body of a <code>ResponseEntity</code>. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-http-streaming">HTTP Streaming</a>.</td></tr>
<tr><td style="text-align: left"><code>StreamingResponseBody</code></td><td style="text-align: left">Write to the response <code>OutputStream</code> asynchronously. Also supported as the body of a <code>ResponseEntity</code>. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-http-streaming">HTTP Streaming</a>.</td></tr>
<tr><td style="text-align: left">Reactive types — Reactor, RxJava, or others through <code>ReactiveAdapterRegistry</code></td><td style="text-align: left">Alternative to <code>DeferredResult</code> with multi-value streams (for example, <code>Flux</code>, <code>Observable</code>) collected to a <code>List</code>.For streaming scenarios (for example, <code>text/event-stream</code>, <code>application/json+stream</code>), <code>SseEmitter</code> and <code>ResponseBodyEmitter</code> are used instead, where <code>ServletOutputStream</code> blocking I/O is performed on a Spring MVC-managed thread and back pressure is applied against the completion of each write.See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-reactive-types">Reactive Types</a>.</td></tr>
<tr><td style="text-align: left">Any other return value</td><td style="text-align: left">Any return value that does not match any of the earlier values in this table and that is a <code>String</code> or <code>void</code> is treated as a view name (default view name selection through <code>RequestToViewNameTranslator</code> applies), provided it is not a simple type, as determined by <a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>. Values that are simple types remain unresolved.</td></tr>
</tbody></table>
<h2 id="type-conversion"><a class="header" href="#type-conversion">Type Conversion</a></h2>
<ul>
<li>
<p>Some annotated controller method arguments that represent <code>String</code>-based request input (such as <code>@RequestParam</code>, <code>@RequestHeader</code>, <code>@PathVariable</code>, <code>@MatrixVariable</code>, and <code>@CookieValue</code>) can require type conversion if the argument is declared as something other than <code>String</code>.</p>
</li>
<li>
<p>For such cases, type conversion is automatically applied based on the configured converters. By default, simple types (<code>int</code>, <code>long</code>, <code>Date</code>, and others) are supported. You can customize type conversion through a <code>WebDataBinder</code> (see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-initbinder"><code>DataBinder</code></a>) or by registering <code>Formatters</code> with the <code>FormattingConversionService</code>. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#format">Spring Field Formatting</a>.</p>
</li>
<li>
<p>类型转换中的一个实际问题是处理空的String源值。This can be the case for <code>Long</code>, <code>UUID</code>, and other target types.如果要允许注入“ null”，请在参数注释上使用“ required”标志，或将参数声明为“ @Nullable”。</p>
</li>
</ul>
<p><strong>Null值处理</strong></p>
<ul>
<li>
<p>从5.3开始，即使在类型转换之后，也将强制使用非null参数，如果您的处理程序方法也打算接受null值，请在相应的@RequestParam等注释中将您的参数声明为@Nullable或将其标记为required = false。这是最佳实践，也是针对5.3升级中遇到的回归问题的推荐解决方案。</p>
</li>
<li>
<p>the resulting <code>MissingPathVariableException</code> in the case of a required <code>@PathVariable</code>. </p>
</li>
<li>
<p>转换后的空值将被视为空的原始值，因此将抛出相应的“ Missing…Exception”变体。</p>
</li>
</ul>
<h2 id="matrix-variables"><a class="header" href="#matrix-variables">Matrix Variables</a></h2>
<p><a href="https://tools.ietf.org/html/rfc3986#section-3.3">RFC 3986</a> 讨论了路径段中的 名称/值对. 在Spring MVC中，我们根据Tim Berners-Lee的<a href="https://www.w3.org/DesignIssues/MatrixURIs.html">“旧帖子”</a>将其称为“矩阵变量”，但它们也可以是被称为URI路径参数。</p>
<p>矩阵变量可以出现在任何路径段中，每个变量用分号分隔，多个值用逗号分隔，也可以通过重复的变量名称指定多个值</p>
<p><em>/cars;color=red,green;year=2012</em>  <code>color=red;color=green;color=blue</code></p>
<p>如果期望URL包含矩阵变量，则控制器方法的请求映射  必须使用URI变量来屏蔽该变量内容，并确保可以成功地匹配请求，而与矩阵变量的顺序和状态无关。
以下示例使用矩阵变量：</p>
<pre><code class="language-java">// GET /pets/42;q=11;r=22

@GetMapping(&quot;/pets/{petId}&quot;)
public void findPet(@PathVariable String petId, @MatrixVariable int q) {

    // petId == 42
    // q == 11
}
</code></pre>
<p>鉴于所有路径段都可能包含矩阵变量，因此有时您可能需要消除矩阵变量应位于哪个路径变量的歧义。下面的示例演示了如何做到这一点：</p>
<pre><code class="language-java">// GET /owners/42;q=11/pets/21;q=22, 手动指定路径变量

@GetMapping(&quot;/owners/{ownerId}/pets/{petId}&quot;)
public void findPet(
        @MatrixVariable(name=&quot;q&quot;, pathVar=&quot;ownerId&quot;) int q1,
        @MatrixVariable(name=&quot;q&quot;, pathVar=&quot;petId&quot;) int q2) {

    // q1 == 11
    // q2 == 22
}
</code></pre>
<p>矩阵变量可以 被定义为可选，并且可以指定默认值</p>
<pre><code class="language-java">// GET /pets/42

@GetMapping(&quot;/pets/{petId}&quot;)
public void findPet(@MatrixVariable(required=false, defaultValue=&quot;1&quot;) int q) {

    // q == 1
}
</code></pre>
<p><strong>获取所有矩阵变量</strong></p>
<pre><code class="language-java">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

@GetMapping(&quot;/owners/{ownerId}/pets/{petId}&quot;)
public void findPet(
        @MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,
        @MatrixVariable(pathVar=&quot;petId&quot;) MultiValueMap&lt;String, String&gt; petMatrixVars) {

    // matrixVars: [&quot;q&quot; : [11,22], &quot;r&quot; : 12, &quot;s&quot; : 23]
    // petMatrixVars: [&quot;q&quot; : 22, &quot;s&quot; : 23]
}
</code></pre>
<p>Note that you need to enable the use of matrix variables. </p>
<p>请注意，您需要启用矩阵变量的使用。在MVCJava配置中，设置 <code>UrlPathHelper</code> ，参数为 <code>removeSemicolonContent=false</code></p>
<p>XML配置  <code>&lt;mvc:annotation-driven enable-matrix-variables=&quot;true&quot;/&gt;</code>.</p>
<h2 id="requestparam"><a class="header" href="#requestparam"><code>@RequestParam</code></a></h2>
<p><strong>绑定请求参数</strong></p>
<p>您可以使用@RequestParam注解将Servlet请求参数（即查询参数或表单数据）绑定到控制器中的方法参数</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/pets&quot;)
public class EditPetForm {

    // ...

    @GetMapping
    public String setupForm(@RequestParam(&quot;petId&quot;) int petId, Model model) { 
        Pet pet = this.clinic.loadPet(petId);
        model.addAttribute(&quot;pet&quot;, pet);
        return &quot;petForm&quot;;
    }

    // ...

}
</code></pre>
<p>申明该注解的参数 不能为空，可以设置 <code>required</code> flag为 <em>false</em> 或者 申明为<code>java.util.Optional</code> </p>
<p>将参数类型声明为数组或列表，可以为同一参数名称解析多个参数值。</p>
<p>当将@RequestParam注解 声明为 <em>Map</em> 或 <em>MultiValueMap</em> 时，在注解中未指定参数名称时，则将为每个给定参数名称 填充请求参数值</p>
<p>注意，使用@RequestParam是可选的（例如，设置其属性）。
默认情况下，任何简单值类型的参数（由<a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>） 决定，并且未由其他任何参数解析器解析，则将其视为用@RequestParam注释。</p>
<h2 id="requestheader"><a class="header" href="#requestheader"><code>@RequestHeader</code></a></h2>
<p>You can use the <code>@RequestHeader</code> annotation to bind a request header to a method argument in a controller.</p>
<p>Consider the following request, with headers:</p>
<pre><code>Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300
</code></pre>
<p>The following example gets the value of the <code>Accept-Encoding</code> and <code>Keep-Alive</code> headers:</p>
<pre><code class="language-java">@GetMapping(&quot;/demo&quot;)
public void handle(
        @RequestHeader(&quot;Accept-Encoding&quot;) String encoding, 
        @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) { 
    //...
}
</code></pre>
<p>当在Map ，MultiValueMap 或HttpHeaders参数上使用@RequestHeader 注解时，将使用所有标头值填充映射。</p>
<p>将逗号分隔的字符串转换为数组或字符串集合或类型转换系统已知的其他类型。是内置支持的，例如 @RequestHeader(&quot;Accept&quot;) 可以是 String[],List[]</p>
<h2 id="cookievalue"><a class="header" href="#cookievalue"><code>@CookieValue</code></a></h2>
<pre><code class="language-java">@GetMapping(&quot;/demo&quot;)
public void handle(@CookieValue(&quot;JSESSIONID&quot;) String cookie) { 
    //...
}
</code></pre>
<h2 id="modelattribute"><a class="header" href="#modelattribute"><code>@ModelAttribute</code></a></h2>
<p>您可以在方法参数上使用@ModelAttribute注解，以从模型访问属性，或将其实例化（如果不存在）。 
model属性还覆盖了   名称与字段名称匹配的HTTP Servlet请求参数中的值。 这称为数据绑定，</p>
<p>它使您不必处理解析和转换单个查询参数和表单字段的工作。
以下示例显示了如何执行此操作：</p>
<pre><code class="language-java">@PostMapping(&quot;/owners/{ownerId}/pets/{petId}/edit&quot;)
public String processSubmit(@ModelAttribute Pet pet) { } 
</code></pre>
<p>The <code>Pet</code> instance above is resolved as follows:</p>
<ul>
<li>From the model if already added by using <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-modelattrib-methods">Model</a>. 首先尝试从模型中取</li>
<li>From the HTTP session by using <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a>. 从Session中取</li>
<li>From a URI path variable passed through a <code>Converter</code> (see the next example). 从Http 参数中取</li>
<li>From the invocation of a default constructor.  调用默认构造函数实例化 </li>
<li>从调用具有与Servlet请求参数匹配的参数的“主要构造函数”开始。
参数名称是通过JavaBeans @ConstructorProperties或字节码中  运行时保留的参数名称确定的。</li>
</ul>
<p>另一种替代方法是将“ Converter ”与URI路径变量约定结合使用。
在以下示例中，模型属性名称“ account”与URI路径变量“ account”匹配，并且通过将“ String”帐号传递给已注册的“ Converter ”来加载“ Account”。 </p>
<pre><code class="language-java">@PutMapping(&quot;/accounts/{account}&quot;)
public String save(@ModelAttribute(&quot;account&quot;) Account account) {
    // ...
}
</code></pre>
<p>The <code>WebDataBinder</code> class  匹配 请求参数名与 目标对象的字段名。匹配的名称对象在应用 类型转换之后 会被填充，有必要时  see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation">Validation</a>.see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-initbinder"><code>DataBinder</code></a>.</p>
<p>数据绑定可能导致错误。默认情况下，引发BindException。但是，要检查控制器方法中的此类错误，可以在@ModelAttribute旁边立即添加BindingResult参数，如以下示例所示：</p>
<pre><code class="language-java">@PostMapping(&quot;/owners/{ownerId}/pets/{petId}/edit&quot;)
public String processSubmit(@ModelAttribute(&quot;pet&quot;) Pet pet, BindingResult result) { 
    if (result.hasErrors()) {
        return &quot;petForm&quot;;
    }
    // ...
}
</code></pre>
<p>在某些情况下，您可能希望访问没有数据绑定的模型属性。对于这种情况，可以将模型注入控制器并直接访问它，或者设置@ModelAttribute（binding = false），如以下示例所示：</p>
<pre><code class="language-java">@ModelAttribute
public AccountForm setUpForm() {
    return new AccountForm();
}

@ModelAttribute
public Account findAccount(@PathVariable String accountId) {
    return accountRepository.findOne(accountId);
}

@PostMapping(&quot;update&quot;)
public String update(@Valid AccountForm form, BindingResult result,
        @ModelAttribute(binding=false) Account account) { 
    // ...
}
</code></pre>
<p>您可以在数据绑定之后通过添加javax.validation.Valid注解 或Spring的@Validated注解 自动应用校验 (<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation-beanvalidation">Bean Validation</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation">Spring validation</a>).</p>
<pre><code class="language-java">@PostMapping(&quot;/owners/{ownerId}/pets/{petId}/edit&quot;)
public String processSubmit(@Valid @ModelAttribute(&quot;pet&quot;) Pet pet, BindingResult result) { 
    if (result.hasErrors()) {
        return &quot;petForm&quot;;
    }
    // ...
}
</code></pre>
<p>注意，使用@ModelAttribute是可选的（例如，设置其属性）,</p>
<p>默认情况下，任何不是简单值类型的参数（由<a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>）并且未由其他任何参数解析器解析，就如同使用@ModelAttribute注释一样。</p>
<h2 id="sessionattributes"><a class="header" href="#sessionattributes"><code>@SessionAttributes</code></a></h2>
<p>@SessionAttributes用于在请求之间的HTTP Servlet会话中存储模型属性。</p>
<p>它是类型级别的注释，用于声明特定控制器使用的会话属性。</p>
<p>这通常列出  应该透明地存储在会话中以供后续访问请求的模型<strong>属性的名称</strong>或模型<strong>属性的类型</strong>。</p>
<pre><code class="language-java">@Controller
@SessionAttributes(&quot;pet&quot;) 
public class EditPetForm {
    // ...
}
</code></pre>
<p>在第一个请求中，将名称为“ pet”的模型属性添加到模型时，该属性会自动提升为HTTP Servlet会话并保存在该会话中。
它会一直保留在那里，直到另一个控制器方法使用一个SessionStatus方法参数来清除存储空间为止，如以下示例所示：</p>
<pre><code class="language-java">@Controller
@SessionAttributes(&quot;pet&quot;)  //存储 pet在session中
public class EditPetForm {

    // ...

    @PostMapping(&quot;/pets/{id}&quot;)
    public String handle(Pet pet, BindingResult errors, SessionStatus status) {
        if (errors.hasErrors) {
            // ...
        }
            status.setComplete(); // 清除  session中的 pet value
            // ...
        }
    }
}
</code></pre>
<h2 id="sessionattribute"><a class="header" href="#sessionattribute"><code>@SessionAttribute</code></a></h2>
<p>如果您需要访问    全局管理（例如，在控制器外部（例如，通过过滤器））管理  且可能存在或不存在的预先存在的会话属性，则可以在方法参数上使用@SessionAttribute批注，如以下示例所示：</p>
<pre><code class="language-java">@RequestMapping(&quot;/&quot;)
public String handle(@SessionAttribute User user) { 
    // ...
}
</code></pre>
<p>Using a <code>@SessionAttribute</code> annotation.</p>
<p>For use cases that require adding or removing session attributes, consider injecting <code>org.springframework.web.context.request.WebRequest</code> or <code>javax.servlet.http.HttpSession</code> into the controller method.</p>
<p>对于需要添加或删除会话属性的用例，请考虑将org.springframework.web.context.request.WebRequest或javax.servlet.http.HttpSession注入到控制器方法中。</p>
<p>为了将模型属性作为控制器工作流的一部分临时存储在会话中，请考虑使用 <code>@SessionAttributes</code> as described in <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a>.</p>
<h2 id="requestattribute"><a class="header" href="#requestattribute"><code>@RequestAttribute</code></a></h2>
<p>Similar to <code>@SessionAttribute</code>, you can use the <code>@RequestAttribute</code> annotations to access pre-existing request attributes created earlier (for example, by a Servlet <code>Filter</code> or <code>HandlerInterceptor</code>):</p>
<p>与<code>@ SessionAttribute</code>类似，您可以使用@RequestAttribute 注解 来访问先前创建的请求属性（例如，由Servlet<code>Filter</code>或<code>HandlerInterceptor</code>创建）：</p>
<pre><code class="language-java">@GetMapping(&quot;/&quot;)
public String handle(@RequestAttribute Client client) { 
    // ...
}
</code></pre>
<h2 id="redirect-attributes"><a class="header" href="#redirect-attributes">Redirect Attributes.</a></h2>
<p>默认情况下，所有模型属性均被视为在重定向URL中作为URI模板变量公开。在其余属性中，那些属于原始类型或原始类型的集合或数组的属性会自动附加为查询参数。</p>
<p>如果专门为重定向准备了模型实例，将原始类型属性作为查询参数附加可能是理想的结果。
但是，在带注解的控制器中，模型可以包含为渲染目的添加的其他属性（例如，下拉字段值）。
为了避免此类属性出现在URL中，@RequestMapping方法可以声明类型为RedirectAttributes的参数，并使用它来指定确切的属性以供RedirectView使用。
如果该方法确实重定向，则使用<code>RedirectAttributes</code>的内容。
否则，将使用模型的内容。</p>
<p>“RequestMappingHandlerAdapter”提供了一个名为“ ignoreDefaultModelOnRedirect”的标志，您可以使用该标志指示如果控制器方法重定向，则绝不要使用默认“ Model”的内容。相反，控制器方法应声明一个类型为RedirectAttributes的属性，或者如果没有声明，则不应将任何属性传递给RedirectView。 
MVC命名空间和MVC Java配置都将此标志设置为“ false”，以保持向后兼容性。
但是，对于新应用程序，我们建议将其设置为“ true”。</p>
<p>请注意，展开重定向URL时，当前请求中的URI模板变量会自动变为可用，并且您无需通过“模型”或“ RedirectAttributes”显式添加它们。</p>
<pre><code class="language-java">@PostMapping(&quot;/files/{path}&quot;)
public String upload(...) {
    // ...
    return &quot;redirect:files/{path}&quot;;
}
</code></pre>
<p>将数据传递到重定向目标的另一种方法是使用闪存属性。与其他重定向属性不同，Flash属性保存在HTTP会话中（因此不会出现在URL中）。 See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-flash-attributes">Flash Attributes</a> for more information.</p>
<h2 id="flash-attributes"><a class="header" href="#flash-attributes">Flash Attributes</a></h2>
<p>Flash属性为一个请求 提供了 向另一种请求传递属性的 存储方式。重定向时最常需要此操作，例如Post-Redirect-Get模式。 Flash属性在重定向之前（通常在会话中）被临时保存，以便在重定向之后可供请求使用，并立即被删除。</p>
<p>Spring MVC有两个主要抽象来支持Flash属性。 FlashMap用于保存Flash属性，而FlashMapManager用于存储，检索和管理FlashMap实例。</p>
<p>Flash属性支持始终处于“打开”状态，无需显式启用。</p>
<p>在每个请求上，都有一个“输入”“ FlashMap”，其属性是从前一个请求（如果有）传递过来的；“输出”“ FlashMap”，其属性是为后续请求保存的。</p>
<p>可以通过RequestContextUtils中的静态方法从Spring MVC中的任何位置访问这两个FlashMap实例。</p>
<p>带注释的控制器通常不需要直接与FlashMap一起使用。
相反，@ RequestMapping方法可以接受RedirectAttributes类型的参数，并使用它为重定向方案添加Flash属性。
通过“ RedirectAttributes”添加的Flash属性会自动传播到“输出” FlashMap。
同样，重定向后，来自“输入”“ FlashMap”的属性会自动添加到提供目标URL的控制器的“模型”中</p>
<p><strong>Matching requests to flash attributes</strong></p>
<p>Flash属性的概念存在于许多其他Web框架中，并已证明有时会遇到并发问题。
这是因为根据定义，闪存属性将存储到下一个请求。
但是，“下一个”请求可能不是预期的接收者，而是另一个异步请求（例如，轮询或资源请求），在这种情况下，过早删除闪存属性。</p>
<p>为了减少此类问题的可能性，“ RedirectView”会自动使用目标重定向URL的路径和查询参数对“ FlashMap”实例进行“标记”。
反过来，默认的FlashMapManager在查找“输入” FlashMap时会将信息与传入请求匹配。</p>
<p>这不能完全消除并发问题的可能性，但是可以通过重定向URL中已经可用的信息大大减少并发问题。
因此，我们建议您主要将Flash属性用于重定向方案。</p>
<h2 id="multipart"><a class="header" href="#multipart">Multipart</a></h2>
<pre><code class="language-java">@Controller
public class FileUploadController {

    @PostMapping(&quot;/form&quot;)
    public String handleFormUpload(@RequestParam(&quot;name&quot;) String name,
            @RequestParam(&quot;file&quot;) MultipartFile file) {

        if (!file.isEmpty()) {
            byte[] bytes = file.getBytes();
            // store the bytes somewhere
            return &quot;redirect:uploadSuccess&quot;;
        }
        return &quot;redirect:uploadFailure&quot;;
    }
}
</code></pre>
<p>将参数类型声明为List 允许解析相同参数名称的多个文件。
如果将@RequestParam批注声明为Map 或MultiValueMap ，但未在批注中指定参数名称，则将使用每个给定参数名称的多部分文件填充该映射。</p>
<blockquote>
<p>使用Servlet 3.0多部分解析时，您还可以将Javax.servlet.http.Part声明为方法参数或集合值类型，而不是Spring的MultipartFile。</p>
</blockquote>
<p>您还可以将多部件内容用作数据绑定到  <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-modelattrib-method-args">command object</a>. 的一部分，例如表单字段，</p>
<pre><code class="language-java">class MyForm {

    private String name;

    private MultipartFile file;

    // ...
}

@Controller
public class FileUploadController {

    @PostMapping(&quot;/form&quot;)
    public String handleFormUpload(MyForm form, BindingResult errors) {
        if (!form.getFile().isEmpty()) {
            byte[] bytes = form.getFile().getBytes();
            // store the bytes somewhere
            return &quot;redirect:uploadSuccess&quot;;
        }
        return &quot;redirect:uploadFailure&quot;;
    }
}
</code></pre>
<p>在RESTful服务方案中，也可以从非浏览器客户端提交多部分请求。 以下示例显示了带有JSON的文件：</p>
<pre><code class="language-java">POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name=&quot;meta-data&quot;
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
    &quot;name&quot;: &quot;value&quot;
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name=&quot;file-data&quot;; filename=&quot;file.properties&quot;
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...
</code></pre>
<p>您可以使用@RequestParam作为字符串访问“元数据”部分，但您可能希望将其从JSON反序列化（类似于“ @RequestBody”）。
在使用  <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#rest-message-conversion">HttpMessageConverter</a> 将其转换后，使用@RequestPart注解来访问多部件</p>
<pre><code class="language-java">@PostMapping(&quot;/&quot;)
public String handle(@RequestPart(&quot;meta-data&quot;) MetaData metadata,
        @RequestPart(&quot;file-data&quot;) MultipartFile file) {
    // ...
}
</code></pre>
<p>您可以将@RequestPart与javax.validation.Valid结合使用，也可以使用Spring的@Validated注释，这两种注释都会导致应用标准Bean验证。
默认情况下，验证错误会导致“ MethodArgumentNotValidException”，并将其转换为400（BAD_REQUEST）响应。
或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误，如以下示例所示：</p>
<pre><code class="language-javascript">@PostMapping(&quot;/&quot;)
public String handle(@Valid @RequestPart(&quot;meta-data&quot;) MetaData metadata,
        BindingResult result) {
    // ...
}
</code></pre>
<h2 id="requestbody-1"><a class="header" href="#requestbody-1"><code>@RequestBody</code></a></h2>
<p>您可以使用@RequestBody 注解 使请求正文通过HttpMessageConverter读取并反序列化为Object。 以下示例使用@RequestBody参数：</p>
<pre><code class="language-java">@PostMapping(&quot;/accounts&quot;)
public void handle(@RequestBody Account account) {
    // ...
}

</code></pre>
<p>You can use the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-message-converters">Message Converters</a> option of the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config">MVC Config</a> to configure or customize message conversion.</p>
<p>您可以结合使用@RequestBody和Javax.validation.Valid或Spring的@Validated注释，这两种注释都会导致应用标准Bean验证。
默认情况下，验证错误会导致“ MethodArgumentNotValidException”，并将其转换为400（BAD_REQUEST）响应。
或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误，如以下示例所示：</p>
<pre><code class="language-java">@PostMapping(&quot;/accounts&quot;)
public void handle(@Valid @RequestBody Account account, BindingResult result) {
    // ...
}
</code></pre>
<h2 id="httpentity"><a class="header" href="#httpentity">HttpEntity</a></h2>
<p>HttpEntity或多或少与使用@RequestBody相同，但它基于公开请求标头和正文的容器对象。以下清单显示了一个示例：</p>
<pre><code class="language-java">@PostMapping(&quot;/accounts&quot;)
public void handle(HttpEntity&lt;Account&gt; entity) {
    // ...
}
</code></pre>
<h2 id="responsebody"><a class="header" href="#responsebody"><code>@ResponseBody</code></a></h2>
<p>您可以在方法上使用@ResponseBody批注，以通过HttpMessageConverter将返回序列化为响应主体。
以下清单显示了一个示例：</p>
<pre><code class="language-java">@GetMapping(&quot;/accounts/{id}&quot;)
@ResponseBody
public Account handle() {
    // ...
}
</code></pre>
<p><code>@ResponseBody</code> is also supported at the class level, in which case it is inherited by all controller methods. This is the effect of <code>@RestController</code>, which is nothing more than a meta-annotation marked with <code>@Controller</code> and <code>@ResponseBody</code>.</p>
<p>在类级别还支持@ResponseBody，在这种情况下，它由所有控制器方法继承。这就是@RestController的效果，它只不过是带有@Controller和@ResponseBody标记的元注释。</p>
<p>@ResponseBody与 响应式类型一起使用 See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-reactive-types">Reactive Types</a> for more details.</p>
<p>You can use the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-message-converters">Message Converters</a> option of the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config">MVC Config</a> to configure or customize message conversion.</p>
<p>You can combine <code>@ResponseBody</code> methods with JSON serialization views. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-jackson">Jackson JSON</a> for details.</p>
<h2 id="responseentity"><a class="header" href="#responseentity">ResponseEntity</a></h2>
<p><code>ResponseEntity</code> is like <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-responsebody"><code>@ResponseBody</code></a> but with status and headers. For example:</p>
<pre><code class="language-java">@GetMapping(&quot;/something&quot;)
public ResponseEntity&lt;String&gt; handle() {
    String body = ... ;
    String etag = ... ;
    return ResponseEntity.ok().eTag(etag).build(body);
}
</code></pre>
<p>Spring MVC supports using a single value <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-reactive-types">reactive type</a> to produce the <code>ResponseEntity</code> asynchronously, and/or single and multi-value reactive types for the body.</p>
<h2 id="jackson-json"><a class="header" href="#jackson-json">Jackson JSON</a></h2>
<p>Spring offers support for the Jackson JSON library.</p>
<p>Spring MVC为Jackson的序列化视图提供了内置支持，该视图仅可呈现Object中所有字段的一部分。
要将其与@ResponseBody或ResponseEntity控制器方法一起使用，可以使用Jackson的@JsonView批注来激活序列化视图类，如以下示例所示：</p>
<pre><code class="language-java">@RestController
public class UserController {

    @GetMapping(&quot;/user&quot;)
    @JsonView(User.WithoutPasswordView.class)
    public User getUser() {
        return new User(&quot;eric&quot;, &quot;7!jd#h23&quot;);
    }
}

public class User {

    public interface WithoutPasswordView {};
    public interface WithPasswordView extends WithoutPasswordView {};

    private String username;
    private String password;

    public User() {
    }

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    @JsonView(WithoutPasswordView.class)
    public String getUsername() {
        return this.username;
    }

    @JsonView(WithPasswordView.class)
    public String getPassword() {
        return this.password;
    }
}
</code></pre>
<p>@JsonView允许一组视图类，但是每个控制器方法只能指定一个。
如果需要激活多个视图，则可以使用组合接口</p>
<p>如果要以编程方式执行上述操作，而不是声明@JsonView批注，请使用MappingJacksonValue包装返回值，并使用其提供序列化视图：</p>
<pre><code class="language-java">@RestController
public class UserController {

    @GetMapping(&quot;/user&quot;)
    public MappingJacksonValue getUser() {
        User user = new User(&quot;eric&quot;, &quot;7!jd#h23&quot;);
        MappingJacksonValue value = new MappingJacksonValue(user);
        value.setSerializationView(User.WithoutPasswordView.class);
        return value;
    }
}
</code></pre>
<p>对于依赖视图解析 的控制器，可以将序列化视图类添加到模型中，如以下示例所示</p>
<pre><code class="language-java">@Controller
public class UserController extends AbstractController {

    @GetMapping(&quot;/user&quot;)
    public String getUser(Model model) {
        model.addAttribute(&quot;user&quot;, new User(&quot;eric&quot;, &quot;7!jd#h23&quot;));
        model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);
        return &quot;userView&quot;;
    }
}
</code></pre>
<h1 id="model"><a class="header" href="#model">Model</a></h1>
<p>您可以使用<code>@ ModelAttribute</code>注解：</p>
<ul>
<li>注解在@RequestMapping方法中的方法参数中 ，  从模型创建或访问“对象”，然后通过“ WebDataBinder”将其绑定到请求。</li>
<li>作为@Controller或@ControllerAdvice类中的方法级 注解，可在任何@RequestMapping方法调用之前帮助初始化模型。 </li>
<li>在@RequestMapping方法上   标记其返回值的是模型属性</li>
</ul>
<p>This section discusses <code>@ModelAttribute</code> methods的第二项 控制器可以具有任意数量的@ModelAttribute方法，所有这些方法均在同一控制器中的@RequestMapping方法之前被调用,也可以通过@ControllerAdvice在控制器之间共享@ModelAttribute方法。See the section on <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-controller-advice">Controller Advice</a> for more details.</p>
<pre><code class="language-java">@ModelAttribute
public void populateModel(@RequestParam String number, Model model) {
    model.addAttribute(accountRepository.findAccount(number));
    // add more ...
}
</code></pre>
<p>The following example adds only one attribute:</p>
<pre><code class="language-java">@ModelAttribute
public Account addAccount(@RequestParam String number) {
    return accountRepository.findAccount(number);
}
</code></pre>
<p>如果未明确指定名称，则根据“对象”类型选择默认名称，如约定的javadoc中所述。 您始终可以使用重载的addAttribute方法或通过@ModelAttribute上的name属性（用于返回值）来分配显式名称。</p>
<p>您也可以将@ModelAttribute用作@RequestMapping方法上的方法级注释，在这种情况下，@ RequestMapping方法的返回值将解释为模型属性。
通常不需要这样做，因为它是HTML控制器的默认行为，除非返回值是一个String，否则它将被解释为视图名称。 
@ModelAttribute还可以自定义模型属性名称，如以下示例所示：</p>
<pre><code class="language-java">@GetMapping(&quot;/accounts/{id}&quot;)
@ModelAttribute(&quot;myAccount&quot;)
public Account handle() {
    // ...
    return account;
}
</code></pre>
<h1 id="databinder"><a class="header" href="#databinder"><code>DataBinder</code></a></h1>
<p>@Controller或@ControllerAdvice类   可以具有用于初始化WebDataBinder实例的@InitBinder方法，而这些方法又可以：</p>
<ul>
<li>将请求参数（即表单或查询数据）绑定到模型对象。</li>
<li>将基于字符串的请求值（例如请求参数，路径变量，标头，Cookie等）转换为控制器方法参数的目标类型。</li>
<li>呈现HTML表单时，将模型对象的值格式化为String值。</li>
</ul>
<p>@InitBinder方法可以注册特定于控制器的java.beans.PropertyEditor或Spring Converter和Formatter组件。
此外，您可以使用MVC配置在全局共享的FormattingConversionService中注册Converter和Formatter类型。</p>
<p>@InitBinder方法支持与@RequestMapping方法相同的许多参数，除了@ModelAttribute（命令对象）参数。
通常，它们使用WebDataBinder参数（用于注册）和 返回 void
以下清单显示了一个示例：</p>
<p>另外，当通过共享的FormattingConversionService使用基于Formatter的设置时，可以重新使用相同的方法并注册特定于控制器的Formatter实现，如以下示例所示：</p>
<pre><code class="language-java">@Controller
public class FormController {

    @InitBinder 
    protected void initBinder(WebDataBinder binder) {
        binder.addCustomFormatter(new DateFormatter(&quot;yyyy-MM-dd&quot;));
    }

    // ...
}
</code></pre>
<h1 id="exceptions-1"><a class="header" href="#exceptions-1">Exceptions</a></h1>
<p>@Controller和@ControllerAdvice类可以具有@ExceptionHandler方法来处理控制器方法的异常，如以下示例所示：</p>
<pre><code class="language-java">@Controller
public class SimpleController {

    // ...

    @ExceptionHandler
    public ResponseEntity&lt;String&gt; handle(IOException ex) {
        // ...
    }
}
</code></pre>
<ul>
<li>该异常可能与正在传播的顶级异常（例如，直接IOException被抛出）匹配，</li>
<li>也可能与包装器异常内的嵌套原因（例如，包装在IllegalStateException中的IOException）相匹配。</li>
<li>从5.3开始，这可以在任意  原因异常 级别上匹配，而以前只考虑了直接原因。</li>
</ul>
<p>对于匹配的异常类型，如前面的示例所示，最好将目标异常声明为方法参数。当多个异常方法匹配时，根源异常匹配通常比 原因异常 匹配更可取。
更具体地说，ExceptionDepthComparator用于根据从引发的异常类型开始的深度对异常进行排序。</p>
<p>另外，注释声明可以缩小异常类型以使其匹配，如以下示例所示：</p>
<pre><code class="language-java">@ExceptionHandler({FileSystemException.class, RemoteException.class})
public ResponseEntity&lt;String&gt; handle(IOException ex) {
    // ...
}
</code></pre>
<p>您甚至可以使用带有非常<strong>通用的参数签名</strong>的<strong>特定异常类型的列表</strong>，如以下示例所示：</p>
<pre><code class="language-java">@ExceptionHandler({FileSystemException.class, RemoteException.class})
public ResponseEntity&lt;String&gt; handle(Exception ex) {
    // ...
}
</code></pre>
<p><strong>root and cause exception matching</strong></p>
<p>在前面显示的IOException变体中，通常使用实际的FileSystemException或RemoteException实例作为参数来调用该方法，因为这两个实例均从IOException扩展。但是，如果任何此类匹配异常都在本身是IOException的包装器异常中传播，则传入的异常实例就是该包装器异常。</p>
<p>仅当将它们作为顶级异常抛出时，传入的异常才是实际的FileSystemException或RemoteException实例。</p>
<p>我们通常建议您在参数签名中尽可能具体，以减少根类型和原因异常类型之间不匹配的可能性。
考虑将多重匹配方法分解为单独的@ExceptionHandler方法，每个方法均通过其签名匹配单个特定的异常类型。</p>
<p>最后但并非最不重要的一点是，@ExceptionHandler方法实现可以选择通过以原始形式重新抛出异常来退出处理给定异常实例。
在仅对根级别匹配或无法静态确定的特定上下文中的匹配感兴趣的情况下，这很有用。
重新抛出的异常会在其余的解决方案链中传播，就像给定的@ExceptionHandler方法最初不会匹配一样。</p>
<p>Spring MVC中对@ExceptionHandler方法的支持建立在DispatcherServlet级别HandlerExceptionResolver机制上。</p>
<h2 id="method-arguments"><a class="header" href="#method-arguments">Method Arguments</a></h2>
<p><code>@ExceptionHandler</code> 方法支持 以下参数</p>
<table><thead><tr><th style="text-align: left">Method argument</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Exception type</td><td style="text-align: left">For access to the raised exception.</td></tr>
<tr><td style="text-align: left"><code>HandlerMethod</code></td><td style="text-align: left">For access to the controller method that raised the exception.</td></tr>
<tr><td style="text-align: left"><code>WebRequest</code>, <code>NativeWebRequest</code></td><td style="text-align: left">Generic access to request parameters and request and session attributes without direct use of the Servlet API.</td></tr>
<tr><td style="text-align: left"><code>javax.servlet.ServletRequest</code>, <code>javax.servlet.ServletResponse</code></td><td style="text-align: left">Choose any specific request or response type (for example, <code>ServletRequest</code> or <code>HttpServletRequest</code> or Spring’s <code>MultipartRequest</code> or <code>MultipartHttpServletRequest</code>).</td></tr>
<tr><td style="text-align: left"><code>javax.servlet.http.HttpSession</code></td><td style="text-align: left">Enforces the presence of a session. As a consequence, such an argument is never <code>null</code>. Note that session access is not thread-safe. Consider setting the <code>RequestMappingHandlerAdapter</code> instance’s <code>synchronizeOnSession</code> flag to <code>true</code> if multiple requests are allowed to access a session concurrently.</td></tr>
<tr><td style="text-align: left"><code>java.security.Principal</code></td><td style="text-align: left">Currently authenticated user — possibly a specific <code>Principal</code> implementation class if known.</td></tr>
<tr><td style="text-align: left"><code>HttpMethod</code></td><td style="text-align: left">The HTTP method of the request.</td></tr>
<tr><td style="text-align: left"><code>java.util.Locale</code></td><td style="text-align: left">The current request locale, determined by the most specific <code>LocaleResolver</code> available — in effect, the configured <code>LocaleResolver</code> or <code>LocaleContextResolver</code>.</td></tr>
<tr><td style="text-align: left"><code>java.util.TimeZone</code>, <code>java.time.ZoneId</code></td><td style="text-align: left">The time zone associated with the current request, as determined by a <code>LocaleContextResolver</code>.</td></tr>
<tr><td style="text-align: left"><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td style="text-align: left">For access to the raw response body, as exposed by the Servlet API.</td></tr>
<tr><td style="text-align: left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td style="text-align: left">For access to the model for an error response. Always empty.</td></tr>
<tr><td style="text-align: left"><code>RedirectAttributes</code></td><td style="text-align: left">Specify attributes to use in case of a redirect — (that is to be appended to the query string) and flash attributes to be stored temporarily until the request after the redirect. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-redirecting-passing-data">Redirect Attributes</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-flash-attributes">Flash Attributes</a>.</td></tr>
<tr><td style="text-align: left"><code>@SessionAttribute</code></td><td style="text-align: left">For access to any session attribute, in contrast to model attributes stored in the session as a result of a class-level <code>@SessionAttributes</code> declaration. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-sessionattribute"><code>@SessionAttribute</code></a> for more details.</td></tr>
<tr><td style="text-align: left"><code>@RequestAttribute</code></td><td style="text-align: left">For access to request attributes. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestattrib"><code>@RequestAttribute</code></a> for more details.</td></tr>
</tbody></table>
<p><strong>返回值</strong></p>
<table><thead><tr><th style="text-align: left">Return value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>@ResponseBody</code></td><td style="text-align: left">The return value is converted through <code>HttpMessageConverter</code> instances and written to the response. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-responsebody"><code>@ResponseBody</code></a>.</td></tr>
<tr><td style="text-align: left"><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></td><td style="text-align: left">The return value specifies that the full response (including the HTTP headers and the body) be converted through <code>HttpMessageConverter</code> instances and written to the response. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-responseentity">ResponseEntity</a>.</td></tr>
<tr><td style="text-align: left"><code>String</code></td><td style="text-align: left">A view name to be resolved with <code>ViewResolver</code> implementations and used together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method can also programmatically enrich the model by declaring a <code>Model</code> argument (described earlier).</td></tr>
<tr><td style="text-align: left"><code>View</code></td><td style="text-align: left">A <code>View</code> instance to use for rendering together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method may also programmatically enrich the model by declaring a <code>Model</code> argument (descried earlier).</td></tr>
<tr><td style="text-align: left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></td><td style="text-align: left">Attributes to be added to the implicit model with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>.</td></tr>
<tr><td style="text-align: left"><code>@ModelAttribute</code></td><td style="text-align: left">An attribute to be added to the model with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>.Note that <code>@ModelAttribute</code> is optional. See “Any other return value” at the end of this table.</td></tr>
<tr><td style="text-align: left"><code>ModelAndView</code> object</td><td style="text-align: left">The view and model attributes to use and, optionally, a response status.</td></tr>
<tr><td style="text-align: left"><code>void</code></td><td style="text-align: left">A method with a <code>void</code> return type (or <code>null</code> return value) is considered to have fully handled the response if it also has a <code>ServletResponse</code> an <code>OutputStream</code> argument, or a <code>@ResponseStatus</code> annotation. The same is also true if the controller has made a positive <code>ETag</code> or <code>lastModified</code> timestamp check (see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-caching-etag-lastmodified">Controllers</a> for details).If none of the above is true, a <code>void</code> return type can also indicate “no response body” for REST controllers or default view name selection for HTML controllers.</td></tr>
<tr><td style="text-align: left">Any other return value</td><td style="text-align: left">If a return value is not matched to any of the above and is not a simple type (as determined by <a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>), by default, it is treated as a model attribute to be added to the model. If it is a simple type, it remains unresolved.</td></tr>
</tbody></table>
<h2 id="rest-api-exceptions"><a class="header" href="#rest-api-exceptions">REST API exceptions</a></h2>
<p>REST服务的常见要求是在响应正文中包含错误详细信息。 
Spring框架不会自动执行此操作，因为响应主体中错误详细信息的表示是特定于应用程序的。
但是，@ RestController可以将@ExceptionHandler方法与ResponseEntity返回值一起使用，以设置响应的状态和主体。
也可以在@ControllerAdvice类中声明此类方法，以将其全局应用。</p>
<p>在响应主体中实现具有错误详细信息的全局异常处理的应用程序应考虑扩展ResponseEntityExceptionHandler，它提供了Spring MVC引发的异常的处理并提供了自定义响应主体的钩子。
要使用此功能，请创建ResponseEntityExceptionHandler的子类，并使用@ControllerAdvice对其进行注释，重写必需的方法，并将其声明为Spring bean。</p>
<h1 id="controller-advice"><a class="header" href="#controller-advice">Controller Advice</a></h1>
<p>通常，@ ExceptionHandler，@ InitBinder和@ModelAttribute方法在声明它们的@Controller类（或类层次结构）中应用。
如果要使<strong>此类方法更全局地应用</strong>（跨控制器），则可以在带有@ControllerAdvice或@RestControllerAdvice注释的类中声明它们。</p>
<ul>
<li>启动时，@RequestMapping和@ExceptionHandler方法的基础结构类将检测使用  @ControllerAdvice注释的Spring bean，然后在运行时应用其方法。
全局@ExceptionHandler方法（来自@ControllerAdvice）在本地方法（来自@Controller）之后应用。</li>
<li>相比之下，全局@ModelAttribute和@InitBinder方法在本地方法之前应用。</li>
</ul>
<p>默认情况下，@ ControllerAdvice方法适用于每个请求（即所有控制器），但是您可以通过使用批注上的属性将其范围缩小到控制器的子集，如以下示例所示：</p>
<pre><code class="language-java">// Target all Controllers annotated with @RestController 所有RestController
@ControllerAdvice(annotations = RestController.class)
public class ExampleAdvice1 {}

// Target all Controllers within specific packages 特定 controller类
@ControllerAdvice(&quot;org.example.controllers&quot;)
public class ExampleAdvice2 {}

// Target all Controllers assignable to specific classes  抽象基类
@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
public class ExampleAdvice3 {}
</code></pre>
<p>前面示例中的选择器在运行时进行评估，如果广泛使用，可能会对性能产生负面影响。
有关更多详细信息，请参见@ControllerAdvice javadoc。</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="静态资源处理"><a class="header" href="#静态资源处理">静态资源处理</a></h1>
<h2 id="静态资源映射规则"><a class="header" href="#静态资源映射规则">静态资源映射规则</a></h2>
<p>SpringBoot中，SpringMVC的web配置都在 <em>WebMvcAutoConfiguration</em> 这个配置类里面；</p>
<p><em>WebMvcAutoConfiguration.EnableWebMvcConfiguration#addResourceHandlers</em> 方法可以添加</p>
<pre><code class="language-java">protected void addResourceHandlers(ResourceHandlerRegistry registry) {
    super.addResourceHandlers(registry);
    if (!this.resourceProperties.isAddMappings()) {
        logger.debug(&quot;Default resource handling disabled&quot;);
        return;
    }
    ServletContext servletContext = getServletContext();
    addResourceHandler(registry, &quot;/webjars/**&quot;, &quot;classpath:/META-INF/resources/webjars/&quot;);
    addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; {
        registration.addResourceLocations(this.resourceProperties.getStaticLocations());
        if (servletContext != null) {
            registration.addResourceLocations(new ServletContextResource(servletContext, SERVLET_LOCATION));
        }
    });
}
</code></pre>
<h3 id="webjar"><a class="header" href="#webjar">webJar</a></h3>
<p>比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源；</p>
<p>Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。</p>
<p>使用SpringBoot需要使用Webjars，网站：<a href="https://www.webjars.org/">https://www.webjars.org</a></p>
<h3 id="静态目录"><a class="header" href="#静态目录">静态目录</a></h3>
<pre><code class="language-java">private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { 
    &quot;classpath:/META-INF/resources/&quot;,
  &quot;classpath:/resources/&quot;, 
    &quot;classpath:/static/&quot;, 
    &quot;classpath:/public/&quot; 
};
</code></pre>
<h1 id="自定义静态资源路径"><a class="header" href="#自定义静态资源路径">自定义静态资源路径</a></h1>
<p>spring.resources.static-locations=classpath:/coding/,classpath:/kuang/
<strong>一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！</strong></p>
<p>`</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mybatis多数据源配置"><a class="header" href="#mybatis多数据源配置">mybatis多数据源配置</a></h1>
<h2 id="继承数据源路由类"><a class="header" href="#继承数据源路由类">继承数据源路由类</a></h2>
<p><em>AbstractRoutingDataSource</em></p>
<pre><code class="language-java">    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDatasourceType();
    }
数据源的路由策略是:同一线程内的 数据源一致

package com.weisanju.hikaricp.datasource;

public class DataSourceContextHolder {
    public static final ThreadLocal&lt;String&gt; contextHolder=new ThreadLocal&lt;&gt;();

    public static void setDataSource(String type){
        contextHolder.set(type);
    }

    public static String getDatasourceType(){
        return contextHolder.get();
    }

    public static void clearDataSourceType(){
        contextHolder.remove();
    }
}

</code></pre>
<h2 id="使用自定义注解aop切换数据源"><a class="header" href="#使用自定义注解aop切换数据源">使用自定义注解+AOP切换数据源</a></h2>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD,ElementType.TYPE})
public @interface DataSourceSwitch {
    String value()default &quot;test&quot;;
}
</code></pre>
<pre><code class="language-java">@Aspect
@Component
public class DataSourceAspect {
    @Before(&quot;@annotation(ds)&quot;)
    public void beforeDataSource(DataSourceSwitch ds) {
        DataSourceContextHolder.setDataSource(ds.value());
    }
    @After(&quot;@annotation(ds)&quot;)
    public void afterDataSource(DataSourceSwitch ds){
        DataSourceContextHolder.clearDataSourceType();
    }
}
</code></pre>
<h2 id="使用配置类配置mybatis"><a class="header" href="#使用配置类配置mybatis">使用配置类配置mybatis</a></h2>
<ul>
<li>
<p>配置 原始 数据源</p>
</li>
<li>
<p>配置 动态数据源(代理类)</p>
</li>
<li>
<p>配置<em>sqlsessionFactory</em></p>
<p>需要指定的东西</p>
<ul>
<li>动态数据源</li>
<li>xml文件(原本在配置文件种指定的)</li>
</ul>
</li>
<li>
<p>配置事务管理器</p>
<pre><code class="language-java">@Configuration
@MapperScan(basePackages=&quot;com.weisanju.hikaricp.mapper&quot;)
public class MybatisConfig {

    @Bean(&quot;ase&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.ase&quot;)
    public DataSource ase(){
        return DataSourceBuilder.create().build();
    }
    @Bean(&quot;test&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.test&quot;)
    public DataSource test(){
        return DataSourceBuilder.create().build();
    }

    @Bean
    public DynamicDataSource dataSource(@Qualifier(&quot;ase&quot;) DataSource ase,
                                        @Qualifier(&quot;test&quot;) DataSource test) {
        DynamicDataSource.datasouceMap.put(DataSourceType.ASE.getDbname(), ase);
        DynamicDataSource.datasouceMap.put(DataSourceType.TEST.getDbname(), test);
        DynamicDataSource.instance.setTargetDataSources(DynamicDataSource.datasouceMap);
        DynamicDataSource.instance.setDefaultTargetDataSource(test);
        return DynamicDataSource.instance;
    }
    @Bean
    public SqlSessionFactory sqlSessionFactory(DynamicDataSource dynamicDataSource) throws Exception {
        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
        factoryBean.setDataSource(dynamicDataSource);
//        factoryBean.setTypeAliasesPackage();
        // 设置mapper.xml的位置路径
        Resource[] resources = new PathMatchingResourcePatternResolver().getResources(&quot;classpath:xml/*.xml&quot;);
        factoryBean.setMapperLocations(resources);
        return factoryBean.getObject();
    }

    @Bean
    public PlatformTransactionManager transactionManager(DynamicDataSource dynamicDataSource){
        return new DataSourceTransactionManager(dynamicDataSource);
    }
}
</code></pre>
</li>
</ul>
<h2 id="从数据库实例化数据源"><a class="header" href="#从数据库实例化数据源">从数据库实例化数据源</a></h2>
<pre><code class="language-java">public class DynamicDataSource extends AbstractRoutingDataSource {
    public static final DynamicDataSource instance=new DynamicDataSource();
    public static final Map&lt;Object,Object&gt; datasouceMap = new HashMap&lt;&gt;();
    @Override
    public void setTargetDataSources(Map&lt;Object, Object&gt; targetDataSources) {
        super.setTargetDataSources(targetDataSources);
        super.afterPropertiesSet();
    }

    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDatasourceType();
    }

}
    要调用 afterPropertiesSet才会对 数据源的datasource Map生效
</code></pre>
<p>从数据库查数据源</p>
<pre><code class="language-java">{
        DataSourceExample dataSourceExample = new DataSourceExample();
        String db = &quot;ase&quot;;
        if(DynamicDataSource.datasouceMap.get(db) ==null){
            dataSourceExample.createCriteria().andDsnameEqualTo(db);
            List&lt;DataSource&gt; dataSources = dataSourceMapper.selectByExample(dataSourceExample);
            DataSource dataSource = dataSources.get(0);
            HikariDataSource hikariDataSource = new HikariDataSource();

            hikariDataSource.setJdbcUrl(dataSource.getUrl());
            hikariDataSource.setUsername(dataSource.getUsername());
            hikariDataSource.setPassword(dataSource.getPassword());
            hikariDataSource.setDriverClassName(dataSource.getDrivername());

            DynamicDataSource.datasouceMap.put(db,hikariDataSource);
            DynamicDataSource.instance.setTargetDataSources(DynamicDataSource.datasouceMap);
        }
        DataSourceContextHolder.setDataSource(db);
        //更新
        ZunshiRecord zunshiRecord = new ZunshiRecord();
        zunshiRecord.setId(1L);
        zunshiRecord.setCompanyCode(&quot;666&quot;);
        mapper.updateByPrimaryKeySelective(zunshiRecord);
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="springboot-devtools是做什么的"><a class="header" href="#springboot-devtools是做什么的">springboot devtools是做什么的?</a></h1>
<ul>
<li>使Spring Boot应用支持热部署，提高开发者的开发效率，无需手动重启Spring Boot应用</li>
<li>深层原理是使用了两个ClassLoader，一个Classloader加载那些不会改变的类（第三方Jar包），另一个ClassLoader加载会更改的类,称为restart ClassLoader</li>
<li>但如果你期望第三方jar文件的变动也会触发devtools进行自动重启，则可以创建<code>META-INF/spring-devtools.properties</code>,在文件中通过<code>restart.include.xxx</code>指定需要自动重启的jar，通过<code>restart.exclude.xxx</code>指定不需要自动重启的jar，属性值采用正则表达式匹配</li>
<li>有代码更改的时候，原来的restart ClassLoader 被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间。</li>
<li>默认情况下，/META-INF/maven, /META-INF/resources, /resources, /static, /public, 和 /templates下面的资源的变化不会触发自动重启</li>
<li>如果想监听非Classpath路径下的文件的变更进行自动重启，则可以通过<code>spring.devtools.restart.additional-paths</code>属性进行指定。</li>
<li>如果你想禁用devtools的自动重启功能，则可以指定spring.devtools.restart.enabled=false，也可以在Spring Boot启动的main程序中，在调用SpringApplication.run(..)之前指定系统属性spring.devtools.restart.enabled为false</li>
<li>spring.devtools.restart.trigger-file,指定触发自动重启的文件可以实现一次重启
<ul>
<li>spring.devtools.restart.trigger-file=application.properties</li>
</ul>
</li>
<li>上面的针对devtools的配置都是基于单个项目的配置，如果希望上述配置能够针对所有的项目都生效，则可以在HOME目录下新建一个<code>.spring-boot-devtools.properties</code>文件（注意文件名是以点开头的），在其中定义那些配置属性。</li>
</ul>
<h1 id="maven配置"><a class="header" href="#maven配置">maven配置</a></h1>
<pre><code>&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
		&lt;optional&gt;true&lt;/optional&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;build&gt;
	&lt;plugins&gt;
		&lt;plugin&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
			&lt;configuration&gt;
				&lt;fork&gt;true&lt;/fork&gt;
			&lt;/configuration&gt;
		&lt;/plugin&gt;
	&lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<h1 id="devtools的配置"><a class="header" href="#devtools的配置">devtools的配置</a></h1>
<pre><code>#热部署生效
spring.devtools.restart.enabled: true
#设置重启的目录
#spring.devtools.restart.additional-paths: src/main/java
#classpath目录下的WEB-INF文件夹内容修改不重启
spring.devtools.restart.exclude: WEB-INF/**
</code></pre>
<h1 id="idea配置"><a class="header" href="#idea配置">IDEA配置</a></h1>
<ul>
<li>当我们修改了Java类后，IDEA默认是不自动编译的</li>
<li>而spring-boot-devtools又是监测classpath下的文件发生变化才会重启应用</li>
<li>所以需要设置IDEA的自动编译：
<ul>
<li>File-Settings-Compiler-Build Project automatically</li>
<li>ctrl + shift + alt + /,选择Registry,勾上 Compiler autoMake allow when app running</li>
</ul>
</li>
</ul>
<h1 id="热部署的文件类型"><a class="header" href="#热部署的文件类型">热部署的文件类型</a></h1>
<ul>
<li>devtools可以实现页面热部署
<ul>
<li>这个可以直接在application.properties文件中配置spring.thymeleaf.cache=false来实现</li>
</ul>
</li>
<li>实现类文件热部署（类文件修改后不会立即生效）</li>
<li>实现对属性文件的热部署。</li>
</ul>
<h1 id="配置项"><a class="header" href="#配置项">配置项</a></h1>
<p>前缀spring.devtools.restart</p>
<table><thead><tr><th>属性名</th><th>默认值</th><th>说明</th></tr></thead><tbody>
<tr><td>log-condition-evaluation-delta</td><td>false</td><td>是否报告</td></tr>
<tr><td>exclude</td><td></td><td>exclude=static/<strong>,public/</strong>,指定要排除的文件</td></tr>
<tr><td>additional-exclude</td><td></td><td>额外排除的文件</td></tr>
<tr><td>enabled</td><td>false</td><td>是否启用</td></tr>
<tr><td>additional-paths</td><td></td><td>类路径之外的路径</td></tr>
<tr><td>trigger-file</td><td></td><td>使用触发文件</td></tr>
</tbody></table>
<p><a href="https://docs.spring.io/spring-boot/docs/2.0.3.RELEASE/reference/html/using-boot-devtools.html">官网说明</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是元数据文件"><a class="header" href="#什么是元数据文件">什么是元数据文件</a></h1>
<ul>
<li>springboot jar包含 元数据文件,这些文件提供了所有支持的配置属性</li>
<li>这些文件是为了让开发者在编辑application.properties,application.yml文件时有代码完成功能</li>
<li>大部分的元数据文件是 在编译期通过 带有 ConfigurationProperties 自动生成的</li>
<li>所有元数据在 <em>META-INF/spring-configuration-metadata.json</em>文件中</li>
</ul>
<h1 id="元数据格式"><a class="header" href="#元数据格式">元数据格式</a></h1>
<ul>
<li>
<p>json格式, 元数据项在 group类,或者properties类,值提示在 hints类</p>
</li>
<li>
<p>group是 前缀,properties是具体的项</p>
</li>
<li>
<p>不要求每个 properties有一个组</p>
<pre><code class="language-xml">{&quot;groups&quot;: [
    {
        &quot;name&quot;: &quot;server&quot;,
        &quot;type&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties&quot;,
        &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties&quot;
    },
    {
        &quot;name&quot;: &quot;spring.jpa.hibernate&quot;,
        &quot;type&quot;: &quot;org.springframework.boot.autoconfigure.orm.jpa.JpaProperties$Hibernate&quot;,
        &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.orm.jpa.JpaProperties&quot;,
        &quot;sourceMethod&quot;: &quot;getHibernate()&quot;
    }
    ...
],&quot;properties&quot;: [
    {
        &quot;name&quot;: &quot;server.port&quot;,
        &quot;type&quot;: &quot;java.lang.Integer&quot;,
        &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties&quot;
    },
    {
        &quot;name&quot;: &quot;server.address&quot;,
        &quot;type&quot;: &quot;java.net.InetAddress&quot;,
        &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties&quot;
    },
    {
          &quot;name&quot;: &quot;spring.jpa.hibernate.ddl-auto&quot;,
          &quot;type&quot;: &quot;java.lang.String&quot;,
          &quot;description&quot;: &quot;DDL mode. This is actually a shortcut for the \&quot;hibernate.hbm2ddl.auto\&quot; property.&quot;,
          &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.orm.jpa.JpaProperties$Hibernate&quot;
    }
    ...
],&quot;hints&quot;: [
    {
        &quot;name&quot;: &quot;spring.jpa.hibernate.ddl-auto&quot;,
        &quot;values&quot;: [
            {
                &quot;value&quot;: &quot;none&quot;,
                &quot;description&quot;: &quot;Disable DDL handling.&quot;
            },
            {
                &quot;value&quot;: &quot;validate&quot;,
                &quot;description&quot;: &quot;Validate the schema, make no changes to the database.&quot;
            },
            {
                &quot;value&quot;: &quot;update&quot;,
                &quot;description&quot;: &quot;Update the schema if necessary.&quot;
            },
            {
                &quot;value&quot;: &quot;create&quot;,
                &quot;description&quot;: &quot;Create the schema and destroy previous data.&quot;
            },
            {
                &quot;value&quot;: &quot;create-drop&quot;,
                &quot;description&quot;: &quot;Create and then destroy the schema at the end of the session.&quot;
            }
        ]
    }
]}
</code></pre>
</li>
</ul>
<h2 id="group属性"><a class="header" href="#group属性">group属性</a></h2>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Type</th><th style="text-align: left">Purpose</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>name</code></td><td style="text-align: left">String</td><td style="text-align: left">组名,必填</td></tr>
<tr><td style="text-align: left"><code>type</code></td><td style="text-align: left">String</td><td style="text-align: left">组的数据类型的类名 ,如果组是基于类上的<code>@ConfigurationProperties</code>注解,该属性的值就是类的全名,如果基于@Bean,就是返回值的类,否则忽略</td></tr>
<tr><td style="text-align: left">description</td><td style="text-align: left">String</td><td style="text-align: left">最后一行必须以点结尾</td></tr>
<tr><td style="text-align: left"><code>sourceType</code></td><td style="text-align: left">String</td><td style="text-align: left">如果是 <code>@Bean</code>方法的上注解带<code>@ConfigurationProperties</code>,则为  <code>@Configuration</code>的全类名</td></tr>
<tr><td style="text-align: left"><code>sourceMethod</code></td><td style="text-align: left">String</td><td style="text-align: left"><code>@ConfigurationProperties``@Bean</code> 上的方法注解,返回方法的签名,(带参数列表)</td></tr>
</tbody></table>
<h2 id="property-attributes"><a class="header" href="#property-attributes">Property Attributes</a></h2>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Type</th><th style="text-align: left">Purpose</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>name</code></td><td style="text-align: left">String</td><td style="text-align: left">属性名,小写, 英文句号 分割,必填</td></tr>
<tr><td style="text-align: left"><code>type</code></td><td style="text-align: left">String</td><td style="text-align: left">属性的数据类型的全签名,(<code>java.lang.String</code>,<code>java.util.Map&lt;java.lang.String,acme.MyEnum&gt;</code>),基本类型使用对应的包装类型,</td></tr>
<tr><td style="text-align: left"><code>description</code></td><td style="text-align: left">String</td><td style="text-align: left">以 . 结尾</td></tr>
<tr><td style="text-align: left"><code>sourceType</code></td><td style="text-align: left">String</td><td style="text-align: left">带有<code>@ConfigurationProperties</code>的类的全类名</td></tr>
<tr><td style="text-align: left"><code>defaultValue</code></td><td style="text-align: left">Object</td><td style="text-align: left">默认值,可以为数组</td></tr>
<tr><td style="text-align: left"><code>deprecation</code></td><td style="text-align: left">Deprecation</td><td style="text-align: left">是否过期</td></tr>
</tbody></table>
<h2 id="hint-attributes"><a class="header" href="#hint-attributes">Hint Attributes</a></h2>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Type</th><th style="text-align: left">Purpose</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>name</code></td><td style="text-align: left">String</td><td style="text-align: left">点号分隔的属性名,如果属性为 map则会提示map的keys,或者值提示values</td></tr>
<tr><td style="text-align: left"><code>values</code></td><td style="text-align: left">ValueHint[]</td><td style="text-align: left">数组值</td></tr>
<tr><td style="text-align: left"><code>providers</code></td><td style="text-align: left">ValueProvider[]</td><td style="text-align: left">定义 providers的 名字和参数</td></tr>
</tbody></table>
<h2 id="值提示的values"><a class="header" href="#值提示的values">值提示的values</a></h2>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Type</th><th style="text-align: left">Purpose</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>value</code></td><td style="text-align: left">Object</td><td style="text-align: left">值</td></tr>
<tr><td style="text-align: left"><code>description</code></td><td style="text-align: left">String</td><td style="text-align: left">以点结尾</td></tr>
</tbody></table>
<h2 id="providers"><a class="header" href="#providers">providers</a></h2>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Type</th><th style="text-align: left">Purpose</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>name</code></td><td style="text-align: left">String</td><td style="text-align: left">提供该值的提供者,用于指示属性的值由项目中的哪些属性提供</td></tr>
<tr><td style="text-align: left"><code>parameters</code></td><td style="text-align: left">JSON object</td><td style="text-align: left">额外的参数</td></tr>
</tbody></table>
<h2 id="属性过期指定"><a class="header" href="#属性过期指定">属性过期指定</a></h2>
<pre><code class="language-java">@ConfigurationProperties(&quot;app.acme&quot;)
public class AcmeProperties {

    private String name;

    public String getName() { ... }

    public void setName(String name) { ... }

    @DeprecatedConfigurationProperty(replacement = &quot;app.acme.name&quot;)
    @Deprecated
    public String getTarget() {
        return getName();
    }

    @Deprecated
    public void setTarget(String target) {
        setName(target);
    }
}
</code></pre>
<h1 id="手动值提示"><a class="header" href="#手动值提示">手动值提示</a></h1>
<h2 id="示例-6"><a class="header" href="#示例-6">示例</a></h2>
<pre><code class="language-java">@ConfigurationProperties(&quot;sample&quot;)
public class SampleProperties {

    private Map&lt;String,Integer&gt; contexts;
    // getters and setters
}
</code></pre>
<pre><code class="language-json">{&quot;hints&quot;: [
    {
        &quot;name&quot;: &quot;sample.contexts.keys&quot;,
        &quot;values&quot;: [
            {
                &quot;value&quot;: &quot;sample1&quot;
            },
            {
                &quot;value&quot;: &quot;sample2&quot;
            }
        ]
    }
]}
</code></pre>
<h2 id="value-providers"><a class="header" href="#value-providers">Value Providers</a></h2>
<p>valueProviders是一个强大的方式给 属性附加额外语义</p>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>any</code></td><td style="text-align: left">可以添加任何属性,</td></tr>
<tr><td style="text-align: left"><code>class-reference</code></td><td style="text-align: left">自动完成 引用可用的类,可以被 变量 限制</td></tr>
<tr><td style="text-align: left"><code>handle-as</code></td><td style="text-align: left">Handles the property as if it were defined by the type defined by the mandatory <code>target</code> parameter.</td></tr>
<tr><td style="text-align: left"><code>logger-name</code></td><td style="text-align: left">Auto-completes valid logger names and <a href="https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/spring-boot-features.html#boot-features-custom-log-groups">logger groups</a>. Typically, package and class names available in the current project can be auto-completed as well as defined groups.</td></tr>
<tr><td style="text-align: left"><code>spring-bean-reference</code></td><td style="text-align: left">Auto-completes the available bean names in the current project. Usually constrained by a base class that is specified by the <code>target</code> parameter.</td></tr>
<tr><td style="text-align: left"><code>spring-profile-name</code></td><td style="text-align: left">Auto-completes the available Spring profile names in the project.</td></tr>
</tbody></table>
<h3 id="any"><a class="header" href="#any">any</a></h3>
<p>如果您具有值列表并且任何其他值仍应视为有效，</p>
<pre><code class="language-json">{&quot;hints&quot;: [
    {
        &quot;name&quot;: &quot;system.state&quot;,
        &quot;values&quot;: [
            {
                &quot;value&quot;: &quot;on&quot;
            },
            {
                &quot;value&quot;: &quot;off&quot;
            }
        ],
        &quot;providers&quot;: [
            {
                &quot;name&quot;: &quot;any&quot;
            }
        ]
    }
]}
</code></pre>
<h3 id="class-reference"><a class="header" href="#class-reference">Class Reference</a></h3>
<table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Default value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>target</code></td><td style="text-align: left"><code>String</code> (<code>Class</code>)</td><td style="text-align: left"><em>none</em></td><td style="text-align: left">指定类名,则只会提示项目里存在的类或者其子类</td></tr>
<tr><td style="text-align: left"><code>concrete</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left">true</td><td style="text-align: left">是否需要精确到 全类名</td></tr>
</tbody></table>
<pre><code class="language-json">{&quot;hints&quot;: [
    {
        &quot;name&quot;: &quot;server.servlet.jsp.class-name&quot;,
        &quot;providers&quot;: [
            {
                &quot;name&quot;: &quot;class-reference&quot;,
                &quot;parameters&quot;: {
                    &quot;target&quot;: &quot;javax.servlet.http.HttpServlet&quot;
                }
            }
        ]
    }
]}
</code></pre>
<h3 id="handle-as"><a class="header" href="#handle-as">Handle As</a></h3>
<table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Default value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong><code>target</code></strong></td><td style="text-align: left"><code>String</code> (<code>Class</code>)</td><td style="text-align: left"><em>none</em></td><td style="text-align: left">依赖其他高级属性</td></tr>
</tbody></table>
<ul>
<li>Any <code>java.lang.Enum</code>: Lists the possible values for the property. (We recommend defining the property with the <code>Enum</code> type, as no further hint should be required for the IDE to auto-complete the values)</li>
<li><code>java.nio.charset.Charset</code>: Supports auto-completion of charset/encoding values (such as <code>UTF-8</code>)</li>
<li><code>java.util.Locale</code>: auto-completion of locales (such as <code>en_US</code>)</li>
<li><code>org.springframework.util.MimeType</code>: Supports auto-completion of content type values (such as <code>text/plain</code>)</li>
<li><code>org.springframework.core.io.Resource</code>: Supports auto-completion of Spring’s Resource abstraction to refer to a file on the filesystem or on the classpath (such as <code>classpath:/sample.properties</code>)</li>
</ul>
<pre><code class="language-json">{&quot;hints&quot;: [
    {
        &quot;name&quot;: &quot;spring.liquibase.change-log&quot;,
        &quot;providers&quot;: [
            {
                &quot;name&quot;: &quot;handle-as&quot;,
                &quot;parameters&quot;: {
                    &quot;target&quot;: &quot;org.springframework.core.io.Resource&quot;
                }
            }
        ]
    }
]}
</code></pre>
<h3 id="logger-name"><a class="header" href="#logger-name">Logger Name</a></h3>
<table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Default value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>group</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left"><code>true</code></td><td style="text-align: left">Specify whether known groups should be considered.</td></tr>
</tbody></table>
<p>内置的logger日志级别定义</p>
<pre><code>{&quot;hints&quot;: [
    {
        &quot;name&quot;: &quot;logging.level.keys&quot;,
        &quot;values&quot;: [
            {
                &quot;value&quot;: &quot;root&quot;,
                &quot;description&quot;: &quot;Root logger used to assign the default logging level.&quot;
            },
            {
                &quot;value&quot;: &quot;sql&quot;,
                &quot;description&quot;: &quot;SQL logging group including Hibernate SQL logger.&quot;
            },
            {
                &quot;value&quot;: &quot;web&quot;,
                &quot;description&quot;: &quot;Web logging group including codecs.&quot;
            }
        ],
        &quot;providers&quot;: [
            {
                &quot;name&quot;: &quot;logger-name&quot;
            }
        ]
    },
    {
        &quot;name&quot;: &quot;logging.level.values&quot;,
        &quot;values&quot;: [
            {
                &quot;value&quot;: &quot;trace&quot;
            },
            {
                &quot;value&quot;: &quot;debug&quot;
            },
            {
                &quot;value&quot;: &quot;info&quot;
            },
            {
                &quot;value&quot;: &quot;warn&quot;
            },
            {
                &quot;value&quot;: &quot;error&quot;
            },
            {
                &quot;value&quot;: &quot;fatal&quot;
            },
            {
                &quot;value&quot;: &quot;off&quot;
            }

        ],
        &quot;providers&quot;: [
            {
                &quot;name&quot;: &quot;any&quot;
            }
        ]
    }
]}
</code></pre>
<h3 id="spring-bean-reference"><a class="header" href="#spring-bean-reference">Spring Bean Reference</a></h3>
<table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Default value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>target</code></td><td style="text-align: left"><code>String</code> (<code>Class</code>)</td><td style="text-align: left"><em>none</em></td><td style="text-align: left">配置成springBean的类的全限定名</td></tr>
</tbody></table>
<pre><code class="language-json">{&quot;hints&quot;: [
    {
        &quot;name&quot;: &quot;spring.jmx.server&quot;,
        &quot;providers&quot;: [
            {
                &quot;name&quot;: &quot;spring-bean-reference&quot;,
                &quot;parameters&quot;: {
                    &quot;target&quot;: &quot;javax.management.MBeanServer&quot;
                }
            }
        ]
    }
]}
</code></pre>
<h3 id="spring-profile-name"><a class="header" href="#spring-profile-name">Spring Profile Name</a></h3>
<p>与<em>spring.profiles.active</em> 相对应</p>
<pre><code>{&quot;hints&quot;: [
    {
        &quot;name&quot;: &quot;spring.profiles.active&quot;,
        &quot;providers&quot;: [
            {
                &quot;name&quot;: &quot;spring-profile-name&quot;
            }
        ]
    }
]}
</code></pre>
<h1 id="产生自己的元数据"><a class="header" href="#产生自己的元数据">产生自己的元数据</a></h1>
<ol>
<li>
<p>META-INF/additional-spring-configuration-metadata.json文件位置</p>
</li>
<li>
<p>通过 <code>spring-boot-configuration-processor</code> jar的 @<em>ConfigurationProperties</em>配置产生自己的元数据</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>If you are using an <code>additional-spring-configuration-metadata.json</code> file, the <code>compileJava</code> task should be configured to depend on the <code>processResources</code> task, as shown in the following example:</p>
<pre><code class="language-java">compileJava.inputs.files(processResources)
</code></pre>
</li>
<li>
<p>处理器会处理 类和方法上的 @ConfigurationProperties注解</p>
</li>
</ol>
<pre><code class="language-xml">@ConfigurationProperties(prefix = &quot;acme.messaging&quot;)
public class MessagingProperties {

    private List&lt;String&gt; addresses = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;));

    private ContainerType containerType = ContainerType.SIMPLE;

    // ... getter and setters

    public enum ContainerType {

        SIMPLE,
        DIRECT

    }

}
{&quot;properties&quot;: [
    {
        &quot;name&quot;: &quot;acme.messaging.addresses&quot;,
        &quot;defaultValue&quot;: [&quot;a&quot;, &quot;b&quot;]
    },
    {
        &quot;name&quot;: &quot;acme.messaging.container-type&quot;,
        &quot;defaultValue&quot;: &quot;simple&quot;
    }
]}
</code></pre>
<h2 id="嵌套属性"><a class="header" href="#嵌套属性">嵌套属性</a></h2>
<pre><code>@ConfigurationProperties(prefix=&quot;server&quot;)
public class ServerProperties {

    private String name;

    private Host host;

    // ... getter and setters

    public static class Host {

        private String ip;

        private int port;

        // ... getter and setters

    }

}
对应内部类
可以对该字段使用 @NestedConfigurationProperty 来使用外部类
</code></pre>
<p><a href="https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/appendix-configuration-metadata.html">官网地址</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="步骤-1"><a class="header" href="#步骤-1">步骤</a></h1>
<h2 id="生成项目"><a class="header" href="#生成项目">生成项目</a></h2>
<p>建立父POM.不存放代码,只存放子模块</p>
<ol>
<li>
<p>官网生成,</p>
<p>https://start.spring.io/</p>
</li>
<li>
<p>在 idea可以选择POM方式打包</p>
</li>
</ol>
<h2 id="修改pom文件"><a class="header" href="#修改pom文件">修改pom文件</a></h2>
<ol>
<li>
<p>源代码目录删除</p>
</li>
<li>
<pre><code>&lt;packaging&gt;pom&lt;/packaging&gt;
</code></pre>
</li>
<li>
<p>注释掉springboot的打包方式(只有springboot 主项目才需要springboot打包成可执行文件,依赖库不需要)</p>
</li>
<li>
<p>添加子模块 </p>
<pre><code class="language-xml">&lt;modules&gt;
        &lt;module&gt;unifiedoutput&lt;/module&gt;
        &lt;module&gt;common&lt;/module&gt;
&lt;/modules&gt;
</code></pre>
</li>
<li>
<p>子模块的POM文件</p>
<ol>
<li>
<p>添加父模块依赖</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;com.weisanju&lt;/groupId&gt;
    &lt;artifactId&gt;springboot-study&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;!--        &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;--&gt;
&lt;/parent&gt;
</code></pre>
</li>
<li>
<p>添加其他子模块依赖</p>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;com.weisanju&lt;/groupId&gt;
            &lt;artifactId&gt;common&lt;/artifactId&gt;
            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="完整的配置文件"><a class="header" href="#完整的配置文件">完整的配置文件</a></h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.3.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.weisanju&lt;/groupId&gt;
    &lt;artifactId&gt;springboot-study&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;springboot-study&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;modules&gt;
        &lt;module&gt;unifiedoutput&lt;/module&gt;
        &lt;module&gt;common&lt;/module&gt;
    &lt;/modules&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;!--
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;--&gt;

&lt;/project&gt;

</code></pre>
<ol start="4">
<li>父项目的公共依赖,请确保加上<em>optional</em>,避免依赖重复</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging-1"><a class="header" href="#logging-1">Logging</a></h1>
<p><strong>CommonsLoggingAPI</strong></p>
<p>SpringBoot 使用 <a href="https://commons.apache.org/logging">Commons Logging</a> API 记录所有内部日志 ，但是允许多种底层内部实现</p>
<p><strong>默认提供控制台输出</strong></p>
<p>提供  Java Util Logging、Log4J2 和 Logback 默认配置，在每种情况下，记录器都预先配置为使用控制台输出，也可以使用可选的文件输出。</p>
<p>默认情况下，如果您使用“Starters”，则使用 Logback 进行日志记录，还包括适当的 Logback 路由，以确保使用 Java Util Logging、Commons Logging、Log4J 或 SLF4J 的依赖库都能正常工作。</p>
<h1 id="log-format"><a class="header" href="#log-format">Log Format</a></h1>
<p>Spring Boot 的默认日志输出类似于以下示例：</p>
<pre><code>019-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms
2019-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
</code></pre>
<p><strong>格式为</strong></p>
<ul>
<li>Date and Time: Millisecond precision and easily sortable.</li>
<li>Log Level: <code>ERROR</code>, <code>WARN</code>, <code>INFO</code>, <code>DEBUG</code>, or <code>TRACE</code>.</li>
<li>Process ID.</li>
<li>A <code>---</code> separator ：分割日志头和日志内容</li>
<li>Thread name: 括在方括号中（控制台输出可能会被截断）。</li>
<li>Logger name: 通常是源类名称（通常缩写）。</li>
<li>The log message.</li>
</ul>
<h1 id="console-output"><a class="header" href="#console-output">Console Output</a></h1>
<p>默认日志配置在写入消息时将消息回显到控制台。</p>
<p>默认情况下，会记录 ERROR 级别、WARN 级别和 INFO 级别的消息。</p>
<p>您还可以通过使用 --debug 标志启动应用程序来启用 “debug” 模式。</p>
<pre><code class="language-shell">$ java -jar myapp.jar --debug
</code></pre>
<p>You can also specify <code>debug=true</code> in your <code>application.properties</code>.</p>
<p>或者，您可以通过使用 --trace 标志（或 application.properties 中的 trace=true）启动应用程序来启用“跟踪”模式。</p>
<h2 id="color-coded-output"><a class="header" href="#color-coded-output">Color-coded Output</a></h2>
<p>如果您的终端支持 ANSI，则使用颜色输出来提高可读性。</p>
<p>您可以将 spring.output.ansi.enabled 设置为支持的值以覆盖自动检测。</p>
<p>颜色编码是使用 %clr 转换字配置的。</p>
<p>在最简单的形式中，转换器根据日志级别为输出着色，如以下示例所示：</p>
<pre><code>%clr(%5p)
</code></pre>
<table><thead><tr><th style="text-align: left">Level</th><th style="text-align: left">Color</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>FATAL</code></td><td style="text-align: left">Red</td></tr>
<tr><td style="text-align: left"><code>ERROR</code></td><td style="text-align: left">Red</td></tr>
<tr><td style="text-align: left"><code>WARN</code></td><td style="text-align: left">Yellow</td></tr>
<tr><td style="text-align: left"><code>INFO</code></td><td style="text-align: left">Green</td></tr>
<tr><td style="text-align: left"><code>DEBUG</code></td><td style="text-align: left">Green</td></tr>
<tr><td style="text-align: left"><code>TRACE</code></td><td style="text-align: left">Green</td></tr>
</tbody></table>
<p>或者，您可以通过将其作为转换选项提供来指定应使用的颜色或样式。</p>
<p>例如，要使文本变黄，请使用以下设置：</p>
<pre><code>%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){yellow}
</code></pre>
<p>支持以下颜色和样式：</p>
<ul>
<li><code>blue</code></li>
<li><code>cyan</code></li>
<li><code>faint</code></li>
<li><code>green</code></li>
<li><code>magenta</code></li>
<li><code>red</code></li>
<li><code>yellow</code></li>
</ul>
<h1 id="file-output"><a class="header" href="#file-output">File Output</a></h1>
<p>默认情况下，Spring Boot 只记录到控制台，不写入日志文件。</p>
<p>如果您想在控制台输出之外写入日志文件，您需要设置 logging.file.name 或 logging.file.path 属性（例如，在您的 application.properties 中）。</p>
<p>下表显示了 logging.* 属性如何一起使用：</p>
<table><thead><tr><th style="text-align: left"><code>logging.file.name</code></th><th style="text-align: left"><code>logging.file.path</code></th><th style="text-align: left">Example</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><em>(none)</em></td><td style="text-align: left"><em>(none)</em></td><td style="text-align: left"></td><td style="text-align: left">仅控制台记录。</td></tr>
<tr><td style="text-align: left">Specific file</td><td style="text-align: left"><em>(none)</em></td><td style="text-align: left"><code>my.log</code></td><td style="text-align: left">写入指定的日志文件。名称可以是确切位置或相对于当前目录。</td></tr>
<tr><td style="text-align: left"><em>(none)</em></td><td style="text-align: left">Specific directory</td><td style="text-align: left"><code>/var/log</code></td><td style="text-align: left">将 <code>spring.log</code> 写入指定目录。名称可以是确切位置或相对于当前目录。</td></tr>
</tbody></table>
<p>日志文件在达到 10 MB 时会轮换，并且与控制台输出一样，默认情况下会记录 ERROR 级别、WARN 级别和 INFO 级别的消息。</p>
<p>日志属性独立于实际的日志基础设施。</p>
<p>因此，特定的配置键（例如 Logback 的 logback.configurationFile）不受 spring Boot 管理。</p>
<h1 id="file-rotation"><a class="header" href="#file-rotation">File Rotation</a></h1>
<p>如果您使用的是 Logback，则可以使用 application.properties 或 application.yaml 文件微调日志轮换设置。</p>
<p>对于所有其他日志系统，您需要自己直接配置轮换设置（例如，如果您使用 Log4J2，那么您可以添加一个 log4j.xml 文件）。</p>
<p>支持以下轮换策略属性：</p>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>logging.logback.rollingpolicy.file-name-pattern</code></td><td style="text-align: left">用于创建日志存档的文件名模式。</td></tr>
<tr><td style="text-align: left"><code>logging.logback.rollingpolicy.clean-history-on-start</code></td><td style="text-align: left">如果在应用程序启动时应该进行日志归档清理。</td></tr>
<tr><td style="text-align: left"><code>logging.logback.rollingpolicy.max-file-size</code></td><td style="text-align: left">归档前日志文件的最大大小。</td></tr>
<tr><td style="text-align: left"><code>logging.logback.rollingpolicy.total-size-cap</code></td><td style="text-align: left">在删除之前可以使用的最大大小日志存档数量。</td></tr>
<tr><td style="text-align: left"><code>logging.logback.rollingpolicy.max-history</code></td><td style="text-align: left">保留日志存档的天数（默认为 7）</td></tr>
</tbody></table>
<h1 id="log-levels"><a class="header" href="#log-levels">Log Levels</a></h1>
<p>所有支持的日志系统都可以通过使用 logging.level.= 在 Spring Environment（例如，在 application.properties）中设置记录器级别，其中级别是 TRACE, DEBUG, INFO, WARN, ERROR, FATAL, or OFF 之一</p>
<p>可以使用 logging.level.root 配置根记录器</p>
<pre><code class="language-yaml">logging:
  level:
    root: &quot;warn&quot;
    org.springframework.web: &quot;debug&quot;
    org.hibernate: &quot;error&quot;

</code></pre>
<p><strong>也可以使用环境变量设置日志记录级别。</strong></p>
<p>例如， LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG 会将 org.springframework.web 设置为 DEBUG。</p>
<p>上述方法仅适用于包级日志记录。</p>
<p>由于宽松绑定总是将环境变量转换为小写，因此不可能以这种方式为单个类配置日志记录</p>
<p>如果需要为类配置日志记录，可以使用 SPRING_APPLICATION_JSON 变量。</p>
<h1 id="log-groups"><a class="header" href="#log-groups">Log Groups</a></h1>
<p>能够将相关的记录器组合在一起以便可以同时配置它们通常很有用。</p>
<p>例如，您通常可能会更改所有与 Tomcat 相关的记录器的日志记录级别，但您无法轻松记住顶级包。</p>
<p>为了解决这个问题，Spring Boot 允许您在 Spring 环境中定义日志记录组。</p>
<p>例如，下面是如何通过将“tomcat”组添加到 application.properties 来定义它：</p>
<pre><code class="language-yaml">logging:
  group:
    tomcat: &quot;org.apache.catalina,org.apache.coyote,org.apache.tomcat&quot;
</code></pre>
<p>定义后，您可以使用一行更改组中所有记录器的级别：</p>
<pre><code class="language-yaml">logging:
  level:
    tomcat: &quot;trace&quot;
</code></pre>
<p>Spring Boot 包括以下可以开箱即用的预定义日志记录组：</p>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Loggers</th></tr></thead><tbody>
<tr><td style="text-align: left">web</td><td style="text-align: left"><code>org.springframework.core.codec</code>, <code>org.springframework.http</code>, <code>org.springframework.web</code>, <code>org.springframework.boot.actuate.endpoint.web</code>, <code>org.springframework.boot.web.servlet.ServletContextInitializerBeans</code></td></tr>
<tr><td style="text-align: left">sql</td><td style="text-align: left"><code>org.springframework.jdbc.core</code>, <code>org.hibernate.SQL</code>, <code>org.jooq.tools.LoggerListener</code></td></tr>
</tbody></table>
<h1 id="using-a-log-shutdown-hook"><a class="header" href="#using-a-log-shutdown-hook">Using a Log Shutdown Hook</a></h1>
<p>为了在您的应用程序终止时释放日志资源，提供了一个关闭挂钩,当 JVM 退出时将触发日志系统清理。</p>
<pre><code class="language-yaml">logging:
  register-shutdown-hook: false

</code></pre>
<h1 id="custom-log-configuration"><a class="header" href="#custom-log-configuration">Custom Log Configuration</a></h1>
<p>可以通过在类路径中包含适当的库来激活各种日志系统</p>
<p>并且可以通过在类路径的根目录或以下 Spring 环境变量属性指定的位置提供合适的配置文件来进一步定制：logging.config。</p>
<p>您可以通过使用 <strong>org.springframework.boot.logging.LoggingSystem</strong> 系统属性来强制 Spring Boot 使用特定的日志记录系统。</p>
<p>该值应该是 LoggingSystem 实现的完全限定类名。</p>
<p>您还可以使用 none 值完全禁用 Spring Boot 的日志记录配置。</p>
<p><strong>注意</strong></p>
<ol>
<li>
<p>由于日志记录是在创建 ApplicationContext 之前初始化的，因此无法从 Spring @Configuration 文件中的 @PropertySources 控制日志记录。</p>
</li>
<li>
<p>更改日志系统或完全禁用它的唯一方法是通过系统属性。</p>
</li>
</ol>
<p><strong>根据您的日志系统，加载以下文件：</strong></p>
<table><thead><tr><th style="text-align: left">Logging System</th><th style="text-align: left">Customization</th></tr></thead><tbody>
<tr><td style="text-align: left">Logback</td><td style="text-align: left"><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td></tr>
<tr><td style="text-align: left">Log4j2</td><td style="text-align: left"><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr>
<tr><td style="text-align: left">JDK (Java Util Logging)</td><td style="text-align: left"><code>logging.properties</code></td></tr>
</tbody></table>
<p>如果可能，我们建议您将 -spring 变体用于日志记录配置（例如，logback-spring.xml 而不是 logback.xml）。</p>
<p>如果使用标准配置位置，Spring 无法完全控制日志初始化。</p>
<p><strong>警告</strong></p>
<p>Java Util Logging 存在已知的类加载问题，这些问题会导致从“可执行 jar”运行时出现问题。</p>
<p>我们建议您在从“可执行 jar”运行时尽可能避免使用它。</p>
<p>为了帮助定制，一些其他属性从 Spring Environment 转移到 System properties，如下表所述：</p>
<table><thead><tr><th style="text-align: left">Spring Environment</th><th style="text-align: left">System Property</th><th style="text-align: left">Comments</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>logging.exception-conversion-word</code></td><td style="text-align: left"><code>LOG_EXCEPTION_CONVERSION_WORD</code></td><td style="text-align: left">记录异常时使用的转换词。</td></tr>
<tr><td style="text-align: left"><code>logging.file.name</code></td><td style="text-align: left"><code>LOG_FILE</code></td><td style="text-align: left">如果定义，则在默认日志配置中使用。</td></tr>
<tr><td style="text-align: left"><code>logging.file.path</code></td><td style="text-align: left"><code>LOG_PATH</code></td><td style="text-align: left">如果定义，则在默认日志配置中使用。</td></tr>
<tr><td style="text-align: left"><code>logging.pattern.console</code></td><td style="text-align: left"><code>CONSOLE_LOG_PATTERN</code></td><td style="text-align: left">The log pattern to use on the console (stdout).</td></tr>
<tr><td style="text-align: left"><code>logging.pattern.dateformat</code></td><td style="text-align: left"><code>LOG_DATEFORMAT_PATTERN</code></td><td style="text-align: left">Appender pattern for log date format.</td></tr>
<tr><td style="text-align: left"><code>logging.charset.console</code></td><td style="text-align: left"><code>CONSOLE_LOG_CHARSET</code></td><td style="text-align: left">The charset to use for console logging.</td></tr>
<tr><td style="text-align: left"><code>logging.pattern.file</code></td><td style="text-align: left"><code>FILE_LOG_PATTERN</code></td><td style="text-align: left">The log pattern to use in a file (if <code>LOG_FILE</code> is enabled).</td></tr>
<tr><td style="text-align: left"><code>logging.charset.file</code></td><td style="text-align: left"><code>FILE_LOG_CHARSET</code></td><td style="text-align: left">The charset to use for file logging (if <code>LOG_FILE</code> is enabled).</td></tr>
<tr><td style="text-align: left"><code>logging.pattern.level</code></td><td style="text-align: left"><code>LOG_LEVEL_PATTERN</code></td><td style="text-align: left">The format to use when rendering the log level (default <code>%5p</code>).</td></tr>
<tr><td style="text-align: left"><code>PID</code></td><td style="text-align: left"><code>PID</code></td><td style="text-align: left">The current process ID (discovered if possible and when not already defined as an OS environment variable).</td></tr>
</tbody></table>
<p>如果您使用的是 Logback，以下属性也会被转移：</p>
<table><thead><tr><th style="text-align: left">Spring Environment</th><th style="text-align: left">System Property</th><th style="text-align: left">Comments</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>logging.logback.rollingpolicy.file-name-pattern</code></td><td style="text-align: left"><code>LOGBACK_ROLLINGPOLICY_FILE_NAME_PATTERN</code></td><td style="text-align: left">Pattern for rolled-over log file names (default <code>${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz</code>).</td></tr>
<tr><td style="text-align: left"><code>logging.logback.rollingpolicy.clean-history-on-start</code></td><td style="text-align: left"><code>LOGBACK_ROLLINGPOLICY_CLEAN_HISTORY_ON_START</code></td><td style="text-align: left">Whether to clean the archive log files on startup.</td></tr>
<tr><td style="text-align: left"><code>logging.logback.rollingpolicy.max-file-size</code></td><td style="text-align: left"><code>LOGBACK_ROLLINGPOLICY_MAX_FILE_SIZE</code></td><td style="text-align: left">Maximum log file size.</td></tr>
<tr><td style="text-align: left"><code>logging.logback.rollingpolicy.total-size-cap</code></td><td style="text-align: left"><code>LOGBACK_ROLLINGPOLICY_TOTAL_SIZE_CAP</code></td><td style="text-align: left">Total size of log backups to be kept.</td></tr>
<tr><td style="text-align: left"><code>logging.logback.rollingpolicy.max-history</code></td><td style="text-align: left"><code>LOGBACK_ROLLINGPOLICY_MAX_HISTORY</code></td><td style="text-align: left">Maximum number of archive log files to keep.</td></tr>
</tbody></table>
<p>所有支持的日志系统在解析其配置文件时都可以查询系统属性。示例参见 spring-boot.jar 中的默认配置：</p>
<ul>
<li><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.4/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml">Logback</a></li>
<li><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.4/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml">Log4j 2</a></li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;WARN&quot;&gt;
	&lt;Properties&gt;
		&lt;Property name=&quot;LOG_EXCEPTION_CONVERSION_WORD&quot;&gt;%xwEx&lt;/Property&gt;
		&lt;Property name=&quot;LOG_LEVEL_PATTERN&quot;&gt;%5p&lt;/Property&gt;
		&lt;Property name=&quot;LOG_DATEFORMAT_PATTERN&quot;&gt;yyyy-MM-dd HH:mm:ss.SSS&lt;/Property&gt;
		&lt;Property name=&quot;CONSOLE_LOG_PATTERN&quot;&gt;%clr{%d{${sys:LOG_DATEFORMAT_PATTERN}}}{faint} %clr{${sys:LOG_LEVEL_PATTERN}} %clr{%pid}{magenta} %clr{---}{faint} %clr{[%15.15t]}{faint} %clr{%-40.40c{1.}}{cyan} %clr{:}{faint} %m%n${sys:LOG_EXCEPTION_CONVERSION_WORD}&lt;/Property&gt;
		&lt;Property name=&quot;FILE_LOG_PATTERN&quot;&gt;%d{${LOG_DATEFORMAT_PATTERN}} ${LOG_LEVEL_PATTERN} %pid --- [%t] %-40.40c{1.} : %m%n${sys:LOG_EXCEPTION_CONVERSION_WORD}&lt;/Property&gt;
	&lt;/Properties&gt;
	&lt;Appenders&gt;
		&lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot; follow=&quot;true&quot;&gt;
			&lt;PatternLayout pattern=&quot;${sys:CONSOLE_LOG_PATTERN}&quot; charset=&quot;${sys:CONSOLE_LOG_CHARSET}&quot;/&gt;
		&lt;/Console&gt;
	&lt;/Appenders&gt;
	&lt;Loggers&gt;
		&lt;Logger name=&quot;org.apache.catalina.startup.DigesterFactory&quot; level=&quot;error&quot; /&gt;
		&lt;Logger name=&quot;org.apache.catalina.util.LifecycleBase&quot; level=&quot;error&quot; /&gt;
		&lt;Logger name=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; level=&quot;warn&quot; /&gt;
		&lt;Logger name=&quot;org.apache.sshd.common.util.SecurityUtils&quot; level=&quot;warn&quot;/&gt;
		&lt;Logger name=&quot;org.apache.tomcat.util.net.NioSelectorPool&quot; level=&quot;warn&quot; /&gt;
		&lt;Logger name=&quot;org.eclipse.jetty.util.component.AbstractLifeCycle&quot; level=&quot;error&quot; /&gt;
		&lt;Logger name=&quot;org.hibernate.validator.internal.util.Version&quot; level=&quot;warn&quot; /&gt;
		&lt;Logger name=&quot;org.springframework.boot.actuate.endpoint.jmx&quot; level=&quot;warn&quot;/&gt;
		&lt;Root level=&quot;info&quot;&gt;
			&lt;AppenderRef ref=&quot;Console&quot; /&gt;
		&lt;/Root&gt;
	&lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<ul>
<li><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.4/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties">Java Util logging</a></li>
</ul>
<p><strong>提示</strong></p>
<p>如果你想在日志属性中使用占位符，你应该使用 Spring Boot 的语法而不是底层框架的语法。</p>
<p>值得注意的是，如果您使用 Logback，您应该使用 : 作为属性名称与其默认值之间的分隔符，而不是使用 :-。</p>
<p>您可以通过仅覆盖 LOG_LEVEL_PATTERN（或带有 Logback 的 logging.pattern.level ）将 MDC 和其他临时内容添加到日志行。</p>
<p>例如，如果您使用 logging.pattern.level=user:%X{user} %5p，则默认日志格式包含“user”的 MDC 条目（如果存在），如以下示例所示。</p>
<h1 id="源码分析-5"><a class="header" href="#源码分析-5">源码分析</a></h1>
<h2 id="如何初始化日志系统"><a class="header" href="#如何初始化日志系统">如何初始化日志系统</a></h2>
<p>通过SpringAppliccationListener 事件监听器：监听spring的启动事件：以初始化日志系统</p>
<pre><code class="language-java">@Override
public void onApplicationEvent(ApplicationEvent event) {
    //spring刚启动时，执行 日志系统的载入与前初始化
   if (event instanceof ApplicationStartingEvent) {
      onApplicationStartingEvent((ApplicationStartingEvent) event);
   }
    //spring环境变量准备好时：日志系统的初始化
   else if (event instanceof ApplicationEnvironmentPreparedEvent) {
      onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);
   }
    //spring启动好 之后：往容器中注入 日志相关bean springBootLoggingSystem、springBootLogFile
   else if (event instanceof ApplicationPreparedEvent) {
      onApplicationPreparedEvent((ApplicationPreparedEvent) event);
   }
    //spring容器关闭之后，调用日志系统的关闭
   else if (event instanceof ContextClosedEvent
         &amp;&amp; ((ContextClosedEvent) event).getApplicationContext().getParent() == null) {
      onContextClosedEvent();
   }
    //spring容器启动 失败后，调用清理
   else if (event instanceof ApplicationFailedEvent) {
      onApplicationFailedEvent();
   }
}
</code></pre>
<h2 id="日志系统的载入与前初始化"><a class="header" href="#日志系统的载入与前初始化">日志系统的载入与前初始化</a></h2>
<p><strong>载入日志 系统</strong></p>
<pre><code class="language-java">public static LoggingSystem get(ClassLoader classLoader) {
    //如果指定了 `org.springframework.boot.logging.LoggingSystem`系统环境变量,则使用指定的
   String loggingSystem = System.getProperty(SYSTEM_PROPERTY);
   if (StringUtils.hasLength(loggingSystem)) {
      if (NONE.equals(loggingSystem)) {
         return new NoOpLoggingSystem();
      }
      return get(classLoader, loggingSystem);
   }
   //否则 按默认顺序检测特定类
   return SYSTEMS.entrySet().stream().filter((entry) -&gt; ClassUtils.isPresent(entry.getKey(), classLoader))
         .map((entry) -&gt; get(classLoader, entry.getValue())).findFirst()
         .orElseThrow(() -&gt; new IllegalStateException(&quot;No suitable logging system located&quot;));
}
	static {
		Map&lt;String, String&gt; systems = new LinkedHashMap&lt;&gt;();
		systems.put(&quot;ch.qos.logback.core.Appender&quot;, &quot;org.springframework.boot.logging.logback.LogbackLoggingSystem&quot;);
		systems.put(&quot;org.apache.logging.log4j.core.impl.Log4jContextFactory&quot;,
				&quot;org.springframework.boot.logging.log4j2.Log4J2LoggingSystem&quot;);
		systems.put(&quot;java.util.logging.LogManager&quot;, &quot;org.springframework.boot.logging.java.JavaLoggingSystem&quot;);
		SYSTEMS = Collections.unmodifiableMap(systems);
	}
</code></pre>
<p><strong>前初始化</strong></p>
<pre><code class="language-java">//sl4j前初始化：桥接 JUL与 sl4j
private void configureJdkLoggingBridgeHandler() {
   try {
      if (isBridgeJulIntoSlf4j()) {
         removeJdkLoggingBridgeHandler();
         SLF4JBridgeHandler.install();
      }
   }
   catch (Throwable ex) {
      // Ignore. No java.util.logging bridge is installed.
   }
}

//log4j前初始化：禁用一切日志打印
public void beforeInitialize() {
    LoggerContext loggerContext = getLoggerContext();
    if (isAlreadyInitialized(loggerContext)) {
        return;
    }
    super.beforeInitialize();
    loggerContext.getConfiguration().addFilter(FILTER);
}
</code></pre>
<h2 id="日志系统的初始化"><a class="header" href="#日志系统的初始化">日志系统的初始化</a></h2>
<ol>
<li>转换 日志配置到 系统环境变量中</li>
<li>将 日志位置的配置 加载到环境变量 中</li>
<li>日志组的获取与处理</li>
<li>设置初始化日志级别</li>
<li>注册jvm关闭回调</li>
</ol>
<pre><code class="language-java">protected void initialize(ConfigurableEnvironment environment, ClassLoader classLoader) {
    //转换 日志配置到 系统环境变量中：并对配置进行环境变量替换
   new LoggingSystemProperties(environment).apply();
   //获取指定 的logFile
   this.logFile = LogFile.get(environment);
    //将 日志位置的配置 加载到环境变量 中
   if (this.logFile != null) {
      this.logFile.applyToSystemProperties();
   }
    //日志组的处理
   this.loggerGroups = new LoggerGroups(DEFAULT_GROUP_LOGGERS);
    //早期日志级别的 设置：兼容 命令行选项 --debug --trace
   initializeEarlyLoggingLevel(environment);
    //初始化日志系统
   initializeSystem(environment, this.loggingSystem, this.logFile);
    /设置初始化日志级别
   initializeFinalLoggingLevels(environment, this.loggingSystem);
    //注册jvm关闭回调
   registerShutdownHookIfNecessary(environment, this.loggingSystem);
}
</code></pre>
<h2 id="初始化特定日志系统的抽象实现"><a class="header" href="#初始化特定日志系统的抽象实现">初始化特定日志系统的抽象实现</a></h2>
<blockquote>
<p>org.springframework.boot.logging.AbstractLoggingSystem#initialize</p>
</blockquote>
<h3 id="按配置or约定查找配置"><a class="header" href="#按配置or约定查找配置"><strong>按配置Or约定查找配置</strong></a></h3>
<pre><code class="language-java">public void initialize(LoggingInitializationContext initializationContext, String configLocation, LogFile logFile) {
    //如果有配置日志路径
   if (StringUtils.hasLength(configLocation)) {
       //使用特定配置文件初始化
      initializeWithSpecificConfig(initializationContext, configLocation, logFile);
      return;
   }
    //按照约定查找配置文件
   initializeWithConventions(initializationContext, logFile);
}
</code></pre>
<p><strong>按照约定查找配置文件</strong></p>
<blockquote>
<p>以log4j为例</p>
</blockquote>
<p>添加 <code>log4j2.properties</code> <code>log4j2-test.properties</code> 等等</p>
<pre><code class="language-java">//org.springframework.boot.logging.log4j2.Log4J2LoggingSystem#getCurrentlySupportedConfigLocations
private String[] getCurrentlySupportedConfigLocations() {
   List&lt;String&gt; supportedConfigLocations = new ArrayList&lt;&gt;();
   addTestFiles(supportedConfigLocations);
   supportedConfigLocations.add(&quot;log4j2.properties&quot;);
   if (isClassAvailable(&quot;com.fasterxml.jackson.dataformat.yaml.YAMLParser&quot;)) {
      Collections.addAll(supportedConfigLocations, &quot;log4j2.yaml&quot;, &quot;log4j2.yml&quot;);
   }
   if (isClassAvailable(&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;)) {
      Collections.addAll(supportedConfigLocations, &quot;log4j2.json&quot;, &quot;log4j2.jsn&quot;);
   }
   supportedConfigLocations.add(&quot;log4j2.xml&quot;);
   return StringUtils.toStringArray(supportedConfigLocations);
}
</code></pre>
<p><strong>如果有多个返回配置中的第一个资源存在的</strong></p>
<pre><code class="language-java">//org.springframework.boot.logging.AbstractLoggingSystem#findConfig
private String findConfig(String[] locations) {
   for (String location : locations) {
      ClassPathResource resource = new ClassPathResource(location, this.classLoader);
      if (resource.exists()) {
         return &quot;classpath:&quot; + location;
      }
   }
   return null;
}
</code></pre>
<h3 id="按照惯例初始化流程"><a class="header" href="#按照惯例初始化流程">按照惯例初始化流程</a></h3>
<p>主要实现了 以下几点</p>
<ol>
<li>如果使用<strong>标准的日志文件</strong>名，则说名日志内部已初始化 则<strong>重新初始化</strong>一遍 以防 属性改变</li>
<li>如果使用的spring的日志文件名，则使用spring的方式<strong>初始化日志配置</strong></li>
<li>如果都不存在则 <strong>载入默认配置</strong></li>
</ol>
<p><strong>其中 加黑的方法都需要之类实现</strong></p>
<pre><code class="language-java">//org.springframework.boot.logging.AbstractLoggingSystem#initializeWithConventions
private void initializeWithConventions(LoggingInitializationContext initializationContext, LogFile logFile) {
    //获取标准配置文件
   String config = getSelfInitializationConfig();
    //配置文件存在，且没有指定专门日志文件：则重新初始化以防属性变化
   if (config != null &amp;&amp; logFile == null) {
      // self initialization has occurred, reinitialize in case of property changes
      reinitialize(initializationContext);
      return;
   }
    //如果标准的不存在，则获取-spring后缀的
   if (config == null) {
      config = getSpringInitializationConfig();
   }
    //载入配置文件
   if (config != null) {
      loadConfiguration(initializationContext, config, logFile);
      return;
   }
    //如果配置文件不存在则 载入默认配置文件
   loadDefaults(initializationContext, logFile);
}
</code></pre>
<h3 id="指定日志配置文件初始化"><a class="header" href="#指定日志配置文件初始化">指定日志配置文件初始化</a></h3>
<ol>
<li>对配置文件名进行 占位符替换</li>
<li>载入对应配置</li>
</ol>
<pre><code class="language-java">private void initializeWithSpecificConfig(LoggingInitializationContext initializationContext, String configLocation,
      LogFile logFile) {
   configLocation = SystemPropertyUtils.resolvePlaceholders(configLocation);
   loadConfiguration(initializationContext, configLocation, logFile);
}
</code></pre>
<h2 id="log4j2的具体实现"><a class="header" href="#log4j2的具体实现">log4j2的具体实现</a></h2>
<h3 id="获取标准配置文件"><a class="header" href="#获取标准配置文件">获取标准配置文件</a></h3>
<p>先后顺序决定了加载优先级</p>
<pre><code>log4j2.properties log4j2.yaml log4j2.yml log4j2.json log4j2.jsn log4j2.xml
</code></pre>
<h3 id="重新初始化"><a class="header" href="#重新初始化">重新初始化</a></h3>
<p>无</p>
<h3 id="初始化日志配置"><a class="header" href="#初始化日志配置">初始化日志配置</a></h3>
<pre><code class="language-java">protected void loadConfiguration(String location, LogFile logFile) {
   Assert.notNull(location, &quot;Location must not be null&quot;);
   try {
      LoggerContext ctx = getLoggerContext();
      URL url = ResourceUtils.getURL(location);
      ConfigurationSource source = getConfigurationSource(url);
      ctx.start(ConfigurationFactory.getInstance().getConfiguration(ctx, source));
   }
   catch (Exception ex) {
      throw new IllegalStateException(&quot;Could not initialize Log4J2 logging from &quot; + location, ex);
   }
}
</code></pre>
<h3 id="载入默认配置"><a class="header" href="#载入默认配置">载入默认配置</a></h3>
<pre><code class="language-java">@Override
protected void loadDefaults(LoggingInitializationContext initializationContext, LogFile logFile) {
   if (logFile != null) {
      loadConfiguration(getPackagedConfigFile(&quot;log4j2-file.xml&quot;), logFile);
   }
   else {
      loadConfiguration(getPackagedConfigFile(&quot;log4j2.xml&quot;), logFile);
   }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="webfilter"><a class="header" href="#webfilter">@WebFilter</a></h2>
<p>标记一个过滤器</p>
<pre><code class="language-java">@WebFilter(urlPatterns = &quot;/*&quot;)
public class MyFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        System.out.println(&quot;-----doFilter-----&quot;);
        chain.doFilter(request, response);
    }
}
</code></pre>
<p>需要标注:@ServletComponentScan 注解,因为这是 servlet的注解</p>
<h2 id="bean"><a class="header" href="#bean">@Bean</a></h2>
<pre><code class="language-java">@Component
public class MyFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        System.out.println(&quot;-----doFilter-----&quot;);
        chain.doFilter(request, response);
    }
}

指定优先级
@Component
@Order(-1)
public class MyFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        System.out.println(&quot;-----doFilter-----&quot;);
        chain.doFilter(request, response);
    }
}
</code></pre>
<h2 id="filterregistrationbean"><a class="header" href="#filterregistrationbean">FilterRegistrationBean</a></h2>
<pre><code class="language-java">@Configuration
public class FilterConfiguration {
    @Bean
    FilterRegistrationBean&lt;MyFilter&gt; myFilterFilterRegistrationBean() {
        FilterRegistrationBean&lt;MyFilter&gt; bean = new FilterRegistrationBean&lt;&gt;();
        bean.setFilter(new MyFilter());
        bean.setOrder(-1);
        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));
        return bean;
    }
    @Bean
    FilterRegistrationBean&lt;MyFilter2&gt; myFilterFilterRegistrationBean2() {
        FilterRegistrationBean&lt;MyFilter2&gt; bean = new FilterRegistrationBean&lt;&gt;();
        bean.setFilter(new MyFilter2());
        bean.setOrder(-2);
        bean.setUrlPatterns(Arrays.asList(&quot;/hello&quot;));
        return bean;
    }
}
</code></pre>
<p>spring有很多注册<em>bean</em>,用来向spring容器注册特殊业务功能的bean</p>
<ol>
<li>ServletListenerRegistrationBean 用来注册监听器。</li>
<li>ServletRegistrationBean 用来注册 Servlet。</li>
<li>DispatcherServletRegistrationBean 用来注册 DispatcherServlet。</li>
<li>FilterRegistrationBean 用来注册过滤器。</li>
<li>DelegatingFilterProxyRegistrationBean 则用来注册 DelegatingFilterProxy，DelegatingFilterProxy 在 Spring Security、Spring Session、Shiro 等整合时非常有用。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>
<p>配置maven resource插件</p>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;copy-resources&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;copy-resources&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;resources&gt;
                    &lt;resource&gt;
                     	&lt;directory&gt;src/main/resources&lt;/directory&gt; 
                    &lt;/resource&gt;
                &lt;/resources&gt;
                &lt;outputDirectory&gt;${project.build.directory}/config&lt;/outputDirectory&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
</li>
<li>
<p>将项目</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是-springboot"><a class="header" href="#什么是-springboot">什么是 springBoot?</a></h1>
<p>curl https://start.spring.io/starter.zip -d bootVersion=2.3.0.M1 -d dependencies=web,devtools -o demo.zip</p>
<h1 id="优点"><a class="header" href="#优点">优点</a></h1>
<p>自动配置,无需配置XML</p>
<p>微服务</p>
<h1 id="springboot原理"><a class="header" href="#springboot原理">springboot原理</a></h1>
<p><code>Spring Boot</code>将所有的功能场景都抽取出来，做成一个个的<code>starters</code>（启动器），只需要在项目里面引入这些<code>starter</code>相关场景的所有依赖都会导入进来</p>
<h1 id=""><a class="header" href="#"></a></h1>
<h1 id="springboot相关依赖"><a class="header" href="#springboot相关依赖">springBoot相关依赖</a></h1>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.3.0.RELEASE&lt;/version&gt;
&lt;/parent&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;	
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring‐boot‐starter‐web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h1 id="打jar包插件"><a class="header" href="#打jar包插件">打jar包插件</a></h1>
<pre><code>&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<h1 id="主程序类主入口类"><a class="header" href="#主程序类主入口类">主程序类，主入口类</a></h1>
<p>SpringApplication.run(HelloWorldMainApplication.class,args);</p>
<h1 id="spring运行器"><a class="header" href="#spring运行器">spring运行器</a></h1>
<p>应用程序运行器</p>
<ul>
<li>启动后执行代码的接口</li>
<li>ApplicationRunner </li>
</ul>
<p>命令行运行器</p>
<ul>
<li>完全启动后回传 命令行参数</li>
<li>CommandLineRunner</li>
</ul>
<h1 id="属性的使用"><a class="header" href="#属性的使用">属性的使用</a></h1>
<h2 id="自定义属性与加载"><a class="header" href="#自定义属性与加载">自定义属性与加载</a></h2>
<p>定义</p>
<p><code>com.didispace.blog.name=程序猿DD</code></p>
<p>使用</p>
<p><code>@Value(&quot;${com.didispace.blog.name}&quot;)    private String name;</code></p>
<h2 id="参数间的引用"><a class="header" href="#参数间的引用">参数间的引用</a></h2>
<pre><code>com.didispace.blog.name=程序猿DD 
com.didispace.blog.title=Spring Boot教程 com.didispace.blog.desc=${com.didispace.blog.name}正在努力写《${com.didispace.blog.title}》
</code></pre>
<h2 id="使用随机数"><a class="header" href="#使用随机数">使用随机数</a></h2>
<p>RandomValuePropertySource  提供支持</p>
<pre><code># 随机字符串
com.didispace.blog.value=${random.value}
# 随机int
com.didispace.blog.number=${random.int}
# 随机long
com.didispace.blog.bignumber=${random.long}
# 10以内的随机数
com.didispace.blog.test1=${random.int(10)}
# 10-20的随机数
com.didispace.blog.test2=${random.int[10,20]}
</code></pre>
<h2 id="通过命令行设置属性值"><a class="header" href="#通过命令行设置属性值">通过命令行设置属性值</a></h2>
<p>设置值</p>
<pre><code>连续的两个减号`--`就是对`application.properties`中的属性值进行赋值的标识。所以，`java -jar xxx.jar --server.port=8888`命令，等价于我们在`application.properties`中添加属性`server.port=8888`
</code></pre>
<p>屏蔽值</p>
<p><code>SpringApplication.setAddCommandLineProperties(false)</code></p>
<h2 id="外部参数设置"><a class="header" href="#外部参数设置">外部参数设置</a></h2>
<p>java -D</p>
<h2 id="多环境配置"><a class="header" href="#多环境配置">多环境配置</a></h2>
<ul>
<li>在Spring Boot中多环境配置文件名需要满足<code>application-{profile}.properties</code>的格式，其中<code>{profile}</code>对应你的环境标识</li>
<li><code>application-dev.properties</code>：开发环境</li>
<li><code>application-test.properties</code>：测试环境</li>
<li><code>application-prod.properties</code>：生产环境</li>
<li>至于哪个具体的配置文件会被加载，需要在<code>application.properties</code>文件中通过<code>spring.profiles.active</code>属性来设置，其值对应<code>{profile}</code>值。</li>
<li><code>application.properties</code>中配置通用内容</li>
</ul>
<h2 id="spring获取配置属性的方法按优先级-降序"><a class="header" href="#spring获取配置属性的方法按优先级-降序">spring获取配置属性的方法，按优先级 降序</a></h2>
<p>1.命令行参数</p>
<p>2.java:comp/env 里的 JNDI 属性</p>
<p>3.JVM 系统属性</p>
<p>4.操作系统环境变量</p>
<p>5.RandomValuePropertySource 属性类生成的 random.* 属性</p>
<p>6.应用以外的 application.properties（或 yml）文件</p>
<p>7.打包在应用内的 application.properties（或 yml）文件</p>
<p>8.在应用 @Configuration 配置类中，用 @PropertySource 注解声明的属性文件</p>
<p>9.SpringApplication.setDefaultProperties 声明的默认属性</p>
<h2 id="yml与-properties"><a class="header" href="#yml与-properties">YML与 properties</a></h2>
<ul>
<li>yml格式键值对冒号后面，必须空一格。</li>
<li>iso-8859 的编码方式读取 application.properties 配置文件，</li>
</ul>
<h1 id="spring构建restful-web服务"><a class="header" href="#spring构建restful-web服务">spring构建restful web服务</a></h1>
<h2 id="restcontroller"><a class="header" href="#restcontroller"><code>@RestController</code></a></h2>
<p>注释用于定义RESTful Web服务。它提供JSON，XML和自定义响应</p>
<h2 id="requestmapping"><a class="header" href="#requestmapping"><code>@RequestMapping</code></a></h2>
<p>定义rest端点的URI，默认是GET</p>
<h2 id="requestbody-2"><a class="header" href="#requestbody-2"><code>@RequestBody</code></a></h2>
<p>定义请求正文内容类型</p>
<h2 id="pathvariable"><a class="header" href="#pathvariable"><code>@PathVariable</code></a></h2>
<p>路径变量</p>
<pre><code>@RequestMapping(&quot;/hello/{aaa}/{bbb}&quot;)
    public String hello(@PathVariable(&quot;aaa&quot;)String aa1,@PathVariable(&quot;bbb&quot;) String bb1 ){
        return aa1+&quot;:&quot;+bb1;
    }
</code></pre>
<h2 id="getputpostdelete"><a class="header" href="#getputpostdelete">GET,PUT,POST,DELETE</a></h2>
<p>@RequestMapping(value = &quot;/products&quot;, method = RequestMethod.POST) </p>
<h1 id="springboot异常处理"><a class="header" href="#springboot异常处理">SpringBoot异常处理</a></h1>
<h2 id="controlleradvice"><a class="header" href="#controlleradvice"><code>@ControllerAdvice</code></a></h2>
<p>是一个注解，用于标识这是一个 全局处理</p>
<h2 id="exceptionhandlervalue--productnotfoundexceptionclass"><a class="header" href="#exceptionhandlervalue--productnotfoundexceptionclass"><code>@ExceptionHandler(value = ProductNotfoundException.class)</code></a></h2>
<p>针对特定异常的特定类</p>
<h1 id="springboot拦截器"><a class="header" href="#springboot拦截器">springboot拦截器</a></h1>
<h2 id="可以在以下三种情况拦截"><a class="header" href="#可以在以下三种情况拦截">可以在以下三种情况拦截</a></h2>
<ul>
<li>
<p>在将请求发送到控制器之前</p>
</li>
<li>
<p>在将响应发送给客户端之前</p>
</li>
<li>
<p>完成响应之后</p>
</li>
</ul>
<h2 id="实现步骤"><a class="header" href="#实现步骤">实现步骤</a></h2>
<ol>
<li>实现HandlerInterceptor,与component组件</li>
<li>使用 webMVCConfigurerAdapter 向InterceptorRegistry 注册</li>
</ol>
<h1 id="servlet过滤器"><a class="header" href="#servlet过滤器">Servlet过滤器</a></h1>
<p><code>public class SimpleFilter implements Filter</code></p>
<p>用于拦截应用程序的HTTP请求和响应的对象</p>
<h1 id="springboot端口"><a class="header" href="#springboot端口">springBoot端口		</a></h1>
<p>Spring Boot允许在不同的端口号上多次运行相同的应用程序。 在本章中，将详细了解和学习这一点。 请注意，默认端口号为:<code>8080</code>。</p>
<p>自定义端口</p>
<p><code>server.port = 9090</code></p>
<pre><code>server: 
   port: 9090
</code></pre>
<p>随机端口：<code>server.port = 0</code></p>
<h1 id="springrest模板"><a class="header" href="#springrest模板">springRest模板		 				 				 				 			</a></h1>
<ul>
<li>Rest模板 可以调用  RESTfulWeb服务</li>
<li>调用方法</li>
</ul>
<pre><code> ResponseEntity&lt;T&gt; exchange(
 	String url,
 	HttpMethod method,
    @Nullable HttpEntity&lt;?&gt; requestEntity,
    Class&lt;T&gt; responseType,
    Object... uriVariables
)
</code></pre>
<h1 id="spring-boot文件处理"><a class="header" href="#spring-boot文件处理">Spring Boot文件处理</a></h1>
<h2 id="文件上传"><a class="header" href="#文件上传">文件上传</a></h2>
<pre><code>MultipartFile file
consumes = MediaType.MULTIPART_FORM_DATA_VALUE 
//媒体类型
</code></pre>
<h2 id="文件下载"><a class="header" href="#文件下载">文件下载</a></h2>
<ol>
<li>
<p>接收下载请求</p>
</li>
<li>
<p>找到下载文件,转换成流</p>
</li>
<li>
<p>设置报文头</p>
<ol>
<li><em>Content-Disposition</em></li>
<li><em>&quot;Pragma&quot;, &quot;no-cache&quot;</em>  为了兼容HTTP1.1</li>
<li><em>&quot;Expires&quot;, &quot;0&quot;</em> </li>
</ol>
</li>
<li>
<p>组键响应头</p>
<ol>
<li>构建OK报文</li>
<li>构建报文头</li>
<li>文件大小</li>
<li>响应类型</li>
<li>响应体</li>
</ol>
</li>
</ol>
<h1 id="spring-boot-thymeleaf"><a class="header" href="#spring-boot-thymeleaf">Spring Boot Thymeleaf</a></h1>
<ul>
<li>
<p>Thymeleaf是一个基于Java的模板解析库，用于创建Web应用程序</p>
</li>
<li>
<p>支持 HTML,XML模板</p>
</li>
</ul>
<p>依赖配置</p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h1 id="spring-boot-cors支持"><a class="header" href="#spring-boot-cors支持">Spring Boot CORS支持</a></h1>
<p>在控制器中启用CORS</p>
<pre><code>@RequestMapping(value = &quot;/products&quot;) @CrossOrigin(origins = &quot;http://localhost:8080&quot;) 
public ResponseEntity&lt;Object&gt; getProduct() 
{   return null; } 

</code></pre>
<p>全局CORS配置</p>
<pre><code>@Bean
public WebMvcConfigurer corsConfigurer() {
   return new WebMvcConfigurerAdapter() {
      @Override
      public void addCorsMappings(CorsRegistry registry) {
         registry.addMapping(&quot;/products&quot;).allowedOrigins(&quot;http://localhost:9000&quot;);
      }    
   };
}
</code></pre>
<h1 id="springboot国际化"><a class="header" href="#springboot国际化">springBoot国际化</a></h1>
<p>依赖tymeleaf</p>
<p>启用国际化步骤</p>
<ol>
<li>需要确定应用程序的默认Locale</li>
</ol>
<pre><code>@Bean
public LocaleResolver localeResolver() {
   SessionLocaleResolver sessionLocaleResolver = new SessionLocaleResolver();
sessionLocaleResolver.setDefaultLocale
(Locale.US);
   return sessionLocaleResolver;
}
</code></pre>
<ol start="2">
<li>
<p>语言环境变更拦截器:设置拦截参数</p>
<pre><code>@Bean
public LocaleChangeInterceptor localeChangeInterceptor() {
   LocaleChangeInterceptor localeChangeInterceptor = new LocaleChangeInterceptor();
   localeChangeInterceptor.setParamName(&quot;language&quot;);
   return localeChangeInterceptor;
}
</code></pre>
</li>
<li>
<p>注册拦截器</p>
<pre><code>@Override
public void addInterceptors(InterceptorRegistry registry) {
   registry.addInterceptor(localeChangeInterceptor());
}
</code></pre>
</li>
<li>
<p>默认从 src/main/resources 获取消息源</p>
<ul>
<li>
<p>消息文件</p>
<p>message.properties</p>
<p>messages_XX.properties XX表示区码</p>
</li>
<li>
<p>idea创建 Resource Bundle</p>
</li>
<li>
<p>idea默认properties文件为GBK编码</p>
</li>
</ul>
</li>
</ol>
<h1 id="spring-boot调度"><a class="header" href="#spring-boot调度">Spring Boot调度</a></h1>
<ul>
<li>Java Cron表达式用于配置CronTrigger的实例</li>
</ul>
<h2 id="使用-1"><a class="header" href="#使用-1">使用</a></h2>
<ul>
<li>
<p><em>@EnableScheduling</em> 注解用于为应用程序启用调度程序</p>
</li>
<li>
<pre><code>@Scheduled(cron = &quot;0 * 9 * * ?&quot;)
public void cronJobSch() throws Exception {
}
</code></pre>
</li>
<li>
<p>固定速率</p>
<ul>
<li>@Scheduled(fixedRate = 1000) </li>
</ul>
</li>
<li>
<p>固定延迟</p>
<ul>
<li>@Scheduled(fixedDelay = 1000, initialDelay = 1000)</li>
</ul>
</li>
</ul>
<h1 id="spring-boot启用https"><a class="header" href="#spring-boot启用https">Spring Boot启用HTTPS</a></h1>
<p>可按照以下步骤，在Spring Boot应用程序中配置HTTPS和端口443 -</p>
<ol>
<li>
<p>获取SSL证书 - 创建自签名证书或从证书颁发机构获取证书</p>
<pre><code> keytool.exe -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650
</code></pre>
</li>
<li>
<p>启用HTTPS和443端口</p>
<pre><code class="language-yml">server:
   port: 443
   ssl:
      key-store: keystore.p12
      key-store-password: springboot
      keyStoreType: PKCS12
      keyAlias: tomcat

</code></pre>
</li>
</ol>
<h1 id="springboot发送电子邮件"><a class="header" href="#springboot发送电子邮件">springBoot发送电子邮件</a></h1>
<p>依赖</p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h1 id="springbootapplication-注解解析"><a class="header" href="#springbootapplication-注解解析">@SpringBootApplication 注解解析</a></h1>
<ul>
<li>
<p>Spring Boot应用标注在某个类上说明这个类是<code>SpringBoot</code>的主配置类</p>
</li>
<li>
<p><code>SpringBoot</code>就应该运行这个类的<code>main</code>方法来启动<code>SpringBoot</code>应用；这是一个<strong>组合注解</strong>。</p>
<ul>
<li>@SpringBootConfiguration 等同于 spring的 @Configuration 也就是Spring里面的配置类</li>
<li>@EnableAutoConfiguration，开启自动配置
<ul>
<li>@AutoConfigurationPackage 自动配置包
<ul>
<li><code>@Import(AutoConfigurationPackages.Registrar.class)</code>：<code>Spring</code>的底层注解<code>@Import</code>，给容器中导入一个组件；导入的组件由<code>AutoConfigurationPackages.Registrar.class</code>指定。 也就是: 将主配置类（<code>@SpringBootApplication</code>标注的类）的<strong>所在包及下面所有子包里面的所有组件扫描到Spring容器</strong></li>
</ul>
</li>
</ul>
</li>
<li>@Import(AutoConfigurationImportSelector.class)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="依赖配置"><a class="header" href="#依赖配置">依赖配置</a></h1>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
    &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.18.16&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
    &lt;version&gt;2.4.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h1 id="定义service业务类"><a class="header" href="#定义service业务类">定义Service业务类</a></h1>
<pre><code class="language-java">package com.weisanju;

public class MsgService {
    String url;
    String accessKeySecret;
    String accessKeyId;
    public MsgService(String url,String accessKeyId, String accessKeySecret) {
        this.url = url;
        this.accessKeySecret = accessKeySecret;
        this.accessKeyId = accessKeyId;
    }
    public void sendMsgService(String msg){
        HttpClientUtils.sendMsg(url,accessKeyId,accessKeySecret,msg);
    }

    public MsgService() {
    }
}
</code></pre>
<h1 id="定义配置类"><a class="header" href="#定义配置类">定义配置类</a></h1>
<pre><code class="language-java">package com.weisanju;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = &quot;msg&quot;)
@Data
public class MsgProperties {
    private String url;
    private String accessKeyId;
    private String accessKeySecret;

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getAccessKeyId() {
        return accessKeyId;
    }

    public void setAccessKeyId(String accessKeyId) {
        this.accessKeyId = accessKeyId;
    }

    public String getAccessKeySecret() {
        return accessKeySecret;
    }

    public void setAccessKeySecret(String accessKeySecret) {
        this.accessKeySecret = accessKeySecret;
    }
}
</code></pre>
<h1 id="定义自动配置类"><a class="header" href="#定义自动配置类">定义自动配置类</a></h1>
<pre><code class="language-java">package com.weisanju;

import com.weisanju.MsgService;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.annotation.Resource;

@Configuration
@ConditionalOnClass(MsgService.class)
@EnableConfigurationProperties(MsgProperties.class)
public class MsgAutoConfiguration {
    //注入属性配置类
    @Resource
    private MsgProperties msgProperties;

    @Bean
    @ConditionalOnMissingBean(MsgService.class)
    @ConditionalOnProperty(prefix = &quot;msg&quot;,value = &quot;enabled&quot;,havingValue = &quot;true&quot;)
    public MsgService msgService() {
        return new MsgService(msgProperties.getUrl(),msgProperties.getAccessKeyId() ,msgProperties.getAccessKeySecret());
    }
}
</code></pre>
<h1 id="定义-类spi查找"><a class="header" href="#定义-类spi查找">定义 类SPI查找</a></h1>
<p><em>src/main/resources/META-INF/spring.factories</em></p>
<p>路径中 定义 自动配置类 <em>org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.weisanju.MsgAutoConfiguration</em></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="springboot默认读取配置文件的优先级"><a class="header" href="#springboot默认读取配置文件的优先级">SpringBoot默认读取配置文件的优先级</a></h1>
<ol>
<li>工作目录同级下的config文件夹是优先级最高的</li>
<li>工作目录同级 是次优先级</li>
<li>classpath:config/ 是第三优先级</li>
<li>classpath: 同级是第四优先级</li>
</ol>
<h1 id="自定义配置文件"><a class="header" href="#自定义配置文件">自定义配置文件</a></h1>
<h2 id="命令行自定义"><a class="header" href="#命令行自定义">命令行自定义</a></h2>
<pre><code class="language-sh"># 指定 classPath
java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties

# 指定绝对路径
java -jar -Dspring.config.location=D:\config\config.properties springbootrestdemo-0.0.1-SNAPSHOT.jar 
</code></pre>
<h2 id="代码中指定"><a class="header" href="#代码中指定">代码中指定</a></h2>
<pre><code>@SpringBootApplication
@PropertySource(value={&quot;file:config.properties&quot;,&quot;classpath:config.properties&quot;})
public class SpringbootrestdemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootrestdemoApplication.class, args);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="springapplication"><a class="header" href="#springapplication">SpringApplication</a></h1>
<p><code>SpringApplication</code>  类提供了 启动 spring 应用程序 便利的 方式，从 main方法启动</p>
<p>通常调用 <code>SpringApplication.run</code>  方法</p>
<pre><code class="language-java">@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
</code></pre>
<p><strong>日志打印</strong></p>
<p>默认情况下 打印 <em>INFO</em> 级别日志， 包括相关的启动细节，例如 启动应用的用户，更改日志级别，详见：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.logging.log-levels">Log Levels</a></p>
<p>启动信息日志可以通过  <code>spring.main.log-startup-info</code>  关闭，这也会关闭application’s active profiles的打印</p>
<p>在启动时 加入 额外日志，可以在 <code>SpringApplication</code>    覆盖 <code>logStartupInfo(boolean)</code> 方法</p>
<h1 id="startup-failure"><a class="header" href="#startup-failure">Startup Failure</a></h1>
<p>如果启动失败，注册 <code>FailureAnalyzers</code> 可以 专用的错误消息，和修复问题的 精确 动作</p>
<p>例如 8080端口占用会显示以下信息</p>
<pre><code>***************************
APPLICATION FAILED TO START
***************************
Description:
Embedded servlet container failed to start. Port 8080 was already in use.
Action:
Identify and stop the process that's listening on port 8080 or configure this application to listen on another port.
</code></pre>
<p>Spring Boot 提供很多 <code>FailureAnalyzer</code> 实现，自定义：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.application.failure-analyzer">add your own</a></p>
<p>如果没有analyzers 能 处理异常，可以展示详细信息，需要启用 debug 属性 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config">enable the <code>debug</code> property</a> or <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.logging.log-levels">enable <code>DEBUG</code> logging</a> </p>
<p><code>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</code></p>
<pre><code class="language-shell">$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug
</code></pre>
<h1 id="lazy-initialization"><a class="header" href="#lazy-initialization">Lazy Initialization</a></h1>
<p><code>SpringApplication</code> 允许懒加载，懒加载可以减少启动时间，也会延迟错误的发现，确保JVM有足够内存容纳bean，最好在启动懒加载前调整队大小</p>
<p>在 <code>SpringApplicationBuilder</code>  中使用 <code>lazyInitialization</code> 可以编程式启用，或者调用<code>SpringApplication</code> 的 <code>setLazyInitialization</code> </p>
<p>可以使用 <code>spring.main.lazy-initialization</code>  启用</p>
<p>如果您想禁用 某些bean 的懒加载，对其他启用懒加载，可以使用 <code>@Lazy(false)</code> 显示设置</p>
<h1 id="customizing-the-banner"><a class="header" href="#customizing-the-banner">Customizing the Banner</a></h1>
<ul>
<li>
<p>启动时会读取   <em>classpath</em> 下的<code>banner.txt</code>，通过 <code>spring.banner.location</code> 指定</p>
</li>
<li>
<p><code>spring.banner.charset</code> 指定字符集</p>
</li>
<li>
<p>通过设置 <code>spring.banner.image.location</code>  可以添加图片 <code>banner.gif</code>, <code>banner.jpg</code>, or <code>banner.png</code></p>
</li>
</ul>
<p><code>banner.txt</code> 中可以使用 以下占位符</p>
<table><thead><tr><th style="text-align: left">Variable</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>${application.version}</code></td><td style="text-align: left"><code>MANIFEST.MF</code>中定义的版本号，例如, <code>Implementation-Version: 1.0</code> is printed as <code>1.0</code></td></tr>
<tr><td style="text-align: left"><code>${application.formatted-version}</code></td><td style="text-align: left"><code>MANIFEST.MF</code>中定义的版本号： (surrounded with brackets and prefixed with <code>v</code>). For example <code>(v1.0)</code>.</td></tr>
<tr><td style="text-align: left"><code>${spring-boot.version}</code></td><td style="text-align: left">spring-boot版本号</td></tr>
<tr><td style="text-align: left"><code>${spring-boot.formatted-version}</code></td><td style="text-align: left">格式化的版本号 (surrounded with brackets and prefixed with <code>v</code>). For example <code>(v2.5.5)</code>.</td></tr>
<tr><td style="text-align: left"><code>${Ansi.NAME}</code> (or <code>${AnsiColor.NAME}</code>, <code>${AnsiBackground.NAME}</code>, <code>${AnsiStyle.NAME}</code>)</td><td style="text-align: left">Where <code>NAME</code> is the name of an ANSI escape code. See <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.5/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java"><code>AnsiPropertySource</code></a> for details.</td></tr>
<tr><td style="text-align: left"><code>${application.title}</code></td><td style="text-align: left"><code>MANIFEST.MF</code>中定义的 标题：For example <code>Implementation-Title: MyApp</code> is printed as <code>MyApp</code>.</td></tr>
</tbody></table>
<p><code>SpringApplication.setBanner(…)</code>  方法 可以编程式设置 <em>banner</em>，实现自己的 <code>org.springframework.boot.Banner</code> </p>
<p><code>spring.main.banner-mode</code>  属性决定  <em>banner</em> 是否要 打印到 控制台</p>
<p><em>banner</em> 被注册为 单例，名称叫：<code>springBootBanner</code></p>
<p><code>${application.version}</code>  和 <code>${application.formatted-version}</code> 只在 使用Spring Boot 可用。</p>
<p>如果使用 解压的jar，使用 <code>java -cp &lt;classpath&gt; &lt;mainclass&gt;</code>. 启动的则不能使用变量</p>
<p>建议使用 <code>java org.springframework.boot.loader.JarLauncher</code>.  启动 解压的jar 这会初始化  <code>application.*</code>  banner变量 </p>
<h1 id="customizing-springapplication"><a class="header" href="#customizing-springapplication">Customizing SpringApplication</a></h1>
<p>可以自定义 <code>SpringApplication</code> </p>
<pre><code class="language-java">@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication application = new SpringApplication(MyApplication.class);
        application.setBannerMode(Banner.Mode.OFF);
        application.run(args);
    }
}
</code></pre>
<p>构造参数 需要传递 bean的 配置源，大多数情况下是 <code>@Configuration</code> 配置类，也可以直接引用 <code>@Component</code> 类</p>
<p>外部化配置,详见：<em><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config">Externalized Configuration</a></em> </p>
<h1 id="fluent-builder-api"><a class="header" href="#fluent-builder-api">Fluent Builder API</a></h1>
<p>使用 <code>SpringApplicationBuilder</code> 链式构建 带层级的 <em>SpringApplication</em></p>
<pre><code class="language-java">  new SpringApplicationBuilder()
        .sources(Parent.class)
        .child(Application.class)
        .bannerMode(Banner.Mode.OFF)
        .run(args);
</code></pre>
<p>See the <a href="https://docs.spring.io/spring-boot/docs/2.5.5/api/org/springframework/boot/builder/SpringApplicationBuilder.html"><code>SpringApplicationBuilder</code> Javadoc</a> for full details</p>
<h1 id="application-availability"><a class="header" href="#application-availability">Application Availability</a></h1>
<p>应用程序可以提供不同架构不同平台的信息，Spring Boot 提供开箱即用的 支持，包括常用的  <em>liveness</em> 跟 <em>readiness</em>  的可用状态</p>
<p>使用 Spring Boot’s actuator 支持这些状态的展示，此外，通过注入 <code>ApplicationAvailability</code>  接口到 bean中，获取 可用状态</p>
<h2 id="liveness-state"><a class="header" href="#liveness-state">Liveness State</a></h2>
<p>应用程序 的 Liveness  状态  告诉 其内部 状态 是否 允许它 正确工作，或者如果当前失败，自行恢复</p>
<p>A broken “Liveness” state  意味着 应用程序处于无法恢复的状态，基础架构平台 应该 重启应用程序</p>
<p>一般，Liveness 状态 不应该 基于 外部检查，例如：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.health">Health checks</a></p>
<p>如果确实存在，失败的外部系统（database，webAPI，an external cache）会触发平台大规模重新启动和 级联故障</p>
<p>Spring Boot 应用的 内部状态 主要由 <code>ApplicationContext</code>表示</p>
<ol>
<li>如果 应用上下文 已经成功启动了，Spring Boot 则认为 该程序是 有效状态</li>
<li>当 上下文刷新了，应用则认为是 活的</li>
</ol>
<p>详见 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners">Spring Boot application lifecycle and related Application Events</a>.</p>
<h2 id="readiness-state"><a class="header" href="#readiness-state">Readiness State</a></h2>
<p>应用的 <em>Readiness</em> 状态 表明：应用程序是否已经准备好 处理流量，失败的 <em>Readiness</em> 表明：不应将流量路由到应用程序</p>
<p>这通常 发生在启动时刻，<code>CommandLineRunner</code>  和 <code>ApplicationRunner</code>  组件正被处理，或者 应用程序认为 它太忙 无法处理更多流量</p>
<p>一旦 应用程序和命令行运行者 被调用，应用程序就被认为准备就绪，详见： <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners">Spring Boot application lifecycle and related Application Events</a>.</p>
<p>在 启动就要被执行的 任务，应该通过  <code>CommandLineRunner</code>   和 <code>ApplicationRunner</code> 组件执行，而不是使用  spring组件中的 生命周期的回调 （例如：<code>@PostConstruct</code>）执行</p>
<h2 id="managing-the-application-availability-state"><a class="header" href="#managing-the-application-availability-state">Managing the Application Availability State</a></h2>
<p>应用程序组件 可以 在任意时间获取 当前 可用性，通过注入 <code>ApplicationAvailability</code>  接口，在其上调用</p>
<p>更普遍的，应用程序 将会 监听 状态 变更，或者 更新应用程序的  状态</p>
<p>例如：可以将 应用的 <em>Readiness</em> 状态  导出到文件中， Kubernetes 即可 通过 <em>exec Probe</em> 查看</p>
<pre><code class="language-java">@Component
public class MyReadinessStateExporter {

    @EventListener
    public void onStateChange(AvailabilityChangeEvent&lt;ReadinessState&gt; event) {
        switch (event.getState()) {
        case ACCEPTING_TRAFFIC:
            // create file /tmp/healthy
            break;
        case REFUSING_TRAFFIC:
            // remove file /tmp/healthy
            break;
        }
    }
}
</code></pre>
<p>当应用程序中断且无法恢复时，我们还可以更新应用程序状态：</p>
<pre><code class="language-java">@Component
public class MyLocalCacheVerifier {

    private final ApplicationEventPublisher eventPublisher;

    public MyLocalCacheVerifier(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    public void checkLocalCache() {
        try {
            // ...
        }
        catch (CacheCompletelyBrokenException ex) {
            AvailabilityChangeEvent.publish(this.eventPublisher, ex, LivenessState.BROKEN);
        }
    }

}
</code></pre>
<p>Spring Boot provides <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.kubernetes-probes">Kubernetes HTTP probes for &quot;Liveness&quot; and &quot;Readiness&quot; with Actuator Health Endpoints</a>. You can get more guidance about <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/deployment.html#deployment.cloud.kubernetes">deploying Spring Boot applications on Kubernetes in the dedicated section</a>.</p>
<h1 id="application-events-and-listeners"><a class="header" href="#application-events-and-listeners">Application Events and Listeners</a></h1>
<p>事件跟监听机制，除了常见的 SpringFramework 事件，例如：<a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/context/event/ContextRefreshedEvent.html"><code>ContextRefreshedEvent</code></a> ，<code>SpringApplication</code>  也会产生额外的事件</p>
<p>一些事件 实在 <code>ApplicationContext</code> 创建之前 触发的，不能通过@Bean 注册监听器，可以通过  <code>SpringApplication.addListeners(…)</code>  或者 <code>SpringApplicationBuilder.listeners(…)</code>  方法  注册监听器</p>
<p>如果想要其自动注册，则可以将 <code>META-INF/spring.factories</code>  加入到 classpath下，写法如下</p>
<p><code>org.springframework.context.ApplicationListener=com.example.project.MyListener</code></p>
<p>应用事件按以下顺序发送</p>
<ol>
<li>An <code>ApplicationStartingEvent</code> is sent at the start of a run but before any processing, except for the registration of listeners and initializers.</li>
<li>An <code>ApplicationEnvironmentPreparedEvent</code> is sent when the <code>Environment</code> to be used in the context is known but before the context is created.</li>
<li>An <code>ApplicationContextInitializedEvent</code> is sent when the <code>ApplicationContext</code> is prepared and ApplicationContextInitializers have been called but before any bean definitions are loaded.</li>
<li>An <code>ApplicationPreparedEvent</code> is sent just before the refresh is started but after bean definitions have been loaded.</li>
<li>An <code>ApplicationStartedEvent</code> is sent after the context has been refreshed but before any application and command-line runners have been called.</li>
<li>An <code>AvailabilityChangeEvent</code> is sent right after with <code>LivenessState.CORRECT</code> to indicate that the application is considered as live.</li>
<li>An <code>ApplicationReadyEvent</code> is sent after any <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.command-line-runner">application and command-line runners</a> have been called.</li>
<li>An <code>AvailabilityChangeEvent</code> is sent right after with <code>ReadinessState.ACCEPTING_TRAFFIC</code> to indicate that the application is ready to service requests.</li>
<li>An <code>ApplicationFailedEvent</code> is sent if there is an exception on startup.</li>
</ol>
<p>The above list only includes <code>SpringApplicationEvent</code>s that are tied to a <code>SpringApplication</code>. In addition to these, the following events are also published after <code>ApplicationPreparedEvent</code> and before <code>ApplicationStartedEvent</code>:</p>
<ul>
<li>A <code>WebServerInitializedEvent</code> is sent after the <code>WebServer</code> is ready. <code>ServletWebServerInitializedEvent</code> and <code>ReactiveWebServerInitializedEvent</code> are the servlet and reactive variants respectively.</li>
<li>A <code>ContextRefreshedEvent</code> is sent when an <code>ApplicationContext</code> is refreshed.</li>
</ul>
<p>You often need not use application events, but it can be handy to know that they exist. Internally, Spring Boot uses events to handle a variety of tasks.</p>
<p>Event listeners should not run potentially lengthy tasks as they execute in the same thread by default. Consider using <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.command-line-runner">application and command-line runners</a> instead.</p>
<p>Application events are sent by using Spring Framework’s event publishing mechanism. Part of this mechanism ensures that an event published to the listeners in a child context is also published to the listeners in any ancestor contexts. As a result of this, if your application uses a hierarchy of <code>SpringApplication</code> instances, a listener may receive multiple instances of the same type of application event.</p>
<p>To allow your listener to distinguish between an event for its context and an event for a descendant context, it should request that its application context is injected and then compare the injected context with the context of the event. The context can be injected by implementing <code>ApplicationContextAware</code> or, if the listener is a bean, by using <code>@Autowired</code>.</p>
<h1 id="web-environment"><a class="header" href="#web-environment">Web Environment</a></h1>
<p><code>SpringApplication</code>  会自行 尝试创建   正确类型的  <code>ApplicationContext</code> ，用于确定<code>WebApplicationType</code>  的算法如下</p>
<ul>
<li>SpringMVC 在，则使用 <code>AnnotationConfigServletWebServerApplicationContext</code> </li>
<li>Spring MVC 不在，Spring WebFlux 在，则使用 <code>AnnotationConfigReactiveWebServerApplicationContext</code> </li>
<li>否则使用 <code>AnnotationConfigApplicationContext</code></li>
</ul>
<p>通过 <code>setWebApplicationType(WebApplicationType)</code>设置web应用类型</p>
<p>可以完全控制 web的类型，通过：<code>ApplicationContext#setApplicationContextClass(…)</code></p>
<p>当使用 junit 单元测试时，可以 调用  <code>setWebApplicationType(WebApplicationType.NONE)</code> </p>
<h1 id="accessing-application-arguments"><a class="header" href="#accessing-application-arguments">Accessing Application Arguments</a></h1>
<blockquote>
<p>访问应用参数</p>
</blockquote>
<p>你想要访问 传给<code>SpringApplication.run(…)</code> 的参数，可以注入  <code>org.springframework.boot.ApplicationArguments</code>  bean，<code>ApplicationArguments</code> 接口提供 原始的  <code>String[]</code>，或者访问 解析的<code>option</code> and <code>non-option</code>  参数</p>
<pre><code class="language-java">@Component
public class MyBean {
    public MyBean(ApplicationArguments args) {
        boolean debug = args.containsOption(&quot;debug&quot;);
        List&lt;String&gt; files = args.getNonOptionArgs();
        if (debug) {
            System.out.println(files);
        }
        // if run with &quot;--debug logfile.txt&quot; prints [&quot;logfile.txt&quot;]
    }

}
</code></pre>
<p>SpringBoot同样 使用Spring <code>Environment</code>  注册 <code>CommandLinePropertySource</code>  ，这允许你 使用 <code>@Value</code> 注入应用程序参数</p>
<h1 id="using-the-applicationrunner-or-commandlinerunner"><a class="header" href="#using-the-applicationrunner-or-commandlinerunner">Using the ApplicationRunner or CommandLineRunner</a></h1>
<p><code>ApplicationRunner</code> or <code>CommandLineRunner</code>  的代码 在 <code>SpringApplication.run(…)</code>  启动完之后，就执行</p>
<p>，此接口非常适合在应用程序启动后（但在开始接受流量之前）运行的任务。</p>
<p><code>CommandLineRunner</code>  提供string数组，<code>ApplicationRunner</code> 是 <code>ApplicationArguments</code> 对象</p>
<pre><code class="language-java">@Component
public class MyCommandLineRunner implements CommandLineRunner {
    @Override
    public void run(String... args) {
        // Do something...
    }
}
</code></pre>
<p>多个 bean对象实现了该接口 ，可以实现 <code>org.springframework.core.Ordered</code>接口，或者 <code>org.springframework.core.annotation.Order</code> 注解 实现排序</p>
<h1 id="application-exit"><a class="header" href="#application-exit">Application Exit</a></h1>
<p>每个 <code>SpringApplication</code> 应用 都与JVM 注册一个 关闭挂钩，确保 <code>ApplicationContext</code>  能优雅关闭，所有 Spring生命周期回调都可以使用（例如：DisposableBean 接口，或者 @PreDestroy 注解） ，另外可以使用 <em>ExitCodeGenerator</em> 接口 </p>
<pre><code class="language-java">@SpringBootApplication
public class MyApplication {
    @Bean
    public ExitCodeGenerator exitCodeGenerator() {
        return () -&gt; 42;
    }
    public static void main(String[] args) {
        System.exit(SpringApplication.exit(SpringApplication.run(MyApplication.class, args)));
    }
}
</code></pre>
<h1 id="admin-features"><a class="header" href="#admin-features">Admin Features</a></h1>
<p>可以通过 <code>spring.application.admin.enabled</code>属性开启 应用程序管理员功能</p>
<p>This exposes the <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.5/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/admin/SpringApplicationAdminMXBean.java"><code>SpringApplicationAdminMXBean</code></a> on the platform <code>MBeanServer</code>. 可以使用这个远程管理服务</p>
<p>如果您想知道应用程序正在运行哪个 HTTP 端口，使用 <code>local.server.port</code> 获取端口名</p>
<h1 id="application-startup-tracking"><a class="header" href="#application-startup-tracking">Application Startup tracking</a></h1>
<p>During the application startup, the <code>SpringApplication</code> and the <code>ApplicationContext</code> perform many tasks related to the application lifecycle, the beans lifecycle or even processing application events. </p>
<p>在应用程序启动期间，<code>SpringApplication</code> 和  <code>ApplicationContext</code> 执行与 应用生命周期、bean生命周期 或者 处理应用事件 相关的许多任务，</p>
<p>使用 <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/core/metrics/ApplicationStartup.html"><code>ApplicationStartup</code></a>, Spring Framework 允许你 使用 <a href="https://docs.spring.io/spring-framework/docs/5.3.10/reference/html/core.html#context-functionality-startup">StartupStep</a> 对象 记录应用启动序列，收集这些数据可以用于分析目的，或者只是为了更好的了解应用程序启动过程</p>
<p><code>ApplicationStartup</code> 有多个实现，例如，可以使用<code>BufferingApplicationStartup</code>, </p>
<pre><code class="language-java">@SpringBootApplication
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication application = new SpringApplication(MyApplication.class);
        application.setApplicationStartup(new BufferingApplicationStartup(2048));
        application.run(args);
    }

}
</code></pre>
<p>第一个可用的实现类是：<code>FlightRecorderApplicationStartup</code>  ，他将 spring特有的启动实现加入到 java Flight Recorder session中，用于分析应用程序并将其SpringContext 生命周期与 JVM 事件相关联（allocations, GCs, class loading）。一旦配置，可以通过 启用 Flight Recorder 记录数据</p>
<pre><code class="language-shell">$ java -XX:StartFlightRecording:filename=recording.jfr,duration=10s -jar demo.jar
</code></pre>
<p>Spring Boot 实现了 <code>BufferingApplicationStartup</code> 变体，目的是用于输出到外部 指标系统，</p>
<p>Spring Boot can also be configured to expose a <a href="https://docs.spring.io/spring-boot/docs/2.5.5/actuator-api/htmlsingle/#startup"><code>startup</code> endpoint</a> that provides this information as a JSON document.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-6"><a class="header" href="#概述-6">概述</a></h1>
<p>Spring Security为基于 Java EE 的企业软件应用程序提供全面的安全服务。特别是使用 Spring Framework 构建的项目，可以更好的使用 Spring Security 来加快构建的速度。</p>
<p>应用程序安全性的两个主要领域是</p>
<ul>
<li>身份认证（authentication）：“认证”是建立主体 （principal）的过程。主体 通常是指可以在您的应用程序中执行操作的用户、设备或其他系统；</li>
<li>授权（authorization）：或称为“访问控制（access-control），“授权”是指决定是否允许主体在应用程序中执行操作。为了到达需要授权决定的点，认证过程已经建立了主体的身份</li>
</ul>
<p>在认证级别，Spring Security 支持各种各样的认证模型，这些认证模型中的大多数由第三方提供，或者由诸如 IETF (因特网工程任务组) 的相关标准机构开发</p>
<p>此外，Spring Security 提供了自己的一组认证功能。具体来说，Spring Security 目前支持所有这些技术的身份验证集成：</p>
<p>测试提交</p>
<h1 id="认证方式"><a class="header" href="#认证方式">认证方式</a></h1>
<ul>
<li>HTTP BASIC 认证头（基于IETF RFC的标准）</li>
<li>HTTP Digest 认证头（基于IETF RFC的标准）</li>
<li>HTTP X.509 客户端证书交换（基于IETF RFC的标准）</li>
<li>LDAP（一种非常常见的跨平台身份验证需求，特别是在大型环境中）</li>
<li>基于表单的身份验证（用于简单的用户界面需求）</li>
<li>OpenID 身份验证</li>
<li>基于预先建立的请求头的验证（例如Computer Associates Siteminder）</li>
<li>Jasig Central Authentication Service，也称为CAS，这是一个流行的开源单点登录系统</li>
<li>远程方法调用（RMI）和HttpInvoker（Spring远程协议）的透明认证上下文传播</li>
<li>自动“remember-me”身份验证（所以您可以勾选一个框，以避免在预定时间段内重新验证）</li>
<li>匿名身份验证（允许每个未经身份验证的调用，来自动承担特定的安全身份）</li>
<li>Run-as 身份验证（如果一个调用应使用不同的安全身份继续运行，这是有用的）</li>
<li>Java认证和授权服务（Java Authentication and Authorization Service，JAAS）</li>
<li>Java EE 容器认证（因此，如果需要，仍然可以使用容器管理身份验证）</li>
<li>Kerberos</li>
<li>Java Open Source Single Sign-On（JOSSO）*</li>
<li>OpenNMS Network Management Platform *</li>
<li>AppFuse *</li>
<li>AndroMDA *</li>
<li>Mule ESB *</li>
<li>Direct Web Request （DWR）*</li>
<li>Grails *</li>
<li>Tapestry *</li>
<li>JTrac *</li>
<li>Jasypt *</li>
<li>Roller *</li>
<li>Elastic Path *</li>
<li>Atlassian人群*</li>
<li>自己创建的认证系统</li>
</ul>
<p>（其中加*是指由第三方提供，Spring Security 来集成）</p>
<h1 id="授权方式"><a class="header" href="#授权方式">授权方式</a></h1>
<p>Spring Security提供了一组深入的授权功能。有三个主要领域：</p>
<ul>
<li>对 Web 请求进行授权</li>
<li>授权某个方法是否可以被调用</li>
<li>授权访问单个领域对象实例</li>
</ul>
<h1 id="spring-security-的安装"><a class="header" href="#spring-security-的安装">Spring Security 的安装</a></h1>
<h2 id="最小化依赖"><a class="header" href="#最小化依赖">最小化依赖</a></h2>
<p><strong>maven</strong></p>
<pre><code class="language-xml">&lt;dependencies&gt;
    ......
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
        &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;
        &lt;version&gt;4.2.2.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
        &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;
        &lt;version&gt;4.2.2.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    ......
&lt;/dependencies&gt;
</code></pre>
<p><strong>Gradle</strong></p>
<pre><code class="language-java">dependencies {
     ......
    compile 'org.springframework.security:spring-security-web:4.2.2.RELEASE'
    compile 'org.springframework.security:spring-security-config:4.2.2.RELEASE'
    ......
}
</code></pre>
<h1 id="模块"><a class="header" href="#模块">模块</a></h1>
<p>自 Spring 3 开始，Spring Security 将代码划分到不同的 jar 中，这使得不同的功能模块和第三方依赖显得更加清晰。</p>
<h2 id="core---spring-security-corejar"><a class="header" href="#core---spring-security-corejar">Core - spring-security-core.jar</a></h2>
<ul>
<li>
<p>包含核心的 authentication 和 authorization 的类和接口、远程支持和基础配置API。</p>
</li>
<li>
<p>任何使用 Spring Security 的应用都需要引入这个 jar。支持本地应用、远程客户端、方法级别的安全和 JDBC 用户配置。主要包含的顶级包为为：</p>
</li>
</ul>
<ul>
<li><code>org.springframework.security.core</code>：核心</li>
<li><code>org.springframework.security.access</code>：访问，即 authorization 的作用</li>
<li><code>org.springframework.security.authentication</code>：认证</li>
<li><code>org.springframework.security.provisioning</code>：配置</li>
</ul>
<h2 id="remoting---spring-security-remotingjar"><a class="header" href="#remoting---spring-security-remotingjar">Remoting - spring-security-remoting.jar</a></h2>
<p>提供与 Spring Remoting 整合的支持，你并不需要这个除非你需要使用 Spring Remoting 写一个远程客户端。主包为： <code>org.springframework.security.remoting</code></p>
<h2 id="web---spring-security-webjar"><a class="header" href="#web---spring-security-webjar">Web - spring-security-web.jar</a></h2>
<p>包含 filter 和相关 Web安全的基础代码。如果我们需要使用 Spring Security 进行 Web 安全认证和基于URL的访问控制。主包为： <code>org.springframework.security.web</code></p>
<h2 id="config---spring-security-configjar"><a class="header" href="#config---spring-security-configjar">Config - spring-security-config.jar</a></h2>
<p>包含安全命名空间解析代码和 Java 配置代码。 如果您使用 Spring Security XML 命名空间进行配置或 Spring Security 的 Java 配置支持，则需要它。 主包为： <code>org.springframework.security.config</code>。我们不应该在代码中直接使用这个jar中的类。</p>
<h2 id="ldap---spring-security-ldapjar"><a class="header" href="#ldap---spring-security-ldapjar">LDAP - spring-security-ldap.jar</a></h2>
<p>LDAP 认证和配置代码。如果你需要进行 LDAP 认证或者管理 LDAP 用户实体。顶级包为： <code>org.springframework.security.ldap</code></p>
<h2 id="acl---spring-security-acljar"><a class="header" href="#acl---spring-security-acljar">ACL - spring-security-acl.jar</a></h2>
<p>特定领域对象的ACL(访问控制列表)实现。使用其可以对特定对象的实例进行一些安全配置。顶级包为： <code>org.springframework.security.acls</code></p>
<h2 id="cas---spring-security-casjar"><a class="header" href="#cas---spring-security-casjar">CAS - spring-security-cas.jar</a></h2>
<p>Spring Security CAS 客户端集成。如果你需要使用一个单点登录服务器进行 Spring Security Web 安全认证，需要引入。顶级包为： <code>org.springframework.security.cas</code></p>
<h2 id="openid---spring-security-openidjar"><a class="header" href="#openid---spring-security-openidjar">OpenID - spring-security-openid.jar</a></h2>
<p>OpenId Web 认证支持。基于一个外部 OpenId 服务器对用户进行验证。顶级包为： <code>org.springframework.security.openid</code>，需要使用 OpenID4Java.</p>
<p>一般情况下，<code>spring-security-core</code>和<code>spring-security-config</code>都会引入，在 Web 开发中，我们通常还会引入<code>spring-security-web</code>。</p>
<h2 id="test---spring-security-testjar"><a class="header" href="#test---spring-security-testjar">Test - spring-security-test.jar</a></h2>
<p>用于测试 Spring Security。在开发环境中，我们通常需要添加该包。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="springsecurity核心注解"><a class="header" href="#springsecurity核心注解">SpringSecurity核心注解</a></h1>
<h2 id="enablewebsecurity"><a class="header" href="#enablewebsecurity">@EnableWebSecurity</a></h2>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import({ WebSecurityConfiguration.class, SpringWebMvcImportSelector.class, OAuth2ImportSelector.class,
      HttpSecurityConfiguration.class })
@EnableGlobalAuthentication
@Configuration
public @interface EnableWebSecurity {

   /**
    * Controls debugging support for Spring Security. Default is false.
    * @return if true, enables debug support with Spring Security
    */
   boolean debug() default false;

}
</code></pre>
<p>从注解源码可以看到，该注解有如下作用：</p>
<ol>
<li>控制Spring Security是否使用调试模式(通过注解属性debug指定)，默认为false，表示缺省不使用调试模式。</li>
<li>导入 WebSecurityConfiguration，用于配置Web安全过滤器FilterChainProxy，并创建过滤器链springSecurityFilterChain来保护你的Spring应用。
<ol>
<li>如果是Servlet 环境，导入WebMvcSecurityConfiguration。</li>
<li>如果是OAuth2环境（spring-security-oauth2-client），导入OAuth2ClientConfiguration。</li>
<li>使用注解@EnableGlobalAuthentication启用全局认证机制，即全局的AuthenticationManager，AuthenticationManager会在运行时对请求着进行身份验证。</li>
</ol>
</li>
</ol>
<h2 id="enableglobalauthentication"><a class="header" href="#enableglobalauthentication">@EnableGlobalAuthentication</a></h2>
<ul>
<li>通过启用认证管理器（AuthenticationManager）来启用全局认证机制，核心逻辑就在AuthenticationConfiguration类里</li>
</ul>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(AuthenticationConfiguration.class)
@Configuration
public @interface EnableGlobalAuthentication {

}
</code></pre>
<h2 id="enableglobalmethodsecurity"><a class="header" href="#enableglobalmethodsecurity">@EnableGlobalMethodSecurity</a></h2>
<p>Spring Security默认是禁用注解的，要想开启注解，需要在继承WebSecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解，来判断用户对某个控制层的方法是否具有访问权限。</p>
<p>还可以在@EnableGlobalMethodSecurity中添加几个属性。</p>
<ul>
<li>@EnableGlobalMethodSecurity(securedEnabled=true)开启@Secured 注解过滤权限。</li>
<li>@EnableGlobalMethodSecurity(jsr250Enabled=true)开启@RolesAllowed 注解过滤权限 。</li>
<li>@EnableGlobalMethodSecurity(prePostEnabled=true)使用表达式时间方法级别的安全性 4个注解可用。
<ul>
<li>@PreAuthorize 在方法调用之前,基于表达式的计算结果来限制对方法的访问</li>
<li>@PostAuthorize 允许方法调用,但是如果表达式计算结果为false,将抛出一个安全性异常</li>
<li>@PostFilter 允许方法调用,但必须按照表达式来过滤方法的结果</li>
<li>@PreFilter 允许方法调用,但必须在进入方法之前过滤输入值</li>
</ul>
</li>
</ul>
<h1 id="springsecurity核心组件"><a class="header" href="#springsecurity核心组件">SpringSecurity核心组件</a></h1>
<p>在SpringSecurity中，有着许多的组件包括AuthenticationManager、AccessDesicionManager和UsernamePasswordAuthenticationFilter等。</p>
<p>对于SpringSecurity来说，最大的两个问题就是：<strong>认证（Authentication）和授权（Authorization）</strong>。SpringSecurity框架旨在将认证从授权中剥离出来，并也有适用于二者的策略和可扩展的设计。</p>
<h2 id="认证"><a class="header" href="#认证">认证</a></h2>
<pre><code class="language-java">public interface AuthenticationManager {
  Authentication authenticate(Authentication authentication)
    throws AuthenticationException;
}
</code></pre>
<p><em>AuthenticationManger</em>最普遍的实现类是 <em>ProviderManager</em>，而 <em>ProviderManager</em> 会将认证委托给 <em>AuthenticationProvider</em>。</p>
<p><em>AuthenticationProvider</em>接口和<em>AuthenticationManager</em>相似，但是它有一个额外的方法允许查询它支持的<em>Authentication</em>方式：</p>
<pre><code class="language-java">public interface AuthenticationProvider {
	Authentication authenticate(Authentication authentication)
			throws AuthenticationException;

	boolean supports(Class&lt;?&gt; authentication);
}
</code></pre>
<h2 id="授权"><a class="header" href="#授权">授权</a></h2>
<p>旦认证成功，我们就可以进行授权了，它核心的策略就是AccessDecisionManager。同样的，它将授权逻辑全部委托给AccessDecisionVoter来实现。</p>
<p>一个AccessDecisionVoter考虑一个Authentication（代表一个Principal）和一个被ConfigAttributes装饰的安全对象，这里的ConfigAttributes就是一个包含了URL以及这个URL该有权限的对象的集合。</p>
<pre><code class="language-java">boolean supports(ConfigAttribute attribute);

boolean supports(Class&lt;?&gt; clazz);

int vote(Authentication authentication, S object,
        Collection&lt;ConfigAttribute&gt; attributes);
</code></pre>
<h1 id="springsecurity中的filter"><a class="header" href="#springsecurity中的filter">SpringSecurity中的Filter</a></h1>
<p>除了认证和授权外，SpringSecurity的另外一个核心就是Servlet的Filter来实现的。先简单回顾下Servlet中Filter的调用原理。 下图展示了处理单个</p>
<h2 id="servlet调用原理"><a class="header" href="#servlet调用原理"><strong>Servlet调用原理</strong></a></h2>
<p><img src="13.spring_SpringSecurity/../images/servlet_filter.png" alt="" /></p>
<h2 id="filterchainproxy以及其内部的filter"><a class="header" href="#filterchainproxy以及其内部的filter">FilterChainProxy以及其内部的Filter</a></h2>
<p>SpringSecurity在过滤器链中扮演的就是一个Filter，其类型是FilterChainProxy。但它又不是一个普通的Filter，因为FilterChainProxy中包含了额外的过滤器，每个过滤器都发挥特殊的作用。下面用一张图展示下FliterChainProxy中包含的过滤器链。</p>
<p><img src="13.spring_SpringSecurity/../images/springSecurity_filterChain.png" alt="" /></p>
<p>SpringSecurity的FilterChainProxy是以bean的形式注入到Spring容器中的，并且它是默认配置，所以在每次请求中都会存在，所以在SpringSecurity保护的应用中，每次请求都会经过FilterChainProxy。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1-spring-webflux"><a class="header" href="#1-spring-webflux">1. Spring WebFlux</a></h2>
<p>Spring WebFlux 是 5.0 之后加入的，它支持完全的 非阻塞、支持  <a href="https://www.reactive-streams.org/">Reactive Streams</a>  背压、可以运行在 Netty、Undertow、以及 Servlet3.1+以上的 容器</p>
<p><a href="https://github.com/spring-projects/spring-framework/tree/main/spring-webmvc">spring-webmvc</a> and  <a href="https://github.com/spring-projects/spring-framework/tree/main/spring-webflux">spring-webflux</a> 在 spring框架中并存、都是可选的、也可以都选，例如：使用 Spring MVC controllers 和 reactive WebClient</p>
<h3 id="11-overview"><a class="header" href="#11-overview">1.1. Overview</a></h3>
<p>Why was Spring WebFlux created?</p>
<ol>
<li>非阻塞 web端  使用小部分线程 处理并发，能够以更小的硬件资源为代价 实现扩展 这部分的需求，Servlet3.1提供了非阻塞的API，但是使用它违背 rest 风格的Servlet API，这就是  需要一个  通用API 作为 任何非阻塞运行时的底层 </li>
<li>另一个原因是 函数式编程：它 让非阻塞应用 和 流API 能够以 声明式的方式组合异步逻辑</li>
</ol>
<h4 id="111-define-reactive"><a class="header" href="#111-define-reactive">1.1.1. Define “Reactive”</a></h4>
<p>我们提到 非阻塞、函数式。响应式是什么意思呢?</p>
<p>术语，<code>reactive</code> 引用自 编程模型 。围绕对变化的响应而构建：网络组件响应 IO事件、UI控制器 响应鼠标事件，非阻塞是响应式的，因为 我们正处于  一种 针对 操作完成 或  数据可用 进行响应的模型</p>
<p>还有另外一个跟响应式 关联的重要的机制：非阻塞背压，在同步的命令式代码中，阻塞的调用作为 一种自然的背压的形式，让调用者强制等待</p>
<p>在非阻塞代码中，控制事件的速率使得 生产者不会 压倒 目的地，Reactive Streams 是 一个小的规范，处理背压的方式是 让 订阅者 控制 产生元素的速率</p>
<blockquote>
<p>如果一个生产者 没有减速： ReactorStream的机制是 建立一种机制跟边界，决定是否要 缓存、丢弃、或者 失败</p>
</blockquote>
<h4 id="112-reactive-api"><a class="header" href="#112-reactive-api">1.1.2. Reactive API</a></h4>
<p>Reactive Stream 在互操作性上有着 很重要的作用，但是这是 库或者基础设施 组件所需要关注的 地方</p>
<p>对于应用程序来说，用处不是很大。因为它 太低级了。应用程序需要 更高级的 更丰富的API</p>
<p>Spring WebFlux 选用 Reactor 作为响应式框架</p>
<h4 id="113-programming-models"><a class="header" href="#113-programming-models">1.1.3. Programming Models</a></h4>
<p><strong>spring-web</strong> 模块 包含了响应式基础模块，是构建 Spring WebFlux 的基础。包括 </p>
<ul>
<li>HTTP abstractions</li>
<li>Reactive Streams <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-httphandler">adapters</a> for supported servers</li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-codecs">codecs</a></li>
<li>a core <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api"><code>WebHandler</code> API</a> comparable to the Servlet API but with non-blocking contracts</li>
</ul>
<p>在上述基础之上，提供两种基础模型</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-controller">Annotated Controllers</a>: 和Spring-web模块中的 注解一致，SpringMVC 跟 WebFlux 控制器 支持 响应式的 返回值类型（Reactor and RxJava），因此也难以将两者分开，一个显著的区别是：WebFlux 支持 reactive <code>@RequestBody</code>  参数</li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-fn">Functional Endpoints</a>: 基于Lambda、轻量级、函数式编程模型，与基于注解的最大区别是：应用程序 负责从头到尾 的请求处理</li>
</ul>
<h4 id="114-applicability"><a class="header" href="#114-applicability">1.1.4. Applicability</a></h4>
<p>Spring MVC or WebFlux?</p>
<p>两者协同工作，互补</p>
<p><img src="https://docs.spring.io/spring-framework/docs/current/reference/html/images/spring-mvc-and-webflux-venn.png" alt="spring mvc and webflux venn" /></p>
<p>要使用 MVC或者 WebFlux，请考虑以下几点</p>
<ul>
<li>
<p>正在使用MVC、且工作得很好，不用换</p>
</li>
<li>
<p>如果你在对 非阻塞的 响应式web栈 进行技术选型</p>
<ul>
<li>SpringWebFlux提供 servers可选（Netty, Tomcat, Jetty, Undertow, and Servlet 3.1+ containers）</li>
<li>提供编程模式 可选（基于注解的、基于函数式）</li>
<li>提供 响应式库 可选(Reactor, RxJava, or other)</li>
</ul>
</li>
<li>
<p>检查应用程序的依赖：如果有 使用 阻塞式的API（JPA、JDBC）或者网络APIs，最好使用 SpringMVC，从技术上讲，Reactor在单独的线程执行 阻塞调用 是可行的，但没有充分利用非阻塞</p>
</li>
<li>
<p>建议先尝试使用 <em>WebClient</em></p>
</li>
</ul>
<h4 id="115-servers"><a class="header" href="#115-servers">1.1.5. Servers</a></h4>
<p><strong>支持servers</strong></p>
<p>Spring WebFlux 支持 Tomcat、jetty，Servlet3.1+ 容器，同样非Servlet运行环境例如 Netty、Undertow</p>
<p>所有servers 适配于 低级<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-httphandler">common API</a> ，这样 高级 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-programming-models">programming models</a>  能够 跨 serves使用</p>
<p><strong>启停</strong></p>
<p>Spring WebFlux 没有对 启停服务 提供内置支持 但是很容器 从 Spring配置 和 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config">WebFlux infrastructure</a>   中 使用少量代码组装 并运行</p>
<p>Spring Boot has a WebFlux starter  自动完成这些步骤</p>
<p><strong>对Servlet3.1的依赖</strong></p>
<p>Spring MVC 依赖于 Servlet阻塞API  可以让应用程序  直接使用 ServletAPI</p>
<p>Spring WebFlux 依赖 Servlet3.1 非阻塞IO ，在一个较低级别的 适配器中 使用的，不能让应用程序直接使用</p>
<h4 id="116-performance"><a class="header" href="#116-performance">1.1.6. Performance</a></h4>
<p>性能有许多方面，Reactive 和非阻塞 不会 让应用程序运行更快，反而需要更多的工作，略微提供了处理事件。</p>
<p>核心的 收益是 ：以较少的线程和更低的内存 去缩放，使得应用程序在负载下更具弹性</p>
<h4 id="117-configuring"><a class="header" href="#117-configuring"><strong>1.1.7. Configuring</strong></a></h4>
<p>The Spring Framework does not provide support for starting and stopping <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-server-choice">servers</a>. </p>
<p>Spring不提供 servers的启停，配置一个 server的 线程模型你需要 使用 特定server的 配置API或者使用SpringBoot</p>
<p>检查SpringBoot的每个server的 配置选项</p>
<p>可以直接配置 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client-builder">WebClient</a></p>
<h1 id="杂项问题"><a class="header" href="#杂项问题">杂项问题</a></h1>
<h2 id="springboot是如何判断-webflux还是-webmvc还是其他"><a class="header" href="#springboot是如何判断-webflux还是-webmvc还是其他"><strong>springBoot是如何判断 webflux还是 webMVC，还是其他</strong></a></h2>
<h3 id="从-classpath-判断"><a class="header" href="#从-classpath-判断"><strong>从 <em>classPath</em> 判断</strong></a></h3>
<ul>
<li><em>org.springframework.web.reactive.DispatcherHandler</em> 对应 webflux的核心类</li>
<li><em>org.springframework.web.servlet.DispatcherServlet</em> webMVC的核心类</li>
<li><em>org.glassfish.jersey.servlet.ServletContainer</em> jersey的核心类</li>
</ul>
<h3 id="如果三个都存在"><a class="header" href="#如果三个都存在"><strong>如果三个都存在</strong></a></h3>
<ul>
<li>则判断 <em>javax.servlet.Servlet</em> <em>org.springframework.web.context.ConfigurableWebApplicationContext</em> 是否存在类路径</li>
<li>都存在则 使用 <em>SERVLET</em> </li>
</ul>
<pre><code class="language-java">//org.springframework.boot.WebApplicationType#deduceFromClasspath
    static WebApplicationType deduceFromClasspath() {
		if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)
				&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {
			return WebApplicationType.REACTIVE;
		}
		for (String className : SERVLET_INDICATOR_CLASSES) {
			if (!ClassUtils.isPresent(className, null)) {
				return WebApplicationType.NONE;
			}
		}
		return WebApplicationType.SERVLET;
	}
</code></pre>
<h3 id="根据-不同的-webapplicationtype-创建不同的-springcontext"><a class="header" href="#根据-不同的-webapplicationtype-创建不同的-springcontext">根据 不同的 <em>WebApplicationType</em> 创建不同的 <em>SpringContext</em></a></h3>
<pre><code class="language-java">//org.springframework.boot.ApplicationContextFactory
ApplicationContextFactory DEFAULT = (webApplicationType) -&gt; {
   try {
      switch (webApplicationType) {
      case SERVLET:
         return new AnnotationConfigServletWebServerApplicationContext();
      case REACTIVE:
         return new AnnotationConfigReactiveWebServerApplicationContext();
      default:
         return new AnnotationConfigApplicationContext();
      }
   }
   catch (Exception ex) {
      throw new IllegalStateException(&quot;Unable create a default ApplicationContext instance, &quot;
            + &quot;you may need a custom ApplicationContextFactory&quot;, ex);
   }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactive-core"><a class="header" href="#reactive-core">Reactive Core</a></h1>
<p>对于响应式 web应用，spring-web模块 包含以下 几个 基础支持</p>
<ul>
<li>对于服务端请求处理，有两个级别的支持
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-httphandler">HttpHandler</a>: 使用非阻塞IO处理Http请求的基本协定  还有 Reactive Streams back pressure, along with adapters for Reactor Netty, Undertow, Tomcat, Jetty, and any Servlet 3.1+ container.</li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api"><code>WebHandler</code> API</a>: 稍微高一点的API, 用于请求处理的通用 Web API,具体的编程模型 在这个基础上 构建（例如：基于注解、函数式）</li>
</ul>
</li>
<li>对于客户端, <code>ClientHttpConnector</code> 是一个基本的 非阻塞的 执行 Http请求的约定 并且 Reactive Streams back pressure, along with adapters for <a href="https://github.com/reactor/reactor-netty">Reactor Netty</a>, reactive <a href="https://github.com/jetty-project/jetty-reactive-httpclient">Jetty HttpClient</a> and <a href="https://hc.apache.org/">Apache HttpComponents</a>. 
<ul>
<li>更高级的 API： <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client">WebClient</a> 基于 此协定</li>
</ul>
</li>
<li>对于客户端 服务端 都可用的是, <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-codecs">codecs</a> for serialization and deserialization of HTTP request and response content.</li>
</ul>
<h1 id="httphandler"><a class="header" href="#httphandler"><code>HttpHandler</code></a></h1>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/http/server/reactive/HttpHandler.html">HttpHandler</a>  是一个简单的 接口，只有一个方法处理 请求和响应</p>
<p>以下表格 表明支持的 <em>HttpHandler</em></p>
<table><thead><tr><th style="text-align: left">Server name</th><th style="text-align: left">Server API used</th><th style="text-align: left">Reactive Streams support</th></tr></thead><tbody>
<tr><td style="text-align: left">Netty</td><td style="text-align: left">Netty API</td><td style="text-align: left"><a href="https://github.com/reactor/reactor-netty">Reactor Netty</a></td></tr>
<tr><td style="text-align: left">Undertow</td><td style="text-align: left">Undertow API</td><td style="text-align: left">spring-web: Undertow to Reactive Streams bridge</td></tr>
<tr><td style="text-align: left">Tomcat</td><td style="text-align: left">Servlet 3.1 non-blocking I/O; Tomcat API to read and write ByteBuffers vs byte[]</td><td style="text-align: left">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</td></tr>
<tr><td style="text-align: left">Jetty</td><td style="text-align: left">Servlet 3.1 non-blocking I/O; Jetty API to write ByteBuffers vs byte[]</td><td style="text-align: left">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</td></tr>
<tr><td style="text-align: left">Servlet 3.1 container</td><td style="text-align: left">Servlet 3.1 non-blocking I/O</td><td style="text-align: left">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</td></tr>
</tbody></table>
<p>以下表格描述了 依赖以及版本</p>
<table><thead><tr><th style="text-align: left">Server name</th><th style="text-align: left">Group id</th><th style="text-align: left">Artifact name</th></tr></thead><tbody>
<tr><td style="text-align: left">Reactor Netty</td><td style="text-align: left">io.projectreactor.netty</td><td style="text-align: left">reactor-netty</td></tr>
<tr><td style="text-align: left">Undertow</td><td style="text-align: left">io.undertow</td><td style="text-align: left">undertow-core</td></tr>
<tr><td style="text-align: left">Tomcat</td><td style="text-align: left">org.apache.tomcat.embed</td><td style="text-align: left">tomcat-embed-core</td></tr>
<tr><td style="text-align: left">Jetty</td><td style="text-align: left">org.eclipse.jetty</td><td style="text-align: left">jetty-server, jetty-servlet</td></tr>
</tbody></table>
<h2 id="codeexample"><a class="header" href="#codeexample">CodeExample</a></h2>
<h3 id="reactornetty-code"><a class="header" href="#reactornetty-code">ReactorNetty Code</a></h3>
<pre><code class="language-java">HttpHandler handler = ...
ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);
HttpServer.create().host(host).port(port).handle(adapter).bind().block();
</code></pre>
<h3 id="tomcat"><a class="header" href="#tomcat">Tomcat</a></h3>
<pre><code class="language-java">HttpHandler handler = ...
Servlet servlet = new TomcatHttpHandlerAdapter(handler);

Tomcat server = new Tomcat();
File base = new File(System.getProperty(&quot;java.io.tmpdir&quot;));
Context rootContext = server.addContext(&quot;&quot;, base.getAbsolutePath());
Tomcat.addServlet(rootContext, &quot;main&quot;, servlet);
rootContext.addServletMappingDecoded(&quot;/&quot;, &quot;main&quot;);
server.setHost(host);
server.setPort(port);
server.start();
</code></pre>
<h3 id="servlet-31-container"><a class="header" href="#servlet-31-container"><strong>Servlet 3.1+ Container</strong></a></h3>
<p>To deploy as a WAR to any Servlet 3.1+ container, you can extend and include <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/server/adapter/AbstractReactiveWebInitializer.html">AbstractReactiveWebInitializer</a> in the WAR. That class wraps an HttpHandler with ServletHttpHandlerAdapter and registers that as a Servlet.</p>
<h1 id="webhandler"><a class="header" href="#webhandler"><code>WebHandler</code></a></h1>
<h2 id="webhandler作用"><a class="header" href="#webhandler作用">webhandler作用</a></h2>
<p><em>WebHandler</em> 主要是为了 提供  通用 web-APi，通过 多个 <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/server/WebExceptionHandler.html">WebExceptionHandler</a> 多个  <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/server/WebFilter.html"><code>WebFilter</code></a> 和一个  <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/server/WebHandler.html"><code>WebHandler</code></a> 组件</p>
<p>这些链条可以通过  <code>WebHttpHandlerBuilder</code> 中设置 <em>ApplicationContext</em> ，会自动检测 或者 手动注册</p>
<p>HttpHandler主要是为了处理 不同 HttpServer的抽象使用</p>
<p>WebHandler旨在 提供 web应用中 更广泛的使用</p>
<ul>
<li><em>session with attribute</em> </li>
<li><em>request attribute</em></li>
<li>本地化：<em>Resolved <code>Locale</code> or <code>Principal</code> for the request.</em></li>
<li>对表单的解析、缓存、访问</li>
<li>multipart data的抽象</li>
<li>and more..</li>
</ul>
<h2 id="special-bean-types-1"><a class="header" href="#special-bean-types-1">Special bean types</a></h2>
<p>下表列出了 WebHttpHandlerBuilder 能够自动检测容器中的bean类型的列表，或者能够直接注册</p>
<table><thead><tr><th style="text-align: left">Bean name</th><th style="text-align: left">Bean type</th><th style="text-align: left">Count</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><any></td><td style="text-align: left"><code>WebExceptionHandler</code></td><td style="text-align: left">0..N</td><td style="text-align: left">Provide handling for exceptions from the chain of <code>WebFilter</code> instances and the target <code>WebHandler</code>. For more details, see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-exception-handler">Exceptions</a>.</td></tr>
<tr><td style="text-align: left"><any></td><td style="text-align: left"><code>WebFilter</code></td><td style="text-align: left">0..N</td><td style="text-align: left">Apply interception style logic to before and after the rest of the filter chain and the target <code>WebHandler</code>. For more details, see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-filters">Filters</a>.</td></tr>
<tr><td style="text-align: left"><code>webHandler</code></td><td style="text-align: left"><code>WebHandler</code></td><td style="text-align: left">1</td><td style="text-align: left">The handler for the request.</td></tr>
<tr><td style="text-align: left"><code>webSessionManager</code></td><td style="text-align: left"><code>WebSessionManager</code></td><td style="text-align: left">0..1</td><td style="text-align: left">The manager for <code>WebSession</code> instances exposed through a method on <code>ServerWebExchange</code>. <code>DefaultWebSessionManager</code> by default.</td></tr>
<tr><td style="text-align: left"><code>serverCodecConfigurer</code></td><td style="text-align: left"><code>ServerCodecConfigurer</code></td><td style="text-align: left">0..1</td><td style="text-align: left">For access to <code>HttpMessageReader</code> instances for parsing form data and multipart data that is then exposed through methods on <code>ServerWebExchange</code>. <code>ServerCodecConfigurer.create()</code> by default.</td></tr>
<tr><td style="text-align: left"><code>localeContextResolver</code></td><td style="text-align: left"><code>LocaleContextResolver</code></td><td style="text-align: left">0..1</td><td style="text-align: left">The resolver for <code>LocaleContext</code> exposed through a method on <code>ServerWebExchange</code>. <code>AcceptHeaderLocaleContextResolver</code> by default.</td></tr>
<tr><td style="text-align: left"><code>forwardedHeaderTransformer</code></td><td style="text-align: left"><code>ForwardedHeaderTransformer</code></td><td style="text-align: left">0..1</td><td style="text-align: left">For processing forwarded type headers, either by extracting and removing them or by removing them only. Not used by default.</td></tr>
</tbody></table>
<h2 id="form-data-1"><a class="header" href="#form-data-1">Form Data</a></h2>
<p><code>ServerWebExchange</code> 暴露了下面方法 以访问 FormData:</p>
<pre><code class="language-java">Mono&lt;MultiValueMap&lt;String, String&gt;&gt; getFormData();
</code></pre>
<p>The <code>DefaultServerWebExchange</code> uses the configured <code>HttpMessageReader</code> to parse form data (<code>application/x-www-form-urlencoded</code>) into a <code>MultiValueMap</code>.</p>
<p>By default, <code>FormHttpMessageReader</code> is configured for use by the <code>ServerCodecConfigurer</code> bean (see the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api">Web Handler API</a>).</p>
<h2 id="multipart-data"><a class="header" href="#multipart-data">Multipart Data</a></h2>
<p><code>ServerWebExchange</code> exposes the following method for accessing multipart data:</p>
<pre><code class="language-java">Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; getMultipartData();
</code></pre>
<p><strong>默认使用 <em>HttpMessageReader</em></strong></p>
<p>The <code>DefaultServerWebExchange</code> uses the configured <code>HttpMessageReader&lt;MultiValueMap&lt;String, Part&gt;&gt;</code> to parse <code>multipart/form-data</code> content into a <code>MultiValueMap</code>. By default, this is the <code>DefaultPartHttpMessageReader</code>, which does not have any third-party dependencies. </p>
<p><strong>使用SynchronossPartHttpMessageReader</strong></p>
<p>Alternatively, the <code>SynchronossPartHttpMessageReader</code> can be used, which is based on the <a href="https://github.com/synchronoss/nio-multipart">Synchronoss NIO Multipart</a> library. Both are configured through the <code>ServerCodecConfigurer</code> bean (see the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api">Web Handler API</a>).</p>
<p><strong>使用 StreamingFashion</strong></p>
<p>To parse multipart data in streaming fashion, you can use the <code>Flux&lt;Part&gt;</code> returned from an <code>HttpMessageReader&lt;Part&gt;</code> instead. For example, in an annotated controller, use of <code>@RequestPart</code> implies <code>Map</code>-like access to individual parts by name and, hence, requires parsing multipart data in full. By contrast, you can use <code>@RequestBody</code> to decode the content to <code>Flux&lt;Part&gt;</code> without collecting to a <code>MultiValueMap</code>.</p>
<h2 id="forwarded-headers-1"><a class="header" href="#forwarded-headers-1">Forwarded Headers</a></h2>
<p><strong>代理改变服务器信息</strong></p>
<p>由于请求会走代理，host、port、scheme、可能会变。这导致 客户端无法连接正确的服务端</p>
<p><strong>原始信息</strong></p>
<p><a href="https://tools.ietf.org/html/rfc7239">RFC 7239</a>  定义了  <code>Forwarded</code> HTTP header，代理可以提供 原始请求的信息，也有非标准的：including <code>X-Forwarded-Host</code>, <code>X-Forwarded-Port</code>, <code>X-Forwarded-Proto</code>, <code>X-Forwarded-Ssl</code>, and <code>X-Forwarded-Prefix</code>.</p>
<p><strong>将Forwarded 头 替代为 request中信息</strong></p>
<ul>
<li>
<p><code>ForwardedHeaderTransformer</code>  基于 转发的headers 修改 host、port、scheme</p>
</li>
<li>
<p>移除这些转发的头</p>
</li>
<li>
<p>如果申明为 <em>forwardedHeaderTransformer</em> bean 则会自动检测</p>
</li>
</ul>
<p>对于 forwarded headers 这是处于安全问题考虑的，因为 应用程序 无法知道 请求头是被代理添加的还是 被 可疑的客户端</p>
<p>这也就是为什么 一个 边界区域的代理 应配置 移除外部不受信任的转发流量</p>
<p>你可以设置为  <code>removeOnly=true</code> ：这意味着 只删除不适用</p>
<p><strong>向下兼容</strong></p>
<p>从5.1 <em>ForwardedHeaderFilter</em> 已过时，被 <em>ForwardedHeaderTransformer</em> 取代，在 exchange创建之前 以尽早处理  forwarded headers</p>
<p>如果配置了 <em>ForwardedHeaderFilter</em> 会把它拿出来、然后 使用 <em>ForwardedHeaderTransformer</em></p>
<h1 id="filters"><a class="header" href="#filters">Filters</a></h1>
<p>在 WebHandler的API中、使用 <em>WebFilter</em> 应用 拦截器样式逻辑，在 处理链中的 前、后、剩余部分 以及 目标 <em>webHandler</em></p>
<p>当使用  <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config">WebFlux Config</a>, 时 通过 容器自动注册 或者 手动、使用 @Order 注解 或者 实现 Ordered接口 来表明 先后顺序</p>
<p><strong>CORS</strong></p>
<p>Spring WebFlux provides fine-grained support for CORS configuration through annotations on controllers. However, when you use it with Spring Security, </p>
<p>Spring WebFlux 提供了 细粒度的 CORS 配置支持 通过 controllers上的注解</p>
<p>当使用Spring Security 时呢？，我们建议使用 内置的<code>CorsFilter</code>  必须在 Spring Security’s 其他过滤器之前</p>
<p>See the section on <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-cors">CORS</a> and the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/webflux-cors.html#webflux-cors-webfilter">webflux-cors.html</a> for more details.</p>
<h1 id="exceptions-2"><a class="header" href="#exceptions-2">Exceptions</a></h1>
<p>In the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api"><code>WebHandler</code> API</a>, you can use a <code>WebExceptionHandler</code> to handle exceptions from the chain of <code>WebFilter</code> instances and the target <code>WebHandler</code>. When using the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config">WebFlux Config</a>, registering a <code>WebExceptionHandler</code> is as simple as declaring it as a Spring bean and (optionally) expressing precedence by using <code>@Order</code> on the bean declaration or by implementing <code>Ordered</code>.</p>
<p>The following table describes the available <code>WebExceptionHandler</code> implementations:</p>
<table><thead><tr><th style="text-align: left">Exception Handler</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ResponseStatusExceptionHandler</code></td><td style="text-align: left">Provides handling for exceptions of type <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/server/ResponseStatusException.html"><code>ResponseStatusException</code></a> by setting the response to the HTTP status code of the exception.</td></tr>
<tr><td style="text-align: left"><code>WebFluxResponseStatusExceptionHandler</code></td><td style="text-align: left">Extension of <code>ResponseStatusExceptionHandler</code> that can also determine the HTTP status code of a <code>@ResponseStatus</code> annotation on any exception.This handler is declared in the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config">WebFlux Config</a>.</td></tr>
</tbody></table>
<h1 id="codecs"><a class="header" href="#codecs">Codecs</a></h1>
<h2 id="介绍-10"><a class="header" href="#介绍-10">介绍</a></h2>
<p>The <code>spring-web</code> and <code>spring-core</code> 模块提供 序列化与反序列化，从字节码到高级对象之间、通过非阻塞IO、使用Reactive Streams back pressure.</p>
<p>以下是详情</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/core/codec/Encoder.html"><code>Encoder</code></a> and <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/core/codec/Decoder.html"><code>Decoder</code></a> 是独立于 HTTP 对内容进行编码和解码的低级协定</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/http/codec/HttpMessageReader.html"><code>HttpMessageReader</code></a> and <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/http/codec/HttpMessageWriter.html"><code>HttpMessageWriter</code></a> 是编码和解码 HTTP 消息内容的协定</li>
<li>An <code>Encoder</code> can be wrapped with <code>EncoderHttpMessageWriter</code> to adapt it for use in a web application, while a <code>Decoder</code> can be wrapped with <code>DecoderHttpMessageReader</code>.</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/core/io/buffer/DataBuffer.html"><code>DataBuffer</code></a> abstracts different byte buffer representations (e.g. Netty <code>ByteBuf</code>, <code>java.nio.ByteBuffer</code>, etc.) and is what all codecs work on. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#databuffers">Data Buffers and Codecs</a> in the &quot;Spring Core&quot; section for more on this topic.</li>
</ul>
<p><strong>spring默认实现</strong></p>
<p>The <code>spring-core</code> 模块提供 <code>byte[]</code>, <code>ByteBuffer</code>, <code>DataBuffer</code>, <code>Resource</code>, and <code>String</code>  encoder、decoder实现</p>
<p>The <code>spring-web</code> module provides Jackson JSON, Jackson Smile, JAXB2, Protocol Buffers and other encoders and decoders along with web-only HTTP message reader and writer implementations for form data, multipart content, server-sent events, and others.</p>
<p><code>ClientCodecConfigurer</code> and <code>ServerCodecConfigurer</code> are typically used to configure and customize the codecs to use in an application. See the section on configuring <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config-message-codecs">HTTP message codecs</a>.</p>
<h2 id="jackson-json-1"><a class="header" href="#jackson-json-1">Jackson JSON</a></h2>
<p>当 jackson library 存在时  JSON and binary JSON 支持</p>
<p><code>Jackson2Decoder</code> 工作</p>
<ul>
<li>Jackson’s 异步非阻塞的 parser 用于 byte chunks 聚合 成 <code>TokenBuffer</code>，代表一个 JSON Object</li>
<li>每一个 TokenBuffer 传给 ObjectMapper 用来船舰 高等级的对象</li>
<li>When decoding to a multi-value publisher (e.g. <code>Flux</code>), each <code>TokenBuffer</code> is passed to the <code>ObjectMapper</code> as soon as enough bytes are received for a fully formed object. The input content can be a JSON array, or any <a href="https://en.wikipedia.org/wiki/JSON_streaming">line-delimited JSON</a> format such as NDJSON, JSON Lines, or JSON Text Sequences.</li>
</ul>
<p><code>Jackson2Encoder</code> 工作如下:</p>
<ul>
<li>For a single value publisher (e.g. <code>Mono</code>), simply serialize it through the <code>ObjectMapper</code>.</li>
<li>For a multi-value publisher with <code>application/json</code>, by default collect the values with <code>Flux#collectToList()</code> and then serialize the resulting collection.</li>
<li>For a multi-value publisher with a streaming media type such as <code>application/x-ndjson</code> or <code>application/stream+x-jackson-smile</code>, encode, write, and flush each value individually using a <a href="https://en.wikipedia.org/wiki/JSON_streaming">line-delimited JSON</a> format. Other streaming media types may be registered with the encoder.</li>
<li>For SSE the <code>Jackson2Encoder</code> is invoked per event and the output is flushed to ensure delivery without delay.</li>
</ul>
<p><code>Jackson2Encoder</code> and <code>Jackson2Decoder</code> 不支持 <em>string</em></p>
<h2 id="form-data-2"><a class="header" href="#form-data-2">Form Data</a></h2>
<p><code>FormHttpMessageReader</code> and <code>FormHttpMessageWriter</code>  支持 <code>application/x-www-form-urlencoded</code>  的编码与解码</p>
<p>在服务器端，表单内容通常需要在多个位置访问， <code>ServerWebExchange</code> 提供专门的 <code>getFormData()</code>  方法 ，使用 <em>FormHttpMessageReader</em> 解析 重复访问会缓存结果 See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-form-data">Form Data</a> in the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api"><code>WebHandler</code> API</a> section.</p>
<p>一旦调用 <em>getFormData()</em> 那么无法从 request body中 读取原始内容，因此，应用程序应该始终通过 <em>ServerWebExchange</em> 一致的访问 缓存的 form data而不是从 原始请求体读取数据</p>
<h2 id="multipart-1"><a class="header" href="#multipart-1">Multipart</a></h2>
<p><code>MultipartHttpMessageReader</code> and <code>MultipartHttpMessageWriter</code>  支持 编码与解码  <em>multipart/form-data</em> 内容</p>
<p><code>MultipartHttpMessageReader</code>  将实际 解析 Flux&lt;Part&gt; 的工作 交给 另一个 <em>HttpMessageReader</em>，然后简单的 将其收集成 <em>MultiValueMap</em></p>
<p>默认实现为 ：<code>DefaultPartHttpMessageReader</code> ，通过 <em>ServerCodecConfigurer</em> 可以改变，详见：<a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/http/codec/multipart/DefaultPartHttpMessageReader.html">javadoc of <code>DefaultPartHttpMessageReader</code></a></p>
<p>在服务端，可能需要从多个位置访问 multipart， <code>ServerWebExchange</code>提供了 专门的：<code>getMultipartData()</code>  方法，通过 <code>MultipartHttpMessageReader</code>  解析数据，然后缓存，See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-multipart">Multipart Data</a> in the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api"><code>WebHandler</code> API</a> section.</p>
<p>一旦调用<code>getMultipartData()</code> 那么无法再从 request body中 读取原始内容，所以 应该始终使用  <code>getMultipartData()</code> 或者 依赖 <em>SynchronossPartHttpMessageReader</em> ，一次性访问 <code>Flux&lt;Part&gt;</code></p>
<h2 id="limits"><a class="header" href="#limits">Limits</a></h2>
<p><code>Decoder</code> and <code>HttpMessageReader</code> 的实现 了 要么部分 缓存 要么 全部 缓存 输入流。这是可以配置的，限制在内存中缓冲的最大字节数。</p>
<p>在默写情况，缓冲发生 因为 输入被聚合 表示为单个对象，例如：<code>@RequestBody byte[]</code>, <code>x-www-form-urlencoded</code> </p>
<p>缓冲也可能 发生在 流中，拆分输入流时（例如：分割的文本、JOSN对象流），这个限制适用于 一个对象关联的字节数</p>
<p>使用 <code>maxInMemorySize</code> 属性来配置  <code>Decoder</code> or <code>HttpMessageReader</code></p>
<p>在服务端 <code>ServerCodecConfigurer</code> 提供 统一设置所有 codecs的该limit的地方，, see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config-message-codecs">HTTP message codecs</a></p>
<p>在客户端 通过 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client-builder-maxinmemorysize">WebClient.Builder</a>. 配置</p>
<p>对于 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-codecs-multipart">Multipart parsing</a>   <code>maxInMemorySize</code> 属性限制了 非文件 parts的大小、对于文件 它决定 了 文件是否要写入到磁盘。对于写入到磁盘，还有一个额外的参数：<code>maxDiskUsagePerPart</code> 限制 每个 part 使用的磁盘 上限，<code>maxParts</code> 限制了 在一个 multipart 请求中 最多 parts部件总数</p>
<h2 id="streaming"><a class="header" href="#streaming">Streaming</a></h2>
<p>对于 HTTP 流式的响应，例如：（ <code>text/event-stream</code>, <code>application/x-ndjson</code>）</p>
<p>定期发送数据很重要，尽早的可靠的 检测断开的客户端，这样的发送可以只是 * comment-only* 空 SSE 事件 或者 其他 no-op 数据，作为 heartbeat</p>
<h2 id="databuffer"><a class="header" href="#databuffer"><code>DataBuffer</code></a></h2>
<p><code>DataBuffer</code>  在 WebFlux中表示 a byte buffer ，详见： <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#databuffers">Data Buffers and Codecs</a>. </p>
<p>The key point to understand is that on some servers like Netty, byte buffers are pooled and reference counted,</p>
<p>要知道的关键点是：在 Netty等服务器上，byte buffer 是池化 并且引用计算的，当被消费完之后，需要被释放 避免内存泄漏</p>
<p>WebFlux 程序 大体上 不需要 关系这类问题，除非 直接 消费或者产生 data buffers，相反 一般都依赖 codecs 转换 除非创建自定义的 codecs</p>
<p>详见： <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#databuffers">Data Buffers and Codecs</a>, especially the section on <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#databuffers-using">Using DataBuffer</a>.</p>
<h1 id="logging-2"><a class="header" href="#logging-2">Logging</a></h1>
<p><code>DEBUG</code>  ：在 SpringWebFlux中 <code>DEBUG</code>  级别的日志  旨在 紧凑、最小、可读。关注 重要信息 </p>
<p><code>TRACE</code>： 与 <code>DEBUG</code> 遵循一样的原则 但是可以用来调式 任何问题</p>
<h2 id="log-id"><a class="header" href="#log-id">Log Id</a></h2>
<p>在 WebFlux中，一个请求可能跨多个线程，线程ID 记录 特定请求 的日志消息不是很有用。这也是为什么 WebFlux默认使用 <em>request-specific</em> id</p>
<p>在服务端，logID 存储在 <code>ServerWebExchange</code> 属性，<a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/server/ServerWebExchange.html#LOG_ID_ATTRIBUTE"><code>LOG_ID_ATTRIBUTE</code></a></p>
<p><code>ServerWebExchange#getLogPrefix()</code> 获取完整格式化的 ID 前缀</p>
<p>在客户端，logId 存储在<code>ClientRequest</code>   <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/reactive/function/client/ClientRequest.html#LOG_ID_ATTRIBUTE"><code>LOG_ID_ATTRIBUTE</code></a> </p>
<p><code>ClientRequest#logPrefix()</code> 获取完整格式化的 ID 前缀</p>
<h2 id="sensitive-data"><a class="header" href="#sensitive-data">Sensitive Data</a></h2>
<p><code>DEBUG</code> and <code>TRACE</code>  可以记录 敏感信息，这也是为什么表单参数 跟请求头 默认被掩盖，需要显示启用</p>
<p>Java</p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
class MyConfig implements WebFluxConfigurer {

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        configurer.defaultCodecs().enableLoggingRequestDetails(true);
    }
}
</code></pre>
<p>The following example shows how to do so for client-side requests:</p>
<p>Java</p>
<pre><code class="language-java">Consumer&lt;ClientCodecConfigurer&gt; consumer = configurer -&gt;
        configurer.defaultCodecs().enableLoggingRequestDetails(true);

WebClient webClient = WebClient.builder()
        .exchangeStrategies(strategies -&gt; strategies.codecs(consumer))
        .build();
</code></pre>
<h2 id="appenders"><a class="header" href="#appenders">Appenders</a></h2>
<p>日志库 例如 SLF4J and Log4J2  提供异步 日志器 避免阻塞，这也有缺点，比如 可能会 丢失消息，因为没法对日志 入队列，它们最好的选择就是使用 reactive </p>
<h2 id="custom-codecs"><a class="header" href="#custom-codecs">Custom codecs</a></h2>
<p>应用程序 能注册 自定义的 codecs ，以支持 额外的 请求类型，或者 默认codecs 不支持的 特定行为</p>
<p>想 保持跟 首选项对齐的配置</p>
<p>Java</p>
<pre><code class="language-java">WebClient webClient = WebClient.builder()
        .codecs(configurer -&gt; {
                CustomDecoder decoder = new CustomDecoder();
                configurer.customCodecs().registerWithDefaultConfig(decoder);
        })
        .build();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dispatcherhandler"><a class="header" href="#dispatcherhandler">DispatcherHandler</a></h1>
<p>SpringWebFlux 类似于 SpringMVC 围绕 前端 控制器模式，中央 WebHandler ：<em>DispatcherHandler</em> 为请求处理 提供共享算法，实际工作由 其他组件完成</p>
<p><code>DispatcherHandler</code>  从Spring配置中 发现它 所需要的组件</p>
<p>DispatcherHandler 也可以申明为 <em>WebHandler</em> bean名。由  <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/server/adapter/WebHttpHandlerBuilder.html"><code>WebHttpHandlerBuilder</code></a> 发现，这个类是用来 构建 WebHandler的请求处理链</p>
<p>WebFlux的Spring配置 一般包含</p>
<ul>
<li><code>DispatcherHandler</code> with the bean name <code>webHandler</code></li>
<li><code>WebFilter</code> and <code>WebExceptionHandler</code> beans</li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-special-bean-types"><code>DispatcherHandler</code> special beans</a></li>
<li>Others</li>
</ul>
<p>这些配置由 <code>WebHttpHandlerBuilder</code> 去构建 处理链</p>
<p>Java</p>
<pre><code class="language-java">ApplicationContext context = ...
HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context).build();
</code></pre>
<p>返回的 HttpHandler用于 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-httphandler">server adapter</a></p>
<h2 id="special-bean-types-2"><a class="header" href="#special-bean-types-2">Special Bean Types</a></h2>
<p><code>DispatcherHandler</code>  将 请求处理 响应渲染 委托给 特殊bean（指spring管理的对象，并且是实现WebFlux协定）</p>
<p>以下是 <em>DispatcherHandler</em> 会自动检测的bean</p>
<h3 id="handlermapping"><a class="header" href="#handlermapping"><code>HandlerMapping</code></a></h3>
<p>将请求映射到具体的 Handler</p>
<p>映射规则 基于 不同 <em>HandlerMapping</em>的实现</p>
<ul>
<li>annotated controllers</li>
<li>simple URL pattern mappings</li>
<li>and others</li>
</ul>
<p>主要的实现是</p>
<ul>
<li>基于@RequestMapping的   <em>RequestMappingHandlerMapping</em> </li>
<li>函数式端点：<em>RouterFunctionMapping</em></li>
<li>简单的URL匹配：：<em>SimpleUrlHandlerMapping</em></li>
</ul>
<h3 id="handleradapter"><a class="header" href="#handleradapter">HandlerAdapter</a></h3>
<p>帮助 <em>DispatcherHandler</em> 执行 <em>handler</em> </p>
<p>例如：执行基于注解的控制器，需要解析注解：此类的主要目的是隐藏调用 handler细节</p>
<h3 id="handlerresulthandler"><a class="header" href="#handlerresulthandler">HandlerResultHandler</a></h3>
<p>从Handler 调用的结果，并最终确定响应See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-resulthandling">Result Handling</a>.</p>
<h2 id="processing-1"><a class="header" href="#processing-1">Processing</a></h2>
<p><em>DispatcherHandler</em> 按以下方式处理请求</p>
<ul>
<li>每一个  <code>HandlerMapping</code>  会请求去 匹配 handler，使用第一个匹配到的</li>
<li>找到 handler后，<em>HandlerAdapter</em> 会去调用 该 handler，并返回 <code>HandlerResult</code></li>
<li><code>HandlerResultHandler</code>  会处理 <code>HandlerResult</code> 返回值，完成处理过程，要么直接 写数据到响应、要么使用 视图渲染</li>
</ul>
<h2 id="result-handling"><a class="header" href="#result-handling">Result Handling</a></h2>
<p>通过 <code>HandlerAdapter</code> 调用handler的返回值 被封装为 HandlerResult，包含额外上下文，传给第一个 能支持 该result的 <code>HandlerResultHandler</code> </p>
<p>下表是<code>HandlerResultHandler</code>  的实现</p>
<table><thead><tr><th style="text-align: left">Result Handler Type</th><th style="text-align: left">Return Values</th><th style="text-align: left">Default Order</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ResponseEntityResultHandler</code></td><td style="text-align: left"><code>ResponseEntity</code>, typically from <code>@Controller</code> instances.</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left"><code>ServerResponseResultHandler</code></td><td style="text-align: left"><code>ServerResponse</code>, typically from functional endpoints.</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left"><code>ResponseBodyResultHandler</code></td><td style="text-align: left">Handle return values from <code>@ResponseBody</code> methods or <code>@RestController</code> classes.</td><td style="text-align: left">100</td></tr>
<tr><td style="text-align: left"><code>ViewResolutionResultHandler</code></td><td style="text-align: left"><code>CharSequence</code>, <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/reactive/result/view/View.html"><code>View</code></a>, <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/ui/Model.html">Model</a>, <code>Map</code>, <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html">Rendering</a>, or any other <code>Object</code> is treated as a model attribute.See also <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-viewresolution">View Resolution</a>.</td><td style="text-align: left"><code>Integer.MAX_VALUE</code></td></tr>
</tbody></table>
<h2 id="exceptions-3"><a class="header" href="#exceptions-3">Exceptions</a></h2>
<p><code>HandlerResult</code>  提供错误处理 的 函数，基于 handler-specific  机制</p>
<p>错误函数会在以下情况被调用</p>
<ul>
<li>handler处理发生异常</li>
<li>The handling of the handler return value through a <code>HandlerResultHandler</code> fails.</li>
</ul>
<p>error function 可以改变 响应（例如 error status）只要在 从 handler返回的 响应式类型  产生任何数据项 之前 发出错误信号</p>
<p>这也是 为什么 <code>@ExceptionHandler</code>  方法 支持 在 @Controller类中受支持</p>
<p>Spring MVC  也同样支持，基于 <code>HandlerExceptionResolver</code>. </p>
<p>记住：不能使用 <code>@ControllerAdvice</code>  处理异常，因为这发生在 handler 被选中前</p>
<p>See also <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-controller-exceptions">Managing Exceptions</a> in the “Annotated Controller” section or <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-exception-handler">Exceptions</a> in the WebHandler API section.</p>
<h2 id="view-resolution-1"><a class="header" href="#view-resolution-1">View Resolution</a></h2>
<p>视图解析 使得可以 向浏览器 渲染 HTML 模板，无需使用某一个特定的 模板机制</p>
<p>在 SpringWebFlux中，视图解析 是通过 专有 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-resulthandling">HandlerResultHandler</a> ，使用  <code>ViewResolver</code>  实例 将  string 映射成 View实例</p>
<h3 id="handling"><a class="header" href="#handling">Handling</a></h3>
<p>传给 <code>ViewResolutionResultHandler</code> 的 <code>HandlerResult</code>  包含 从 handler 的返回值，包含 在 request handling 中添加进来的 属性的 model，返回值会按以下步骤处理</p>
<ul>
<li><code>String</code>, <code>CharSequence</code>: 逻辑视图页面，通过配置的 <code>ViewResolver</code> 实例 解析成View实例</li>
<li><code>void</code>: 基于request path选择默认页面, 将请求URI，去除前导斜线和后缀斜线, 解析成 <code>View</code>. 如果未提供视图名也会按此逻辑处理(例如：返回ModelAndAttribute) 或者 返回异步值(例如：<code>Mono</code> 为空)</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html">Rendering</a>: 视图解析API</li>
<li><code>Model</code>, <code>Map</code>: 添加到 model中的额外 model attributes</li>
<li>Any other: 任何其他返回值 (除了简单属性，依据<a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>) 被当作 属性 被添加进 Model当作 ，属性名 使用 <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/core/Conventions.html">conventions</a> 从 类名中取，除非 有<code>@ModelAttribute</code> 注解</li>
</ul>
<p>The model 可以包含 异步 响应式 类型，</p>
<p>在渲染之前<code>AbstractView</code>  将 model attributes 解析成 具体的值，并更新模型，单值响应式类型被解析成单值或无值，多值会被解析成<code>List&lt;T&gt;</code></p>
<p>配置视图解析 <code>ViewResolutionResultHandler</code> 添加到Spring配置中</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config-view-resolvers">WebFlux Config</a> 提供专门的视图解析配置API</p>
<h2 id="redirecting"><a class="header" href="#redirecting">Redirecting</a></h2>
<p>在 视图名的 特殊<code>redirect:</code> 前缀可以 重定向</p>
<p><code>UrlBasedViewResolver</code> （及其子类） 可以识别，余下的是重定向的URL</p>
<p>效果跟 controller返回 <em>RedirectView</em> 或者 <code>Rendering.redirectTo(&quot;abc&quot;).build()</code></p>
<p>但控制器本身可以 按逻辑视图名操作</p>
<p>视图名 如<code>redirect:/some/resource</code> ，相当于当前 应用的重定向</p>
<p><code>redirect:https://example.com/arbitrary/path</code> 绝对路径的重定向</p>
<h2 id="content-negotiation"><a class="header" href="#content-negotiation">Content Negotiation</a></h2>
<p><code>ViewResolutionResultHandler</code> 支持内容协商.</p>
<p>它比较 请求的媒体类型 和 每一个 视图支持的媒体类型 ，第一个支持的 被选中</p>
<p>为了支持 JSON XML媒体类型 SpringWebFlux 提供了 <em>HttpMessageWriterView</em> ，这是一个特殊的视图，通过  <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-codecs">HttpMessageWriter</a>.  渲染</p>
<p>一般来说，你可以通过<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config-view-resolvers">WebFlux Configuration</a>  配置 这些作为 默认视图</p>
<p>默认视图 如果支持请求的媒体类型，它总是第一个被选中</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-endpoints"><a class="header" href="#functional-endpoints">Functional Endpoints</a></h1>
<p>Spring WebFlux 包含 WebFlux.fn，轻量级的函数式编程模型，函数 是用来 作 路由 跟 请求处理，协定旨在不可变，是 基于注解的 编程模型的另一个可用的方式</p>
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>在WebFlux.fn中，使用 <code>HandlerFunction</code>处理 HTTP请求，以 <em>ServerRequest</em> 为参数，返回 延迟的 <em>ServerResponse</em> ，例如 <code>Mono&lt;ServerResponse&gt;</code></p>
<ul>
<li>请求跟响应都 有不变的 协定，以 jdk8友好的 方式 访问 请求跟响应</li>
<li><code>HandlerFunction</code> 类似注解中的  <code>@RequestMapping</code> 方法，即将到来的请求通过 <em>RouterFunction</em> 映射到 handler function</li>
<li><code>RouterFunctions.route()</code>  提供 router的构建</li>
</ul>
<pre><code class="language-java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.RequestPredicates.*;
import static org.springframework.web.reactive.function.server.RouterFunctions.route;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; route = route()
    .GET(&quot;/person/{id}&quot;, accept(APPLICATION_JSON), handler::getPerson)
    .GET(&quot;/person&quot;, accept(APPLICATION_JSON), handler::listPeople)
    .POST(&quot;/person&quot;, handler::createPerson)
    .build();

public class PersonHandler {

    // ...

    public Mono&lt;ServerResponse&gt; listPeople(ServerRequest request) {
        // ...
    }

    public Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) {
        // ...
    }

    public Mono&lt;ServerResponse&gt; getPerson(ServerRequest request) {
        // ...
    }
}
</code></pre>
<p>运行 <code>RouterFunction</code> 的一个方法是：将它转换为 <code>HttpHandler</code> ，通过 内置的 server adapters 安装它们</p>
<ul>
<li><code>RouterFunctions.toHttpHandler(RouterFunction)</code></li>
<li><code>RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)</code></li>
</ul>
<h1 id="handlerfunction-1"><a class="header" href="#handlerfunction-1">HandlerFunction</a></h1>
<p><code>ServerRequest</code> and <code>ServerResponse</code>  是不可变接口，提供 jdk8友好访问 HTTP的请求和响应</p>
<p>请求跟响应 都提供了 响应式流  的背压，请求Body被表示为 <code>Flux</code> or <code>Mono</code> 响应被表示为 任何 Reactive Streams <code>Publisher</code></p>
<h2 id="serverrequest-1"><a class="header" href="#serverrequest-1">ServerRequest</a></h2>
<p><code>ServerRequest</code> 提供对 HTTP方法 URI 请求头、查询参数的访问，访问请求体通过  <em>body</em> 方法</p>
<p><strong>body转<code>Mono&lt;String&gt;</code></strong></p>
<pre><code class="language-java">Mono&lt;String&gt; string = request.bodyToMono(String.class);
</code></pre>
<p><strong>Person对象通过 反序列化的方式（JSON或者 XML</strong>）</p>
<pre><code class="language-java">Flux&lt;Person&gt; people = request.bodyToFlux(Person.class);
</code></pre>
<p><strong>提供自定义函数解析</strong></p>
<pre><code class="language-java">Mono&lt;String&gt; string = request.body(BodyExtractors.toMono(String.class));
Flux&lt;Person&gt; people = request.body(BodyExtractors.toFlux(Person.class));
</code></pre>
<p><strong>访问表单格式</strong></p>
<pre><code class="language-java">Mono&lt;MultiValueMap&lt;String, String&gt;&gt; map = request.formData();
</code></pre>
<p><strong>访问multi-part</strong></p>
<pre><code class="language-java">Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; map = request.multipartData();
</code></pre>
<p><strong>响应式流 一次访问一个</strong></p>
<pre><code class="language-java">Flux&lt;Part&gt; parts = request.body(BodyExtractors.toParts());
</code></pre>
<h2 id="serverresponse-1"><a class="header" href="#serverresponse-1">ServerResponse</a></h2>
<p><code>ServerResponse</code>  提供对 HTTP 响应的 访问。因为是不可变的，可以使用 <em>build</em> 构建</p>
<p>可以设置请求状态、请求头、请求体</p>
<pre><code class="language-java">Mono&lt;Person&gt; person = ...
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person, Person.class);
</code></pre>
<p><strong>201（CREATED）with a location</strong></p>
<pre><code class="language-java">URI location = ...
ServerResponse.created(location).build();
</code></pre>
<p><strong>提供 <em>hint</em> 参数以 自定义 body如何序列化如何反序列化</strong></p>
<pre><code class="language-java">ServerResponse.ok().hint(Jackson2CodecSupport.JSON_VIEW_HINT, MyJacksonView.class).body(...);
</code></pre>
<h2 id="handler-classes-1"><a class="header" href="#handler-classes-1">Handler Classes</a></h2>
<p><strong>使用 Lambada表达式定义HandlerFunction</strong></p>
<pre><code class="language-java">HandlerFunction&lt;ServerResponse&gt; helloWorld =
  request -&gt; ServerResponse.ok().bodyValue(&quot;Hello World&quot;);
</code></pre>
<p>如果有多个hander function，可以使用 一个 handler class 将 多个方法组合起来，类似于 controller的作用</p>
<p><strong>使用 Person repository构建响应式流</strong></p>
<pre><code class="language-java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.ServerResponse.ok;

public class PersonHandler {

    private final PersonRepository repository;

    public PersonHandler(PersonRepository repository) {
        this.repository = repository;
    }

    public Mono&lt;ServerResponse&gt; listPeople(ServerRequest request) { 
        Flux&lt;Person&gt; people = repository.allPeople();
        return ok().contentType(APPLICATION_JSON).body(people, Person.class);
    }

    public Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) { 
        Mono&lt;Person&gt; person = request.bodyToMono(Person.class);
        return ok().build(repository.savePerson(person));
    }

    public Mono&lt;ServerResponse&gt; getPerson(ServerRequest request) { 
        int personId = Integer.valueOf(request.pathVariable(&quot;id&quot;));
        return repository.getPerson(personId)
            .flatMap(person -&gt; ok().contentType(APPLICATION_JSON).bodyValue(person))
            .switchIfEmpty(ServerResponse.notFound().build());
    }
}
</code></pre>
<h2 id="validation-1"><a class="header" href="#validation-1">Validation</a></h2>
<p>functional endpoint 可以使用  Spring’s <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation">validation facilities</a>  以校验请求体</p>
<pre><code class="language-java">public class PersonHandler {

    private final Validator validator = new PersonValidator(); 

    // ...

    public Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) {
        Mono&lt;Person&gt; person = request.bodyToMono(Person.class).doOnNext(this::validate); 
        return ok().build(repository.savePerson(person));
    }

    private void validate(Person person) {
        Errors errors = new BeanPropertyBindingResult(person, &quot;person&quot;);
        validator.validate(person, errors);
        if (errors.hasErrors()) {
            throw new ServerWebInputException(errors.toString()); 
        }
    }
}
</code></pre>
<p>Handlers 同样 使用 the standard bean validation API (JSR-303) ，通过 创建注入 全局 <em>Validator</em> 实例，基于<code>LocalValidatorFactoryBean</code>，See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation-beanvalidation">Spring Validation</a></p>
<h1 id="routerfunction-1"><a class="header" href="#routerfunction-1"><code>RouterFunction</code></a></h1>
<p>使用  <code>RouterFunctions</code>工具类 创建 <em>RouterFunction</em>,<code>RouterFunctions.route()</code> 创建 链式构造器，<code>RouterFunctions.route(RequestPredicate, HandlerFunction)</code>直接创建 router</p>
<h2 id="predicates"><a class="header" href="#predicates">Predicates</a></h2>
<p><code>RequestPredicates</code>工具类 提供基于request path, HTTP method, content-type等 常用的实现</p>
<pre><code class="language-java">RouterFunction&lt;ServerResponse&gt; route = RouterFunctions.route()
    .GET(&quot;/hello-world&quot;, accept(MediaType.TEXT_PLAIN),
        request -&gt; ServerResponse.ok().bodyValue(&quot;Hello World&quot;)).build();
</code></pre>
<p>可以组合 多个 request predicates </p>
<ul>
<li><code>RequestPredicate.and(RequestPredicate)</code> — both must match.</li>
<li><code>RequestPredicate.or(RequestPredicate)</code> — either can match.</li>
</ul>
<p>来自 <code>RequestPredicates</code>  大多数 predicates 是组合的</p>
<p>例如：<code>RequestPredicates.GET(String)</code>  组合于 <code>RequestPredicates.method(HttpMethod)</code> <code>RequestPredicates.path(String)</code></p>
<h2 id="routes"><a class="header" href="#routes">Routes</a></h2>
<p>Router functions  按顺序解析的：如果第一个 不匹配 解析第二个，因此 精确的 routes应该在 广泛的 routes 前面</p>
<p>将 RouterFunction 注册为 Spring beans 也是很重要的，与基于注解的 行为不同之处是：最佳匹配是自动计算的，</p>
<p>还有其他组合 多个 router functions的方法</p>
<ul>
<li><code>add(RouterFunction)</code> on the <code>RouterFunctions.route()</code> builder</li>
<li><code>RouterFunction.and(RouterFunction)</code></li>
<li><code>RouterFunction.andRoute(RequestPredicate, HandlerFunction)</code> — shortcut for <code>RouterFunction.and()</code> with nested <code>RouterFunctions.route()</code>.</li>
</ul>
<p><strong>以下案例是 四个routes组合</strong></p>
<pre><code class="language-java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.RequestPredicates.*;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; otherRoute = ...

RouterFunction&lt;ServerResponse&gt; route = route()
    //`GET /person/{id}` with an `Accept` header that matches JSON is routed to `PersonHandler.getPerson`
    .GET(&quot;/person/{id}&quot;, accept(APPLICATION_JSON), handler::getPerson) 
    //GET /person` with an `Accept` header that matches JSON is routed to `PersonHandler.listPeople
    .GET(&quot;/person&quot;, accept(APPLICATION_JSON), handler::listPeople) 
    //POST /person` with no additional predicates is mapped to `PersonHandler.createPerson
    .POST(&quot;/person&quot;, handler::createPerson) 
    //`otherRoute` is a router function that is created elsewhere, and added to the route built.
    .add(otherRoute) 
    .build();
</code></pre>
<h2 id="nested-routes-1"><a class="header" href="#nested-routes-1">Nested Routes</a></h2>
<p>一组 functions共享 一个predicate，例如 共享前缀</p>
<p>在上述例子中 就是 共享 <code>/person</code> 路径</p>
<p>当使用注解时，使用 <code>@RequestMapping</code>  注解在 类上来共享 <code>/person</code> 路径</p>
<p>在 WebFlux.fn  path predicates  可以 通过 router function  构造器共享</p>
<pre><code class="language-java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path(&quot;/person&quot;, builder -&gt; builder 
        .GET(&quot;/{id}&quot;, accept(APPLICATION_JSON), handler::getPerson)
        .GET(accept(APPLICATION_JSON), handler::listPeople)
        .POST(&quot;/person&quot;, handler::createPerson))
    .build();
</code></pre>
<p>嵌套路由 表示外层的 predicate 在内层是共享的</p>
<p>基于 路径的嵌套式很普遍的  可以使用  <code>builder#nest</code> 方法</p>
<pre><code class="language-java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path(&quot;/person&quot;, b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET(&quot;/{id}&quot;, handler::getPerson)
            .GET(handler::listPeople))
        .POST(&quot;/person&quot;, handler::createPerson))
    .build();
</code></pre>
<h2 id="running-a-server-1"><a class="header" href="#running-a-server-1">Running a Server</a></h2>
<p>如何使用 router function 运行HTTP服务器，一个简单的 方法是 将 一个 router function 转换成 http handler</p>
<ul>
<li><code>RouterFunctions.toHttpHandler(RouterFunction)</code></li>
<li><code>RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)</code></li>
</ul>
<p>将 返回的   <code>HttpHandler</code> 与 一系列 server adapters 配合使用，在SpringBooter中 使用 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-dispatcher-handler"><code>DispatcherHandler</code></a> ，它使用spring 配置化 声明 需要的组件</p>
<p>WebFlux Java configuration 声明了 以下基础设施组件</p>
<ul>
<li><code>RouterFunctionMapping</code>: 检测 <code>RouterFunction&lt;?&gt;</code>  bean对象， <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-ordered">orders them</a>, 通过<code>RouterFunction.andOther</code> 组合</li>
<li><code>HandlerFunctionAdapter</code>:  让  <code>DispatcherHandler</code>  执行 <code>HandlerFunction</code>  的简单适配器 </li>
<li><code>ServerResponseResultHandler</code>: 处理返回结果</li>
</ul>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Bean
    public RouterFunction&lt;?&gt; routerFunctionA() {
        // ...
    }

    @Bean
    public RouterFunction&lt;?&gt; routerFunctionB() {
        // ...
    }

    // ...

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        // configure message conversion...
    }

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // configure CORS...
    }

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        // configure view resolution for HTML rendering...
    }
}
</code></pre>
<h1 id="filtering-handler-functions-1"><a class="header" href="#filtering-handler-functions-1">Filtering Handler Functions</a></h1>
<p>可以在 builder 上使用  <code>before</code>, <code>after</code>, or <code>filter</code> 创建过滤器</p>
<p>也可以使用注解<code>@ControllerAdvice</code>、 <code>ServletFilter</code> 这些过滤器会 应用于所有 路由</p>
<pre><code class="language-java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path(&quot;/person&quot;, b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET(&quot;/{id}&quot;, handler::getPerson)
            .GET(handler::listPeople)
            .before(request -&gt; ServerRequest.from(request) 
                .header(&quot;X-RequestHeader&quot;, &quot;Value&quot;)
                .build()))
        .POST(&quot;/person&quot;, handler::createPerson))
    .after((request, response) -&gt; logResponse(response)) 
    .build();
</code></pre>
<p><code>before</code>过滤器 只应用于 两个 GET routes</p>
<p><code>after</code> 过滤器 应用于所有 路由</p>
<pre><code class="language-java">SecurityManager securityManager = ...

RouterFunction&lt;ServerResponse&gt; route = route()
    .path(&quot;/person&quot;, b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET(&quot;/{id}&quot;, handler::getPerson)
            .GET(handler::listPeople))
        .POST(&quot;/person&quot;, handler::createPerson))
    .filter((request, next) -&gt; {
        if (securityManager.allowAccessTo(request.path())) {
            return next.handle(request);
        }
        else {
            return ServerResponse.status(UNAUTHORIZED).build();
        }
    })
    .build();
</code></pre>
<p>Besides using the <code>filter</code> method on the router function builder, it is possible to apply a filter to an existing router function via <code>RouterFunction.filter(HandlerFilterFunction)</code>.</p>
<p>除了 在 builder上 时使用 过滤器方法，可以在已存在的  router function上应用 过滤器 通过 <code>RouterFunction.filter(HandlerFilterFunction)</code></p>
<p>通过  <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/webflux-cors.html#webflux-cors-webfilter"><code>CorsWebFilter</code></a> 支持 CORS</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uri-links"><a class="header" href="#uri-links">URI Links</a></h1>
<p>此章节讨论 在Spring中 创建 URI s的方式</p>
<h1 id="uricomponents-1"><a class="header" href="#uricomponents-1">UriComponents</a></h1>
<p><code>UriComponentsBuilder</code>  从模板变量 构建 URI</p>
<pre><code class="language-java">UriComponents uriComponents = UriComponentsBuilder
        .fromUriString(&quot;https://example.com/hotels/{hotel}&quot;)  
        .queryParam(&quot;q&quot;, &quot;{q}&quot;)  
        .encode() 
        .build(); 

URI uri = uriComponents.expand(&quot;Westin&quot;, &quot;123&quot;).toUri();  
</code></pre>
<p><strong>简化</strong></p>
<pre><code class="language-java">URI uri = UriComponentsBuilder
        .fromUriString(&quot;https://example.com/hotels/{hotel}&quot;)
        .queryParam(&quot;q&quot;, &quot;{q}&quot;)
        .encode()
        .buildAndExpand(&quot;Westin&quot;, &quot;123&quot;)
        .toUri();
</code></pre>
<p><strong>简化1</strong></p>
<pre><code class="language-java">URI uri = UriComponentsBuilder
        .fromUriString(&quot;https://example.com/hotels/{hotel}&quot;)
        .queryParam(&quot;q&quot;, &quot;{q}&quot;)
        .build(&quot;Westin&quot;, &quot;123&quot;);
</code></pre>
<p><strong>简化2</strong></p>
<pre><code class="language-java">URI uri = UriComponentsBuilder
        .fromUriString(&quot;https://example.com/hotels/{hotel}?q={q}&quot;)
        .build(&quot;Westin&quot;, &quot;123&quot;);
</code></pre>
<h1 id="uribuilder-1"><a class="header" href="#uribuilder-1">UriBuilder</a></h1>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#web-uricomponents"><code>UriComponentsBuilder</code></a>  实现 <code>UriBuilder</code> ，通过 <code>UriBuilderFactory</code> 创建 <code>UriBuilder</code>，可以创建共享的配置（baseURL、encoding preference）</p>
<p>可以使用 <code>UriBuilderFactory</code> 配置 <em>RestTemplate</em> 和 <em>WebClient</em> </p>
<p><code>DefaultUriBuilderFactory</code> 是 <em>UriBuilderFactory</em> 的默认实现 </p>
<p><strong>configure a <code>RestTemplate</code>:</strong></p>
<pre><code class="language-java">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;

String baseUrl = &quot;https://example.org&quot;;
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

RestTemplate restTemplate = new RestTemplate();
restTemplate.setUriTemplateHandler(factory);
</code></pre>
<p><strong><code>WebClient</code></strong></p>
<pre><code class="language-java">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;

String baseUrl = &quot;https://example.org&quot;;
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

WebClient client = WebClient.builder().uriBuilderFactory(factory).build();
</code></pre>
<p><strong>直接使用 uriBuilderFactory</strong></p>
<pre><code class="language-java">String baseUrl = &quot;https://example.com&quot;;
DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl);

URI uri = uriBuilderFactory.uriString(&quot;/hotels/{hotel}&quot;)
        .queryParam(&quot;q&quot;, &quot;{q}&quot;)
        .build(&quot;Westin&quot;, &quot;123&quot;);
</code></pre>
<h1 id="uri-encoding-1"><a class="header" href="#uri-encoding-1">URI Encoding</a></h1>
<p><code>UriComponentsBuilder</code> exposes encoding options at two levels:</p>
<p><code>UriComponentsBuilder</code> 有两个级别的 encoding options </p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html#encode--">UriComponentsBuilder#encode()</a>: 编码 URI template 然后 严格对 URI变量进行编码</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">UriComponents#encode()</a>: 不替换关键字</li>
</ul>
<p>这两个选项 使用 转义的八进制 替换 非ASCII 和非法字符 ，第一个选项会 替换 变量中的关键字</p>
<pre><code class="language-java">URI uri = UriComponentsBuilder.fromPath(&quot;/hotel list/{city}&quot;)
        .queryParam(&quot;q&quot;, &quot;{q}&quot;)
        .encode()
        .buildAndExpand(&quot;New York&quot;, &quot;foo+bar&quot;)
        .toUri();

// Result is &quot;/hotel%20list/New%20York?q=foo%2Bbar&quot;
</code></pre>
<pre><code class="language-java">URI uri = UriComponentsBuilder.fromPath(&quot;/hotel list/{city}&quot;)
        .queryParam(&quot;q&quot;, &quot;{q}&quot;)
        .build(&quot;New York&quot;, &quot;foo+bar&quot;);
</code></pre>
<pre><code class="language-java">URI uri = UriComponentsBuilder.fromUriString(&quot;/hotel list/{city}?q={q}&quot;)
        .build(&quot;New York&quot;, &quot;foo+bar&quot;);
</code></pre>
<pre><code class="language-java">String baseUrl = &quot;https://example.com&quot;;
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl)
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

// Customize the RestTemplate..
RestTemplate restTemplate = new RestTemplate();
restTemplate.setUriTemplateHandler(factory);

// Customize the WebClient..
WebClient client = WebClient.builder().uriBuilderFactory(factory).build();
</code></pre>
<p>The <code>DefaultUriBuilderFactory</code> implementation uses <code>UriComponentsBuilder</code> internally to expand and encode URI templates. As a factory, it provides a single place to configure the approach to encoding, based on one of the below encoding modes:</p>
<ul>
<li><code>TEMPLATE_AND_VALUES</code>: Uses <code>UriComponentsBuilder#encode()</code>, corresponding to the first option in the earlier list, to pre-encode the URI template and strictly encode URI variables when expanded.</li>
<li><code>VALUES_ONLY</code>: Does not encode the URI template and, instead, applies strict encoding to URI variables through <code>UriUtils#encodeUriVariables</code> prior to expanding them into the template.</li>
<li><code>URI_COMPONENT</code>: Uses <code>UriComponents#encode()</code>, corresponding to the second option in the earlier list, to encode URI component value <em>after</em> URI variables are expanded.</li>
<li><code>NONE</code>: No encoding is applied.</li>
</ul>
<p>The <code>RestTemplate</code> is set to <code>EncodingMode.URI_COMPONENT</code> for historic reasons and for backwards compatibility. The <code>WebClient</code> relies on the default value in <code>DefaultUriBuilderFactory</code>, which was changed from <code>EncodingMode.URI_COMPONENT</code> in 5.0.x to <code>EncodingMode.TEMPLATE_AND_VALUES</code> in 5.1.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webflux-config"><a class="header" href="#webflux-config">WebFlux Config</a></h1>
<p>使用 <code>@EnableWebFlux</code>  注解启用 WebFlux</p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig {
}
</code></pre>
<p>以上例子注册了一系列 的 SpringWebFlux <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-special-bean-types">infrastructure beans</a> ，自动应用 可用的依赖：JSON、XML</p>
<h1 id="webflux-config-api"><a class="header" href="#webflux-config-api">WebFlux config API</a></h1>
<p>实现<code>WebFluxConfigurer</code> 去配置</p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {
    // Implement configuration methods...
}
</code></pre>
<h2 id="conversion-formatting"><a class="header" href="#conversion-formatting">Conversion, formatting</a></h2>
<p>默认情况下，各种数据类型的 格式化都已安装。也支持字段的 <code>@NumberFormat</code> <code>@DateTimeFormat</code></p>
<p><strong>注册Formatter</strong></p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {
    @Override
    public void addFormatters(FormatterRegistry registry) {
        // ...
    }
}
</code></pre>
<p>默认情况下，Spring WebFlux 在解析或格式化日期格式 考虑 到 request Locale</p>
<p>自定义日期时间格式化</p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void addFormatters(FormatterRegistry registry) {
        DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
        registrar.setUseIsoFormat(true);
        registrar.registerFormatters(registry);
    }
}
</code></pre>
<p>当使用 <code>FormatterRegistrar</code>  时，详见 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#format-FormatterRegistrar-SPI"><code>FormatterRegistrar</code> SPI</a>   以及 <code>FormattingConversionServiceFactoryBean</code></p>
<h2 id="validation-2"><a class="header" href="#validation-2">Validation</a></h2>
<p>默认情况下：如果 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation-beanvalidation-overview">Bean Validation</a>  在 类路径上（例如：the Hibernate Validator），<code>LocalValidatorFactoryBean</code>  会注册为 全局 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validator">validator</a> 供 @Controller方法参数上的  <code>@Valid</code> and <code>@Validated</code>  使用</p>
<p><strong>可以自定义 Validator实例</strong></p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public Validator getValidator(); {
        // ...
    }

}
</code></pre>
<p><strong>应用本地<code>Validator</code></strong></p>
<pre><code class="language-java">@Controller
public class MyController {

    @InitBinder
    protected void initBinder(WebDataBinder binder) {
        binder.addValidators(new FooValidator());
    }
}
</code></pre>
<p>如果需要<code>LocalValidatorFactoryBean</code>  注入，创建一个 bean 使用 <code>@Primary</code>  标注，避免 在 MVC config 中冲突</p>
<h2 id="content-type-resolvers"><a class="header" href="#content-type-resolvers">Content Type Resolvers</a></h2>
<p>可以配置 Spring WebFlux如何 判断 请求的 媒体类型</p>
<p>默认情况下，会检查 <code>Accept</code> 头，但是你可以 启用 基于 查询参数的 策略</p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {
        // ...
    }
}
</code></pre>
<h2 id="http-message-codecs"><a class="header" href="#http-message-codecs">HTTP message codecs</a></h2>
<p><strong>自定义 request 和 response body 被读写</strong></p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        configurer.defaultCodecs().maxInMemorySize(512 * 1024);
    }
}
</code></pre>
<p><code>ServerCodecConfigurer</code> 提供默认的 读写器，可以添加，自定义修改默认的配置，对于</p>
<p>For Jackson JSON and XML, consider using <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.html"><code>Jackson2ObjectMapperBuilder</code></a>, which customizes Jackson’s default properties with the following ones:</p>
<ul>
<li><a href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES"><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code></a> is disabled.</li>
<li><a href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION"><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code></a> is disabled.</li>
</ul>
<p>It also automatically registers the following well-known modules if they are detected on the classpath:</p>
<ul>
<li><a href="https://github.com/FasterXML/jackson-datatype-joda"><code>jackson-datatype-joda</code></a>: Support for Joda-Time types.</li>
<li><a href="https://github.com/FasterXML/jackson-datatype-jsr310"><code>jackson-datatype-jsr310</code></a>: Support for Java 8 Date and Time API types.</li>
<li><a href="https://github.com/FasterXML/jackson-datatype-jdk8"><code>jackson-datatype-jdk8</code></a>: Support for other Java 8 types, such as <code>Optional</code>.</li>
<li><a href="https://github.com/FasterXML/jackson-module-kotlin"><code>jackson-module-kotlin</code></a>: Support for Kotlin classes and data classes.</li>
</ul>
<h2 id="view-resolvers"><a class="header" href="#view-resolvers">View Resolvers</a></h2>
<p><strong>视图解析</strong></p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        // ...
    }
}
</code></pre>
<p>The <code>ViewResolverRegistry</code>  有配置模板库的快捷方式</p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {


    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.freeMarker();
    }

    // Configure Freemarker...

    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath(&quot;classpath:/templates&quot;);
        return configurer;
    }
}
</code></pre>
<p>配置自定义的视图</p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {


    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        ViewResolver resolver = ... ;
        registry.viewResolver(resolver);
    }
}
</code></pre>
<p>为了支持 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-multiple-representations">Content Negotiation</a>  ，渲染除了 HTML的 其他格式，可以配置多个基于 <code>HttpMessageWriterView</code>的默认视图，它从 <code>spring-web</code> 中接收多种可用的  <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-codecs">Codecs</a> </p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.freeMarker();
        Jackson2JsonEncoder encoder = new Jackson2JsonEncoder();
        registry.defaultViews(new HttpMessageWriterView(encoder));
    }
    // ...
}
</code></pre>
<h2 id="static-resources"><a class="header" href="#static-resources">Static Resources</a></h2>
<p>基于location的 静态资源服务的便捷方法，下面例子中，<code>/resources</code> 使用相对路径查找静态资源，相对于 <em>classPath</em> 下,资源在一年到期，以确保浏览器缓存的最大使用 和减少HTTP请求次数，<code>Last-Modified</code> 请求头 会校验，如果存在则返回304</p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(&quot;/resources/**&quot;)
            .addResourceLocations(&quot;/public&quot;, &quot;classpath:/static/&quot;)
            .setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));
    }

}
</code></pre>
<p>资源处理器 同样支持 <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/reactive/resource/ResourceResolver.html"><code>ResourceResolver</code></a> 与  <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/reactive/resource/ResourceTransformer.html"><code>ResourceTransformer</code></a>  链式处理</p>
<p>可以 使用<code>VersionResourceResolver</code> ， 对版本化资源，可以使用 资源内容的MD5、固定应用程序版本等</p>
<p><code>ContentVersionStrategy</code> (基于内容的MD5) 是一个好的选择，但是有一个明显的缺点（无法处理，使用 module loader的 js）</p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(&quot;/resources/**&quot;)
                .addResourceLocations(&quot;/public/&quot;)
                .resourceChain(true)
                .addResolver(new VersionResourceResolver().addContentVersionStrategy(&quot;/**&quot;));
    }
}
</code></pre>
<p>You can use <code>ResourceUrlProvider</code> to rewrite URLs and apply the full chain of resolvers and transformers (for example, to insert versions). The WebFlux configuration provides a <code>ResourceUrlProvider</code> so that it can be injected into others.</p>
<p>Unlike Spring MVC, at present, in WebFlux, there is no way to transparently rewrite static resource URLs, since there are no view technologies that can make use of a non-blocking chain of resolvers and transformers. When serving only local resources, the workaround is to use <code>ResourceUrlProvider</code> directly (for example, through a custom element) and block.</p>
<p>Note that, when using both <code>EncodedResourceResolver</code> (for example, Gzip, Brotli encoded) and <code>VersionedResourceResolver</code>, they must be registered in that order, to ensure content-based versions are always computed reliably based on the unencoded file.</p>
<p><a href="https://www.webjars.org/documentation">WebJars</a> are also supported through the <code>WebJarsResourceResolver</code> which is automatically registered when the <code>org.webjars:webjars-locator-core</code> library is present on the classpath. The resolver can re-write URLs to include the version of the jar and can also match against incoming URLs without versions — for example, from <code>/jquery/jquery.min.js</code> to <code>/jquery/1.2.0/jquery.min.js</code>.</p>
<h2 id="path-matching"><a class="header" href="#path-matching">Path Matching</a></h2>
<p><strong>自定义路径匹配</strong></p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) {
        configurer
            .setUseCaseSensitiveMatch(true)
            .setUseTrailingSlashMatch(false)
            .addPathPrefix(&quot;/api&quot;,
                    HandlerTypePredicate.forAnnotation(RestController.class));
    }
}
</code></pre>
<h2 id="websocketservice"><a class="header" href="#websocketservice">WebSocketService</a></h2>
<p>WebFlux 定义了 WebSocketHandlerAdapter  提供对 WebSocket handlers 的支持，意味着所有，要处理网络套接字握手请求，所有做的是将 <code>WebSocketHandler</code>  映射到 URL 通过 <code>SimpleUrlHandlerMapping</code></p>
<pre><code class="language-java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public WebSocketService getWebSocketService() {
        TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy();
        strategy.setMaxSessionIdleTimeout(0L);
        return new HandshakeWebSocketService(strategy);
    }
}
</code></pre>
<h2 id="advanced-configuration-mode"><a class="header" href="#advanced-configuration-mode">Advanced Configuration Mode</a></h2>
<p><code>@EnableWebFlux</code> imports <code>DelegatingWebFluxConfiguration</code> that:</p>
<ul>
<li>Provides default Spring configuration for WebFlux applications</li>
<li>detects and delegates to <code>WebFluxConfigurer</code> implementations to customize that configuration.</li>
</ul>
<p><strong>继承DelegatingWebFluxConfiguration</strong></p>
<pre><code class="language-java">@Configuration
public class WebConfig extends DelegatingWebFluxConfiguration {
    // ...
}
</code></pre>
<h2 id="http2"><a class="header" href="#http2">HTTP/2</a></h2>
<p>HTTP/2 is supported with Reactor Netty, Tomcat, Jetty, and Undertow. However, there are considerations related to server configuration. For more details, see the <a href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP/2 wiki page</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>静态资源处理</li>
<li></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="annotated-controllers"><a class="header" href="#annotated-controllers">Annotated Controllers</a></h1>
<p>Spring WebFlux 提供 基于注解的编程模型，使用<code>@Controller</code> and <code>@RestController</code>  组件表示 请求映射、请求输入、处理异常以及其他，基于注解的控制器 方法申明很灵活，没必要继承 基类或者实现接口</p>
<p>Java</p>
<pre><code class="language-java">@RestController
public class HelloController {

    @GetMapping(&quot;/hello&quot;)
    public String handle() {
        return &quot;Hello WebFlux&quot;;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="handler-methods-1"><a class="header" href="#handler-methods-1">Handler Methods</a></h2>
<p><code>@RequestMapping</code>  的handler 方法 可以有 灵活的 申明</p>
<h3 id="method-arguments-1"><a class="header" href="#method-arguments-1">Method Arguments</a></h3>
<p>Reactive types 支持 需要 阻塞IO才能解析的 参数（例如 读请求体），这会在 Description 列中标记</p>
<p>Reactive types 不应该 期望 不需要 阻塞的 参数</p>
<p>JDK 1.8’s <code>java.util.Optional</code>  支持 方法参数 上的注解  <code>required</code> 属性，并设置为<code>required=false</code></p>
<table><thead><tr><th style="text-align: left">Controller method argument</th><th style="text-align: left">Description</th><th></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ServerWebExchange</code></td><td style="text-align: left">Access to the full <code>ServerWebExchange</code> — container for the HTTP request and response, request and session attributes, <code>checkNotModified</code> methods, and others.</td><td></td></tr>
<tr><td style="text-align: left"><code>ServerHttpRequest</code>, <code>ServerHttpResponse</code></td><td style="text-align: left">Access to the HTTP request or response.</td><td></td></tr>
<tr><td style="text-align: left"><code>WebSession</code></td><td style="text-align: left">Access to the session. This does not force the start of a new session unless attributes are added. Supports reactive types.</td><td></td></tr>
<tr><td style="text-align: left"><code>java.security.Principal</code></td><td style="text-align: left">The currently authenticated user — possibly a specific <code>Principal</code> implementation class if known. Supports reactive types.</td><td></td></tr>
<tr><td style="text-align: left"><code>org.springframework.http.HttpMethod</code></td><td style="text-align: left">The HTTP method of the request.</td><td></td></tr>
<tr><td style="text-align: left"><code>java.util.Locale</code></td><td style="text-align: left">The current request locale, determined by the most specific <code>LocaleResolver</code> available — in effect, the configured <code>LocaleResolver</code>/<code>LocaleContextResolver</code>.</td><td></td></tr>
<tr><td style="text-align: left"><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></td><td style="text-align: left">The time zone associated with the current request, as determined by a <code>LocaleContextResolver</code>.</td><td></td></tr>
<tr><td style="text-align: left"><code>@PathVariable</code></td><td style="text-align: left">For access to URI template variables. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-requestmapping-uri-templates">URI Patterns</a>.</td><td></td></tr>
<tr><td style="text-align: left"><code>@MatrixVariable</code></td><td style="text-align: left">For access to name-value pairs in URI path segments. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-matrix-variables">Matrix Variables</a>.</td><td></td></tr>
<tr><td style="text-align: left"><code>@RequestParam</code></td><td style="text-align: left">For access to Servlet request parameters. Parameter values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-requestparam"><code>@RequestParam</code></a>.Note that use of <code>@RequestParam</code> is optional — for example, to set its attributes. See “Any other argument” later in this table.</td><td></td></tr>
<tr><td style="text-align: left"><code>@RequestHeader</code></td><td style="text-align: left">For access to request headers. Header values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-requestheader"><code>@RequestHeader</code></a>.</td><td></td></tr>
<tr><td style="text-align: left"><code>@CookieValue</code></td><td style="text-align: left">For access to cookies. Cookie values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-cookievalue"><code>@CookieValue</code></a>.</td><td></td></tr>
<tr><td style="text-align: left"><code>@RequestBody</code></td><td style="text-align: left">For access to the HTTP request body. Body content is converted to the declared method argument type by using <code>HttpMessageReader</code> instances. Supports reactive types. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-requestbody"><code>@RequestBody</code></a>.</td><td></td></tr>
<tr><td style="text-align: left"><code>HttpEntity&lt;B&gt;</code></td><td style="text-align: left">For access to request headers and body. The body is converted with <code>HttpMessageReader</code> instances. Supports reactive types. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-httpentity"><code>HttpEntity</code></a>.</td><td></td></tr>
<tr><td style="text-align: left"><code>@RequestPart</code></td><td style="text-align: left">For access to a part in a <code>multipart/form-data</code> request. Supports reactive types. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-multipart-forms">Multipart Content</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-multipart">Multipart Data</a>.</td><td></td></tr>
<tr><td style="text-align: left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, and <code>org.springframework.ui.ModelMap</code>.</td><td style="text-align: left">For access to the model that is used in HTML controllers and is exposed to templates as part of view rendering.</td><td></td></tr>
<tr><td style="text-align: left"><code>@ModelAttribute</code></td><td style="text-align: left">For access to an existing attribute in the model (instantiated if not present) with data binding and validation applied. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-modelattrib-method-args"><code>@ModelAttribute</code></a> as well as <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-modelattrib-methods"><code>Model</code></a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-initbinder"><code>DataBinder</code></a>.Note that use of <code>@ModelAttribute</code> is optional — for example, to set its attributes. See “Any other argument” later in this table.</td><td></td></tr>
<tr><td style="text-align: left"><code>Errors</code>, <code>BindingResult</code></td><td style="text-align: left">For access to errors from validation and data binding for a command object, i.e. a <code>@ModelAttribute</code> argument. An <code>Errors</code>, or <code>BindingResult</code> argument must be declared immediately after the validated method argument.</td><td></td></tr>
<tr><td style="text-align: left"><code>SessionStatus</code> + class-level <code>@SessionAttributes</code></td><td style="text-align: left">For marking form processing complete, which triggers cleanup of session attributes declared through a class-level <code>@SessionAttributes</code> annotation. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a> for more details.</td><td></td></tr>
<tr><td style="text-align: left"><code>UriComponentsBuilder</code></td><td style="text-align: left">For preparing a URL relative to the current request’s host, port, scheme, and context path. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-uri-building">URI Links</a>.</td><td></td></tr>
<tr><td style="text-align: left"><code>@SessionAttribute</code></td><td style="text-align: left">For access to any session attribute — in contrast to model attributes stored in the session as a result of a class-level <code>@SessionAttributes</code> declaration. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-sessionattribute"><code>@SessionAttribute</code></a> for more details.</td><td></td></tr>
<tr><td style="text-align: left"><code>@RequestAttribute</code></td><td style="text-align: left">For access to request attributes. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-requestattrib"><code>@RequestAttribute</code></a> for more details.</td><td></td></tr>
<tr><td style="text-align: left">Any other argument</td><td style="text-align: left">If a method argument is not matched to any of the above, it is, by default, resolved as a <code>@RequestParam</code> if it is a simple type, as determined by <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>, or as a <code>@ModelAttribute</code>, otherwise.</td><td></td></tr>
</tbody></table>
<h3 id="return-values"><a class="header" href="#return-values">Return Values</a></h3>
<p>返回值支持的类型</p>
<table><thead><tr><th style="text-align: left">Controller method return value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>@ResponseBody</code></td><td style="text-align: left">使用 <em>HttpMessageWriter</em> 实例 编码，并写入到响应，详见：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-responsebody"><code>@ResponseBody</code></a></td></tr>
<tr><td style="text-align: left"><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></td><td style="text-align: left">包括 Http头,请求体使用<code>HttpMessageWriter</code> 实例 编码，并写入到响应，详见 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-responseentity"><code>ResponseEntity</code></a>.</td></tr>
<tr><td style="text-align: left"><code>HttpHeaders</code></td><td style="text-align: left">只返回头，不返回响应</td></tr>
<tr><td style="text-align: left"><code>String</code></td><td style="text-align: left">使用  <code>ViewResolver</code>  解析的 视图名</td></tr>
<tr><td style="text-align: left"><code>View</code></td><td style="text-align: left">视图实例</td></tr>
<tr><td style="text-align: left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></td><td style="text-align: left">要添加到  隐式模型中的属性</td></tr>
<tr><td style="text-align: left"><code>@ModelAttribute</code></td><td style="text-align: left">要添加到 隐式 模型中的属性</td></tr>
<tr><td style="text-align: left"><code>Rendering</code></td><td style="text-align: left">An API for model and view rendering scenarios.</td></tr>
<tr><td style="text-align: left"><code>void</code></td><td style="text-align: left">返回 Void的方法 可能是 异步的（eg： <code>Mono&lt;Void&gt;</code>）， 返回值类型（可能是 null返回值）<br />1. 被认为是 已经将 响应 处理完成 ，如果有一个 <code>ServerHttpResponse</code>, a <code>ServerWebExchange</code>  参数<br />2. 或者存在  <code>@ResponseStatus</code> 注解<br />3. 如果 controller 对 <em>ETag</em> <em>lastModified timestamp</em> 进行 检查</td></tr>
<tr><td style="text-align: left"><code>Flux&lt;ServerSentEvent&gt;</code>, <code>Observable&lt;ServerSentEvent&gt;</code>, or other reactive type</td><td style="text-align: left">Emit server-sent events. The <code>ServerSentEvent</code> wrapper can be omitted when only data needs to be written (however, <code>text/event-stream</code> must be requested or declared in the mapping through the <code>produces</code> attribute).</td></tr>
<tr><td style="text-align: left">Any other return value</td><td style="text-align: left">如果以上返回值都不匹配，如果是空的或者 是Sting 则默认的作为视图名 or 否则会加入到 Model中作为 attributes,触发 它是简单类型 依据<a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a></td></tr>
</tbody></table>
<h3 id="type-conversion-1"><a class="header" href="#type-conversion-1">Type Conversion</a></h3>
<p>基于 string的请求输入 的 注解控制器方法参数 （例如：<code>@RequestParam</code>，<code>@RequestHeader</code>，<code>@PathVariable</code>, <code>@MatrixVariable</code>, and <code>@CookieValue</code>）</p>
<p>需要类型转换，会自动进行类型转换，基于 配置的 converters</p>
<p>通过 自定义 <code>WebDataBinder</code> 配置类型转换(see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-initbinder"><code>DataBinder</code></a>) ，或者 使用<code>FormattingConversionService</code>  注册 <code>Formatters</code> </p>
<h3 id="matrix-variables-1"><a class="header" href="#matrix-variables-1">Matrix Variables</a></h3>
<p><a href="https://tools.ietf.org/html/rfc3986#section-3.3">RFC 3986</a> discusses name-value pairs in path segments</p>
<p>In Spring WebFlux, 我们把它叫做：<em>matrix variables</em> based on an <a href="https://www.w3.org/DesignIssues/MatrixURIs.html">“old post”</a> by Tim Berners-Lee </p>
<p>但它们也可以称为 URI 路劲参数，Matrix variables 可以出现在任何 路径参数中，每一个变量被 分号分隔，多值用逗号分隔，也可以重复变量名</p>
<pre><code>`&quot;/cars;color=red,green;year=2012&quot;` `&quot;color=red;color=green;color=blue&quot;`
</code></pre>
<p>跟SpringMVC 不一样的是：matrix variables 不会影响请求映射</p>
<pre><code class="language-java">// GET /pets/42;q=11;r=22

@GetMapping(&quot;/pets/{petId}&quot;)
public void findPet(@PathVariable String petId, @MatrixVariable int q) {

    // petId == 42
    // q == 11
}
</code></pre>
<p>每一个路径片段都可以有 matrix variable,这时候需要消除歧义</p>
<pre><code class="language-java">// GET /owners/42;q=11/pets/21;q=22

@GetMapping(&quot;/owners/{ownerId}/pets/{petId}&quot;)
public void findPet(
        @MatrixVariable(name=&quot;q&quot;, pathVar=&quot;ownerId&quot;) int q1,
        @MatrixVariable(name=&quot;q&quot;, pathVar=&quot;petId&quot;) int q2) {

    // q1 == 11
    // q2 == 22
}
</code></pre>
<p><strong>默认值</strong></p>
<pre><code class="language-java">// GET /pets/42

@GetMapping(&quot;/pets/{petId}&quot;)
public void findPet(@MatrixVariable(required=false, defaultValue=&quot;1&quot;) int q) {

    // q == 1
}
</code></pre>
<p><strong>获取某个 路径片段的所有 matrix variable</strong></p>
<pre><code class="language-java">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

@GetMapping(&quot;/owners/{ownerId}/pets/{petId}&quot;)
public void findPet(
        @MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,
        @MatrixVariable(pathVar=&quot;petId&quot;) MultiValueMap&lt;String, String&gt; petMatrixVars) {

    // matrixVars: [&quot;q&quot; : [11,22], &quot;r&quot; : 12, &quot;s&quot; : 23]
    // petMatrixVars: [&quot;q&quot; : 22, &quot;s&quot; : 23]
}
</code></pre>
<h3 id="requestparam-1"><a class="header" href="#requestparam-1">@RequestParam</a></h3>
<p>使用 <code>@RequestParam</code>  注解绑定 查询参数</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/pets&quot;)
public class EditPetForm {
    // ...
    @GetMapping
    public String setupForm(@RequestParam(&quot;petId&quot;) int petId, Model model) { 
        Pet pet = this.clinic.loadPet(petId);
        model.addAttribute(&quot;pet&quot;, pet);
        return &quot;petForm&quot;;
    }
}
</code></pre>
<p>The Servlet API <code>request parameter</code> 概念 将 查询参数、表单、multiparts  合成一个，在 WebFlux中，每一个是通过 <code>ServerWebExchange</code> 独立访问的</p>
<p><code>@RequestParam</code> 只绑定 查询参数，你可以使用数据绑定 将 查询参数、表单、multiparts 绑定到 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-modelattrib-method-args">command object</a>.</p>
<p>使用 <code>@RequestParam</code>  注解的方法参数 默认是 必须，支持 <code>java.util.Optional</code>  wrapper</p>
<p>会自动应用类型转换，See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-typeconversion">Type Conversion</a>.</p>
<p>当 <code>@RequestParam</code>  注解声明在 <code>Map&lt;String, String&gt;</code> or <code>MultiValueMap&lt;String, String&gt;</code>  参数上</p>
<p>map会填充所有 查询参数</p>
<p>注意：<code>@RequestParam</code>   是可选的，例如：为了设置它的属性。</p>
<p>默认的，任何参数，且是一个 简单值类型、依据<a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>  不被任何参数解析器 解析，会被当做 使用了 <code>@RequestParam</code>一样</p>
<h3 id="requestheader-1"><a class="header" href="#requestheader-1">@RequestHeader</a></h3>
<p>在控制器中  使用 <code>@RequestHeader</code> 可以绑定 请求头</p>
<pre><code>Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300
</code></pre>
<p>获取<code>Accept-Encoding</code> <code>Keep-Alive</code> </p>
<pre><code class="language-java">@GetMapping(&quot;/demo&quot;)
public void handle(
        @RequestHeader(&quot;Accept-Encoding&quot;) String encoding, 
        @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) { 
    //...
}
</code></pre>
<ul>
<li>会自动应用类型转换，See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-typeconversion">Type Conversion</a>.</li>
<li><code>@RequestHeader</code> 注解在 <code>Map&lt;String, String&gt;</code>, <code>MultiValueMap&lt;String, String&gt;</code>, or <code>HttpHeaders</code>  上，那么会填充所有 header</li>
</ul>
<p>例如 <code>@RequestHeader(&quot;Accept&quot;)</code> 可以注解在 <code>String</code>、<code>List&lt;String&gt;</code>、 <code>String[]</code> </p>
<h3 id="cookievalue-1"><a class="header" href="#cookievalue-1">@CookieValue</a></h3>
<p>使用  <code>@CookieValue</code>  绑定 HTTP cookie到 参数方法上</p>
<pre><code>JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84
</code></pre>
<pre><code class="language-java">@GetMapping(&quot;/demo&quot;)
public void handle(@CookieValue(&quot;JSESSIONID&quot;) String cookie) { 
    //...
}
</code></pre>
<p>自动应用类型转换 See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-typeconversion">Type Conversion</a></p>
<h3 id="modelattribute-1"><a class="header" href="#modelattribute-1">@ModelAttribute</a></h3>
<p>在参数方法上 使用 <code>@ModelAttribute</code> 注解 ，对 model的属性访问，如果它不在的话 实例化它</p>
<p>The model attribute 同样也和 查询参数、表单字段重叠</p>
<p>这称为 数据绑定、使你避免 处理 解析、转换单独的查询参数以及表单字段</p>
<pre><code class="language-java">@PostMapping(&quot;/owners/{ownerId}/pets/{petId}/edit&quot;)
public String processSubmit(@ModelAttribute Pet pet) { } 
</code></pre>
<p><code>Pet</code> 实例 会按以下方式解析</p>
<ul>
<li>从已添加到 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-modelattrib-methods"><code>Model</code></a>  的属性</li>
<li>来自 HTTP session  通过<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a></li>
<li>从默认构造器的调用</li>
<li>来自 <em>primary constructor</em> 的调用，带着 匹配 查询参数或表单字段的 参数</li>
<li>参数名 通过 JavaBean的 <em>@ConstructorProperties</em> 判断，或者通过 字节码中 运行时的 参数名保留</li>
</ul>
<p>获取到 model attribute  的实例后，开始应用数据绑定，<code>WebExchangeDataBinder</code> 类在目标对象上 匹配 查询参数和表单字段名</p>
<p>匹配字段会在 类型转换后 填充,对于校验 详见： <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation">Validation</a>，对于 自定义数据绑定，详见：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-initbinder"><code>DataBinder</code></a>.</p>
<p>数据绑定会造成错误，默认情况下，<code>WebExchangeBindException</code> 会被抛出，但是为了在控制器方法 检查异常，可以在  <code>@ModelAttribute</code> 下一个参数中声明  <code>BindingResult</code> 0</p>
<pre><code class="language-java">@PostMapping(&quot;/owners/{ownerId}/pets/{petId}/edit&quot;)
public String processSubmit(@ModelAttribute(&quot;pet&quot;) Pet pet, BindingResult result) { 
    if (result.hasErrors()) {
        return &quot;petForm&quot;;
    }
    // ...
}
</code></pre>
<p>可以通过 添加  <code>javax.validation.Valid</code>   或者 spring的注解<code>@Validated</code>  注解 在数据绑定后 自动应用 校验，详见  (see also <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation-beanvalidation">Bean Validation</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation">Spring validation</a>)</p>
<pre><code class="language-java">@PostMapping(&quot;/owners/{ownerId}/pets/{petId}/edit&quot;)
public String processSubmit(@Valid @ModelAttribute(&quot;pet&quot;) Pet pet, BindingResult result) { 
    if (result.hasErrors()) {
        return &quot;petForm&quot;;
    }
    // ...
}
</code></pre>
<p>Spring WebFlux 支持 在 model中的 响应式类型  例如：<code>Mono&lt;Account&gt;</code> ，可以声明 存在或不存在 响应式类型的包装类的 <code>@ModelAttribute</code> 注解的参数</p>
<p>如果使用 <code>BindingResult</code>  参数，必须 声明<code>@ModelAttribute</code>  是非响应式的</p>
<p>Java</p>
<pre><code class="language-java">@PostMapping(&quot;/owners/{ownerId}/pets/{petId}/edit&quot;)
public Mono&lt;String&gt; processSubmit(@Valid @ModelAttribute(&quot;pet&quot;) Mono&lt;Pet&gt; petMono) {
    return petMono
        .flatMap(pet -&gt; {
            // ...
        })
        .onErrorResume(ex -&gt; {
            // ...
        });
}
</code></pre>
<h3 id="sessionattributes-1"><a class="header" href="#sessionattributes-1">@SessionAttributes</a></h3>
<p><code>@SessionAttributes</code> 是用来在 请求间 保存 model属性的，将属性存储在 <code>WebSession</code>，这是个类级别的注解，声明在某个控制器中，这通常列出model属性的 名称 或者模型属性的  类型，它们被透明的 存储在 <em>session</em> 中以供下次请求使用</p>
<p>Java</p>
<pre><code class="language-java">@Controller
@SessionAttributes(&quot;pet&quot;) 
public class EditPetForm {
    // ...
}
</code></pre>
<p>在第一次请求中，模型属性 <code>pet</code> 会被添加到 模型中、自动保存在 <code>WebSession</code>，它保持直到 另一个控制器 方法 使用 <code>SessionStatus</code>  方法参数来 清除存储</p>
<pre><code class="language-java">@Controller
@SessionAttributes(&quot;pet&quot;) 
public class EditPetForm {

    // ...

    @PostMapping(&quot;/pets/{id}&quot;)
    public String handle(Pet pet, BindingResult errors, SessionStatus status) { 
        if (errors.hasErrors()) {
            // ...
        }
            status.setComplete();
            // ...
        }
    }
}
</code></pre>
<h3 id="sessionattribute-1"><a class="header" href="#sessionattribute-1">@SessionAttribute</a></h3>
<p>如果想访问 预先存在的 session 属性（由全局管理），可以使用 <code>@SessionAttribute</code>  属性管理</p>
<pre><code class="language-java">@GetMapping(&quot;/&quot;)
public String handle(@SessionAttribute User user) { 
    // ...
}
</code></pre>
<p>如果想添加 或者删除session属性，注入WebSession 到方法参数中</p>
<h3 id="requestattribute-1"><a class="header" href="#requestattribute-1">@RequestAttribute</a></h3>
<p>使用 <code>@RequestAttribute</code>  访问 request attirbutes 中的属性</p>
<pre><code class="language-java">@GetMapping(&quot;/&quot;)
public String handle(@RequestAttribute Client client) { 
    // ...
}
</code></pre>
<h3 id="multipart-content"><a class="header" href="#multipart-content">Multipart Content</a></h3>
<p>上述提到的 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-multipart">Multipart Data</a>, <code>ServerWebExchange</code>  提供了 对 multipart 内容的访问</p>
<p>在控制器中 最佳的处理文件上传的方式是 通过数据绑定到  <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-modelattrib-method-args">command object</a></p>
<p>Java</p>
<pre><code class="language-java">class MyForm {

    private String name;

    private MultipartFile file;

    // ...

}

@Controller
public class FileUploadController {

    @PostMapping(&quot;/form&quot;)
    public String handleFormUpload(MyForm form, BindingResult errors) {
        // ...
    }

}
</code></pre>
<p>在 RESTFUL 场景 从非浏览器客户端 中提交 multipart 请求</p>
<pre><code>POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name=&quot;meta-data&quot;
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
    &quot;name&quot;: &quot;value&quot;
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name=&quot;file-data&quot;; filename=&quot;file.properties&quot;
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...
</code></pre>
<p>使用 <code>@RequestPart</code> 访问 单独部件</p>
<pre><code class="language-java">@PostMapping(&quot;/&quot;)
public String handle(@RequestPart(&quot;meta-data&quot;) Part metadata, 
        @RequestPart(&quot;file-data&quot;) FilePart file) { 
    // ...
}
</code></pre>
<p>反序列化 原始部件内容（例如：to JSON），你可以申明一个具体的 对象，而不是 <em>Part</em></p>
<p>Java</p>
<pre><code class="language-java">@PostMapping(&quot;/&quot;)
public String handle(@RequestPart(&quot;meta-data&quot;) MetaData metadata) { 
    // ...
}
</code></pre>
<p>你可以将  <code>@RequestPart</code>  与 <code>javax.validation.Valid</code> or Spring’s <code>@Validated</code>  注解组合，这会 引入 Standard Bean Validation </p>
<p>校验报错 会导致 <code>WebExchangeBindException</code>   导致 BAD_REQUEST（400）</p>
<p>异常包含<code>BindingResult</code>  ，可以通过申明为 Mono&lt;MetaData&gt; ，在<code>Mono</code> 中 进行错误的处理</p>
<pre><code class="language-java">@PostMapping(&quot;/&quot;)
public String handle(@Valid @RequestPart(&quot;meta-data&quot;) Mono&lt;MetaData&gt; metadata) {
    // use one of the onError* operators...
}
</code></pre>
<p>声明为 <code>MultiValueMap</code> 可以使用 <code>@RequestBody</code>  以访问所有部件</p>
<pre><code class="language-java">@PostMapping(&quot;/&quot;)
public String handle(@RequestBody Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; parts) { 
    // ...
}
</code></pre>
<p>以流式序列的访问，可以申明 <code>@RequestBody</code>  以及<code>Flux&lt;Part&gt;</code></p>
<pre><code class="language-java">@PostMapping(&quot;/&quot;)
public String handle(@RequestBody Flux&lt;Part&gt; parts) { 
    // ...
}
</code></pre>
<h3 id="requestbody-3"><a class="header" href="#requestbody-3">@RequestBody</a></h3>
<p>使用 <code>@RequestBody</code>  注解 通过 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-codecs">HttpMessageReader</a>.  读取 请求头 反序列化 成 对象</p>
<pre><code class="language-java">@PostMapping(&quot;/accounts&quot;)
public void handle(@RequestBody Account account) {
    // ...
}
</code></pre>
<p>和SpringMVC不同的是，WebMVC中，<code>@RequestBody</code> 注解的方法参数支持 响应式类型，完全支持 非阻塞读</p>
<pre><code class="language-java">@PostMapping(&quot;/accounts&quot;)
public void handle(@RequestBody Mono&lt;Account&gt; account) {
    // ...
}
</code></pre>
<p>可以使用  <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config">WebFlux Config</a> 中的 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config-message-codecs">HTTP message codecs</a>  选项去配置</p>
<p>你可以将  <code>@RequestBody</code>  与 <code>javax.validation.Valid</code> or Spring’s <code>@Validated</code>  注解组合，这会 引入 Standard Bean Validation </p>
<p>校验报错 会导致 <code>WebExchangeBindException</code>   导致 BAD_REQUEST（400）</p>
<p>异常包含<code>BindingResult</code>  ，可以通过申明为 Mono&lt;MetaData&gt; ，在<code>Mono</code> 中 进行错误的处理</p>
<pre><code class="language-java">@PostMapping(&quot;/accounts&quot;)
public void handle(@Valid @RequestBody Mono&lt;Account&gt; account) {
    // use one of the onError* operators...
}
</code></pre>
<h3 id="httpentity-1"><a class="header" href="#httpentity-1">HttpEntity</a></h3>
<p><code>HttpEntity</code> 或多或少 与  <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-requestbody"><code>@RequestBody</code></a>  相同 ，但是基于 一个容器对象，暴露请求体和请求头</p>
<pre><code class="language-java">@PostMapping(&quot;/accounts&quot;)
public void handle(HttpEntity&lt;Account&gt; entity) {
    // ...
}
</code></pre>
<h3 id="responsebody-1"><a class="header" href="#responsebody-1">@ResponseBody</a></h3>
<p>使用<code>@ResponseBody</code>  注解在 方法上 使得 方法的返回值 使用 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-codecs">HttpMessageWriter</a> 进行序列化</p>
<pre><code class="language-java">@GetMapping(&quot;/accounts/{id}&quot;)
@ResponseBody
public Account handle() {
    // ...
}
</code></pre>
<ul>
<li><code>@ResponseBody</code> 支持类级别上，被所有控制器的方法继承</li>
<li><code>@RestController</code> 只不过是 一个 注解了<code>@Controller</code> and <code>@ResponseBody</code>的元注解</li>
<li><code>@ResponseBody</code>  支持 响应式 类型这意味着 你可以 返回Reactor类型</li>
</ul>
<p>更多额外的 细节详见： see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-codecs-streaming">Streaming</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-codecs-jackson">JSON rendering</a></p>
<p>可以使用 JSON serialization views 综合 <code>@ResponseBody</code>  方法See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-jackson">Jackson JSON</a> for details.</p>
<h3 id="responseentity-1"><a class="header" href="#responseentity-1">ResponseEntity</a></h3>
<p><code>ResponseEntity</code> 与<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-responsebody"><code>@ResponseBody</code></a>  类似但是 由 状态 和 头</p>
<p>Java</p>
<pre><code class="language-java">@GetMapping(&quot;/something&quot;)
public ResponseEntity&lt;String&gt; handle() {
    String body = ... ;
    String etag = ... ;
    return ResponseEntity.ok().eTag(etag).build(body);
}
</code></pre>
<p>WebFlux supports using a single value <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-reactive-libraries">reactive type</a> to produce the <code>ResponseEntity</code> asynchronously, and/or single and multi-value reactive types for the body. This allows a variety of async responses with <code>ResponseEntity</code> as follows:</p>
<p>WebFlux 支持 使用 单值 响应式类型 异步产生ResponseEntity </p>
<ul>
<li><code>ResponseEntity&lt;Mono&lt;T&gt;&gt;</code> or <code>ResponseEntity&lt;Flux&lt;T&gt;&gt;</code>  使得 响应 状态跟 请求头立即 可用，但是 请求体 是稍后异步 提供的，如果body是单值 则 使用Mono、如果 多值使用 Flux</li>
</ul>
<ul>
<li><code>Mono&lt;ResponseEntity&lt;T&gt;&gt;</code>  异步提供 响应状态、请求头、请求体，这允许 响应状态 和头 因异步请求的结果而异</li>
<li><code>Mono&lt;ResponseEntity&lt;Mono&lt;T&gt;&gt;&gt;</code> or <code>Mono&lt;ResponseEntity&lt;Flux&lt;T&gt;&gt;&gt;</code>  这又是另一种可能，虽然是不太常见的选择，异步的提供请求头、请求体，之后在异步的响应请求内容</li>
</ul>
<h3 id="jackson-json-2"><a class="header" href="#jackson-json-2">Jackson JSON</a></h3>
<p>Spring offers support for the Jackson JSON library.</p>
<h4 id="json-views"><a class="header" href="#json-views">JSON Views</a></h4>
<p>Spring WebFlux 提供内置 <a href="https://www.baeldung.com/jackson-json-view-annotation">Jackson’s Serialization Views</a> 的支持，允许 渲染对象中字段的某个子集</p>
<p>To use it with <code>@ResponseBody</code> or <code>ResponseEntity</code> controller methods, </p>
<p>需要 配合<code>@ResponseBody</code> or <code>ResponseEntity</code> 使用，使用  <code>@JsonView</code> 注解 激活 序列化视图</p>
<p>Java</p>
<pre><code class="language-java">@RestController
public class UserController {

    @GetMapping(&quot;/user&quot;)
    @JsonView(User.WithoutPasswordView.class)
    public User getUser() {
        return new User(&quot;eric&quot;, &quot;7!jd#h23&quot;);
    }
}

public class User {

    public interface WithoutPasswordView {};
    public interface WithPasswordView extends WithoutPasswordView {};

    private String username;
    private String password;

    public User() {
    }

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    @JsonView(WithoutPasswordView.class)
    public String getUsername() {
        return this.username;
    }

    @JsonView(WithPasswordView.class)
    public String getPassword() {
        return this.password;
    }
}
</code></pre>
<p><code>@JsonView</code> 允许数组的视图类，但是 每个 控制器方法 指定一个</p>
<p>如果需要多个视图 ，请组合接口 </p>
<h3 id="model-1"><a class="header" href="#model-1">Model</a></h3>
<p>可以使用 <code>@ModelAttribute</code> 注解</p>
<ul>
<li>方法参数：在 <code>@RequestMapping</code>方法参数中  从model 中 创建或访问 对象，然后 通过<code>WebDataBinder</code> 绑定到 请求中</li>
<li>方法上：在 <code>@Controller</code> or <code>@ControllerAdvice</code> 类中， 作为方法级别的注解，优先于  <code>@RequestMapping</code>  方法的调用 帮助 初始化 model</li>
<li>返回值：在一个<code>@RequestMapping</code> 方法中，将其返回值 标记为 model 属性</li>
</ul>
<p>这节讨论 <code>@ModelAttribute</code>  方法，或者 上述列表中的第二项</p>
<p>控制器可以有 任意数量的 <code>@ModelAttribute</code> 方法</p>
<p>所有这些方法都 在 <code>@RequestMapping</code> 方法之前调用</p>
<p>通过 <code>@ControllerAdvice</code> <code>@ModelAttribute</code> 方法 可以 跨控制器 共享</p>
<p>详见：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-controller-advice">Controller Advice</a> 章节</p>
<p><code>@ModelAttribute</code> 方法有很灵活的  方法声明</p>
<p>它们与 <code>@RequestMapping</code> 方法一样 支持同样多的 参数 除了 <code>@ModelAttribute</code>  本身任何其他 跟 <em>request body</em> 相关的参数</p>
<pre><code class="language-java">@ModelAttribute
public void populateModel(@RequestParam String number, Model model) {
    model.addAttribute(accountRepository.findAccount(number));
    // add more ...
}
</code></pre>
<p><strong>将返回值 加入到 Model中</strong></p>
<pre><code class="language-java">@ModelAttribute
public Account addAccount(@RequestParam String number) {
    return accountRepository.findAccount(number);
}
</code></pre>
<p>当没有显示指定名称时，会基于类型选择默认名称，详见： <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/core/Conventions.html"><code>Conventions</code></a></p>
<p>可以通过 <code>addAttribute</code>  显示指定名称 或者 在返回值中加入  <code>@ModelAttribute</code>  注解指定</p>
<p>Spring WebFlux 支持 显示的 响应式类型</p>
<pre><code class="language-java">@ModelAttribute
public void addAccount(@RequestParam String number) {
    Mono&lt;Account&gt; accountMono = accountRepository.findAccount(number);
    model.addAttribute(&quot;account&quot;, accountMono);
}

@PostMapping(&quot;/accounts&quot;)
public String handle(@ModelAttribute Account account, BindingResult errors) {
    // ...
}
</code></pre>
<p>另外 ，任何 模型属性 ，只要有响应式类型包装 ，在 视图渲染前 会被 解析成实际值</p>
<p>可以在 <code>@RequestMapping</code> 方法上注解 <code>@RequestMapping</code>，这会让 返回值 被当作 模型属性</p>
<p>这个不用特别指定，因为 这是 HTML 控制器的默认行为，除非 返回值 是 string类型：这个会被解析成视图</p>
<p><code>@ModelAttribute</code> 也可以自定义 属性名</p>
<p>Java</p>
<pre><code class="language-java">@GetMapping(&quot;/accounts/{id}&quot;)
@ModelAttribute(&quot;myAccount&quot;)
public Account handle() {
    // ...
    return account;
}
</code></pre>
<h3 id="databinder-1"><a class="header" href="#databinder-1">DataBinder</a></h3>
<p><code>@Controller</code>  或者  <code>@ControllerAdvice</code>  类 可以有 <code>@InitBinder</code> 方法，用来初始化 <code>WebDataBinder</code> 实例</p>
<p>这个实例是用来以下：</p>
<ul>
<li>绑定请求参数到模型中去.</li>
<li>将基于 string的请求值 转换成 控制器方法参数对象</li>
<li>在渲染模板时，将 model对象 转换为 string</li>
</ul>
<p><code>@InitBinder</code> 方法 可以注解 特定于 控制器的 <code>java.beans.PropertyEditor</code>  或者 Spring <code>Converter</code> and <code>Formatter</code> 组件</p>
<p>另外：可以使用<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config-conversion">WebFlux Java configuration</a>  在全局共享的<code>FormattingConversionService</code>中注册 <code>Converter</code> and <code>Formatter</code></p>
<p><code>@InitBinder</code> 支持 跟  <code>@RequestMapping</code> 方法 许多相同的参数，除了 <code>@ModelAttribute</code>参数</p>
<p>典型的，<code>WebDataBinder</code>  参数用来注册 ，返回 VOID</p>
<p>Java</p>
<pre><code class="language-java">@Controller
public class FormController {

    @InitBinder 
    public void initBinder(WebDataBinder binder) {
        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        dateFormat.setLenient(false);
        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
    }
    // ...
}
</code></pre>
<p>另外可以通过 <code>FormattingConversionService</code> 注册   <code>Formatter</code> based </p>
<p>Java</p>
<pre><code class="language-java">@Controller
public class FormController {

    @InitBinder
    protected void initBinder(WebDataBinder binder) {
        binder.addCustomFormatter(new DateFormatter(&quot;yyyy-MM-dd&quot;)); 
    }

    // ...
}
</code></pre>
<h3 id="managing-exceptions"><a class="header" href="#managing-exceptions">Managing Exceptions</a></h3>
<p><code>@Controller</code> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-controller-advice">@ControllerAdvice</a>  类可以有  <code>@ExceptionHandler</code> 方法来处理 控制器方法的异常</p>
<p>Java</p>
<pre><code class="language-java">@Controller
public class SimpleController {

    // ...

    @ExceptionHandler 
    public ResponseEntity&lt;String&gt; handle(IOException ex) {
        // ...
    }
}
</code></pre>
<p>异常可以 与 正在传播的 顶层 异常相匹配 （也就是：一个直接的 IOException 被抛出） 或者是 包装异常的直接 异常（例如： <code>IOException</code>包装在 <code>IllegalStateException</code>的内部）</p>
<p>对于异常类型匹配，最好 声明 目标异常作为 方法参数</p>
<p>也可以在 注解中声明 异常的类型</p>
<p>通常建议：</p>
<ol>
<li>在参数中 声明的越具体越好</li>
<li>在注解中 声明 primary root exception</li>
<li>在  @ControllerAdvice中 按照 优先级的顺序 声明 异常处理方法，See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-exceptionhandler">the MVC section</a> for details</li>
</ol>
<p>An <code>@ExceptionHandler</code> 方法 支持 与<code>@RequestMapping</code> method  同样的方法参数、返回值，除了 equest body- 和 <code>@ModelAttribute</code> 关联的 方法参数</p>
<p>在SpringWebFlux中 <code>@ExceptionHandler</code>  方法支持 由  <code>@RequestMapping</code>  方法的 <code>HandlerAdapter</code> 提供</p>
<p>See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-dispatcher-handler"><code>DispatcherHandler</code></a></p>
<h4 id="rest-api-exceptions-1"><a class="header" href="#rest-api-exceptions-1">REST API exceptions</a></h4>
<p>REST services  的 通用要求是 包含 错误明细在 响应中</p>
<p>Spring Framework 不会自动做这些工作，因为 错误的明细 是特定于应用程序的</p>
<p><code>@RestController</code>  可以使用 <code>@ExceptionHandler</code>  方法 ，返回 <code>ResponseEntity</code>  值 用来设置 状态 和响应体</p>
<p>可以生命在 <code>@ControllerAdvice</code>  以全局 处理 </p>
<p>注意：Spring WebFlux 没有 SpringMVC中 类似的 <em>ResponseEntityExceptionHandler</em>  因为WebFlux 只抛出 ResponseStatusException 或者其 子类，不需要转换成 HTTP状态码</p>
<h3 id="controller-advice-1"><a class="header" href="#controller-advice-1">Controller Advice</a></h3>
<p>典型说来，<code>@ExceptionHandler</code>, <code>@InitBinder</code>, and <code>@ModelAttribute</code> 方法  应用于 它们所声明的控制器类（或者类继承结构）内部，如果你想跨控制器全局使用 可以把它们声明在 <code>@ControllerAdvice</code> or <code>@RestControllerAdvice</code></p>
<p><code>@ControllerAdvice</code>  被 <code>@Component</code> 注解了，这意味着 这些类可以被 注册到 Spring bean容器中</p>
<p><code>@RestControllerAdvice</code>  是一个组合注解，由  <code>@ControllerAdvice</code> and <code>@ResponseBody</code> 注解 注解 这也意味着 <code>@ExceptionHandler</code> 方法 渲染数据到 响应体，通过 message conversion</p>
<p>在启动时， <code>@RequestMapping</code> and <code>@ExceptionHandler</code> 方法的 基础设施类 检测 Spring beans 中 带有 <code>@ControllerAdvice</code> 注解的 bean,在运行时 应用</p>
<p>Global (来自<code>@ControllerAdvice</code>)  <code>@ExceptionHandler</code>  方法  应用于 本地 之后（来自  <code>@Controller</code>）</p>
<p>据约定， 全局的 <code>@ModelAttribute</code> and <code>@InitBinder</code>  应用于 本地之前</p>
<p>By default, <code>@ControllerAdvice</code> methods apply to every request (that is, all controllers), but you can narrow that down to a subset of controllers by using attributes on the annotation, as the following example shows:</p>
<p>默认情况下，<code>@ControllerAdvice</code> 方法应用于每个请求（即所有控制器类），但是可以缩小 控制器的范围</p>
<pre><code class="language-java">// Target all Controllers annotated with @RestController
@ControllerAdvice(annotations = RestController.class)
public class ExampleAdvice1 {}

// Target all Controllers within specific packages
@ControllerAdvice(&quot;org.example.controllers&quot;)
public class ExampleAdvice2 {}

// Target all Controllers assignable to specific classes
@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
public class ExampleAdvice3 {}
</code></pre>
<p>上述案例的  选择 是在运行时 解析的，可能会轻微的影响性能，详见 <a href="https://docs.spring.io/spring-framework/docs/5.3.10/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html"><code>@ControllerAdvice</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="request-mapping-1"><a class="header" href="#request-mapping-1">Request Mapping</a></h2>
<p><code>@RequestMapping</code> 注解用来 映射请求到 控制器方法</p>
<p>它有很多参数进行匹配</p>
<ul>
<li>by URL</li>
<li>HTTP method</li>
<li>request parameters</li>
<li>headers</li>
<li>media types</li>
</ul>
<p>在类级别用于 共享映射</p>
<p>在方法级别 用于 确定一个 指定的 endpoint mapping</p>
<p>基于不同的Http方法的<code>@RequestMapping</code> 的快捷方式</p>
<ul>
<li><code>@GetMapping</code></li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
<p>前面的注解是  <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-requestmapping-composed">Custom Annotations</a> ，因为 大多数方法都需要映射到一个指定的 Http方法，而不是 直接使用 <code>@RequestMapping</code>匹配所有Http方法，同时 <code>@RequestMapping</code>需要 在类级别 上表示 共享的 映射</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/persons&quot;)
class PersonController {

    @GetMapping(&quot;/{id}&quot;)
    public Person getPerson(@PathVariable Long id) {
        // ...
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public void add(@RequestBody Person person) {
        // ...
    }
}
</code></pre>
<h3 id="uri-patterns-1"><a class="header" href="#uri-patterns-1">URI Patterns</a></h3>
<p>可以使用通配符</p>
<table><thead><tr><th style="text-align: left">Pattern</th><th style="text-align: left">Description</th><th style="text-align: left">Example</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>?</code></td><td style="text-align: left">匹配一个字符</td><td style="text-align: left"><code>&quot;/pages/t?st.html&quot;</code> matches <code>&quot;/pages/test.html&quot;</code> and <code>&quot;/pages/t3st.html&quot;</code></td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left">Matches zero or more characters within a path segment</td><td style="text-align: left"><code>&quot;/resources/*.png&quot;</code> matches <code>&quot;/resources/file.png&quot;``&quot;/projects/*/versions&quot;</code> matches <code>&quot;/projects/spring/versions&quot;</code> but does not match <code>&quot;/projects/spring/boot/versions&quot;</code></td></tr>
<tr><td style="text-align: left"><code>**</code></td><td style="text-align: left">Matches zero or more path segments until the end of the path</td><td style="text-align: left"><code>&quot;/resources/**&quot;</code> matches <code>&quot;/resources/file.png&quot;</code> and <code>&quot;/resources/images/file.png&quot;``&quot;/resources/**/file.png&quot;</code> is invalid as <code>**</code> is only allowed at the end of the path.</td></tr>
<tr><td style="text-align: left"><code>{name}</code></td><td style="text-align: left">Matches a path segment and captures it as a variable named &quot;name&quot;</td><td style="text-align: left"><code>&quot;/projects/{project}/versions&quot;</code> matches <code>&quot;/projects/spring/versions&quot;</code> and captures <code>project=spring</code></td></tr>
<tr><td style="text-align: left"><code>{name:[a-z]+}</code></td><td style="text-align: left">Matches the regexp <code>&quot;[a-z]+&quot;</code> as a path variable named &quot;name&quot;</td><td style="text-align: left"><code>&quot;/projects/{project:[a-z]+}/versions&quot;</code> matches <code>&quot;/projects/spring/versions&quot;</code> but not <code>&quot;/projects/spring1/versions&quot;</code></td></tr>
<tr><td style="text-align: left"><code>{*path}</code></td><td style="text-align: left">Matches zero or more path segments until the end of the path and captures it as a variable named &quot;path&quot;</td><td style="text-align: left"><code>&quot;/resources/{*file}&quot;</code> matches <code>&quot;/resources/images/file.png&quot;</code> and captures <code>file=/images/file</code></td></tr>
</tbody></table>
<p>捕获的URI可以通过  <code>@PathVariable</code> 变量访问</p>
<pre><code class="language-java">@GetMapping(&quot;/owners/{ownerId}/pets/{petId}&quot;)
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
    // ...
}

//类级别上的 变量捕获
@Controller
@RequestMapping(&quot;/owners/{ownerId}&quot;) 
public class OwnerController {

    @GetMapping(&quot;/pets/{petId}&quot;) 
    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
        // ...
    }
}
</code></pre>
<ul>
<li>
<p>URI 变量 自动转换成合适的类型，或者抛出<code>TypeMismatchException</code> ，默认支持简单类型（<code>int</code>, <code>long</code>, <code>Date</code>）可以注册其他类型的支持See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-typeconversion">Type Conversion</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-initbinder"><code>DataBinder</code></a></p>
</li>
<li>
<p>URI variables 可以显示命名（<code>@PathVariable(&quot;customId&quot;)</code>） 但是可以忽略，如果使用 Java8 <code>-parameters</code> 选项 编译代码</p>
</li>
<li>
<p><code>{*varName}</code> 语法 申明了 一个 URI 变量，匹配一个或多个 剩余路径片段 例如 <code>/resources/{*path}</code>  匹配  <code>/resources/</code> 下所有资源的路径</p>
</li>
<li>
<p><code>{varName:regex}</code>  申明了 URI 变量 使用正则表达式示例如下</p>
</li>
</ul>
<pre><code class="language-java">@GetMapping(&quot;/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}&quot;)
public void handle(@PathVariable String version, @PathVariable String ext) {
    // ...
}
</code></pre>
<p>URI path支持 <code>${}</code> 占位符 ，在启动时 使用 <code>PropertyPlaceHolderConfigurer</code> 通过 local、system、environment等其他 资源属性</p>
<p>Spring WebFlux  使用<code>PathPattern</code>  <code>PathPatternParser</code>  来进行 路径匹配，这些类在 <code>spring-web</code> 模块，主要是用来在web应用 运行时 对 HTTP URL path进行大量的路径匹配</p>
<p>Spring WebFlux 不支持 后缀路径匹配</p>
<h3 id="pattern-comparison-1"><a class="header" href="#pattern-comparison-1">Pattern Comparison</a></h3>
<p>当多个模式 都匹配 到URL时，必须比较出一个 最佳比配，使用 <em>PathPattern.SPECIFICITY_COMPARATOR</em> 已经完成，这回查找最精确的 patterns</p>
<p>对于每一个 pattern，都会计算出一个分数，URI变量和 通配符的个数，URI变量 分数低于 通配符，更低的 分数 获胜，分数一致的 更长的获胜</p>
<p>Catch-all patterns (for example, <code>**</code>, <code>{*varName}</code>)  不会计算分数，最会最后一个考虑，如果两个都是 catch-all 则长的 会被选择</p>
<h3 id="consumable-media-types-1"><a class="header" href="#consumable-media-types-1">Consumable Media Types</a></h3>
<p>你可以更加精确 请求 通过 <code>Content-Type</code> </p>
<p>Java</p>
<pre><code class="language-java">@PostMapping(path = &quot;/pets&quot;, consumes = &quot;application/json&quot;)
public void addPet(@RequestBody Pet pet) {
    // ...
}
</code></pre>
<p>consumers属性 支持内容协商表达式：</p>
<ul>
<li><code>!text/plain</code>  匹配任何内容除了 <code>text/plain</code></li>
<li>可以在类级别 定义 <em>consumes</em></li>
<li>方法级别的 consumes覆盖 类级别的  consumes</li>
</ul>
<p><code>MediaType</code> 提供 通用使用的常量 例如：<code>APPLICATION_JSON_VALUE</code> and <code>APPLICATION_XML_VALUE</code>.</p>
<h3 id="producible-media-types-1"><a class="header" href="#producible-media-types-1">Producible Media Types</a></h3>
<p>基于 Accept请求头 可以列出 controller 方法 产生的 内容类型   更加精确请求，</p>
<p>Java</p>
<pre><code class="language-java">@GetMapping(path = &quot;/pets/{petId}&quot;, produces = &quot;application/json&quot;)
@ResponseBody
public Pet getPet(@PathVariable String petId) {
    // ...
}
</code></pre>
<ul>
<li>
<p>媒体类型可以 指定 字符集</p>
</li>
<li>
<p>支持 否定表达式 例如：<code>!text/plain</code></p>
</li>
<li>
<p>可以在类级别声明 <code>produces</code> 属性，方法级别的 produces属性 会 覆盖类级别的</p>
</li>
<li>
<p><code>MediaType</code>  提供 常量访问，e.g. <code>APPLICATION_JSON_VALUE</code>, <code>APPLICATION_XML_VALUE</code>.</p>
</li>
</ul>
<h3 id="parameters-and-headers"><a class="header" href="#parameters-and-headers">Parameters and Headers</a></h3>
<p>支持查询参数条件匹配</p>
<ul>
<li>使用<code>myParam</code> 测试参数存在</li>
<li>使用 <code>!myParam</code> 测试 条件不存在</li>
<li>使用 <code>myParam=myValue</code> 测试等于某一个具体值</li>
</ul>
<p>Java</p>
<pre><code class="language-java">@GetMapping(path = &quot;/pets/{petId}&quot;, params = &quot;myParam=myValue&quot;) 
public void findPet(@PathVariable String petId) {
    // ...
}
</code></pre>
<p><strong>测试请求体中的头</strong></p>
<p>Java</p>
<pre><code class="language-java">@GetMapping(path = &quot;/pets&quot;, headers = &quot;myHeader=myValue&quot;) 
public void findPet(@PathVariable String petId) {
    // ...
}
</code></pre>
<h3 id="http-head-options"><a class="header" href="#http-head-options">HTTP HEAD, OPTIONS</a></h3>
<p><code>@GetMapping</code> and <code>@RequestMapping(method=HttpMethod.GET)</code> 透明的 支持 HTTP HEAD方法</p>
<p>response wrapper 应用于 <code>HttpHandler</code> server adapter，确保 <code>Content-Length</code> 头 被设置 ，且字节数没有计算 实际响应。</p>
<p>默认的 HTTP OPTIONS  通过 设置 Allow 头 来处理，由该URL匹配的  方法所支持的请求方式</p>
<ul>
<li>对于 没有指定请求方法的<code>@RequestMapping</code> ，Allow头 设置为 <code>GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS</code></li>
<li>控制器方法 应该始终指定 请求方法： <code>@GetMapping</code>, <code>@PostMapping</code></li>
</ul>
<h3 id="custom-annotations"><a class="header" href="#custom-annotations">Custom Annotations</a></h3>
<p>Spring WebFlux 支持 request mapping的  组合注解 （ <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-meta-annotations">composed annotations</a> ）的使用</p>
<p>自定义注解本身 使用 <code>@RequestMapping</code>  注解，并在注解中 重新声明 RequetMapping 的属性</p>
<p><code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, and <code>@PatchMapping</code> 就是组合注解的实例</p>
<p>Spring WebFlux 同样支持 自定义请求 映射属性 和 自定以请求匹配逻辑</p>
<p>这是更高级的选项：需要继承 <code>RequestMappingHandlerMapping</code>  覆盖<code>getCustomMethodCondition</code>  方法，这里你可以检查 自定义属性，并且返回 自己的<code>RequestCondition</code></p>
<h3 id="explicit-registrations"><a class="header" href="#explicit-registrations">Explicit Registrations</a></h3>
<p>可以编程式注册 handler 方法，这可以用于动态注册 或者 高级 案例</p>
<p>例如同一个 Handler类 的不同实例 处理不同的 URLs</p>
<p>Java</p>
<pre><code class="language-java">@Configuration
public class MyConfig {

    @Autowired
    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) 
            throws NoSuchMethodException {
//准备 request mapping 元数据
        RequestMappingInfo info = RequestMappingInfo
                .paths(&quot;/user/{id}&quot;).methods(RequestMethod.GET).build(); 
//获取handler方法
        Method method = UserHandler.class.getMethod(&quot;getUser&quot;, Long.class); 
//注册
        mapping.registerMapping(info, handler, method); 
    }

}
</code></pre>
<h2 id="-1"><a class="header" href="#-1"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="服务层"><a class="header" href="#服务层">服务层</a></h1>
<p>该层是各个 HTTP 服务器的 启动方法，服务就是从该层启动</p>
<h2 id="netty"><a class="header" href="#netty">Netty</a></h2>
<pre><code class="language-java">HttpHandler handler = ...
ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);
HttpServer.create().host(host).port(port).handle(adapter).bind().block();
</code></pre>
<h2 id="tomcat-1"><a class="header" href="#tomcat-1">Tomcat</a></h2>
<pre><code class="language-java">HttpHandler handler = ...
Servlet servlet = new TomcatHttpHandlerAdapter(handler);

Tomcat server = new Tomcat();
File base = new File(System.getProperty(&quot;java.io.tmpdir&quot;));
Context rootContext = server.addContext(&quot;&quot;, base.getAbsolutePath());
Tomcat.addServlet(rootContext, &quot;main&quot;, servlet);
rootContext.addServletMappingDecoded(&quot;/&quot;, &quot;main&quot;);
server.setHost(host);
server.setPort(port);
server.start();
</code></pre>
<h1 id="适配层"><a class="header" href="#适配层">适配层</a></h1>
<ul>
<li>利用服务库的API实现响应式</li>
<li>不同 的 服务层中 有不同形式的 handler去处理请求与响应</li>
</ul>
<h2 id="netty-1"><a class="header" href="#netty-1">Netty</a></h2>
<p><strong>需要的handler签名</strong></p>
<pre><code class="language-java">BiFunction&lt;HttpServerRequest, HttpServerResponse, Mono&lt;Void&gt;&gt;
</code></pre>
<h2 id="tomcat-2"><a class="header" href="#tomcat-2">Tomcat</a></h2>
<pre><code class="language-java">Servlet
</code></pre>
<h1 id="webflux处理层"><a class="header" href="#webflux处理层">WebFlux处理层</a></h1>
<p>WebFlux将处理逻辑转交给 <em>HttpHandler</em></p>
<h2 id="httpwebhandleradapter"><a class="header" href="#httpwebhandleradapter"><em>HttpWebHandlerAdapter</em></a></h2>
<ul>
<li>将请求逻辑转统一定向到WebHandler</li>
<li>并提供 spring容器，会话管理，请求、国际化，编解码等的初步支持</li>
</ul>
<h2 id="webhandler-1"><a class="header" href="#webhandler-1">WebHandler</a></h2>
<ul>
<li>处理会话、容器、国际化、编解码等</li>
<li>将路由与 业务处理逻辑交给其他层</li>
</ul>
<h2 id="路由与业务处理"><a class="header" href="#路由与业务处理">路由与业务处理</a></h2>
<h3 id="routerfunctionwebhandler"><a class="header" href="#routerfunctionwebhandler"><em>RouterFunctionWebHandler</em></a></h3>
<p>基于 <em>RouterFunction</em> 的路由</p>
<p>基于 <em>HandlerFunction</em> 的业务处理</p>
<h3 id="dispatcherhandler-1"><a class="header" href="#dispatcherhandler-1"><em>DispatcherHandler</em></a></h3>
<p><strong>路由查找</strong></p>
<p><em>HandlerMapping</em>  ：不同的路由方式 映射到 不同的 handler</p>
<ul>
<li>
<p><em>RouterFunctionMapping</em>：基于 <em>RouterFunction</em> 的路由</p>
</li>
<li>
<p><em>AbstractUrlHandlerMapping</em>：基于Url匹配的路由</p>
</li>
<li>
<p><em>AbstractHandlerMethodMapping</em>：基于RequestMapping方法的路由</p>
</li>
</ul>
<p><strong>业务处理</strong></p>
<p>由于不同的 <em>HandlerMapping</em>  返回不同的 handler，所以定义了 <em>HandlerAdapter</em> 去定义了如何调用 <em>handler</em></p>
<ul>
<li><em>RequestMappingHandlerAdapter</em>：处理 <em>AbstractHandlerMethodMapping</em>产生的 HandlerMethod</li>
<li><em>HandlerFunctionAdapter</em>：处理 <em>RouterFunctionMapping</em> 产生的 <em>HandlerFunction</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="创建上下文"><a class="header" href="#创建上下文">创建上下文</a></h1>
<pre><code class="language-java">//org.springframework.boot.SpringApplication#createApplicationContext
ApplicationContextFactory DEFAULT = (webApplicationType) -&gt; {
    try {
        switch (webApplicationType) {
            case SERVLET:
                return new AnnotationConfigServletWebServerApplicationContext();
            case REACTIVE:
                return new AnnotationConfigReactiveWebServerApplicationContext();
            default:
                return new AnnotationConfigApplicationContext();
        }
    }
    catch (Exception ex) {
        throw new IllegalStateException(&quot;Unable create a default ApplicationContext instance, &quot;
                                        + &quot;you may need a custom ApplicationContextFactory&quot;, ex);
    }
};
</code></pre>
<p><strong>如何判断 web应用类型</strong></p>
<pre><code class="language-java">	private static final String[] SERVLET_INDICATOR_CLASSES = { &quot;javax.servlet.Servlet&quot;,
			&quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot; };

	//webmvc判断类
	private static final String WEBMVC_INDICATOR_CLASS = &quot;org.springframework.web.servlet.DispatcherServlet&quot;;

	//webflux判断类
	private static final String WEBFLUX_INDICATOR_CLASS = &quot;org.springframework.web.reactive.DispatcherHandler&quot;;

	//jersy
	private static final String JERSEY_INDICATOR_CLASS = &quot;org.glassfish.jersey.servlet.ServletContainer&quot;;

	//servlet
	private static final String SERVLET_APPLICATION_CONTEXT_CLASS = &quot;org.springframework.web.context.WebApplicationContext&quot;;


static WebApplicationType deduceFromClasspath() {
    if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)
        &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {
        return WebApplicationType.REACTIVE;
    }
    for (String className : SERVLET_INDICATOR_CLASSES) {
        if (!ClassUtils.isPresent(className, null)) {
            return WebApplicationType.NONE;
        }
    }
    return WebApplicationType.SERVLET;
}
</code></pre>
<h1 id="创建webservermanager"><a class="header" href="#创建webservermanager">创建WebServerManager</a></h1>
<pre><code class="language-java">//org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#refresh
	private void createWebServer() {
		WebServerManager serverManager = this.serverManager;
		if (serverManager == null) {
			StartupStep createWebServer = this.getApplicationStartup().start(&quot;spring.boot.webserver.create&quot;);
            //获取 ReactiveWebServerFactory bean名
			String webServerFactoryBeanName = getWebServerFactoryBeanName();
            //获取 ReactiveWebServerFactory bean
			ReactiveWebServerFactory webServerFactory = getWebServerFactory(webServerFactoryBeanName);
            
			createWebServer.tag(&quot;factory&quot;, webServerFactory.getClass().toString());
			boolean lazyInit = getBeanFactory().getBeanDefinition(webServerFactoryBeanName).isLazyInit();
            //获取 HttpHandlerbean,创建ServerManager
			this.serverManager = new WebServerManager(this, webServerFactory, this::getHttpHandler, lazyInit);
			getBeanFactory().registerSingleton(&quot;webServerGracefulShutdown&quot;,
					new WebServerGracefulShutdownLifecycle(this.serverManager.getWebServer()));
			getBeanFactory().registerSingleton(&quot;webServerStartStop&quot;,
					new WebServerStartStopLifecycle(this.serverManager));
			createWebServer.end();
		}
		initPropertySources();
	}
</code></pre>
<h1 id="创建websevrer"><a class="header" href="#创建websevrer">创建WebSevrer</a></h1>
<h2 id="nettyserver"><a class="header" href="#nettyserver">NettyServer</a></h2>
<pre><code class="language-java">	public WebServer getWebServer(HttpHandler httpHandler) {
		HttpServer httpServer = createHttpServer();
		ReactorHttpHandlerAdapter handlerAdapter = new ReactorHttpHandlerAdapter(httpHandler);
		NettyWebServer webServer = createNettyWebServer(httpServer, handlerAdapter, this.lifecycleTimeout,
				getShutdown());
		webServer.setRouteProviders(this.routeProviders);
		return webServer;
	}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="微服务的优点"><a class="header" href="#微服务的优点">微服务的优点</a></h1>
<h2 id="概述-7"><a class="header" href="#概述-7">概述</a></h2>
<p>“微服务”一词来源于 Martin Fowler 的《Microservices》一文。微服务是一种架构风格，即将单体应用划分为小型的服务单元，微服务之间使用 HTTP 的 API 进行资源访问与操作。</p>
<p>在笔者看来，微服务架构的演变更像是一个公司的发展过程，从最开始的小公司，到后来的大集团。大集团可拆分出多个子公司，每个子公司的都有自己独立的业务、员工，各自发展，互不影响，合起来则是威力无穷。</p>
<p>臃肿的系统、重复的代码、超长的启动时间带给开发人员的只有无限的埋怨，丝毫没有那种很舒服的、很流畅的写代码的感觉。他们把大部分时间都花在解决问题和项目启动上面了。</p>
<h2 id="微服务架构的优势"><a class="header" href="#微服务架构的优势">微服务架构的优势</a></h2>
<h3 id="服务的独立部署"><a class="header" href="#服务的独立部署">服务的独立部署</a></h3>
<p>每个服务都是一个独立的项目，可以独立部署，不依赖于其他服务，耦合性低。</p>
<h3 id="服务的快速启动"><a class="header" href="#服务的快速启动">服务的快速启动</a></h3>
<p>拆分之后服务启动的速度必然要比拆分之前快很多，因为依赖的库少了，代码量也少了。</p>
<h3 id="更加适合敏捷开发"><a class="header" href="#更加适合敏捷开发">更加适合敏捷开发</a></h3>
<p>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行。服务拆分可以快速发布新版本，修改哪个服务只需要发布对应的服务即可，不用整体重新发布。</p>
<h3 id="职责专一"><a class="header" href="#职责专一">职责专一</a></h3>
<p>由专门的团队负责专门的服务,业务发展迅速时，研发人员也会越来越多，每个团队可以负责对应的业务线，服务的拆分有利于团队之间的分工。</p>
<h3 id="服务可以动态按需扩容"><a class="header" href="#服务可以动态按需扩容">服务可以动态按需扩容</a></h3>
<p>当某个服务的访问量较大时，我们只需要将这个服务扩容即可。</p>
<h3 id="代码的复用"><a class="header" href="#代码的复用">代码的复用</a></h3>
<p>每个服务都提供 REST API，所有的基础服务都必须抽出来，很多的底层实现都可以以接口方式提供。</p>
<h2 id="微服务架构的劣势"><a class="header" href="#微服务架构的劣势">微服务架构的劣势</a></h2>
<p>微服务其实是一把双刃剑，既然有利必然也会有弊。下面我们来谈谈微服务有哪些弊端，以及能采取什么办法避免。</p>
<h3 id="分布式部署调用的复杂性高"><a class="header" href="#分布式部署调用的复杂性高">分布式部署，调用的复杂性高</a></h3>
<p>单体应用的时候，所有模块之前的调用都是在本地进行的，在微服务中，每个模块都是独立部署的，通过 HTTP 来进行通信，这当中会产生很多问题，比如网络问题、容错问题、调用关系等。</p>
<h3 id="独立的数据库分布式事务的挑战"><a class="header" href="#独立的数据库分布式事务的挑战">独立的数据库，分布式事务的挑战</a></h3>
<p>每个微服务都有自己的数据库，这就是所谓的去中心化的数据管理。这种模式的优点在于不同的服务，可以选择适合自身业务的数据，比如订单服务可以用 MySQL、评论服务可以用 Mongodb、商品搜索服务可以用 Elasticsearch。</p>
<p>缺点就是事务的问题了，目前最理想的解决方案就是柔性事务中的最终一致性，后面的章节会给大家做具体介绍。</p>
<h3 id="测试的难度提升"><a class="header" href="#测试的难度提升">测试的难度提升</a></h3>
<p>服务和服务之间通过接口来交互，当接口有改变的时候，对所有的调用方都是有影响的，这时自动化测试就显得非常重要了，如果要靠人工一个个接口去测试，那工作量就太大了。这里要强调一点，就是 API 文档的管理尤为重要。</p>
<h3 id="运维难度的提升"><a class="header" href="#运维难度的提升">运维难度的提升</a></h3>
<p>我们可能只需要关注一个 Tomcat 的集群、一个 MySQL 的集群就可以了，但这在微服务架构下是行不通的。当业务增加时，服务也将越来越多，服务的部署、监控将变得非常复杂，这个时候对于运维的要求就高了。</p>
<h1 id="springcloud是什么"><a class="header" href="#springcloud是什么">SpringCloud是什么</a></h1>
<p>Spring Cloud是一系列框架的有序集合。它利用 Spring Boot 的开发便利性，巧妙地简化了分布式系统基础设施的开发，如服务注册、服务发现、配置中心、消息总线、负载均衡、断路器、数据监控等，这些都可以用 Spring Boot 的开发风格做到一键启动和部署。</p>
<p>通俗地讲，Spring Cloud 就是用于构建微服务开发和治理的框架集合（并不是具体的一个框架），主要贡献来自 Netflix OSS。</p>
<p>Spring Cloud 模块的相关介绍如下：</p>
<ul>
<li>Eureka：服务注册中心，用于服务管理。</li>
<li>Ribbon：基于客户端的负载均衡组件。</li>
<li>Hystrix：容错框架，能够防止服务的雪崩效应。</li>
<li>Feign：Web 服务客户端，能够简化 HTTP 接口的调用。</li>
<li>Zuul：API 网关，提供路由转发、请求过滤等功能。</li>
<li>Config：分布式配置管理。</li>
<li>Sleuth：服务跟踪。</li>
<li>Stream：构建消息驱动的微服务应用程序的框架。</li>
<li>Bus：消息代理的集群消息总线。</li>
</ul>
<h1 id="springcloud版本介绍"><a class="header" href="#springcloud版本介绍">SpringCloud版本介绍</a></h1>
<h2 id="与springboot版本兼容"><a class="header" href="#与springboot版本兼容"><strong>与springBoot版本兼容</strong></a></h2>
<table><thead><tr><th style="text-align: left">Release Train</th><th style="text-align: left">Boot Version</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes">2020.0.x</a> aka Ilford</td><td style="text-align: left">2.4.x</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes">Hoxton</a></td><td style="text-align: left">2.2.x, 2.3.x (Starting with SR5)</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes">Greenwich</a></td><td style="text-align: left">2.1.x</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes">Finchley</a></td><td style="text-align: left">2.0.x</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes">Edgware</a></td><td style="text-align: left">1.5.x</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes">Dalston</a></td><td style="text-align: left">1.5.x</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-7"><a class="header" href="#简介-7">简介</a></h1>
<p>Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign，</p>
<p>ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为</p>
<p>ribbon 已经默认实现了这些配置bean：</p>
<ul>
<li>IClientConfig ribbonClientConfig: DefaultClientConfigImpl</li>
<li>IRule ribbonRule: ZoneAvoidanceRule</li>
<li>IPing ribbonPing: NoOpPing</li>
<li>ServerList ribbonServerList: ConfigurationBasedServerList</li>
<li>ServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter</li>
<li>ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer</li>
</ul>
<h1 id="使用方式-1"><a class="header" href="#使用方式-1">使用方式</a></h1>
<h2 id="依赖申明"><a class="header" href="#依赖申明">依赖申明</a></h2>
<pre><code class="language-xml">       &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p><strong>定义实现接口</strong></p>
<pre><code class="language-java">package com.weisanju.nacConsumer;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.GetMapping;

@Service
@FeignClient(&quot;service-provider&quot;)
public interface RemoteService {
    @GetMapping(&quot;/time&quot;)
    String timeService();
}
</code></pre>
<p><strong>启用扫描代理</strong></p>
<pre><code class="language-java">@EnableFeignClients(basePackages = &quot;com.weisanju.nacConsumer&quot;)
</code></pre>
<p><strong>使用</strong></p>
<pre><code class="language-java">    public static class TestController {

        private final RestTemplate restTemplate;
        @Autowired
        private RemoteService remoteService;

        @Autowired
        public TestController(RestTemplate restTemplate) {
            this.restTemplate = restTemplate;
        }

        @RequestMapping(value = &quot;/echo/{str}&quot;, method = RequestMethod.GET)
        public String echo(@PathVariable String str) {
            return restTemplate.getForObject(&quot;http://service-provider/echo/&quot; + str, String.class);
        }
        @RequestMapping(value = &quot;/myTime&quot;, method = RequestMethod.GET)
        public String echo() {
            return remoteService.timeService();
        }
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是-nacos"><a class="header" href="#什么是-nacos">什么是 Nacos</a></h1>
<h2 id="简介-8"><a class="header" href="#简介-8">简介</a></h2>
<p>Nacos 致力于帮助您发现、配置和管理微服务。</p>
<p>Nacos 提供了一组简单易用的特性集，帮助您快速实现</p>
<ul>
<li><strong>动态服务发现</strong>、</li>
<li><strong>服务配置</strong>、</li>
<li><strong>服务元数据</strong></li>
<li><strong>流量管理</strong></li>
</ul>
<p>Nacos 支持几乎所有主流类型的“服务”的发现、配置和管理</p>
<ul>
<li>
<p><a href="https://kubernetes.io/docs/concepts/services-networking/service/">Kubernetes Service</a></p>
</li>
<li>
<p><a href="https://grpc.io/docs/guides/concepts.html#service-definition">gRPC</a> &amp; <a href="https://dubbo.incubator.apache.org/">Dubbo RPC Service</a></p>
</li>
<li>
<p><a href="https://spring.io/understanding/REST">Spring Cloud RESTful Service</a></p>
</li>
</ul>
<h2 id="特性"><a class="header" href="#特性">特性</a></h2>
<h3 id="服务发现和服务健康监测"><a class="header" href="#服务发现和服务健康监测"><strong>服务发现和服务健康监测</strong></a></h3>
<p>Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用 <a href="https://nacos.io/zh-cn/docs/sdk.html">原生SDK</a>、<a href="https://nacos.io/zh-cn/docs/open-api.html">OpenAPI</a>、或一个<a href="https://nacos.io/zh-cn/docs/other-language.html">独立的Agent TODO</a>注册 Service 后，服务消费者可以使用<a href="https://nacos.io/zh-cn/docs/xx">DNS TODO</a> 或<a href="https://nacos.io/zh-cn/docs/open-api.html">HTTP&amp;API</a>查找和发现服务。</p>
<p>Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求</p>
<p>Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。</p>
<p>Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。</p>
<h3 id="动态配置服务"><a class="header" href="#动态配置服务"><strong>动态配置服务</strong></a></h3>
<p>动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。</p>
<p>动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。</p>
<p>配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。</p>
<p>Nacos 提供了一个简洁易用的UI (<a href="http://console.nacos.io/nacos/index.html">控制台样例 Demo</a>) 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。</p>
<h3 id="动态-dns-服务"><a class="header" href="#动态-dns-服务"><strong>动态 DNS 服务</strong></a></h3>
<p>动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。动态DNS服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险</p>
<p>Nacos 提供了一些简单的 <a href="https://nacos.io/zh-cn/docs/xx">DNS APIs TODO</a> 帮助您管理服务的关联域名和可用的 IP:PORT 列表.</p>
<h3 id="服务及其元数据管理"><a class="header" href="#服务及其元数据管理"><strong>服务及其元数据管理</strong></a></h3>
<p>Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。</p>
<h1 id="nacos大图"><a class="header" href="#nacos大图">Nacos大图</a></h1>
<p><img src="15.spring_SpringCloud/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/nacos//images/nacosMap.jpg" alt="" /></p>
<ul>
<li>特性大图：要从功能特性，非功能特性，全面介绍我们要解的问题域的特性诉求</li>
<li>架构大图：通过清晰架构，让您快速进入 Nacos 世界</li>
<li>业务大图：利用当前特性可以支持的业务场景，及其最佳实践</li>
<li>生态大图：系统梳理 Nacos 和主流技术生态的关系</li>
<li>优势大图：展示 Nacos 核心竞争力</li>
<li>战略大图：要从战略到战术层面讲 Nacos 的宏观优势</li>
</ul>
<h1 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h1>
<h2 id="0版本选择"><a class="header" href="#0版本选择">0.版本选择</a></h2>
<p>您可以在Nacos的<a href="https://github.com/alibaba/nacos/releases">release notes</a>及<a href="https://nacos.io/zh-cn/blog/index.html">博客</a>中找到每个版本支持的功能的介绍，当前推荐的稳定版本为1.4.1。</p>
<h2 id="1预备环境准备"><a class="header" href="#1预备环境准备">1.预备环境准备</a></h2>
<ol>
<li>64 bit OS，支持 Linux/Unix/Mac/Windows，推荐选用 Linux/Unix/Mac。</li>
<li>64 bit JDK 1.8+；<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">下载</a> &amp; <a href="https://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/">配置</a>。</li>
<li>Maven 3.2.x+；<a href="https://maven.apache.org/download.cgi">下载</a> &amp; <a href="https://maven.apache.org/settings.html">配置</a>。</li>
</ol>
<h2 id="2下载源码或者安装包"><a class="header" href="#2下载源码或者安装包">2.下载源码或者安装包</a></h2>
<h3 id="从-github-上下载源码方式"><a class="header" href="#从-github-上下载源码方式">从 Github 上下载源码方式</a></h3>
<pre><code class="language-bash">git clone https://github.com/alibaba/nacos.git
cd nacos/
mvn -Prelease-nacos -Dmaven.test.skip=true clean install -U  
ls -al distribution/target/

// change the $version to your actual path
cd distribution/target/nacos-server-$version/nacos/bin
</code></pre>
<h3 id="下载编译后压缩包方式"><a class="header" href="#下载编译后压缩包方式">下载编译后压缩包方式</a></h3>
<p>您可以从 <a href="https://github.com/alibaba/nacos/releases">最新稳定版本</a> 下载 <code>nacos-server-$version.zip</code> 包。</p>
<pre><code class="language-sh">unzip nacos-server-$version.zip 或者 tar -xvf nacos-server-$version.tar.gz
cd nacos/bin
</code></pre>
<h2 id="3启动服务器"><a class="header" href="#3启动服务器">3.启动服务器</a></h2>
<h3 id="linuxunixmac"><a class="header" href="#linuxunixmac">Linux/Unix/Mac</a></h3>
<p>启动命令(standalone代表着单机模式运行，非集群模式):</p>
<pre><code>sh startup.sh -m standalone
</code></pre>
<p>如果您使用的是ubuntu系统，或者运行脚本报错提示[[符号找不到，可尝试如下运行：</p>
<pre><code>bash startup.sh -m standalone
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>启动命令(standalone代表着单机模式运行，非集群模式):</p>
<pre><code>cmd startup.cmd -m standalone
</code></pre>
<h1 id="服务注册发现和配置管理"><a class="header" href="#服务注册发现和配置管理">服务注册&amp;发现和配置管理</a></h1>
<h2 id="服务注册"><a class="header" href="#服务注册">服务注册</a></h2>
<pre><code class="language-sh">curl -X POST 'http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080'
</code></pre>
<h2 id="服务发现"><a class="header" href="#服务发现">服务发现</a></h2>
<pre><code class="language-sh">curl -X GET 'http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName'
</code></pre>
<h2 id="发布配置"><a class="header" href="#发布配置">发布配置</a></h2>
<pre><code class="language-sh">curl -X POST &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld&quot;
</code></pre>
<h2 id="获取配置"><a class="header" href="#获取配置">获取配置</a></h2>
<pre><code class="language-sh">curl -X GET &quot;http://192.168.1.172:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&quot;
</code></pre>
<h2 id="关闭服务器"><a class="header" href="#关闭服务器">关闭服务器</a></h2>
<pre><code>Linux/Unix/Mac
sh shutdown.sh

Windows
cmd shutdown.cmd

或者双击shutdown.cmd运行文件。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="与spring集成"><a class="header" href="#与spring集成">与Spring集成</a></h1>
<h2 id="配置中心"><a class="header" href="#配置中心">配置中心</a></h2>
<h3 id="依赖"><a class="header" href="#依赖">依赖</a></h3>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.3.5&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;
            &lt;artifactId&gt;nacos-spring-context&lt;/artifactId&gt;
            &lt;version&gt;1.0.0&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="spring配置"><a class="header" href="#spring配置">Spring配置</a></h3>
<pre><code class="language-java">package com.weisanju.nacos;

import com.alibaba.nacos.api.annotation.NacosProperties;
import com.alibaba.nacos.api.config.annotation.NacosValue;
import com.alibaba.nacos.spring.context.annotation.config.EnableNacosConfig;
import com.alibaba.nacos.spring.context.annotation.config.NacosPropertySource;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
@Configuration
@EnableNacosConfig(globalProperties = @NacosProperties(serverAddr = &quot;127.0.0.1:8848&quot;))
@NacosPropertySource(dataId = &quot;test.yml&quot;, autoRefreshed = true)
@ComponentScan(&quot;com.weisanju.nacos&quot;)
public class NacosConfig {
}


@NacosValue(value = &quot;${xjq}&quot;, autoRefreshed = true)
private String xjq;
</code></pre>
<h3 id="使用-2"><a class="header" href="#使用-2">使用</a></h3>
<pre><code class="language-java">package com.weisanju.nacos;

import com.alibaba.nacos.client.config.NacosConfigService;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class MainTest {
    public static void main(String[] args) throws InterruptedException {
        AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(NacosConfig.class);

        //NacosConfigService bean1 = annotationConfigApplicationContext.getBean(NacosConfigService.class);
        ComponentTest bean = annotationConfigApplicationContext.getBean(ComponentTest.class);

        while (true){
            System.out.println(bean.getXjq());
            Thread.sleep(1000);
        }
    }
}
</code></pre>
<h2 id="启动服务发现"><a class="header" href="#启动服务发现">启动服务发现</a></h2>
<pre><code>@EnableNacosDiscovery(globalProperties = @NacosProperties(serverAddr = &quot;127.0.0.1:8848&quot;))
//服务注入
@NacosInjected
NamingService namingService;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始-1"><a class="header" href="#快速开始-1">快速开始</a></h1>
<p>本文主要面向 <a href="https://spring.io/projects/spring-cloud">Spring Cloud</a> 的使用者，通过两个示例来介绍如何使用 Nacos 来实现分布式环境下的配置管理和服务注册发现。</p>
<p>关于 Nacos Spring Cloud 的详细文档请参看：<a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/wiki/Nacos-config">Nacos Config</a> 和 <a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/wiki/Nacos-discovery">Nacos Discovery</a>。</p>
<ul>
<li>
<p>通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-config 实现配置的动态变更。</p>
</li>
<li>
<p>通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现。</p>
</li>
</ul>
<h1 id="启动配置管理"><a class="header" href="#启动配置管理">启动配置管理</a></h1>
<h2 id="1配置依赖"><a class="header" href="#1配置依赖">1.配置依赖</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
    &lt;version&gt;${latest.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="language-xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
            &lt;version&gt;${spring-boot.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<h2 id="2配置注册中心"><a class="header" href="#2配置注册中心">2.配置注册中心</a></h2>
<p>在 <code>bootstrap.properties</code> 中配置 Nacos server 的地址和应用名</p>
<pre><code class="language-xml">spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.application.name=example
</code></pre>
<p>说明：之所以需要配置 <code>spring.application.name</code> ，是因为它是构成 Nacos 配置管理 <code>dataId</code>字段的一部分。</p>
<p>在 Nacos Spring Cloud 中，<code>dataId</code> 的完整格式如下：</p>
<pre><code class="language-plain">${prefix}-${spring.profiles.active}.${file-extension}
</code></pre>
<ul>
<li><code>prefix</code> 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</li>
<li><code>spring.profiles.active</code> 即为当前环境对应的 profile，详情可以参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles">Spring Boot文档</a>。 <strong>注意：当 <code>spring.profiles.active</code> 为空时，对应的连接符 <code>-</code> 也将不存在，dataId 的拼接格式变成 <code>${prefix}.${file-extension}</code></strong></li>
<li><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。目前只支持 <code>properties</code> 和 <code>yaml</code> 类型。</li>
</ul>
<h2 id="3注入"><a class="header" href="#3注入">3.注入</a></h2>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/hello&quot;)
public class HelloController {
    @Value(&quot;${niubi}&quot;)
    private String useLocalCache;

    @RequestMapping(&quot;/index&quot;)
    public String index(){
        return useLocalCache;
    }
}
</code></pre>
<p>通过 Spring Cloud 原生注解 <code>@RefreshScope</code> 实现配置自动更新：</p>
<h1 id="启动服务发现-1"><a class="header" href="#启动服务发现-1">启动服务发现</a></h1>
<h2 id="xml配置-1"><a class="header" href="#xml配置-1">XML配置</a></h2>
<h3 id="父项目"><a class="header" href="#父项目">父项目</a></h3>
<pre><code class="language-xml">    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
                &lt;version&gt;0.2.2.RELEASE&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;
                &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;
                &lt;version&gt;1.1.0&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;	
</code></pre>
<h3 id="服务提供者"><a class="header" href="#服务提供者">服务提供者</a></h3>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;
                    &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;
            &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
            &lt;version&gt;5.1.0.Final&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h3 id="服务消费者"><a class="header" href="#服务消费者">服务消费者</a></h3>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;
                    &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;
            &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h2 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h2>
<h3 id="服务提供者-1"><a class="header" href="#服务提供者-1">服务提供者</a></h3>
<pre><code class="language-properties">server.port=8080
spring.application.name=service-provider
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
</code></pre>
<h3 id="服务消费者-1"><a class="header" href="#服务消费者-1">服务消费者</a></h3>
<pre><code class="language-properties">server.port=8081
spring.application.name=service-consumer
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
</code></pre>
<h2 id="代码"><a class="header" href="#代码">代码</a></h2>
<h3 id="服务提供者-2"><a class="header" href="#服务提供者-2">服务提供者</a></h3>
<pre><code class="language-java">package com.weisanju.nacosProvider;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@EnableDiscoveryClient
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
    @RestController
    static class EchoController {
        @RequestMapping(value = &quot;/echo/{string}&quot;, method = RequestMethod.GET)
        public String echo(@PathVariable String string) {
            return &quot;Hello Nacos Discovery 8080&quot; + string;
        }
    }
}

</code></pre>
<h3 id="服务消费者-2"><a class="header" href="#服务消费者-2">服务消费者</a></h3>
<pre><code class="language-java">package com.weisanju.nacConsumer;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@EnableDiscoveryClient
public class NacosConsumerApplication {

    @LoadBalanced
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(NacosConsumerApplication.class, args);
    }

    @RestController
    public static class TestController {

        private final RestTemplate restTemplate;

        @Autowired
        public TestController(RestTemplate restTemplate) {
            this.restTemplate = restTemplate;
        }

        @RequestMapping(value = &quot;/echo/{str}&quot;, method = RequestMethod.GET)
        public String echo(@PathVariable String str) {
            return restTemplate.getForObject(&quot;http://service-provider/echo/&quot; + str, String.class);
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-8"><a class="header" href="#概述-8">概述</a></h1>
<h2 id="简介-9"><a class="header" href="#简介-9">简介</a></h2>
<ul>
<li><em>SpringCloudGateWay</em> 提供了 构建API网关的 一系列库，基于 <em>SpringWebFlux</em></li>
<li>SpringCloud <em>Gateway</em> 旨在提供简单 有效的 API路由，并重点关注  安全，监控/指标和弹性。</li>
</ul>
<h1 id="特性-1"><a class="header" href="#特性-1">特性</a></h1>
<ul>
<li>基于Spring5，基于响应式，基于springBoot2.0</li>
<li>可以对任意请求属性 匹配 路由</li>
<li>Circuit Breaker即断路器 集成</li>
<li>服务发现客户端集成</li>
<li>请求控制</li>
<li>限流</li>
<li>URL重写</li>
</ul>
<h1 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h1>
<p><img src="15.spring_SpringCloud/%E7%BD%91%E5%85%B3/springCloudGateway/../../../images/spring_cloud_gateway_diagram.png" alt="" /></p>
<ol>
<li>
<p>客户端向Spring Cloud Gateway发出请求</p>
</li>
<li>
<p>如果网关Handler Mapping  确定请求与路由匹配，则将其发送到网关WebHandler。</p>
</li>
<li>
<p>该handler 通过特定于请求的过滤器链来运行请求。</p>
</li>
<li>
<p>filters 由虚线分隔的原因是，filters 可以在发送代理请求之前和之后都运行逻辑。
所有“前置”过滤器逻辑均被执行。然后发出代理请求。发出代理请求后，将运行“后”过滤器逻辑。</p>
</li>
</ol>
<h1 id="源码分析-6"><a class="header" href="#源码分析-6">源码分析</a></h1>
<blockquote>
<p>是基于 WebFlux 的 <em>DispatcherHandler</em> 下的一个 <em>HandlerMapping</em>,DispatherHandler本身不负责处理具体的业务逻辑，只负责寻找<em>HandlerMapping</em></p>
</blockquote>
<ul>
<li><em>SpringGateWay</em> 实现了 <em>RoutePredicateHandlerMapping</em> </li>
</ul>
<h2 id="类分析"><a class="header" href="#类分析">类分析</a></h2>
<h3 id="routepredicatehandlermapping类图"><a class="header" href="#routepredicatehandlermapping类图"><strong>RoutePredicateHandlerMapping类图</strong></a></h3>
<pre><code class="language-mermaid">classDiagram
class RoutePredicateHandlerMapping{
	FilteringWebHandler//负责处理具体业务逻辑,由 SimpleHandlerAdatper调用
	RouteLocator //负责具体路由的查找
}
</code></pre>
<h3 id="route相关类图"><a class="header" href="#route相关类图"><strong>Route相关类图</strong></a></h3>
<pre><code class="language-mermaid">classDiagram
class Route{
	id:路由信息
	uri:
	order:排序
	AsyncPredicate:匹配
	gatewayFilters:过滤器
	metadata:元数据
}

class AsyncBuilder{
		
}

class RouteDefinition{
	id:id
	predicates:异步断言
}

class GatewayFilter{
	filter(ServerWebExchange exchange, GatewayFilterChain chain) Mono~Void~
}
&lt;&lt;interface&gt;&gt; GatewayFilter
</code></pre>
<h3 id="routelocator"><a class="header" href="#routelocator"><strong>RouteLocator</strong></a></h3>
<pre><code class="language-mermaid">classDiagram
class RouteLocator  {
	getRoutes() Flux~Route~
}
&lt;&lt;interface&gt;&gt; RouteLocator

RouteLocator..|&gt;RouteDefinitionRouteLocator:根据Route定义 生成Route
RouteLocator..|&gt;CompositeRouteLocator:委托其他Locator处理
RouteLocator..|&gt;CachingRouteLocator:基于缓存与委托的路由查找
</code></pre>
<h3 id="routedefinitionlocator"><a class="header" href="#routedefinitionlocator">RouteDefinitionLocator</a></h3>
<pre><code class="language-mermaid">classDiagram
class RouteDefinitionLocator{
	getRouteDefinitions() Flux~RouteDefinition~
}
&lt;&lt;interface&gt;&gt;RouteDefinitionLocator

RouteDefinitionLocator&lt;|--CachingRouteDefinitionLocator:基于缓存与委托的Bean定义查找
RouteDefinitionLocator&lt;|--CompositeRouteDefinitionLocator:自动生成路由ID与委托的Route定义查找
RouteDefinitionLocator&lt;|--PropertiesRouteDefinitionLocator:GatewayProperties.routes查找
RouteDefinitionLocator&lt;|--DiscoveryClientRouteDefinitionLocator:从服务发现客户端查找
RouteDefinitionLocator&lt;|--InMemoryRouteDefinitionRepository:内存的Route定义可增删
</code></pre>
<h3 id="gatewayfilter"><a class="header" href="#gatewayfilter">GatewayFilter</a></h3>
<blockquote>
<p>由工厂模式构建</p>
</blockquote>
<pre><code class="language-mermaid">classDiagram
class GatewayFilterFactory{
	apply(C config) GatewayFilter
}
&lt;&lt;interface&gt;&gt;GatewayFilterFactory

GatewayFilterFactory&lt;|--AbstractGatewayFilterFactory:新增NameConfig
GatewayFilterFactory&lt;|--PrefixPathGatewayFilterFactory:添加新前缀
GatewayFilterFactory&lt;|--RetryGatewayFilterFactory:重试
GatewayFilterFactory&lt;|--RedirectToGatewayFilterFactory:重定向
GatewayFilterFactory&lt;|--RequestRateLimiterGatewayFilterFactory:限流
</code></pre>
<h3 id="globalfilter"><a class="header" href="#globalfilter">GlobalFilter</a></h3>
<blockquote>
<p>全局过滤器</p>
</blockquote>
<pre><code class="language-mermaid">classDiagram
class GlobalFilter {
	 filter(ServerWebExchange exchange, GatewayFilterChain chain) 	Mono~Void~
}
&lt;&lt;interface&gt;&gt; GlobalFilter
GlobalFilter&lt;|--LoadBalancerClientFilter:负载均衡，进行服务发现并重组URL
GlobalFilter&lt;|--GatewayMetricsFilter:指标，性能统计
GlobalFilter&lt;|--WebClientHttpRoutingFilter:使用web Client请求
GlobalFilter&lt;|--ForwardRoutingFilter:转发
</code></pre>
<p><strong>AsyncBuilder</strong>：构建 响应式的 <em>Route</em></p>
<p><em><strong>RouteDefinition</strong></em>：构建者的数据来源</p>
<p><em><strong>RouteDefinitionLocator</strong></em>： route定义查找</p>
<p><em><strong>Route</strong></em> ：路由的定义</p>
<p><em><strong>RouteLocator</strong></em>:查找<em>Route</em></p>
<p><strong>重定向代码</strong></p>
<pre><code class="language-java">public Mono&lt;Void&gt; filter(ServerWebExchange exchange,
                         GatewayFilterChain chain) {
    if (!exchange.getResponse().isCommitted()) {
        setResponseStatus(exchange, httpStatus);

        final ServerHttpResponse response = exchange.getResponse();
        response.getHeaders().set(HttpHeaders.LOCATION, uri.toString());
        return response.setComplete();
    }
    return Mono.empty();
}
</code></pre>
<h3 id="filteringwebhandler"><a class="header" href="#filteringwebhandler">FilteringWebHandler</a></h3>
<p><strong>源码</strong></p>
<pre><code class="language-java">	@Override
	public Mono&lt;Void&gt; handle(ServerWebExchange exchange) {
		Route route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR);
		List&lt;GatewayFilter&gt; gatewayFilters = route.getFilters();

		List&lt;GatewayFilter&gt; combined = new ArrayList&lt;&gt;(this.globalFilters);
		combined.addAll(gatewayFilters);
		// TODO: needed or cached?
		AnnotationAwareOrderComparator.sort(combined);

		if (logger.isDebugEnabled()) {
			logger.debug(&quot;Sorted gatewayFilterFactories: &quot; + combined);
		}

		return new DefaultGatewayFilterChain(combined).filter(exchange);
	}
</code></pre>
<h2 id="流程图-1"><a class="header" href="#流程图-1"><strong>流程图</strong></a></h2>
<pre><code class="language-mermaid">graph
c[DispatcherHandler]
d[RoutePredicateHandlerMapping]
e[FilteringWebHandler]
f[GatewayFilter]
a[DefaultGatewayFilterChain]

c-- 查找HandlerMapping --&gt;d
d-- 根据Locator,Predict查找Route,并保存该路由 --&gt; e
e-- 取出Route,取出Route上的Filter,并执行 --&gt; f
f-- 使用过滤器执行链,执行 --&gt; a
</code></pre>
<h1 id="使用案例"><a class="header" href="#使用案例">使用案例</a></h1>
<blockquote>
<p>以 spring-cloud-nacos为例</p>
</blockquote>
<h2 id="依赖-1"><a class="header" href="#依赖-1">依赖</a></h2>
<pre><code class="language-xml">//nacos配置中心
&lt;!-- SpringCloud Ailibaba Nacos Config --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
            &lt;version&gt;0.9.0.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

//如果不引用这个的话，无法自动加载服务注册
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
        &lt;/dependency&gt;

//ncaos服务注册与发现
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;
                    &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;
            &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<pre><code class="language-properties">server.port=8084
spring.application.name=gateways
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
spring.cloud.nacos.config.server-addr=127.0.0.1:8848

//使用nacos作为注册中心
spring.cloud.nacos.config.file-extension=yml
spring.cloud.nacos.config.shared-dataids=${spring.application.name}.${spring.cloud.nacos.config.file-extension}
spring.cloud.nacos.config.refreshable-dataids=${spring.application.name}.${spring.cloud.nacos.config.file-extension}
</code></pre>
<h2 id="使用-3"><a class="header" href="#使用-3">使用</a></h2>
<h3 id="代码配置"><a class="header" href="#代码配置">代码配置</a></h3>
<pre><code class="language-java">package com.weisanju.gateway;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.server.RequestPredicates;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.RouterFunctions;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Mono;

import java.util.Map;

@SpringBootApplication
//@Import(AdditionalRoutesImportSelector.class)
public class GatewayApplication {
    public static final String HELLO_FROM_FAKE_ACTUATOR_METRICS_GATEWAY_REQUESTS = &quot;hello from fake /actuator/metrics/gateway.requests&quot;;
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
    @Value(&quot;${test.uri:http://httpbin.org:80}&quot;)
    String uri;


    @Value(&quot;${xjq}&quot;)
    String xjq;

    @Bean
    public RouterFunction&lt;ServerResponse&gt; testWhenMetricPathIsNotMeet() {
        RouterFunction&lt;ServerResponse&gt; route = RouterFunctions
                .route(RequestPredicates.path(&quot;/actuator/metrics/gateway.requests&quot;), request -&gt; ServerResponse.ok()
                        .body(BodyInserters.fromObject(HELLO_FROM_FAKE_ACTUATOR_METRICS_GATEWAY_REQUESTS)));
        return route;
    }

    @Bean
    public RouterFunction&lt;ServerResponse&gt; testFunRouterFunction() {
        RouterFunction&lt;ServerResponse&gt; route = RouterFunctions.route(RequestPredicates.path(&quot;/testfun&quot;),
                request -&gt; ServerResponse.ok().body(BodyInserters.fromObject(&quot;hello&quot;)));
        return route;
    }

    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        //@formatter:off
        // String uri = &quot;http://httpbin.org:80&quot;;
        // String uri = &quot;http://localhost:9080&quot;;
        return builder.routes()
                .route(r -&gt; r.host(&quot;**.abc.org&quot;).and().path(&quot;/anything/png&quot;)
                        .filters(f -&gt;
                                f.prefixPath(&quot;/httpbin&quot;)
                                        .addResponseHeader(&quot;X-TestHeader&quot;, &quot;foobar&quot;))
                        .uri(uri)
                )
                .route(&quot;read_body_pred&quot;, r -&gt; r.host(&quot;*.readbody.org&quot;)
                        .and().readBody(String.class,
                                s -&gt; s.trim().equalsIgnoreCase(&quot;hi&quot;))
                        .filters(f -&gt; f.prefixPath(&quot;/httpbin&quot;)
                                .addResponseHeader(&quot;X-TestHeader&quot;, &quot;read_body_pred&quot;)
                        ).uri(uri)
                )
                .route(&quot;rewrite_request_obj&quot;, r -&gt; r.host(&quot;*.rewriterequestobj.org&quot;)
                        .filters(f -&gt; f.prefixPath(&quot;/httpbin&quot;)
                                .addResponseHeader(&quot;X-TestHeader&quot;, &quot;rewrite_request&quot;)
                                .modifyRequestBody(String.class, Hello.class, (exchange, s) -&gt; {
                                    return Mono.just(new Hello(s.toUpperCase()));
                                })
                        ).uri(uri)
                )
                .route(&quot;rewrite_request_upper&quot;, r -&gt; r.host(&quot;*.rewriterequestupper.org&quot;)
                        .filters(f -&gt; f.prefixPath(&quot;/httpbin&quot;)
                                .addResponseHeader(&quot;X-TestHeader&quot;, &quot;rewrite_request_upper&quot;)
                                .modifyRequestBody(String.class, String.class,
                                        (exchange, s) -&gt; {
                                            return Mono.just(s.toUpperCase() + s.toUpperCase());
                                        })
                        ).uri(uri)
                )
                .route(&quot;rewrite_response_upper&quot;, r -&gt; r.host(&quot;*.rewriteresponseupper.org&quot;)
                        .filters(f -&gt; f.prefixPath(&quot;/httpbin&quot;)
                                .addResponseHeader(&quot;X-TestHeader&quot;, &quot;rewrite_response_upper&quot;)
                                .modifyResponseBody(String.class, String.class,
                                        (exchange, s) -&gt; {
                                            return Mono.just(s.toUpperCase());
                                        })
                        ).uri(uri)
                )
                .route(&quot;rewrite_empty_response&quot;, r -&gt; r.host(&quot;*.rewriteemptyresponse.org&quot;)
                        .filters(f -&gt; f.prefixPath(&quot;/httpbin&quot;)
                                .addResponseHeader(&quot;X-TestHeader&quot;, &quot;rewrite_empty_response&quot;)
                                .modifyResponseBody(String.class, String.class,
                                        (exchange, s) -&gt; {
                                            if (s == null) {
                                                return Mono.just(&quot;emptybody&quot;);
                                            }
                                            return Mono.just(s.toUpperCase());
                                        })

                        ).uri(uri)
                )
                .route(&quot;rewrite_response_fail_supplier&quot;, r -&gt; r.host(&quot;*.rewriteresponsewithfailsupplier.org&quot;)
                        .filters(f -&gt; f.prefixPath(&quot;/httpbin&quot;)
                                .addResponseHeader(&quot;X-TestHeader&quot;, &quot;rewrite_response_fail_supplier&quot;)
                                .modifyResponseBody(String.class, String.class,
                                        (exchange, s) -&gt; {
                                            if (s == null) {
                                                return Mono.error(new IllegalArgumentException(&quot;this should not happen&quot;));
                                            }
                                            return Mono.just(s.toUpperCase());
                                        })
                        ).uri(uri)
                )
                .route(&quot;rewrite_response_obj&quot;, r -&gt; r.host(&quot;*.rewriteresponseobj.org&quot;)
                        .filters(f -&gt; f.prefixPath(&quot;/httpbin&quot;)
                                .addResponseHeader(&quot;X-TestHeader&quot;, &quot;rewrite_response_obj&quot;)
                                .modifyResponseBody(Map.class, String.class, MediaType.TEXT_PLAIN_VALUE,
                                        (exchange, map) -&gt; {
                                            Object data = map.get(&quot;data&quot;);
                                            return Mono.just(data.toString());
                                        })
                                .setResponseHeader(&quot;Content-Type&quot;, MediaType.TEXT_PLAIN_VALUE)
                        ).uri(uri)
                )
                .route(r -&gt; r.path(&quot;/image/webp&quot;)
                        .filters(f -&gt;
                                f.prefixPath(&quot;/httpbin&quot;)
                                        .addResponseHeader(&quot;X-AnotherHeader&quot;, &quot;baz&quot;))
                        .uri(uri)
                ).route(&quot;xjqService&quot;,r-&gt;r.path(&quot;/xjq/**&quot;).uri(&quot;lb://service-xjq&quot;))
/*                .route(r -&gt; r.order(-1)
                        .host(&quot;**.throttle.org&quot;).and().path(&quot;/get&quot;)
                        .filters(f -&gt; f.prefixPath(&quot;/httpbin&quot;)
                                .filter(new ThrottleGatewayFilter()
                                        .setCapacity(1)
                                        .setRefillTokens(1)
                                        .setRefillPeriod(10)
                                        .setRefillUnit(TimeUnit.SECONDS)))
                        .uri(uri)
                )*/
                .build();
        //@formatter:on
    }
    static class Hello {

        String message;

        Hello() {
        }

        Hello(String message) {
            this.message = message;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }

    }

}
</code></pre>
<h3 id="配置文件配置"><a class="header" href="#配置文件配置">配置文件配置</a></h3>
<pre><code class="language-yml">spring:
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true
      routes:
        # 认证中心
        - id: xjqService
          uri: lb://service-xjq
          predicates:
            - Path=/xjq/**
        - id: xdhService
          uri: lb://service-xdh
          predicates:
            - Path=/xdh/**
</code></pre>
<h3 id="配置中心配置"><a class="header" href="#配置中心配置">配置中心配置</a></h3>
<pre><code>.route(&quot;xjqService&quot;,r-&gt;r.path(&quot;/xjq/**&quot;).uri(&quot;lb://service-xjq&quot;))
</code></pre>
<h2 id="过滤器"><a class="header" href="#过滤器">过滤器</a></h2>
<h3 id="全局过滤器"><a class="header" href="#全局过滤器">全局过滤器</a></h3>
<h3 id="专用过滤器"><a class="header" href="#专用过滤器">专用过滤器</a></h3>
<pre><code class="language-yml">      routes:
        # 认证中心
        - id: xjqService
          uri: lb://service-xjq
          predicates:
            - Path=/xjq/**
          filters:
            # 验证码处理
            - name: BlackListUrlFilter
              args:
                blacklist: 
                  - /xjq/123
                  - /xjq/456
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-mermaid">graph
a[RouteLocatorBuilder]
b[RouteLocatorBuilder.Builder]
c[Route.AsyncBuilder]
d[RouteSpec]
e[PredicateSpec]
a -- 专门Build Route--&gt; b
b -- 中间对象--&gt; d
d -- 构建Spec --&gt; e
e -- 异步PredicateBuilder --&gt;  c
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cache-abstraction"><a class="header" href="#cache-abstraction">Cache Abstraction</a></h1>
<ol>
<li>
<p>从3.1版开始，Spring框架提供了对将缓存透明添加到现有Spring应用程序的支持。与事务支持类似，缓存抽象允许对各种缓存解决方案的一致使用，而对代码的影响最小。</p>
</li>
<li>
<p>从Spring 4.1开始，通过支持JSR-107注释和更多自定义选项，对缓存抽象进行了显着扩展。</p>
</li>
</ol>
<h1 id="了解缓存抽象"><a class="header" href="#了解缓存抽象">了解缓存抽象</a></h1>
<h2 id="cache-vs-buffer"><a class="header" href="#cache-vs-buffer"><strong>Cache vs Buffer</strong></a></h2>
<ul>
<li>术语“缓冲区”和“缓存”倾向于互换使用。但是请注意，它们代表不同的事物。</li>
<li>一般，缓冲区用作快速实体和慢速实体之间的数据的中间临时存储。由于一方必须等待另一方（这会影响性能）</li>
<li>缓冲区通过允许立即移动整个数据块而不是小块数据来缓解这种情况。数据只能从缓冲区写入和读取一次。此外，缓冲区对于至少一个知道缓冲区的一方是可见的。</li>
<li>另一方面，根据定义，缓存是隐藏的，任何一方都不知道发生了缓存。它还可以提高性能，但是可以通过快速读取多次相同数据来实现。</li>
<li>本质上，缓存抽象 是对 方法的缓存，减少方法的执行次数。对于方法的调用者来说是透明的</li>
<li>要保证 方法是无状态的 </li>
</ul>
<h2 id="spring缓存抽象"><a class="header" href="#spring缓存抽象">spring缓存抽象</a></h2>
<blockquote>
<p>spring对 缓存的抽象 是通过对 <em>org.springframework.cache.Cache</em> <code>and</code>  <em>org.springframework.cache.CacheManager</em> </p>
</blockquote>
<p><strong>Spring提供了该抽象的一些实现：</strong></p>
<ul>
<li>JDK <code>java.util.concurrent.ConcurrentMap</code> based caches, </li>
<li><a href="https://www.ehcache.org/">Ehcache 2.x</a>, </li>
<li>Gemfire cache, </li>
<li><a href="https://github.com/ben-manes/caffeine/wiki">Caffeine</a>,</li>
<li>JSR-107 compliant caches (such as Ehcache 3.x). </li>
</ul>
<p><strong>多进程环境的缓存</strong></p>
<ul>
<li>如果您具有多进程环境（即，一个应用程序部署在多个节点上），则需要相应地配置缓存提供程序。根据您的用例，在几个节点上复制相同数据就足够了。
但是，如果在应用程序过程中更改数据，则可能需要启用其他传播机制。</li>
</ul>
<p><strong>多线程环境的缓存</strong></p>
<p>缓存某一个对象时， 直接等 同于 典型的  缓存交互程序中的  “如果找不到，然后继续执行 之后并放入”的 代码块。</p>
<p>没有应用锁，几个线程可能会尝试同时加载同一项目。驱逐同样如此。如果多个线程试图同时更新或逐出数据，则可能使用了旧数据。</p>
<p><strong>要使用缓存抽象，您需要注意两个方面：</strong></p>
<ul>
<li>Caching declaration（申明缓存）: Identify the methods that need to be cached and their policy.</li>
<li>Cache configuration（配置缓存）: The backing cache where the data is stored and from which it is read.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="申明式缓存的注解"><a class="header" href="#申明式缓存的注解">申明式缓存的注解</a></h1>
<ul>
<li><code>@Cacheable</code>: Triggers cache population. 触发缓存</li>
<li><code>@CacheEvict</code>: Triggers cache eviction. 触发驱逐</li>
<li><code>@CachePut</code>: Updates the cache without interfering with the method execution. 更新缓存，不会影响方法的执行</li>
<li><code>@Caching</code>: Regroups multiple cache operations to be applied on a method.重新组合要在一个方法上应用的多个缓存操作</li>
<li><code>@CacheConfig</code>: Shares some common cache-related settings at class-level. 在类级别共享一些与缓存有关的常见设置。</li>
</ul>
<h1 id="cacheable-1"><a class="header" href="#cacheable-1">@Cacheable</a></h1>
<h2 id="缓存区"><a class="header" href="#缓存区">缓存区</a></h2>
<p><em>cacheNames</em> 表示 选用的 缓存区名称</p>
<h2 id="default-key-generation"><a class="header" href="#default-key-generation">Default Key Generation</a></h2>
<p><strong>Key生成策略</strong></p>
<ul>
<li>如果没有给出参数，则返回<code>SimpleKey.EMPTY</code>。</li>
<li>如果仅给出一个参数，则返回该实例。作为 <em>key</em></li>
<li>如果给定多个参数，则返回包含所有参数的“ SimpleKey”。</li>
</ul>
<p><strong>自定义策略</strong></p>
<ul>
<li>只要参数具有自然键并实现有效的hashCode（）和equals（）方法，该方法就适用于大多数用例。如果不是这种情况，则需要更改策略。</li>
<li>自定义key生成策略需要实现org.springframework.cache.interceptor.KeyGenerator接口。</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>随着Spring 4.0的发布，默认的密钥生成策略发生了变化。 </li>
<li>Spring的早期版本使用密钥生成策略，对于多个密钥参数，该策略仅考虑参数的hashCode（）而不考虑equals（）。这可能会导致意外的键冲突（有关背景，请参阅SPR-10237）。</li>
<li>新的SimpleKeyGenerator在这种情况下使用复合键</li>
</ul>
<h2 id="custom-key-generation-declaration"><a class="header" href="#custom-key-generation-declaration">Custom Key Generation Declaration</a></h2>
<blockquote>
<p>使用 <em>SpringEL</em> 去申明键 生成策略 是推荐的</p>
</blockquote>
<pre><code class="language-java">@Cacheable(cacheNames=&quot;books&quot;, key=&quot;#isbn&quot;)
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@Cacheable(cacheNames=&quot;books&quot;, key=&quot;#isbn.rawNumber&quot;)
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@Cacheable(cacheNames=&quot;books&quot;, key=&quot;T(someType).hash(#isbn)&quot;)
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
</code></pre>
<p><strong>基于springbean的 keygenerator</strong></p>
<blockquote>
<p>如果key生成策略很复杂或者 需要多出共享，可以自定义一个 <code>keyGenerator</code>  并加入到spring容器管理</p>
</blockquote>
<pre><code class="language-java">@Cacheable(cacheNames=&quot;books&quot;, keyGenerator=&quot;myKeyGenerator&quot;)
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
</code></pre>
<p>key和keyGenerator参数是互斥的，同时指定两个参数的操作将导致异常。</p>
<h2 id="default-cache-resolution"><a class="header" href="#default-cache-resolution">Default Cache Resolution</a></h2>
<p>缓存抽象使用一个简单的CacheResolver，该缓存通过使用配置的CacheManager检索在操作级别定义的缓存。要提供其他默认缓存解析器，您需要实现<em>org.springframework.cache.interceptor.CacheResolver</em>接口。</p>
<h2 id="custom-cache-resolution"><a class="header" href="#custom-cache-resolution">Custom Cache Resolution</a></h2>
<pre><code class="language-java">@Cacheable(cacheNames=&quot;books&quot;, cacheManager=&quot;anotherCacheManager&quot;) 
public Book findBook(ISBN isbn) {...}

@Cacheable(cacheResolver=&quot;runtimeCacheResolver&quot;) 
public Book findBook(ISBN isbn) {...}
Specifying the CacheResolver.

</code></pre>
<h2 id="synchronized-caching"><a class="header" href="#synchronized-caching">Synchronized Caching</a></h2>
<ul>
<li>在多线程环境中，可能会为同一参数同时调用某些操作（通常是在启动时）。</li>
<li>默认情况下，缓存抽象不会锁定任何内容，并且可能会多次计算相同的值，从而破坏了缓存的目的。</li>
<li>对于那些特殊情况，您可以使用sync属性来指示基础缓存提供程序在计算值时锁定缓存条目。</li>
<li>结果，只有一个线程正在忙于计算该值，而其他线程则被阻塞，直到在缓存中更新该条目为止。
以下示例显示如何使用sync属性：</li>
</ul>
<pre><code class="language-java">@Cacheable(cacheNames=&quot;foos&quot;, sync=true) 
public Foo executeExpensiveOperation(String id) {...}
</code></pre>
<h2 id="条件缓存"><a class="header" href="#条件缓存">条件缓存</a></h2>
<p><strong>el布尔表达式</strong></p>
<pre><code class="language-java">@Cacheable(cacheNames=&quot;book&quot;, condition=&quot;#name.length() &lt; 32&quot;) 
public Book findBook(String name)
</code></pre>
<p><strong>unless否决</strong></p>
<pre><code class="language-java">@Cacheable(cacheNames=&quot;book&quot;, condition=&quot;#name.length() &lt; 32&quot;, unless=&quot;#result.hardback&quot;) 
public Book findBook(String name)
</code></pre>
<p><strong>Optional支持</strong></p>
<pre><code class="language-java">@Cacheable(cacheNames=&quot;book&quot;, condition=&quot;#name.length() &lt; 32&quot;, unless=&quot;#result?.hardback&quot;)
public Optional&lt;Book&gt; findBook(String name)
</code></pre>
<h2 id="spel表达式可用的上下文"><a class="header" href="#spel表达式可用的上下文">SpEL表达式可用的上下文</a></h2>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Location</th><th style="text-align: left">Description</th><th style="text-align: left">Example</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>methodName</code></td><td style="text-align: left">Root object</td><td style="text-align: left">The name of the method being invoked，方法名</td><td style="text-align: left"><code>#root.methodName</code></td></tr>
<tr><td style="text-align: left"><code>method</code></td><td style="text-align: left">Root object</td><td style="text-align: left">The method being invoked，正在被调用的方法</td><td style="text-align: left"><code>#root.method.name</code></td></tr>
<tr><td style="text-align: left"><code>target</code></td><td style="text-align: left">Root object</td><td style="text-align: left">The target object being invoked 被调用方法的实例对象</td><td style="text-align: left"><code>#root.target</code></td></tr>
<tr><td style="text-align: left"><code>targetClass</code></td><td style="text-align: left">Root object</td><td style="text-align: left">The class of the target being invoked 被调用方法的实例对象的class</td><td style="text-align: left"><code>#root.targetClass</code></td></tr>
<tr><td style="text-align: left"><code>args</code></td><td style="text-align: left">Root object</td><td style="text-align: left">The arguments (as array) used for invoking the target 调用参数</td><td style="text-align: left"><code>#root.args[0]</code></td></tr>
<tr><td style="text-align: left"><code>caches</code></td><td style="text-align: left">Root object</td><td style="text-align: left">Collection of caches against which the current method is run，运行当前方法的缓存的集合</td><td style="text-align: left"><code>#root.caches[0].name</code></td></tr>
<tr><td style="text-align: left">Argument name</td><td style="text-align: left">Evaluation context</td><td style="text-align: left">Name of any of the method arguments. If the names are not available (perhaps due to having no debug information), the argument names are also available under the <code>#a&lt;#arg&gt;</code> where <code>#arg</code> stands for the argument index (starting from <code>0</code>).</td><td style="text-align: left"><code>#iban</code> or <code>#a0</code> (you can also use <code>#p0</code> or <code>#p&lt;#arg&gt;</code> notation as an alias).</td></tr>
<tr><td style="text-align: left"><code>result</code></td><td style="text-align: left">Evaluation context</td><td style="text-align: left">方法返回值，Only available in <code>unless</code> expressions, <br /><code>cache put</code> expressions (to compute the <code>key</code>), or <br /><code>cache evict</code> expressions (when <code>beforeInvocation</code> is <code>false</code>). For supported wrappers (such as <code>Optional</code>), <code>#result</code> refers to the actual object, not the wrapper.</td><td style="text-align: left"><code>#result</code></td></tr>
</tbody></table>
<h1 id="cacheput-1"><a class="header" href="#cacheput-1">@CachePut</a></h1>
<ul>
<li>当需要在不影响方法执行的情况下更新缓存时，可以使用@CachePut 注解。</li>
<li>也就是说，始终调用该方法，并将其结果放入缓存中（根据@CachePut选项）。</li>
<li>它支持与@Cacheable相同的选项，应用于缓存填充，而不是方法流优化。</li>
</ul>
<p>以下示例使用@CachePut批注：</p>
<p><strong>无论什么时候都会 填充缓存</strong></p>
<pre><code class="language-java">@CachePut(cacheNames=&quot;book&quot;, key=&quot;#isbn&quot;)
public Book updateBook(ISBN isbn, BookDescriptor descriptor)
</code></pre>
<p><strong>@CachePut和@Cacheable 不要同时使用</strong></p>
<h1 id="cacheevict-1"><a class="header" href="#cacheevict-1">@CacheEvict</a></h1>
<ul>
<li>@ CacheEvict需要指定一个或多个受操作影响的缓存，允许指定自定义缓存和键解析或条件</li>
<li>并具有一个额外的参数（allEntries），该参数指示是否在整个缓存范围内逐出需要执行，而不仅仅是输入驱逐（基于密钥）。</li>
</ul>
<p>下面的示例从工作簿缓存中逐出所有条目：</p>
<pre><code class="language-java">@CacheEvict(cacheNames=&quot;books&quot;, allEntries=true) 
public void loadBooks(InputStream batch)
</code></pre>
<ul>
<li>您还可以使用 <em>beforeInvocation</em> 属性指示驱逐是在调用方法之后（默认）还是在调用方法之前发生。</li>
<li>前者提供与其余批注相同的语义：方法成功完成后，将对缓存执行操作（在这种情况下为逐出）。如果该方法未运行（可能已缓存）或引发了异常，则不会发生驱逐。</li>
<li>后者（beforeInvocation = true）导致逐出总是在调用该方法之前发生。在不需要将逐出与方法结果联系在一起的情况下，这很有用。</li>
<li>void方法可与@CacheEvict一起使用-由于这些方法充当触发器，因此将忽略返回值（因为它们不与缓存交互）。 
@Cacheable并非如此，@ Cacheable将数据添加到缓存或更新缓存中的数据，因此需要结果。</li>
</ul>
<h1 id="caching-1"><a class="header" href="#caching-1">@Caching</a></h1>
<ul>
<li>有时，需要指定相同类型的多个注解（例如@CacheEvict或@CachePut），</li>
<li>例如，因为不同缓存之间的条件或键表达式不同。 
@Caching允许在同一方法上使用多个嵌套的@ Cacheable，@ CachePut和@CacheEvict批注。
下面的示例使用两个@CacheEvict批注：</li>
</ul>
<pre><code class="language-java">@Caching(evict = { @CacheEvict(&quot;primary&quot;), @CacheEvict(cacheNames=&quot;secondary&quot;, key=&quot;#p0&quot;) })
public Book importBooks(String deposit, Date date)
</code></pre>
<h2 id="cacheconfig-1"><a class="header" href="#cacheconfig-1">@CacheConfig</a></h2>
<p><strong>全局统一 缓存配置</strong></p>
<pre><code class="language-java">@CacheConfig(&quot;books&quot;) 
public class BookRepositoryImpl implements BookRepository {

    @Cacheable
    public Book findBook(ISBN isbn) {...}
}
</code></pre>
<ul>
<li>@CacheConfig是一个类级别的注解，它允许共享缓存名称，自定义KeyGenerator，自定义CacheManager和自定义CacheResolver。
将此注释放在类上不会打开任何缓存操作。</li>
<li>操作级别的自定义始终会覆盖@CacheConfig上设置的自定义。因此，这为每个缓存操作提供了三个定制级别：
<ul>
<li>Globally configured, available for <code>CacheManager</code>, <code>KeyGenerator</code>.</li>
<li>At the class level, using <code>@CacheConfig</code>.</li>
<li>At the operation level.</li>
</ul>
</li>
</ul>
<h1 id="enablecaching"><a class="header" href="#enablecaching">@EnableCaching</a></h1>
<p>必须声明性地启用缓存功能</p>
<pre><code class="language-java">@Configuration
@EnableCaching
public class AppConfig {
}
</code></pre>
<p>另外，对于XML配置，可以使用cache：annotation-driven元素：</p>
<pre><code class="language-java">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/cache https://www.springframework.org/schema/cache/spring-cache.xsd&quot;&gt;

        &lt;cache:annotation-driven/&gt;
&lt;/beans&gt;
</code></pre>
<p>更多自定义实现 请实现 CachingConfigurer所需的高级自定义（使用Java配置）</p>
<p><strong>可选配置</strong></p>
<table><thead><tr><th style="text-align: left">XML Attribute</th><th style="text-align: left">Annotation Attribute</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>cache-manager</code></td><td style="text-align: left">N/A (see the <a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc)</td><td style="text-align: left"><code>cacheManager</code></td><td style="text-align: left">The name of the cache manager to use. A default <code>CacheResolver</code> is initialized behind the scenes with this cache manager (or <code>cacheManager</code> if not set). For more fine-grained management of the cache resolution, consider setting the 'cache-resolver' attribute.</td></tr>
<tr><td style="text-align: left"><code>cache-resolver</code></td><td style="text-align: left">N/A (see the <a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc)</td><td style="text-align: left">A <code>SimpleCacheResolver</code> using the configured <code>cacheManager</code>.</td><td style="text-align: left">The bean name of the CacheResolver that is to be used to resolve the backing caches. This attribute is not required and needs to be specified only as an alternative to the 'cache-manager' attribute.</td></tr>
<tr><td style="text-align: left"><code>key-generator</code></td><td style="text-align: left">N/A (see the <a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc)</td><td style="text-align: left"><code>SimpleKeyGenerator</code></td><td style="text-align: left">Name of the custom key generator to use.</td></tr>
<tr><td style="text-align: left"><code>error-handler</code></td><td style="text-align: left">N/A (see the <a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc)</td><td style="text-align: left"><code>SimpleCacheErrorHandler</code></td><td style="text-align: left">The name of the custom cache error handler to use. By default, any exception thrown during a cache related operation is thrown back at the client.</td></tr>
<tr><td style="text-align: left"><code>mode</code></td><td style="text-align: left"><code>mode</code></td><td style="text-align: left"><code>proxy</code></td><td style="text-align: left">The default mode (<code>proxy</code>) processes annotated beans to be proxied by using Spring’s AOP framework (following proxy semantics, as discussed earlier, applying to method calls coming in through the proxy only). The alternative mode (<code>aspectj</code>) instead weaves the affected classes with Spring’s AspectJ caching aspect, modifying the target class byte code to apply to any kind of method call. AspectJ weaving requires <code>spring-aspects.jar</code> in the classpath as well as load-time weaving (or compile-time weaving) enabled. (See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw-spring">Spring configuration</a> for details on how to set up load-time weaving.)</td></tr>
<tr><td style="text-align: left"><code>proxy-target-class</code></td><td style="text-align: left"><code>proxyTargetClass</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">Applies to proxy mode only. Controls what type of caching proxies are created for classes annotated with the <code>@Cacheable</code> or <code>@CacheEvict</code> annotations. If the <code>proxy-target-class</code> attribute is set to <code>true</code>, class-based proxies are created. If <code>proxy-target-class</code> is <code>false</code> or if the attribute is omitted, standard JDK interface-based proxies are created. (See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-proxying">Proxying Mechanisms</a> for a detailed examination of the different proxy types.)</td></tr>
<tr><td style="text-align: left"><code>order</code></td><td style="text-align: left"><code>order</code></td><td style="text-align: left">Ordered.LOWEST_PRECEDENCE</td><td style="text-align: left">Defines the order of the cache advice that is applied to beans annotated with <code>@Cacheable</code> or <code>@CacheEvict</code>. (For more information about the rules related to ordering AOP advice, see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj-advice-ordering">Advice Ordering</a>.) No specified ordering means that the AOP subsystem determines the order of the advice</td></tr>
</tbody></table>
<h1 id="注意"><a class="header" href="#注意">注意</a></h1>
<p><strong>同一个 spring容器</strong></p>
<p>仅在定义它的相同 <em>applicationContext</em> 中的bean上查找@ Cacheable / @ CachePut / @ CacheEvict / @ Caching。
这意味着，如果将放在  <em>DispatcherServlet</em> 的  <em>WebApplicationContext</em> 中，它将仅在控制器中检查bean，而不在服务中检查bean。</p>
<p><strong>方法可见性和缓存注解</strong></p>
<p>最好使用 <em>public</em> 访问</p>
<p><strong>注解接口</strong></p>
<ul>
<li>Spring建议您仅使用 @Cache 对具体类（以及具体类的方法）进行注释，而不是对接口进行注释。</li>
<li>您当然可以在接口（或接口方法）上放置@ Cache *批注，但这仅在您使用基于接口的代理时才可以预期。 </li>
<li>Java注解不是从接口继承的事实意味着，如果您使用基于类的代理（代理目标类=“ true”）或基于编织的方面（mode =“ aspectj”），则缓存设置不会生效</li>
</ul>
<h1 id="using-custom-annotations"><a class="header" href="#using-custom-annotations">Using Custom Annotations</a></h1>
<ul>
<li>该功能仅适用于基于代理的方法，但可以通过使用AspectJ花费一点额外的精力来启用。 
spring-aspects模块仅为标准注释定义一个切面。如果定义了自己的注解，则还需要为其定义一个切面。
查看AnnotationCacheAspect中的示例。</li>
</ul>
<p><strong>自定义组合注解</strong></p>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
@Cacheable(cacheNames=&quot;books&quot;, key=&quot;#isbn&quot;)
public @interface SlowService {
}
</code></pre>
<p>在前面的示例中，我们定义了自己的SlowService批注，该批注本身使用@Cacheable批注。现在我们可以替换以下代码：</p>
<pre><code class="language-java">@Cacheable(cacheNames=&quot;books&quot;, key=&quot;#isbn&quot;)
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

//替换为
@SlowService
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jcache-jsr-107-annotations"><a class="header" href="#jcache-jsr-107-annotations">JCache (JSR-107) Annotations</a></h1>
<ul>
<li>
<p>从4.1版开始，Spring的缓存抽象完全支持JCache标准注解：@CacheResult，@CachePut，@CacheRemove和@CacheRemoveAll以及@ CacheDefaults，@ CacheKey和@CacheValue</p>
</li>
<li>
<p>内部实现使用Spring的缓存抽象，并提供符合规范的默认CacheResolver和KeyGenerator实现</p>
</li>
<li>
<p>换句话说，如果您已经在使用Spring的缓存抽象，则可以切换到这些标准注释，而无需更改缓存存储（或配置）。</p>
</li>
</ul>
<h1 id="feature-summary"><a class="header" href="#feature-summary">Feature Summary</a></h1>
<p>下表描述了Spring注释与JSR-107副本之间的主要区别：</p>
<table><thead><tr><th style="text-align: left">Spring</th><th style="text-align: left">JSR-107</th><th style="text-align: left">Remark</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>@Cacheable</code></td><td style="text-align: left"><code>@CacheResult</code></td><td style="text-align: left">Fairly similar. <code>@CacheResult</code> can cache specific exceptions and force the execution of the method regardless of the content of the cache.</td></tr>
<tr><td style="text-align: left"><code>@CachePut</code></td><td style="text-align: left"><code>@CachePut</code></td><td style="text-align: left">While Spring updates the cache with the result of the method invocation, JCache requires that it be passed it as an argument that is annotated with <code>@CacheValue</code>. Due to this difference, JCache allows updating the cache before or after the actual method invocation.</td></tr>
<tr><td style="text-align: left"><code>@CacheEvict</code></td><td style="text-align: left"><code>@CacheRemove</code></td><td style="text-align: left">Fairly similar. <code>@CacheRemove</code> supports conditional eviction when the method invocation results in an exception.</td></tr>
<tr><td style="text-align: left"><code>@CacheEvict(allEntries=true)</code></td><td style="text-align: left"><code>@CacheRemoveAll</code></td><td style="text-align: left">See <code>@CacheRemove</code>.</td></tr>
<tr><td style="text-align: left"><code>@CacheConfig</code></td><td style="text-align: left"><code>@CacheDefaults</code></td><td style="text-align: left">Lets you configure the same concepts, in a similar fashion.</td></tr>
</tbody></table>
<p>JCache具有javax.cache.annotation.CacheResolver的概念，该概念与Spring的CacheResolver接口相同，只是JCache仅支持单个缓存。
默认情况下，一个简单的实现根据 注解中声明的名称检索要使用的缓存。
应该注意的是，如果注释中未指定缓存名称，则会自动生成一个默认值。</p>
<p>CacheResolver实例由CacheResolverFactory检索。可以为每个缓存操作自定义工厂，如以下示例所示：</p>
<pre><code class="language-java">@CacheResult(cacheNames=&quot;books&quot;, cacheResolverFactory=MyCacheResolverFactory.class) 
public Book findBook(ISBN isbn)
</code></pre>
<p><em>key</em> 是由javax.cache.annotation.CacheKeyGenerator生成的，其作用与Spring的KeyGenerator相同。
默认情况下，将考虑所有方法参数，除非至少一个参数用@CacheKey注释。这类似于Spring的自定义密钥生成声明。
例如，以下是相同的操作，一个使用Spring的抽象，另一个使用JCache：</p>
<pre><code class="language-java">@Cacheable(cacheNames=&quot;books&quot;, key=&quot;#isbn&quot;)
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@CacheResult(cacheName=&quot;books&quot;)
public Book findBook(@CacheKey ISBN isbn, boolean checkWarehouse, boolean includeUsed)
</code></pre>
<p><strong>您还可以在操作上指定CacheKeyResolver，类似于指定CacheResolverFactory的方式。</strong></p>
<p><strong>可以缓存异常</strong></p>
<p>JCache可以管理带注解的方法引发的异常。这样可以防止更新缓存，但是也可以将异常缓存为失败的指示，而不必再次调用该方法。
假定如果ISBN的结构无效，则引发InvalidIsbnNotFoundException。
这是一个永久性的失败（使用这样的参数无法检索任何书籍）。
以下内容缓存了该异常，以便使用相同的无效ISBN进行的进一步调用直接引发该缓存的异常，而不是再次调用该方法：</p>
<pre><code class="language-java">@CacheResult(cacheName=&quot;books&quot;, exceptionCacheName=&quot;failures&quot;
            cachedExceptions = InvalidIsbnNotFoundException.class)
public Book findBook(ISBN isbn)
</code></pre>
<h1 id="enabling-jsr-107-support"><a class="header" href="#enabling-jsr-107-support">Enabling JSR-107 Support</a></h1>
<p>除了启用Spring的声明性注释支持外，您无需执行任何其他操作即可启用JSR-107支持。
如果类路径中同时存在JSR-107 API和spring-context-support模块，则@EnableCaching和cache：annotation-driven元素都会自动启用JCache支持。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基于声明式xml的缓存"><a class="header" href="#基于声明式xml的缓存">基于声明式XML的缓存</a></h1>
<p>如果不能使用注释（可能是由于无法访问源代码或没有外部代码），则可以使用XML进行声明式缓存。因此，您可以在外部指定目标方法和缓存指令，而不是注释用于缓存的方法（类似于声明式事务管理建议）。
上一节中的示例可以转换为以下示例：</p>
<pre><code class="language-java">&lt;!-- the service we want to make cacheable --&gt;
&lt;bean id=&quot;bookService&quot; class=&quot;x.y.service.DefaultBookService&quot;/&gt;

&lt;!-- cache definitions --&gt;
&lt;cache:advice id=&quot;cacheAdvice&quot; cache-manager=&quot;cacheManager&quot;&gt;
    &lt;cache:caching cache=&quot;books&quot;&gt;
        &lt;cache:cacheable method=&quot;findBook&quot; key=&quot;#isbn&quot;/&gt;
        &lt;cache:cache-evict method=&quot;loadBooks&quot; all-entries=&quot;true&quot;/&gt;
    &lt;/cache:caching&gt;
&lt;/cache:advice&gt;

&lt;!-- apply the cacheable behavior to all BookService interfaces --&gt;
&lt;aop:config&gt;
    &lt;aop:advisor advice-ref=&quot;cacheAdvice&quot; pointcut=&quot;execution(* x.y.BookService.*(..))&quot;/&gt;
&lt;/aop:config&gt;

&lt;!-- cache manager definition omitted --&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="存储集成"><a class="header" href="#存储集成">存储集成</a></h1>
<p>缓存抽象提供了几种存储集成选项。要使用它们，您需要声明一个适当的CacheManager（控制和管理Cache实例的实体，可用于检索这些实例以进行存储）。</p>
<h1 id="jdk-concurrentmap-based-cache"><a class="header" href="#jdk-concurrentmap-based-cache">JDK <code>ConcurrentMap</code>-based Cache</a></h1>
<p>基于JDK的Cache实现位于org.springframework.cache.concurrent包下。 它使您可以将ConcurrentHashMap用作后备缓存存储。
以下示例显示了如何配置两个缓存：</p>
<pre><code class="language-java">&lt;!-- simple cache manager --&gt;
&lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.cache.support.SimpleCacheManager&quot;&gt;
    &lt;property name=&quot;caches&quot;&gt;
        &lt;set&gt;
            &lt;bean class=&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&quot; p:name=&quot;default&quot;/&gt;
            &lt;bean class=&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&quot; p:name=&quot;books&quot;/&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>上面的代码段使用SimpleCacheManager为两个嵌套的名为default和books的ConcurrentMapCache实例创建CacheManager。请注意，名称是直接为每个缓存配置的。</p>
<h1 id="ehcache-based-cache"><a class="header" href="#ehcache-based-cache">Ehcache-based Cache</a></h1>
<p>Ehcache 3.x完全符合JSR-107，并且不需要专用支持。</p>
<pre><code class="language-xml">&lt;bean id=&quot;cacheManager&quot;
        class=&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot; p:cache-manager-ref=&quot;ehcache&quot;/&gt;

&lt;!-- EhCache library setup --&gt;
&lt;bean id=&quot;ehcache&quot;
        class=&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot; p:config-location=&quot;ehcache.xml&quot;/&gt;
</code></pre>
<h1 id="caffeine-cache"><a class="header" href="#caffeine-cache">Caffeine Cache</a></h1>
<p>Caffeine是Java 8对Guava缓存的重写，它的实现位于org.springframework.cache.caffeine包中，并提供对Caffeine多个功能的访问。
以下示例配置一个CacheManager，该CacheManager按需创建缓存：</p>
<pre><code class="language-java">&lt;bean id=&quot;cacheManager&quot;
        class=&quot;org.springframework.cache.caffeine.CaffeineCacheManager&quot;/&gt;
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.cache.caffeine.CaffeineCacheManager&quot;&gt;
    &lt;property name=&quot;caches&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;default&lt;/value&gt;
            &lt;value&gt;books&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>Caffeine CacheManager还支持自定义Caffeine和CacheLoader。有关这些的更多信息，请参见   <a href="https://github.com/ben-manes/caffeine/wiki">Caffeine documentation</a></p>
<h1 id="gemfire-based-cache"><a class="header" href="#gemfire-based-cache">GemFire-based Cache</a></h1>
<p>GemFire is a memory-oriented, disk-backed, elastically scalable, continuously available, active (with built-in pattern-based subscription notifications), globally replicated database and provides fully-featured edge caching. For further information on how to use GemFire as a <code>CacheManager</code> (and more), see the <a href="https://docs.spring.io/spring-gemfire/docs/current/reference/html/">Spring Data GemFire reference documentation</a>.</p>
<h1 id="jsr-107-cache"><a class="header" href="#jsr-107-cache">JSR-107 Cache</a></h1>
<p>Spring的缓存抽象也可以使用符合JSR-107的缓存。 JCache实现位于org.springframework.cache.jcache包中。
同样，要使用它，您需要声明适当的CacheManager。
以下示例显示了如何执行此操作：</p>
<pre><code class="language-xml">&lt;bean id=&quot;cacheManager&quot;
        class=&quot;org.springframework.cache.jcache.JCacheCacheManager&quot;
        p:cache-manager-ref=&quot;jCacheManager&quot;/&gt;

&lt;!-- JSR-107 cache manager setup  --&gt;
&lt;bean id=&quot;jCacheManager&quot; .../&gt;
</code></pre>
<h1 id="在没有后备存储的情况下处理缓存"><a class="header" href="#在没有后备存储的情况下处理缓存">在没有后备存储的情况下处理缓存</a></h1>
<p>有时，在切换环境或进行测试时，您可能具有缓存声明而未配置实际的后备缓存。
由于这是无效的配置，因此在运行时将引发异常，因为缓存基础结构无法找到合适的存储。
在这种情况下，可以删除一个简单的伪高速缓存，该高速缓存不执行任何高速缓存，而不是删除高速缓存声明（这可能会很乏味），也就是说，它强制每次都调用高速缓存的方法。
以下示例显示了如何执行此操作：</p>
<pre><code class="language-xml">&lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.cache.support.CompositeCacheManager&quot;&gt;
    &lt;property name=&quot;cacheManagers&quot;&gt;
        &lt;list&gt;
            &lt;ref bean=&quot;jdkCache&quot;/&gt;
            &lt;ref bean=&quot;gemfireCache&quot;/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;fallbackToNoOpCache&quot; value=&quot;true&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>前面的CompositeCacheManager链接了多个CacheManager实例，并通过fallbackToNoOpCache标志为未配置的缓存管理器处理的所有定义添加无操作缓存。
也就是说，在jdkCache或gemfireCache（在示例中之前配置）中都找不到的每个缓存定义都由不存储任何信息的无操作缓存处理，从而导致每次都调用目标方法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="springdataredis"><a class="header" href="#springdataredis">SpringDataRedis</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是响应式编程"><a class="header" href="#什么是响应式编程">什么是响应式编程</a></h1>
<p><strong>异步回调地狱</strong></p>
<p>异步编程时，存在很多难题，比如典型的<code>回调地狱(Callback Hell)</code>，一层套一层的回调函数简直是个灾难，这里列出几个异步编程常见的问题：</p>
<ol>
<li>超时、异常处理困难</li>
<li>难以重构</li>
<li>多个异步任务协同处理</li>
</ol>
<p><strong>编程范式</strong></p>
<p>就像面向对象编程，函数式编程一样，反应式编程也是另一种编程范式，响应式编程是一种新的编程范式，可以使用 申明式代码，类似函数式编程来构建异步处理管道，这是一个基于事件的模型，在数据可用时将数据推送到使用者</p>
<p><strong>标准制定</strong></p>
<p>当越来越多的开发人员使用这种编程思想时，自然而然需要一套统一的规范，2013年底Netflix，Pivotal和Lightbend中的工程师们，启动了Reactive Streams项目，希望为异步流(包含背压)处理提供标准，它包括针对运行时环境（JVM和JavaScript）以及网络协议的工作。</p>
<h1 id="概念"><a class="header" href="#概念">概念</a></h1>
<p>处理数据流，特别是实时数据，其体积未预先确定</p>
<p>最突出的问题：需要严格控制资源消耗，以防快速的 数据源 不会压倒流目的地</p>
<p>Reactive Streams  的主要目标是 管理异步边界的流数据交换，可以认为是将元素传递到另一个线程或线程池，同时确保接收方不会被迫缓冲任意数量的数据</p>
<p>换句话说，背压是此模型的一个组成部分，以便允许在线程之间进行调解的队列被绑定。</p>
<p>The benefits of asynchronous processing would be negated if the backpressure signals were synchronous (see also the <a href="http://reactivemanifesto.org/">Reactive Manifesto</a>), </p>
<p>如果背压信号是同步的（另见[反应宣言]（http://reactivemanifesto.org/），异步处理的好处将不存在</p>
<p>在 Reactive Streams 实现中，需要考虑到 完全的非阻塞和异步行为</p>
<p>本规范的目的是允许创建许多符合的实现，通过遵守规则就能顺利地互操作，在整个流应用程序的处理图中保留上述优势和特征。</p>
<p>应当指出，本规范不包括流操作的精确性质（转换、拆分、合并等）</p>
<p>Reactive Streams 只关心 在不同的 API组件中 调解 数据流</p>
<p>总之：Reactive Streams 是面向流的 JVM库的 标准和规范</p>
<ul>
<li>处理可能不受限制的元素数量</li>
<li>顺序处理</li>
<li>异步传递组件之间的元素，</li>
<li>具有强制性的非阻塞背压</li>
</ul>
<p>反应流规范包括以下部分：</p>
<p><em><strong>The API</strong></em> ：API组件定义</p>
<p><em><strong>The Technology Compatibility Kit (TCK)</strong></em> 是实现的符合性测试的标准测试套件</p>
<p>只要符合 API 要求并通过 TCK 中的测试，实施可以自由实现规范未涵盖的其他功能。</p>
<p><code>Reactive Streams API</code>中仅仅包含了如下四个接口：</p>
<pre><code class="language-java">//发布者
public  interface  Publisher &lt; T &gt; {
    public  void  subscribe（Subscriber &lt;？super  T &gt;  s）;
}
//订阅者
public  interface  Subscriber &lt; T &gt; {
    public  void  onSubscribe（Subscription  s）;
    public  void  onNext（T  t）;
    public  void  onError（Throwable  t）;
    public  void  onComplete（）;
}
//表示Subscriber消费Publisher发布的一个消息的生命周期
public interface Subscription {
    public void request(long n);
    public void cancel();
}
//处理器，表示一个处理阶段，它既是订阅者也是发布者，并且遵守两者的契约
public interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {}
</code></pre>
<p><strong>背压(back-pressure)</strong></p>
<p>背压是从流体动力学中借用的类比, 在维基百科的定义是：抵抗所需流体通过管道的阻力或力。</p>
<p>在软件环境中，可以调整定义：<strong>通过软件抵抗所需数据流的阻力或力量。</strong></p>
<p><strong>解决问题</strong></p>
<p>背压是为了解决这个问题的：上游组件了过量的消息，导致下游组件无法及时处理，从而导致程序崩溃。</p>
<p>对于正遭受压力的组件来说，无论是灾难性地失败，还是不受控地丢弃消息，都是不可接受的。既然它既不能应对压力，又不能直接做失败处理，那么它就应该向其上游组件传达其正在遭受压力的事实，并让它们降低负载。</p>
<p>这种背压（back-pressure）是一种重要的反馈机制，使得系统得以优雅地响应负载，而不是在负载下崩溃。相反，如果下游组件比较空闲，则可以向上游组件发出信号，请求获得更多的调用。</p>
<h1 id="事件发布"><a class="header" href="#事件发布">事件发布</a></h1>
<p>Publisher 是潜在无限数量的序列元素的提供者，根据订阅者的需求发布这些元素。</p>
<p>为了响应   <code>Publisher.subscribe(Subscriber)</code> 的呼叫，<code>Subscriber</code>上方法的可能调用顺序遵循以下协议</p>
<pre><code>onSubscribe onNext* (onError | onComplete)?
</code></pre>
<p>This means that <code>onSubscribe</code> is always signalled, </p>
<ol>
<li>这意味着 <code>onSubscribe</code> 总是发出信号，</li>
<li>然后是可能未绑定的&quot;OnNext&quot;信号（as requested by <code>Subscriber</code>）</li>
<li>然后是 <code>onError</code>（如果出现故障）或 <code>onComplete</code> 信号（只要 <code>Subscription</code> 未取消时 且没有更多元素可用）。</li>
</ol>
<h1 id="与java18java19的关系"><a class="header" href="#与java18java19的关系">与Java1.8、Java1.9的关系</a></h1>
<p>Reactive Streams不要求必须使用Java8，Reactive Streams也不是Java API的一部分。</p>
<p>但是使用Java8中lambda表达式的存在，可以发挥Reactive Streams规范的强大特性，比如Reactive Streams的实现<code>Project Reactor</code>项目的当前版本，就要求最低使用Java1.8。</p>
<h1 id="具体实现框架"><a class="header" href="#具体实现框架">具体实现框架</a></h1>
<p>Reactive Streams的实现现在比较多了，David Karnok在Advanced Reactive Java这边文章中，将这些实现分解成几代，也可以侧面了解反应式编程的发展史。</p>
<p><strong>RxJava</strong></p>
<p>RxJava是ReactiveX项目中的Java实现。ReactiveX项目实现了很多语言，比如JavaScript，.NET（C＃），Scala，Clojure，C ++，Ruby，Python，PHP，Swift等。</p>
<p>RxJava早于Reactive Streams规范。虽然RxJava 2.0+确实实现了Reactive Streams API规范，单使用的术语略有不同。</p>
<p><strong>Reactor</strong></p>
<p>Reactor是Pivotal提供的Java实现，它作为Spring Framework 5的重要组成部分，是WebFlux采用的默认反应式框架。</p>
<p><strong>Akka Streams</strong></p>
<p>Akka Streams完全实现了Reactive Streams规范，但Akka Streams API与Reactive Streams API完全分离。</p>
<p><strong>Ratpack</strong></p>
<p>Ratpack是一组用于构建现代高性能HTTP应用程序的Java库。Ratpack使用Java 8，Netty和Reactive原则。可以将RxJava或Reactor与Ratpack一起使用。</p>
<p><strong>Vert.x</strong></p>
<p>Vert.x是一个Eclipse Foundation项目，它是JVM的多语言事件驱动的应用程序框架。Vert.x中的反应支持与Ratpack类似。Vert.x允许我们使用RxJava或其Reactive Streams API的实现。</p>
<p><strong>互操作性</strong></p>
<p>在Reactive Streams之前，各种反应库无法实现互操作性。早期版本的<code>RxJava</code>与<code>Project Reactor</code>的早期版本不兼容。</p>
<p>另外，反应式编程无法大规模普及，一个很重要的原因是并不是所有库都支持反应式编程，当一些类库只能同步调用时，就无法达到节约性能的作用了。</p>
<p>Reactive Streams的推出统一了反应式编程的规范，并且已经被Java9集成。由此，不同的库可以互操作了，互操作性是一个重要的多米诺骨牌。</p>
<p>例如，MongoDB实现了Reactive Streams驱动程序后，我们可以使用Reactor或RxJava来使用MongoDB中的数据</p>
<h1 id="specification"><a class="header" href="#specification">SPECIFICATION</a></h1>
<h2 id="publisher"><a class="header" href="#publisher">Publisher</a></h2>
<pre><code class="language-java">public interface Publisher&lt;T&gt; {
    public void subscribe(Subscriber&lt;? super T&gt; s);
}
</code></pre>
<h3 id="onnext信号总数"><a class="header" href="#onnext信号总数"><strong><code>OnNext</code>信号总数</strong></a></h3>
<p><code>Publisher</code> 向 <code>Subscriber</code> 发布的 <em>OnNext</em> 信号 总数 必须小于等于 该 <em>Subscriber</em> 的订阅要求的总数</p>
<p>此规则的主要目的是表明：发布者不能发出比订阅者要求的更多的元素信号</p>
<p>此规则有一个隐含但重要的后果：由于需求只有在收到需求后才能实现，因此请求元素和接收元素之间之间存在一种先发生的关系。</p>
<h3 id="publisher-产生的信号总数"><a class="header" href="#publisher-产生的信号总数"><em>Publisher</em> 产生的信号总数</a></h3>
<p><code>Publisher</code> 可能发出的 <code>onNext</code> 信号比请求的要少，并通过 调用 <code>onComplete</code> or <code>onError</code> 来终止 <code>Subscription</code></p>
<p>此规则的目的是要表明：<em>Publisher</em> 不能保证它 能够产生所需求的元素数量，他可能根本无法生产他们所有：它可能处于失败状态;它可能是空的或其他已经完成</p>
<h3 id="信号触发的是串行的"><a class="header" href="#信号触发的是串行的">信号触发的是串行的</a></h3>
<p><code>onSubscribe</code>, <code>onNext</code>, <code>onError</code> and <code>onComplete</code> signaled to a <code>Subscriber</code> MUST be signaled <a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.3#term_serially">serially</a>.</p>
<h3 id="publisher失败触发信号"><a class="header" href="#publisher失败触发信号">Publisher失败触发信号</a></h3>
<p>If a <code>Publisher</code> fails it MUST signal an <code>onError</code>.</p>
<p>此规则的目的是要明确说明，如果发布者发现无法继续订阅，则有责任通知其订阅者</p>
<p>订阅者必须有机会清理资源或以其他方式处理  <em>Publisher</em> 的失败</p>
<h3 id="publisher成功触发完成信号"><a class="header" href="#publisher成功触发完成信号">Publisher成功触发完成信号</a></h3>
<p>If a <code>Publisher</code> terminates successfully (finite stream) it MUST signal an <code>onComplete</code>.</p>
<p>此规则的目的是表明，发布者负责通知其订阅者，它已达到 <a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.3#term_terminal_state">terminal state</a> ，订阅者可以根据此信息采取行动：清理资源</p>
<h3 id="publisher失败或成功要取消订阅"><a class="header" href="#publisher失败或成功要取消订阅">Publisher失败或成功要取消订阅</a></h3>
<p>如果&quot;发布者&quot;在&quot;订阅者&quot;上发出    <code>onError</code> or <code>onComplete</code> 的信号，则必须考虑取消&quot;订阅者&quot;的&quot;订阅&quot;。</p>
<p>此规则的目的是确保订阅无论是否被取消，发布者都受到相同的对待</p>
<h3 id="publisher处于终止时不在触发信号"><a class="header" href="#publisher处于终止时不在触发信号">Publisher处于终止时不在触发信号</a></h3>
<p>Once a <a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.3#term_terminal_state">terminal state</a> has been signaled (<code>onError</code>, <code>onComplete</code>) it is REQUIRED that no further signals occur.</p>
<p>此规则的目的是确保在Error和Complete上是发布者和订阅者对之间交互的最终状态</p>
<h3 id="subscription被取消则不再接收信号"><a class="header" href="#subscription被取消则不再接收信号"><code>Subscription</code>被取消则不再接收信号</a></h3>
<p>If a <code>Subscription</code> is cancelled its <code>Subscriber</code> MUST eventually stop being signaled</p>
<p>此规则的目的是确保发布者尊重订阅者在调用订阅时取消订阅的请求。<strong>最终</strong>的原因是，由于异步，信号可能会有传播延迟</p>
<h3 id="subscriber的onsubscribe最先调用"><a class="header" href="#subscriber的onsubscribe最先调用">Subscriber的onSubscribe最先调用</a></h3>
<p><code>Publisher.subscribe</code>方法,必须  在任何其他信号之前  调用 提供的  <code>Subscriber</code> 上的  <code>onSubscribe</code> 方法 ，MUST <a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.3#term_return_normally">return normally</a></p>
<p>如果提供的 <em>Subscriber</em> 是空 抛出 NPE给调用者</p>
<p>对于所有其他情况，发出故障信号（或拒绝&quot;订阅者&quot;）的唯一合法方式是 调用 <code>OnError</code> (在调用 <code>onSubscribe</code> )</p>
<p>此规则的目的是确保&quot;订阅&quot;  始终在任何其他信号之前发出信号，以便订阅者可以在收到信号时执行初始化逻辑。</p>
<p>此外， &quot;订阅&quot; 最多只能调用一次</p>
<p>如果提供的&quot;订阅者&quot;是&quot;空&quot;，除了向调用者 发出信号，别无他法，例如可能会抛出 NPE</p>
<p>可能的情况：一个有状态的 <em>Publisher</em>  可能会不堪重负，受有限数量的基础资源限制用尽，或者处于 <a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.3#term_terminal_state">terminal state</a>.</p>
<h3 id="publishersubscribe多次调用不同subscribe"><a class="header" href="#publishersubscribe多次调用不同subscribe">Publisher.subscribe多次调用不同Subscribe</a></h3>
<p><code>Publisher.subscribe</code> 可以 随需 调用多次 但是每次必须与不同的  <code>Subscriber</code></p>
<p>此规则的目的是让&quot;订阅&quot;调用者 了解到：a generic Publisher and a generic Subscriber 不能支持多次 附加</p>
<p>此外，它还要求无论 <code>subscribe</code> 的语义被调用多少次，都必须得到维护。</p>
<h3 id="多个subscriber的支持"><a class="header" href="#多个subscriber的支持">多个<code>Subscriber</code>的支持</a></h3>
<p>A <code>Publisher</code> MAY support multiple <code>Subscriber</code>s and decides whether each <code>Subscription</code> is unicast or multicast.</p>
<p>发布者可能支持多个 订阅者，并决定每个<code>订阅</code> 是单波还是 多播</p>
<p>此规则的目的是让发布者实现灵活决定他们将支持多少（如果有的话）订阅者，以及如何分发元素</p>
<h2 id="subscriber"><a class="header" href="#subscriber">Subscriber</a></h2>
<pre><code class="language-java">public interface Subscriber&lt;T&gt; {
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}
</code></pre>
<h3 id="subscriber-通过request发出信号接收请求"><a class="header" href="#subscriber-通过request发出信号接收请求"><em>Subscriber</em> 通过<em>request</em>发出信号接收请求</a></h3>
<p><em>Subscriber</em> 必须通过  <code>Subscription.request(long n)</code> 发出 信号需求以 接收 <code>onNext</code> signals</p>
<p>此规则的目的是确定 <code>Subscriber</code>  有责任决定  何时以及能够和愿意接收多少元素</p>
<p>为避免重新加入订阅方法导致信号重新订购，</p>
<p>强烈建议同步订阅者实现在任何信号处理结束时调用订阅方法。</p>
<p>建议订阅者请求其 能够处理的内容的上限，因为一次只请求一个元素会导致固有的低效&quot;停止和等待&quot;协议</p>
<h3 id="建议使用异步处理信号"><a class="header" href="#建议使用异步处理信号">建议使用异步处理信号</a></h3>
<p>如果&quot;订阅者&quot;怀疑其处理信号会对其&quot;发布者&quot;的责任产生负面影响，则建议其异步发送信号。</p>
<p>此规则的意图是，订阅者不应从执行角度阻止 发布者的 进程</p>
<p>换句话说：订阅者不应使发布者无法接收 CPU 周期。</p>
<h3 id="终止状态的信号中-不应该调发布订阅中的方法"><a class="header" href="#终止状态的信号中-不应该调发布订阅中的方法">终止状态的信号中 不应该调发布订阅中的方法</a></h3>
<p><code>Subscriber.onComplete()</code> and <code>Subscriber.onError(Throwable t)</code> MUST NOT call any methods on the <code>Subscription</code> or the <code>Publisher</code>.</p>
<p>此规则的目的是防止在处理完成信号期间 避免 发布者、订阅、订阅者 之间的出现循环 或者 竞争</p>
<h3 id="收到终止信号后必须考虑取消状态"><a class="header" href="#收到终止信号后必须考虑取消状态">收到终止信号后必须考虑取消状态</a></h3>
<p><code>Subscriber.onComplete()</code> and <code>Subscriber.onError(Throwable t)</code> MUST consider the Subscription cancelled after having received the signal</p>
<p>此规则的目的是：确保 Subscribers 尊重 Publisher的  <a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.3#term_terminal_state">terminal state</a> 信号，一旦 收到 <em>onComplete</em> <em>onError</em>  信号，一个订阅过程 就无效了</p>
<h3 id="阻止多个发布者订阅同一个订阅者"><a class="header" href="#阻止多个发布者订阅同一个订阅者">阻止多个发布者订阅同一个订阅者</a></h3>
<p>在 <em>onSubscribe</em> 信号之后， 在一个给定的 <em>Subscription</em>中 ，如果已经存在一个 活跃的 <code>Subscription</code> 则 <code>Subscriber</code> 必须 调用  <code>Subscription.cancel()</code> </p>
<p>此规则的目的是防止两个或更多单独的发布者尝试与同一订阅者进行交互</p>
<p>Enforcing this rule means that resource leaks are prevented since extra Subscriptions will be cancelled</p>
<p>执行此规则意味着防止资源泄漏，因为额外的订阅将被取消。</p>
<p>如果不符合此规则，可能导致违反 Publisher rule 1。此类违规行为可能导致难以诊断的错误</p>
<h3 id="subscription不用之后需要cancel"><a class="header" href="#subscription不用之后需要cancel">Subscription不用之后需要Cancel</a></h3>
<p>一个 <code>Subscription</code> 如果不再需要了，则 <em>Subscriber</em>  必须 调用  <code>Subscription.cancel()</code> </p>
<h3 id="cancel有延迟"><a class="header" href="#cancel有延迟">Cancel有延迟</a></h3>
<p><em>Subscriber</em> 必须有能力处理下列情况</p>
<p>当 调用 <em>Subscription.cancel</em> 时，如果还存在 请求的元素 正 pending中，能够接收一个或多个 <em>onNext</em> 信号，Subscription.cancel() 不保证立即执行基础清洁操作</p>
<p>此规则的目的是强调，在调用 <code>cancel</code> 和  <code>publisher</code> 遵守 cancel之间可能会有延迟。</p>
<h3 id="允许流提前完成"><a class="header" href="#允许流提前完成">允许流提前完成</a></h3>
<p>一个 <em>Subscriber</em> 必须能够 处理 <code>onComplete</code> 信号 无论是否前置调用 <code>Subscription.request(long n)</code> </p>
<p>此规则的目的是确定 completion 与需求流无关，这允许流提前完成，并避免 <em>poll</em> 完成的需要。</p>
<h3 id="onerror与信号需求无关"><a class="header" href="#onerror与信号需求无关">OnError与信号需求无关</a></h3>
<p>订阅者 必须准备好接收 <em>OnError</em> 信号，无论是否事先发出 <code>Subscription.request(long n)</code></p>
<p>此规则的目的是确定发布者故障可能与信号需求完全无关。这意味着订阅者不需要 <em>poll</em> 来了解发布者是否无法满足其请求</p>
<h3 id="信号的异步处理"><a class="header" href="#信号的异步处理">信号的异步处理</a></h3>
<p><code>订阅者</code> 必须确保在处理相关信号之前：所有 发生在其 <em>signal</em> 方法 的调用 </p>
<p>Subscriber必须确保 所有 信号方法的调用 发生于 信号处理之前</p>
<p>即订阅者必须注意正确发布信号以达到其处理逻辑。</p>
<p>此规则的目的是确定订阅者实现的责任，以确保其信号的异步处理是线程安全的</p>
<p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5">JMM definition of Happens-Before in section 17.4.5</a></p>
<h3 id="subscriber对于一个publisher只能调用一次"><a class="header" href="#subscriber对于一个publisher只能调用一次">Subscriber对于一个<em>Publisher</em>只能调用一次</a></h3>
<p><code>Subscriber.onSubscribe</code> 对于给定的 Subscriber（ (based on object equality)最多只能被调用一次</p>
<p>此规则的目的是确定必须假定最多只能订阅一次相同的订阅者</p>
<h3 id="信号方法必须-returnnormal"><a class="header" href="#信号方法必须-returnnormal">信号方法必须 ReturnNormal</a></h3>
<p>调用  <code>onSubscribe</code>, <code>onNext</code>, <code>onError</code> or <code>onComplete</code>  必须 <a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.3#term_return_normally">return normally</a> </p>
<p>除非任何提供的参数是 &quot;空&quot;，在这种情况下 它 必须向 调用者 抛出 java.lang.NullPointerException</p>
<p>对于所有其他情况，&quot;订阅者&quot;发出故障信号的唯一合法方式是取消其 &quot;订阅&quot;。</p>
<p>如果违反此规则，任何与 <em>subscriber</em> 关联的 <em>Subscription</em> 必须 被取消，调用者必须以适应 运行时环境的方式 抛出此 错误状态</p>
<p>此规则的目的是确定 订阅者的方法的语义，以及允许发布者在违反此规则的情况下做什么的语义</p>
<p>«Raise this error condition in a fashion that is adequate for the runtime environment» 可能意味着记录错误</p>
<p>或者使某人某事 意识到这种情况，因为错误不能向有故障的订阅者发出信号</p>
<h2 id="subscription"><a class="header" href="#subscription">Subscription</a></h2>
<pre><code class="language-java">public interface Subscription {
    public void request(long n);
    public void cancel();
}
</code></pre>
<h3 id="subscriber控制请求"><a class="header" href="#subscriber控制请求">Subscriber控制请求</a></h3>
<p><em>Subscription.request</em> <em>Subscription.cancel</em> 必须 在 <em>Subscriber</em> <em>context</em> 中调用</p>
<p>此规则的目的是确定  Subscription  代表订阅者和发布者之间的独特关系</p>
<p>订阅者可以控制何时请求元素以及何时不再需要更多元素</p>
<h3 id="request可重复调用"><a class="header" href="#request可重复调用">Request可重复调用</a></h3>
<p><code>Subscription</code>  必须 允许 <code>Subscriber</code>   在<code>onNext</code> or <code>onSubscribe</code>   中  同步地调用   <code>Subscription.request</code></p>
<p>此规则的目的是明确  <code>request</code>  的实现 必须可重入，以避免在  <code>request</code> <code>onNext</code>  之间相互重复的情况下出现堆栈溢出（最终<code>onComplete</code> / <code>onError</code>）之间发生堆栈溢出</p>
<p>这意味着发布者可以是&quot;同步的&quot;，即在称为&quot;请求&quot;的线程上发出&quot;onNext&quot;的信号</p>
<h3 id="request-onnext递归上限"><a class="header" href="#request-onnext递归上限">Request OnNext递归上限</a></h3>
<p><code>Subscription.request</code> 在  <code>Publisher</code> and <code>Subscriber</code>的递归调用之间 放置一个 上限</p>
<p>此规则的目的是通过对 <code>request</code> <code>onNext</code> 之间的递归调用 设置上限来补充（最终 <em>onComplete</em> <em>onError</em>）</p>
<p>Implementations are RECOMMENDED to limit this mutual recursion to a depth of <code>1</code> (ONE)—for the sake of conserving stack space.</p>
<p>为了节省堆栈空间，建议实现将这种相互递归限制为&quot;1&quot;（One）深度</p>
<h3 id="request应该足够快"><a class="header" href="#request应该足够快">Request应该足够快</a></h3>
<p><code>Subscription.request</code>应该遵循 调用者的 职责 。应及时返回</p>
<p>此规则的目的是确定 <em>request</em> 被实现为 轻量级 非阻塞方法，能在调用线程中 尽快执行，避免 重计算，及其他拖慢调用线程的执行</p>
<h3 id="cancel应该幂等线程安全快"><a class="header" href="#cancel应该幂等线程安全快">Cancel应该幂等线程安全快</a></h3>
<p><code>Subscription.cancel</code>  必须 遵循 调用者的 责任，及时返回，必须是幂等、线程安全</p>
<p>此规则的目的是确定 <em>cancel</em> 旨在 设计为 非阻塞 方法，能够在调用线程尽快执行，避免重计算和其他会拖慢 调用者 线程执行的 事情。</p>
<p>此外，还必须可以多次调用它，而不会产生任何不利影响。</p>
<h3 id="取消后的request是-no-op的"><a class="header" href="#取消后的request是-no-op的">取消后的Request是 No-op的</a></h3>
<p>Subscription被取消后，对  <code>Subscription.request(long n)</code>的调用 都应该是 <a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.3#term_nop">NOPs</a>.</p>
<p>此规则的目的是在取消订阅与随后 <em>non-operation</em> <em>request</em> 更多元素之间建立因果关系</p>
<p>此规则被  <a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.3#3.5">3.5</a> 取代了</p>
<h3 id="request-is-an-additive-operation"><a class="header" href="#request-is-an-additive-operation">Request is an additive operation</a></h3>
<p>当 Subscription未被 取消时， <code>Subscription.request(long n)</code> 必须注册 给定数量的额外元素，这些元素将会产生给 相应的  <em>Subscriber</em></p>
<p>此规则的目的是确保 <em>request</em> 是一个 附加的操作，也确保 元素的请求 被 递送到 <em>Publisher</em></p>
<h3 id="request-param-参数小于等于0时触发onerror"><a class="header" href="#request-param-参数小于等于0时触发onerror">Request Param 参数小于等于0时触发onError</a></h3>
<p>当 <em>Subscription</em> 没有取消时，使用参数小于等于0 调用 <code>Subscription.request(long n)</code> 必须发出 <em>onError</em> 信号，带有java.lang.IllegalArgumentException </p>
<p>Request Param</p>
<p>当订阅未被取消， <code>Subscription.request(long n)</code></p>
<h3 id="request-可以同步调用onnext"><a class="header" href="#request-可以同步调用onnext">Request 可以同步调用onNext</a></h3>
<p>虽然&quot;订阅&quot;未被取消，但 <code>Subscription.request(long n)</code>  可在此（或其他）订阅者上同步调用&quot;onNext&quot;</p>
<p>此规则的目的是确定允许创建同步发布者，即在 调用线程上执行逻辑的发布者</p>
<h3 id="subscriptioncancel停止发出信号"><a class="header" href="#subscriptioncancel停止发出信号">Subscription.Cancel停止发出信号</a></h3>
<p>当订阅未被取消时，<code>Subscription.cancel()</code>  必须  请求 <em>Publisher</em> 最终停止向 订阅者 发出信号</p>
<p>操作不需要 立即 影响 <em>Subscription</em></p>
<p>此规则的目的是 确定： 取消一个 <em>Subscription</em> 最终会 影响到  <em>Publisher</em> 并且 众所周知 可能会 花费一定时间 才能收到 信号</p>
<h3 id="cancel后放弃对subscriber的引用"><a class="header" href="#cancel后放弃对subscriber的引用">cancel后放弃对Subscriber的引用</a></h3>
<p>当 <em>Subscription</em> 未被 取消，但 <em>Subscription.cancel()</em>  必须  请求 <em>Publisher</em> 最终放弃 对相应 <em>subscriber</em> 的任何引用</p>
<p>此规则的目的是确保订阅者在订阅不再有效后可以正确收集垃圾</p>
<p>不鼓励使用同一订阅对象重新订阅，但此规范并不要求它被禁止，因为这意味着必须无限期地存储以前取消的订阅</p>
<h3 id="cancel-可能会导致-publisher进入-shut-down"><a class="header" href="#cancel-可能会导致-publisher进入-shut-down"><em>cancel</em> 可能会导致 Publisher进入 shut-down</a></h3>
<p>当<em>Subscription</em> 未被取消，调用  <code>Subscription.cancel</code> 可能会导致 <em>Publisher</em>（如果是有状态）在此点不存在其他&quot;订阅&quot;时过渡到&quot;关闭&quot;状态</p>
<p>此规则的目的是允许发布者在&quot;订阅&quot;后对新订阅者发出  <em>onComplete</em> 或  <code>onError</code> 上发出信号，以响应现有订阅者的取消信号。</p>
<h3 id="subscriptioncancel-must-return-normally"><a class="header" href="#subscriptioncancel-must-return-normally"><code>Subscription.cancel</code> MUST <a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.3#term_return_normally">return normally</a></a></h3>
<p>此规则的目的是不允许实现 针对所谓的&quot;取消&quot;而抛出例外情况。</p>
<h3 id="subscriptionrequest-must-return-normally"><a class="header" href="#subscriptionrequest-must-return-normally"><code>Subscription.request</code> MUST <a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/v1.0.3#term_return_normally">return normally</a></a></h3>
<p>此规则的目的是不允许实施针对被调用的&quot;请求&quot;抛出例外情况。</p>
<h3 id="subscription必须支持无边界的request"><a class="header" href="#subscription必须支持无边界的request">Subscription必须支持无边界的request</a></h3>
<p>&quot;订阅&quot; 必须支持无限制的&quot;request&quot; 调用数量 并且必须支持高达  2^63-1 需求 , greater than 2^63-1 的需求可能被&quot;发布者&quot;视为&quot;有效无限制&quot;。</p>
<p>此规则的目的是确定订阅者可以请求无限数量的元素，在任何增量超过 0，在任意数量的&quot;请求&quot;中。</p>
<p>因为它不能在合理的时间内使用当前或预见到的硬件（每纳秒 1 个元素需要 292 年）以达到  2×63-1 的需求，允许 <em>Publisher</em> 在此点之后停止跟踪需求</p>
<h2 id="processor"><a class="header" href="#processor">Processor</a></h2>
<pre><code class="language-java">public interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {
}
</code></pre>
<h3 id="processor处理阶段"><a class="header" href="#processor处理阶段">Processor处理阶段</a></h3>
<p><em>Processor</em> 代表 一个处理阶段，既是订阅者又是 发布者，并且遵循两者的  规则</p>
<p>此规则的目的是确定处理器的行为，并受发布者和订阅者规范的约束</p>
<h3 id="onerror恢复与传播"><a class="header" href="#onerror恢复与传播">onError恢复与传播</a></h3>
<p>&quot;处理器&quot;可以选择恢复 onError信号，如果它选择这样做，它必须考虑取消的&quot;订阅&quot;，否则，它必须立即向订阅者传播&quot;OnError&quot;信号。</p>
<p>此规则的目的是告知实现 可能不仅仅是简单的转换</p>
<h1 id="asynchronous-vs-synchronous-processing"><a class="header" href="#asynchronous-vs-synchronous-processing">Asynchronous vs Synchronous Processing</a></h1>
<p>The Reactive Streams API 规定 所有元素的调用 <em>onNext</em> 最终信号的调用 <em>onError</em> <em>onCompelete</em> 必须不阻塞 <em>Publisher</em> 但是 onHander的调用可以是 同步或者异步</p>
<p>以此示例为例：</p>
<pre><code>nioSelectorThreadOrigin map(f) filter(p) consumeTo(toNioSelectorOutput)
</code></pre>
<p>它有一个 异步的 起源 和异步的 目的地  让我们假设原点和目的地都是选择器事件循环  <code>Subscription.request(n)</code> 必须 从 目的地链接到原点</p>
<p>，每个实现可以选择如何执行</p>
<p>下面使用管道|表示不一样边界（队列和计划）和 R#表示资源（可能为线程）的字符。</p>
<pre><code>nioSelectorThreadOrigin | map(f) | filter(p) | consumeTo(toNioSelectorOutput)
-------------- R1 ----  | - R2 - | -- R3 --- | ---------- R4 ----------------
</code></pre>
<p>在此示例中，3 个消费者中的每一个，map、filter 和 consumer 都异步地安排工作。它可以在同一事件循环（trampoline），单独的线程，无论什么。</p>
<pre><code>nioSelectorThreadOrigin map(f) filter(p) | consumeTo(toNioSelectorOutput)
------------------- R1 ----------------- | ---------- R2 ----------------
</code></pre>
<p>只有最后一步 是使用 异步调度，通过将 任务 加入到  <em>NioSelectorOutput event loop</em></p>
<p>The <code>map</code> and <code>filter</code> steps 在原始线程中 同步执行</p>
<p>实现也可以 融合其他操作 到最终消费者</p>
<pre><code>nioSelectorThreadOrigin | map(f) filter(p) consumeTo(toNioSelectorOutput)
--------- R1 ---------- | ------------------ R2 -------------------------
</code></pre>
<p>所有这些变种都是&quot;异步流&quot;。它们都有自己的位置，每个都有不同的权衡，包括性能和实现复杂性。</p>
<p>The Reactive Streams 允许实现管理资源和调度的灵活性，并在非阻塞、异步、动态推拉流范围内混合异步和同步处理。</p>
<p>以便完全异步实现所有参与的 API 元素 <code>Publisher</code>/<code>Subscription</code>/<code>Subscriber</code>/<code>Processor</code> 上的所有方法均返回void</p>
<h1 id="subscriber-controlled-queue-bounds"><a class="header" href="#subscriber-controlled-queue-bounds">Subscriber controlled queue bounds</a></h1>
<p>一个基本设计原则是：所有 bufferSize是 有界的，这些界限必须由Subscribe 已知  和 控制</p>
<p>这些界限以 元素计数 表示（这又导致转化为下一个的调用计数）</p>
<p>旨在支持无限流的任何实现（特别是高输出率流），需要一直控制（<em>enforce</em>） 边界，限制资源使用 以避免内存溢出错误</p>
<p>由于背压是强制性的，可以避免使用无限制的缓冲器,</p>
<p>一般来说，队列增长 没有边界的 唯一时刻 是 当 <em>Publisher</em> 维持 高速率 生产 比 订阅者的消费速度要快，但是这种场景 使用背压 处理</p>
<p>Queue bounds can be controlled by a subscriber signaling demand for the appropriate number of elements. </p>
<p>队列边界可由用户对适当数量的元素发出信号需求来控制：</p>
<p>在任何时刻，subscriber都知道</p>
<ul>
<li>请求的总元素数量: <code>P</code></li>
<li>已处理的元素数量 <code>N</code></li>
</ul>
<p>然后，可能到达的最大元素数量是  <code>P - N</code>，直到更多的需求向 Publisher 发出信号 </p>
<p>如果订阅者也知道其输入缓冲器中的元素 B 数，则此边界重新定义为：P-B-N</p>
<p>这些边界 必须影响 到 <em>publisher</em> 独立于 它所代表的来源是否可以回压，</p>
<p>如果生产率不能受到影响的来源:例如时钟滴答声或鼠标运动,<em>Publisher</em>必须选择缓冲或丢弃元素以遵守  imposed bounds 。</p>
<ol>
<li><em>Subscribers</em> 在接收到一个元素后，发布对一个元素需求的信号。从而有效的执行了： Stop-and-Wait 协议 ：需要信号等同于 确认信号</li>
<li>通过提供 多个元素的 <em>request</em> 确认的成本 被 分摊</li>
<li>值得注意的是： Subscriber 被允许 随时 发起需求信号 ，允许它避免 <em>Publiser</em> 和  <em>Subscriber</em> 之间不必要的延迟（例如：保持输入缓冲填满，无需等待完整的往返）</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍-11"><a class="header" href="#介绍-11">介绍</a></h1>
<p><em>Reactor</em> 是一个 JVM上 完全 非阻塞的 响应式 编程框架，它有着高效的 需求管理（以管理&quot;背压&quot;的形式），它直接与 Java 8 功能 API 集成，特别是 <em>CompletableFuture</em> <em>Stream</em> <em>Duration</em> ，它提供可组合的异步序列 API <code>Flux</code> (for [N] elements)   <code>Mono</code> (for [0|1] elements) </p>
<p>广泛实现了  <a href="https://www.reactive-streams.org/">Reactive Streams</a>  规范</p>
<p>Reactor-netty 还支持 非阻塞的 跨进程 通信，适合微服务架构，Reactor Netty 为 HTTP 包括 <em>websockets</em> TCP, and UDP  提供   backpressure-ready engines  完全支持反应编码和解码。</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="传递依赖引用orgreactivestreams"><a class="header" href="#传递依赖引用orgreactivestreams">传递依赖引用org.reactivestreams</a></h3>
<p>It has a transitive dependency on <code>org.reactivestreams:reactive-streams:1.0.3</code>.</p>
<h3 id="依赖java18"><a class="header" href="#依赖java18">依赖Java1.8</a></h3>
<h2 id="understanding-the-bom-and-versioning-scheme"><a class="header" href="#understanding-the-bom-and-versioning-scheme">Understanding the BOM and versioning scheme</a></h2>
<p><strong>BOM模型</strong></p>
<p>Reactor 3 采用 BOM 模型  （since <code>reactor-core 3.0.4</code>, with the <code>Aluminium</code> release train）</p>
<p>此精心策划的列表将旨在很好地协同工作的器件组。</p>
<p>Note the versioning scheme has changed between 3.3.x and 3.4.x (Dysprosium and Europium).</p>
<p><strong>版本命名规范</strong></p>
<p>构件采用 <code>MAJOR.MINOR.PATCH-QUALIFIER</code>  命名版本</p>
<p>BOM  is versioned using a CalVer inspired scheme of <code>YYYY.MINOR.PATCH-QUALIFIER</code>, </p>
<ul>
<li><code>MAJOR</code> Reactor的 generation, 每一代都能给项目结构带来根本性的变化 (这可能意外着 更重大的迁移工作)</li>
<li><code>YYYY</code> is the year of the first GA release in a given release cycle (like 3.4.0 for 3.4.x)</li>
<li><code>.MINOR</code> is a 0-based number incrementing with each new release cycle(是每个新发布版本周期的基于 0 的数字增量)
<ul>
<li>就构建而言，它通常反映了更广泛的变化，可以表明只需要 适度的迁移工作</li>
<li>在 BOM 的情况下，它允许辨别 同一年的两个 首次发布周期</li>
</ul>
</li>
<li><code>.PATCH</code> 是每个服务版本的基于 0 的数字增量</li>
<li><code>-QUALIFIER</code> 是文本限定符，在 GA 版本的情况下省略（见下文）</li>
</ul>
<p>遵循该约定的第一个发布周期是 <code>2020.0.x</code> 研发代码 <code>Europium</code> 该计划使用以下限定符（注意使用破折号分割），顺序如下：</p>
<ul>
<li><code>-M1</code>..<code>-M9</code>: 里程碑（我们预计每次服务发布不超过 9 个）</li>
<li><code>-RC1</code>..<code>-RC9</code>: 发布候选项（我们预计每个服务版本不会超过 9 个）</li>
<li><code>-SNAPSHOT</code>: snapshots</li>
<li><em>no qualifier</em> for GA releases</li>
</ul>
<p>快照在上面的顺序中显示得更高，因为从概念上讲，它们总是任何给定的 PATCH 的&quot;最新鲜的预发布&quot;。</p>
<p>即使补丁周期中的第一个部署的工件永远是 - 快照</p>
<p>类似命名但更新的快照也将在例如之后发布。例如：里程碑或 发布候选者之间。</p>
<p><strong>版本周期代号</strong></p>
<p>每个版本周期也给出一个代号，与以前的基于代号的方案保持连续性</p>
<p>可用于更非正式地引用它（比如在讨论、博客文章等。）</p>
<p>代号代表传统上 <em>MAJOR.MINOR</em></p>
<p>它们（大部分）来自 <a href="https://en.wikipedia.org/wiki/Periodic_table#Overview">Periodic Table of Elements</a>,以增加字母顺序。</p>
<p>Up until Dysprosium the BOM 使用  release train 模式： codename跟着 qualifier,qualifier略有不同</p>
<p>For example: </p>
<p>Aluminium-RELEASE (first GA release, would now be something like YYYY.0.0), </p>
<p>Bismuth-M1, Californium-SR1 (service release would now be something like YYYY.0.1), </p>
<p>Dysprosium-RC1, Dysprosium-BUILD-SNAPSHOT (after each patch, we’d go back to the same snapshot version. would now be something like YYYY.0.X-SNAPSHOT so we get 1 snapshot per PATCH)</p>
<h1 id="获取reactor"><a class="header" href="#获取reactor">获取Reactor</a></h1>
<p>使用 Reactor最简单的方法是 使用 BOM 并将相关的依赖 添加到 您的项目中</p>
<p>注意：添加此类依赖时，必须省略版本，以便从 BOM 获取版本</p>
<p>As of this version (reactor-core 3.4.10), the latest stable BOM in the associated release train line is <code>2020.0.11</code>, </p>
<p>which is what is used in snippets below. There might be newer versions since then (including snapshots, milestones and new release train lines), see https://projectreactor.io/docs for the latest artifacts and BOMs.</p>
<h2 id="maven"><a class="header" href="#maven">Maven</a></h2>
<p><strong>引入BOM</strong></p>
<pre><code class="language-xml">&lt;dependencyManagement&gt; 
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
            &lt;artifactId&gt;reactor-bom&lt;/artifactId&gt;
            &lt;version&gt;2020.0.11&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<p><strong>引入核心依赖</strong></p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; 
        
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; 
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h2 id="milestones-and-snapshots"><a class="header" href="#milestones-and-snapshots">Milestones and Snapshots</a></h2>
<p>里程碑和开发人员预览 通过 Spring Milestones 仓库 分发，而不是 Maven Central.</p>
<p>要将其添加到构建配置文件，请使用以下片段：</p>
<pre><code class="language-xml">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones Repository&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;

&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshot Repository&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<h2 id="support-and-policies"><a class="header" href="#support-and-policies">Support and policies</a></h2>
<h3 id="stack-overflow-first"><a class="header" href="#stack-overflow-first">Stack Overflow first</a></h3>
<p>Search Stack Overflow first; discuss if necessary</p>
<p>使用我们为此目的监控的标签中的相关标签：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/tagged/reactor-netty"><code>reactor-netty</code></a> for specific reactor-netty questions</li>
<li><a href="https://stackoverflow.com/questions/tagged/project-reactor"><code>project-reactor</code></a> for generic reactor questions</li>
</ul>
<p>如果您喜欢实时讨论，我们还有几个 Gitter 频道：</p>
<ul>
<li><a href="https://gitter.im/reactor/reactor"><code>reactor</code></a> 是历史上最活跃的一个, 社区的大部分可以帮助</li>
<li><a href="https://gitter.im/reactor/reactor-core"><code>reactor-core</code></a> is intended for more advanced pinpointed discussions around the inner workings of the library</li>
<li><a href="https://gitter.im/reactor/reactor-netty"><code>reactor-netty</code></a> is intended for netty-specific questions</li>
</ul>
<p>有关潜在的其他信息来源，请参阅每个项目的 README。</p>
<p>我们通常不鼓励打开 Github 问题的问题， 赞成上述两个渠道。</p>
<h2 id="our-policy-on-deprecations"><a class="header" href="#our-policy-on-deprecations">Our policy on <strong>deprecations</strong></a></h2>
<p>在处理弃用时，如果提供 A .B.C 版本，我们将确保：</p>
<ul>
<li>
<p>deprecations introduced in version <code>A</code>.<code>B</code>.<code>0</code> will be removed <strong>no sooner than</strong> version <code>A</code>.<strong><code>B+1</code></strong>.<code>0</code></p>
<p>A.B.0的弃用  在 A.B+1.0 最早移除</p>
</li>
<li>
<p>deprecations introduced in version <code>A</code>.<code>B</code>.<code>1+</code> will be removed <strong>no sooner than</strong> version <code>A</code>.<strong><code>B+2</code></strong>.<code>0</code></p>
<p>A.B.1+的 弃用 在A.B+2 最早移除</p>
</li>
<li>
<p>we’ll strive to mention the following in the deprecation javadoc:</p>
<ul>
<li>target minimum version for removal：目标弃用版本</li>
<li>pointers to replacements for the deprecated method：替代方法</li>
<li>version in which method was deprecated：声明 国企的版本</li>
</ul>
</li>
</ul>
<h2 id="active-development"><a class="header" href="#active-development">Active Development</a></h2>
<p>The following table summarises the development status of the various Reactor release trains:</p>
<table><thead><tr><th style="text-align: left">Version</th><th style="text-align: left">Supported</th></tr></thead><tbody>
<tr><td style="text-align: left">2020.0.0 (codename Europium) (core 3.4.x, netty 1.0.x)</td><td style="text-align: left">:white_check_mark:</td></tr>
<tr><td style="text-align: left">Dysprosium Train (core 3.3.x, netty 0.9.x)</td><td style="text-align: left">:white_check_mark:</td></tr>
<tr><td style="text-align: left">Califonium and below (core &lt; 3.3, netty &lt; 0.9)</td><td style="text-align: left">:x:</td></tr>
<tr><td style="text-align: left">Reactor 1.x and 2.x Generations</td><td style="text-align: left">:x:</td></tr>
</tbody></table>
<h1 id="响应式编程介绍"><a class="header" href="#响应式编程介绍">响应式编程介绍</a></h1>
<p>Reactor 是反应编程范式的 实现：可以概括为</p>
<blockquote>
<p>响应式编程 是一个 异步编程范式，关注 数据流的 以及 变化的 传播</p>
<p>这意味着 编程语言 轻松表达 静态 （例如 数据） 或者 动态（例如 事件产生器） 数据流 </p>
</blockquote>
<p>作为响应式编程的第一步，微软在.NET生态系统中实现了 <code>Reactive Extensions</code> 库</p>
<p>然后 Rxjava 在 Jvm 上实现了反应性编程 ，随着时间的推移，通过 Reactive Streams  的努力 实现了  Java的标准化, 这个规范为 JVM库  定义了 一系列接口 和 交互规则，这些接口已集成到 Java9的 <em>flow</em> 类</p>
<p>响应式编程范式 通常是 作为面向对象语言中的 观察者模式的 扩展</p>
<p>你还可以 将 主 反应式 流 模式 和 熟悉的 迭代器模式 比较，因为对于 Interable-Iterator 对  具有二元性。一个主要的区别是  迭代器是 拉模式，reactive streams是基于 推模式</p>
<p>使用 迭代器 是一个 必不可少的 设计模式，即使 访问值的方法完全由 <em>Iterable</em> 负责</p>
<p>事实上，它是 由 开发人员选择 何时 访问序列中的  <em>next</em>，在 reactive stream中 等价的  对 是 <em>publisher</em> -<em>subscriber</em>  但是  是由 <em>Publisher</em>  通知 订阅者 最新可用的值 ,这种 <em>push</em> aspect   被称为 <em>reactive</em> </p>
<p>此外：应用 push值 的 操作 是 声明式 而不是 命令式，程序员声明计算逻辑。而不是准确描述 其控制流</p>
<p>除了推值外， 错误处理，完成后处理也以明确的方式定义</p>
<p>A <code>Publisher</code> can push new values to its <code>Subscriber</code> (by calling <code>onNext</code>) but can also signal an error (by calling <code>onError</code>) or completion (by calling <code>onComplete</code>). Both errors and completion terminate the sequence. This can be summed up as follows:</p>
<p><em>Publisher</em> 能够 推 新值 给 它的<em>Subscriber</em>  （通过调用 <em>onNext</em>） 但是 也可以  发出 Error信号（通过 调用 <em>onError</em>） 或者 完成 （通过调用 <em>onComplete</em>）</p>
<p><em>error</em> 或 <em>complete</em> 都会 终止 序列 ，这可以概括为</p>
<pre><code class="language-none">onNext x 0..N [onError | onComplete]
</code></pre>
<h2 id="blocking-can-be-wasteful"><a class="header" href="#blocking-can-be-wasteful">Blocking Can Be Wasteful</a></h2>
<p>现在应用 可会有 大量并发用户 ，尽管 现代硬件能力 得到了长足的发展，现代软件的性能 仍然是一个关键问题</p>
<p>大致而言，有两种方法可以改进程序的性能：</p>
<ul>
<li><strong>parallelize</strong>  使用更多的线程和更多的硬件资源。</li>
<li><strong>seek more efficiency</strong> 当前资源的使用方式</li>
</ul>
<p>通常，Java开发人员使用 阻塞式编程，这种做法 存在性能 瓶颈，然后引入额外线程 ，运行 类似的 阻塞代码 </p>
<p>这种资源利用规模的扩大 可以迅速 引入 数据竞争 和并发问题</p>
<p>更遭的是，阻塞 浪费资源,如果 你仔细观察 只要一个程序 涉及一些延迟 (特别是 I/O 例如数据库请求 或网络请求)</p>
<p>资源被浪费了，因为很多线程处于闲置状态，等待数据</p>
<p>因此 并发化并不是一颗银弹，有必要 利用硬件的 全部能力</p>
<h2 id="asynchronicity-to-the-rescue"><a class="header" href="#asynchronicity-to-the-rescue">Asynchronicity to the Rescue</a></h2>
<blockquote>
<p>异步节省资源</p>
</blockquote>
<p>通过编写 异步 非阻塞代码，您可以让执行 切换到 使用相同基础资源的已活动任务，并在 异步处理完成后返回 当前 过程</p>
<p>但是：如何在JVM上生成 异步代码呢，Java提供了两种 异步编程模式</p>
<p><strong>Callbacks</strong>：</p>
<p>异步方法没有返回值，需要有额外的回调参数</p>
<p><strong>Future</strong></p>
<p>异步方法立即 返回 <code>Future&lt;T&gt;</code></p>
<p>异步计算过程返回 T，通过Future对象包装</p>
<p>该值不可立即获得，对象可以进行 <em>polled</em>，直到该值可用。</p>
<p>例如运行：<code>ExecutorService</code>  <code>Callable&lt;T&gt;</code> tasks  返回 Future队形</p>
<p>这些技术够好吗？并非针对每个用例，两种方法都有局限性。</p>
<p>回调很难组合在一起，导致难以读取 和维护 代码（known as “Callback Hell”）</p>
<p>考虑一个例子：展示来自 用户UI上的 TOP 5 的收藏夹 或者如果没有收藏夹就建议</p>
<p>这需求经过三项服务</p>
<p>第一个提供 favorite IDs</p>
<p>第二个取 favorite details</p>
<p>第三个 提供 建议</p>
<p><strong>传统回调</strong></p>
<p>这是很多代码，它有点难以阅读，具有重复部分</p>
<pre><code class="language-java">userService.getFavorites(userId, new Callback&lt;List&lt;String&gt;&gt;() { 
  public void onSuccess(List&lt;String&gt; list) { 
    if (list.isEmpty()) { 
      suggestionService.getSuggestions(new Callback&lt;List&lt;Favorite&gt;&gt;() {
        public void onSuccess(List&lt;Favorite&gt; list) { 
          UiUtils.submitOnUiThread(() -&gt; { 
            list.stream()
                .limit(5)
                .forEach(uiList::show); 
            });
        }

        public void onError(Throwable error) { 
          UiUtils.errorPopup(error);
        }
      });
    } else {
      list.stream() 
          .limit(5)
          .forEach(favId -&gt; favoriteService.getDetails(favId, 
            new Callback&lt;Favorite&gt;() {
              public void onSuccess(Favorite details) {
                UiUtils.submitOnUiThread(() -&gt; uiList.show(details));
              }

              public void onError(Throwable error) {
                UiUtils.errorPopup(error);
              }
            }
          ));
    }
  }

  public void onError(Throwable error) {
    UiUtils.errorPopup(error);
  }
});
</code></pre>
<p><strong>响应式</strong></p>
<pre><code class="language-java">userService.getFavorites(userId) 
           .flatMap(favoriteService::getDetails) 
           .switchIfEmpty(suggestionService.getSuggestions()) 
           .take(5) 
           .publishOn(UiUtils.uiThreadScheduler()) 
           .subscribe(uiList::show, UiUtils::errorPopup); 
</code></pre>
<p>如果你想确保在不到 800 毫秒内检索到最喜欢的 ID， 该怎么办？</p>
<p>如果需要更长的时间，从缓存中获取它们？</p>
<p>在基于回调的代码中，这是一项复杂的任务</p>
<p>在 <em>Reactor</em> 中 它变得像在链条中添加超时操作员一样简单</p>
<pre><code class="language-java">userService.getFavorites(userId)
           .timeout(Duration.ofMillis(800)) 
           .onErrorResume(cacheService.cachedFavoritesFor(userId)) 
           .flatMap(favoriteService::getDetails) 
           .switchIfEmpty(suggestionService.getSuggestions())
           .take(5)
           .publishOn(UiUtils.uiThreadScheduler())
           .subscribe(uiList::show, UiUtils::errorPopup);
</code></pre>
<p>Future objects 比 回调要好，但是 不能很好的组合，另外 Java8的 <strong>CompletableFuture</strong>  做出了改善</p>
<p>将多个Future对象协调在一起是可行的，但并不容易。此外，Future还有其他问题：</p>
<ul>
<li>get方法会阻塞</li>
<li>不支持懒 计算</li>
<li>缺乏对 多个值的支持 和高级错误处理</li>
</ul>
<p>考虑另一个例子：</p>
<p>我们得到一个ID列表，我们希望从中获取一个名称和一个统计数据，并结合这些配对，所有这些都是异步的</p>
<pre><code class="language-java">CompletableFuture&lt;List&lt;String&gt;&gt; ids = ifhIds(); 

CompletableFuture&lt;List&lt;String&gt;&gt; result = ids.thenComposeAsync(l -&gt; { 
	Stream&lt;CompletableFuture&lt;String&gt;&gt; zip =
			l.stream().map(i -&gt; { 
				CompletableFuture&lt;String&gt; nameTask = ifhName(i); 
				CompletableFuture&lt;Integer&gt; statTask = ifhStat(i); 

				return nameTask.thenCombineAsync(statTask, (name, stat) -&gt; &quot;Name &quot; + name + &quot; has stats &quot; + stat); 
			});
	List&lt;CompletableFuture&lt;String&gt;&gt; combinationList = zip.collect(Collectors.toList()); 
	CompletableFuture&lt;String&gt;[] combinationArray = combinationList.toArray(new CompletableFuture[combinationList.size()]);

	CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(combinationArray); 
	return allDone.thenApply(v -&gt; combinationList.stream()
			.map(CompletableFuture::join) 
			.collect(Collectors.toList()));
});

List&lt;String&gt; results = result.join(); 
assertThat(results).contains(
		&quot;Name NameJoe has stats 103&quot;,
		&quot;Name NameBart has stats 104&quot;,
		&quot;Name NameHenry has stats 105&quot;,
		&quot;Name NameNicole has stats 106&quot;,
		&quot;Name NameABSLAJNFOAJNFOANFANSF has stats 121&quot;);
</code></pre>
<p>由于 Reactor拥有 更多 开箱即用的 组合操作，因此过程可以 简化如下</p>
<pre><code class="language-java">Flux&lt;String&gt; ids = ifhrIds(); 

Flux&lt;String&gt; combinations =
		ids.flatMap(id -&gt; { 
			Mono&lt;String&gt; nameTask = ifhrName(id); 
			Mono&lt;Integer&gt; statTask = ifhrStat(id); 

			return nameTask.zipWith(statTask, 
					(name, stat) -&gt; &quot;Name &quot; + name + &quot; has stats &quot; + stat);
		});

Mono&lt;List&lt;String&gt;&gt; result = combinations.collectList(); 

List&lt;String&gt; results = result.block(); 
assertThat(results).containsExactly( 
		&quot;Name NameJoe has stats 103&quot;,
		&quot;Name NameBart has stats 104&quot;,
		&quot;Name NameHenry has stats 105&quot;,
		&quot;Name NameNicole has stats 106&quot;,
		&quot;Name NameABSLAJNFOAJNFOANFANSF has stats 121&quot;
);
</code></pre>
<h2 id="from-imperative-to-reactive-programming"><a class="header" href="#from-imperative-to-reactive-programming">From Imperative to Reactive Programming</a></h2>
<p>Reactive 库例如 Reactor 旨在 解决 经典异步方法的缺点 同时关注其他几个方面</p>
<ol>
<li>组合型跟可读性</li>
<li>数据流动，丰富的操作方法</li>
<li>懒加载</li>
<li>被压：消费者向 生产者 发出 生产速率 过高的信号的能力</li>
<li>高度抽象，高度价值 抽象   <em>concurrency-agnostic</em></li>
</ol>
<h3 id="composability-and-readability"><a class="header" href="#composability-and-readability">Composability and Readability</a></h3>
<p>通过 可组合性，我们有能力能 协调多个 异步任务，我们使用 以前任务的结果输入到 后续的调用中 或者 我们可以 fork-join style 运行任务 ，此外在更高级的组件中，作为 离散组件  我们可以重用 异步任务 </p>
<p>协调任务的能力与 可读性 和可维护性的代码 紧密结合</p>
<p>随着异步 过程 层在数量和 复杂性上 都有所增加 </p>
<p>能够编写 和阅读代码 变得越来越困难，正如所看到的  回调模型很简单 </p>
<p>主要缺点之一是：回调地狱</p>
<p>Reactor提供了丰富的选项组合，其中 代码反映了 抽象过程的组织，并且所有内容通常 保持在同一水平 （嵌套最小化）</p>
<h3 id="the-assembly-line-analogy"><a class="header" href="#the-assembly-line-analogy">The Assembly Line Analogy</a></h3>
<blockquote>
<p>装配线类比</p>
</blockquote>
<p>您可以将响应式应用程序 处理的数据 视为 通过装配线移动</p>
<p>Reactor 既是 传送带 也是 工作站 ，原料 从源头（原始 <em>Publisher</em> ）倾泻而出 </p>
<p>最终成为成品 准备将推给 消费者（订阅者）</p>
<p>原材料 可以经历 各种转换 和其他中间步骤 或成为  将中间件聚合在一起的 大型装配线 的一部分 </p>
<p>如果某时刻 出现故障 或阻塞 （业务 boxing 产品 花费很长的时间）</p>
<p>负载严重的工作站 可以向上游发出信号，以限制原材料的流动</p>
<h3 id="operators-1"><a class="header" href="#operators-1">Operators</a></h3>
<p>Reactor中，操作就是工作站，每一个操作 都会 将行为添加到 <em>Publisher</em> 中</p>
<p>并将前一步的 Publisher 包装成一个 新的 实例</p>
<p>因此整个链条是相连的</p>
<p>这样 数据源自 第一个 <em>Publisher</em> 沿着 链条向下移动，由每个链节点 转换，最终订阅者 完成了该过程，如果没有 Subscriber没有订阅 ，</p>
<p>了解 operators 创建 新实例 帮助您 避免 常见的误区，这个误区 会导致您相信 一个操作 在链条中没有被应用</p>
<p>虽然 Reactive Streams 规范 没有 规定操作 </p>
<p>one of the best added values of reactive libraries, such as Reactor, is the rich vocabulary of operators that they provide. </p>
<p>这些覆盖了很多面，从简单的 转换 和过滤 到复杂的 编排 和错误处理</p>
<h3 id="nothing-happens-until-you-subscribe"><a class="header" href="#nothing-happens-until-you-subscribe">Nothing Happens Until You <code>subscribe()</code></a></h3>
<p>In Reactor, 当你 编写 <em>Publisher</em> 链时，默认情况下 数据不会 泵入该链条</p>
<p>相反：您可以创建 异步过程的 抽象描述 （这有助于重用和组合）</p>
<p>通过订阅的 行为 您将 发布者 与 订阅者 联系起来 ，从而触发整个链中的数据流。</p>
<p>这是通过 从上游 传播的 Subscriber 的单个 request请求 信号内部实现的，一直传回源  发布者</p>
<h3 id="backpressure"><a class="header" href="#backpressure">Backpressure</a></h3>
<p>上游传播信号也用于实现<strong>背压</strong>，我们在装配线类比中 描述为当 工作站比上游处理得慢时，向线路发送发聩信号</p>
<p>Reactive Streams specification定义的 真实机制 非常接近类比</p>
<p>订阅者可以 在 无限制 的模式 工作 ，并让源 以最快的 速度 推送数据</p>
<p>或者 它可以使用 请求 机制 向 源 发出信号，表明 它已准备好 处理最多 n个元素</p>
<p>中间操作 同样可以更改 在途请求，想象 一个缓冲操作员将元素 分十批分组 </p>
<p>如果订阅者 请求一个缓冲 则 源可以生成 是个元素</p>
<p>一些操作 同样实现了 预取 策略 这避免了 request(1) 的 <em>round-trips</em> </p>
<p>如果在要求 之前 生产 元素不是 太昂贵  则是有益的</p>
<p>这将 推送模型 将 转化为  <strong>push-pull hybrid</strong> ，如果上游随时可用，下游可以从上游拉n元素</p>
<p>如果 元素尚未准备好 ，他们一产生就会 被 上游推</p>
<h3 id="hot-vs-cold"><a class="header" href="#hot-vs-cold">Hot vs Cold</a></h3>
<p>Rx 家族的 反应式库 区分了 两大类反应式 序列库 <strong>hot</strong> and <strong>cold</strong>.</p>
<p>这种区别 主要与  reactive stream 如何与 subscribers 相关联起来</p>
<ul>
<li>
<p>A <strong>Cold</strong> 序列 为每一个 Subscriber开启一个新的 包括数据源. 如果源包住Http调用 则为 每个订阅提出 新的 HTTP 请求</p>
</li>
<li>
<p><strong>hot</strong> 序列 不会为 每个 <em>subscriber</em> 从头开始</p>
<p>收到 他们订阅后 ， 延迟订阅 者 会发出的信号 </p>
<p>但是：请注意，某些热 reactive stream 可以完全 或部分的缓存或重播 安排的历史</p>
<p>从一般角度 来看，当没有subscriber监听时   热序列 可以 发出 信号（订阅前不做任何事的 规则的 例外）</p>
</li>
</ul>
<h1 id="快速开始-2"><a class="header" href="#快速开始-2">快速开始</a></h1>
<p><code>Flux&lt;T&gt;</code>  是 <code>Reactive Streams</code> 体系中的  <code>Publisher</code>，它有许多 <em>operator</em> ,可用于生成，转换或编排Flux序列</p>
<p>它可以发出0到n个元素（<em>onNext</em>事件），要么完成或者出错（<em>onComplete</em>和<em>onError</em>终止事件）。
如果未触发任何终止事件，则 <em>Flux</em>是无限的。</p>
<ul>
<li>Flux上的静态工厂允许创建源，或从几种回调类型生成 <em>Publisher</em></li>
<li>实例方法，operators,使您可以构建异步处理管道，该管道将产生异步序列</li>
<li>每个<code>Flux＃subscribe()</code>或<em>multicasting</em> (多播操作)（例如<code>Flux#publish</code>和<code>Flux#publishNext</code>）都会具体化管道的专用实例并触发其中的数据流。</li>
</ul>
<h2 id="订阅"><a class="header" href="#订阅">订阅</a></h2>
<h3 id="订阅-1"><a class="header" href="#订阅-1">订阅</a></h3>
<pre><code class="language-java">subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer,
          Runnable completeConsumer,
          Consumer&lt;? super Subscription&gt; subscriptionConsumer); 
</code></pre>
<p>处理值 以及 异常 或者成功，同样 触发订阅事件的处理</p>
<h3 id="取消订阅"><a class="header" href="#取消订阅">取消订阅</a></h3>
<blockquote>
<p>disposable</p>
</blockquote>
<p><strong>disposable</strong></p>
<p>所有这些基于 <em>lambda</em> 的 <code>subscribe（）</code>变体都具有<em>Disposable</em>返回类型。
在这种情况下，Disposable接口表示可以通过调用其<code>dispose（）</code>方法来取消订阅的事实。</p>
<p>对于 <em>Flux</em> or <em>Mono</em>，取消 是 信号源 应停止产生元素的信号。
但是，并不能保证立即执行：某些源可能会产生如此快的元素，以至于甚至在接收到取消指令之前它们也可以完成</p>
<p><strong>swap</strong></p>
<p>Disposables类中提供了一些有关Disposable的实用程序。
其中，<code>Disposables.swap（）</code>创建一个Disposable包装器，使您可以原子地取消和替换一个具体的Disposable。</p>
<pre><code>例如，这在UI场景中很有用，在UI场景中，您希望在用户单击按钮时取消请求并将其替换为新的请求。
关闭 包装器本身也会 关闭 它
这样做会 处理 当前的 具体价值 以及将来所有尝试的替代产品。
</code></pre>
<p><strong>composite</strong></p>
<p>您可以收集多个Disposable（例如，与服务调用关联的多个进行中的请求），并在以后一次将所有这些都处置。
在调用组合的dispose（）方法后，任何尝试添加另一个Disposable的尝试都会立即将其处置。</p>
<p><strong>BaseSubscriber</strong></p>
<p>额外的订阅方法，该方法更通用并且采用成熟的订阅服务器，而不是从一个lambda中组成一个。
为了帮助编写这样的订阅服务器，我们提供了一个称为 <em>BaseSubscriber</em> 的可扩展类。</p>
<p>BaseSubscriber（或其子类）的实例是一次性的，这意味着，</p>
<p>如果BaseSubscriber 同时 订阅两个发布者，只有一个能成功，需要CAS 操作去 争抢，失败的则会自行 取消</p>
<p>这是因为使用实例两次将违反“Reactive Stream”规则，即不得并行调用订阅服务器的onNext方法。</p>
<h2 id="stepverifier"><a class="header" href="#stepverifier">StepVerifier</a></h2>
<blockquote>
<p>步骤验证器</p>
</blockquote>
<p>使用 <code>StepVerifier</code> 来 定义一个测试单元 来检查 每个测试的结果</p>
<p>这个类来自 <code>reactor-test</code> 构件，能够订阅任何 <code>Publisher</code> ，然后针对改序列 申明 一些列用户定义的 期望</p>
<p>如果触发了任何与当前期望不符的事件，则<code>StepVerifier</code>将产生一个“ AssertionError”。</p>
<p>您可以从静态工厂<code>create</code>获取<code>StepVerifier</code>的实例。它提供了一个DSL来设置数据部分的期望值，并以单个终端期望值（完成，错误，取消...）结束。</p>
<p>获取到实例后，必须调用<em>verify</em> 方法，或者  结合 <em>termination</em> 期望和验证的快捷方式之一 例如：<code>.verifyErrorMessage(String)</code> </p>
<pre><code class="language-java">StepVerifier.create(T&lt;Publisher&gt;).{expectations...}.verify()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="创建flux的几种方式"><a class="header" href="#创建flux的几种方式">创建FLux的几种方式</a></h2>
<h3 id="empty-flux"><a class="header" href="#empty-flux">Empty flux</a></h3>
<pre><code class="language-java">static &lt;T&gt; Flux&lt;T&gt; empty()
</code></pre>
<h3 id="flux-from-values"><a class="header" href="#flux-from-values">Flux from values</a></h3>
<pre><code>static &lt;T&gt; Flux&lt;T&gt; just(T... data)
</code></pre>
<pre><code class="language-java">Flux.just(&quot;12&quot;,&quot;34&quot;,&quot;56&quot;).subscribe(System.out::println);
</code></pre>
<h3 id="flux-from-range"><a class="header" href="#flux-from-range">Flux from Range</a></h3>
<pre><code class="language-java">Flux&lt;Integer&gt; numbersFromFiveToSeven = Flux.range(5, 3); 
</code></pre>
<h3 id="flux-from-iterator"><a class="header" href="#flux-from-iterator">Flux from iterator</a></h3>
<pre><code>static &lt;T&gt; Flux&lt;T&gt; fromIterable(Iterable&lt;? extends T&gt; it)
</code></pre>
<pre><code class="language-java">Flux&lt;Integer&gt; objectFlux = Flux.fromIterable(() -&gt; new Iterator&lt;Integer&gt;() {
            int i = 0;

            @Override
            public boolean hasNext() {
                return i &lt;= 100;
            }

            @Override
            public Integer next() {
                return i++;
            }
        });
        objectFlux.subscribe(System.out::println);
</code></pre>
<h3 id="create-a-flux-that-emits-an-illegalstateexception"><a class="header" href="#create-a-flux-that-emits-an-illegalstateexception">Create a Flux that emits an IllegalStateException</a></h3>
<pre><code class="language-java">static &lt;T&gt; Flux&lt;T&gt; error(Throwable error)
    
Flux&lt;Object&gt; error = Flux.error(new RuntimeException(&quot;自定义异常&quot;)).onErrorStop();
error.subscribe(e-&gt; System.out.println(e));
</code></pre>
<h3 id="计数器"><a class="header" href="#计数器">计数器</a></h3>
<pre><code class="language-java">static Flux&lt;Long&gt; interval(Duration period)
Flux.interval(Duration.ofMillis(100)).take(10).subscribe(e-&gt; System.out.println(e));
</code></pre>
<h2 id="创建mono的几种方式"><a class="header" href="#创建mono的几种方式">创建Mono的几种方式</a></h2>
<p>Mono 是Reactive Streams发布者，增加了几种运算符，可用于生成，转换或编排Mono序列。</p>
<p>它是Flux的特化，最多可发出1个元素：Mono的值</p>
<ul>
<li>
<p>带元素 完成</p>
</li>
<li>
<p>空（不带元素的完成）</p>
</li>
<li>
<p>或失败（错误）。</p>
</li>
</ul>
<p><code>Mono&lt;Void&gt;</code>可以用于仅关注完成信号的情况（相当于可运行任务的Reactive Streams完成）。</p>
<p>Like for <code>Flux</code>, the operators can be used to define an asynchronous pipeline which will be materialized anew for each <code>Subscription</code>.</p>
<p>跟 <em>Flux</em>  <em>operator</em> 一样 ，可用于定义异步管道，该管道将针对每个“订阅”重新实现。</p>
<p>请注意，某些更改序列的个数的API会返回“ Flux”（反之亦然，将“ Flux”中的个数减小为1的API会返回“ Mono”）。</p>
<h3 id="empty-mono"><a class="header" href="#empty-mono">Empty Mono</a></h3>
<pre><code class="language-java">static &lt;T&gt; Mono&lt;T&gt; empty()
Mono.empty()
</code></pre>
<h3 id="fromvalue"><a class="header" href="#fromvalue">fromValue</a></h3>
<pre><code class="language-java">Mono.just(1);
</code></pre>
<h3 id="永不触发的mono"><a class="header" href="#永不触发的mono">永不触发的Mono</a></h3>
<pre><code class="language-java">Mono.never()
</code></pre>
<h3 id="触发error"><a class="header" href="#触发error">触发Error</a></h3>
<pre><code class="language-java">Mono.error(new IllegalStateException());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="订阅-2"><a class="header" href="#订阅-2">订阅</a></h1>
<pre><code class="language-java">//简单直接订阅：不执行任何动作
subscribe(); 

//	Do something with each produced value.
subscribe(Consumer&lt;? super T&gt; consumer); 

// 错误处理
subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer); 

// 完成处理
subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer,
          Runnable completeConsumer); 

// 针对 Subscription 处理
subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer,
          Runnable completeConsumer,
          Consumer&lt;? super Subscription&gt; subscriptionConsumer); 
</code></pre>
<p>以上变体 返回 对 Subscription的引用 ，当不需要更多的数据时，你可以用来取消该 <em>Subscription</em> </p>
<p>取消后，来源应停止产生值，并清理 其创建的任何资源，这种 <code> cancel-and-clean-up</code> 行为在 Reactor中 以 接口  <code>Disposable</code>表示</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="doonnext"><a class="header" href="#doonnext"><code>doOnNext</code></a></h1>
<p><strong>有数据则触发</strong></p>
<h1 id="doonsuccess"><a class="header" href="#doonsuccess"><code>doOnSuccess</code></a></h1>
<p><strong>成功完成后触发</strong></p>
<h1 id="then"><a class="header" href="#then"><code>then</code></a></h1>
<p>丢弃前面的负载，返回 <code>Mono&lt;Void&gt;</code></p>
<h1 id="thenmonov-other"><a class="header" href="#thenmonov-other"><code>then(Mono&lt;V&gt; other)</code></a></h1>
<p>返回另一个 <em>Mono</em> </p>
<h1 id="数据降维"><a class="header" href="#数据降维">数据降维</a></h1>
<h2 id="flatmap"><a class="header" href="#flatmap"><code>flatMap</code></a></h2>
<p><img src="18.%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/ProjectReactor//images/reactive_flatMap.png" alt="" /></p>
<h2 id="concatmap"><a class="header" href="#concatmap"><code>concatMap</code></a></h2>
<p>合并两个流</p>
<p><img src="18.%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/ProjectReactor//images/reactive_concatMap.png" alt="" /></p>
<ul>
<li>flatMap和flatMapSequential的订阅是同时进行的，而concatMap的是有先后顺序的</li>
<li>concatMap和flatMapSequential的值是跟源中值顺序相同，其中flatMapSequential是经过后排序，二者输出相同</li>
<li>flatMap中的值是交错的，根据事件触发</li>
</ul>
<h1 id="materializedematerialize"><a class="header" href="#materializedematerialize"><em>materialize、dematerialize</em></a></h1>
<blockquote>
<p>将数据封装成 Signal对象</p>
</blockquote>
<h1 id="缓存"><a class="header" href="#缓存">缓存</a></h1>
<p><em>CacheFlux</em></p>
<pre><code class="language-java">CacheFlux.lookup(cache, CACHE_KEY, RouteDefinition.class)
				.onCacheMissResume(this::fetch);
</code></pre>
<h1 id="pushlishon"><a class="header" href="#pushlishon">PushlishOn</a></h1>
<p>在指定的调度器 中运行 <code> onNext, onComplete and onError</code></p>
<p>只会影响后面的操作</p>
<pre><code>Typically used for fast publisher, slow consumer(s) scenarios.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-new-sequence"><a class="header" href="#creating-a-new-sequence">Creating a New Sequence</a></h1>
<h2 id="从已有的值中创建序列"><a class="header" href="#从已有的值中创建序列">从已有的值中创建序列</a></h2>
<ul>
<li>来自 <em>Optional</em> <code>Mono#justOrEmpty(Optional)</code></li>
<li>来自可能为空的值 T  <code>Mono#justOrEmpty(T)</code></li>
</ul>
<h2 id="从方法发出t"><a class="header" href="#从方法发出t">从方法发出T</a></h2>
<ul>
<li><em>Mono#fromSupplier</em></li>
<li>Flux|Mono defer</li>
</ul>
<h2 id="显示枚举"><a class="header" href="#显示枚举">显示枚举</a></h2>
<p><code>Flux#just(T…)</code></p>
<h2 id="从迭代器"><a class="header" href="#从迭代器">从迭代器</a></h2>
<ul>
<li>从数组：<code>Flux#fromArray</code></li>
<li>从Collection类或者迭代器类：<code>Flux#fromIterable</code></li>
<li>从 Range：<code>Flux#range</code></li>
<li>从Stream：<code>Flux#fromStream(Supplier)</code></li>
</ul>
<h2 id="单一来源"><a class="header" href="#单一来源">单一来源</a></h2>
<ul>
<li><em>supplier</em>: <em>Mono#fromSupplier</em></li>
<li>从任务中：Mono#fromCallable,Mono#fromRunnable</li>
<li>从 <em>CompletableFuture</em> 中</li>
</ul>
<h2 id="产生一个已完成的"><a class="header" href="#产生一个已完成的">产生一个已完成的</a></h2>
<p>Flux|Mono.empty</p>
<h2 id="立即产生错误"><a class="header" href="#立即产生错误">立即产生错误</a></h2>
<ul>
<li>Flux|Mono.error</li>
<li>懒加载：<code>error(Supplier&lt;Throwable&gt;)</code></li>
</ul>
<h2 id="永不做任何事"><a class="header" href="#永不做任何事">永不做任何事</a></h2>
<p><code>never</code> </p>
<h2 id="延迟创建元素"><a class="header" href="#延迟创建元素">延迟创建元素</a></h2>
<p><code>defer</code></p>
<h2 id="自动销毁资源"><a class="header" href="#自动销毁资源">自动销毁资源</a></h2>
<p><code>using</code> </p>
<p>三步走规范</p>
<ul>
<li>产生资源</li>
<li>从资源中 产生 序列</li>
<li>序列结束时关闭资源</li>
</ul>
<h2 id="编程式产生事件"><a class="header" href="#编程式产生事件">编程式产生事件</a></h2>
<ul>
<li>同步  Flux#generate</li>
<li>异步或同步： Flux|Mono #create</li>
</ul>
<h1 id="transforming-an-existing-sequence"><a class="header" href="#transforming-an-existing-sequence">Transforming an Existing Sequence</a></h1>
<h2 id="从已存在的数据进行转换"><a class="header" href="#从已存在的数据进行转换">从已存在的数据进行转换</a></h2>
<h3 id="一对一转换"><a class="header" href="#一对一转换">一对一转换</a></h3>
<p>map： 转换</p>
<p>cast：类型转换</p>
<p>index: 生成二元组，附带索引</p>
<h3 id="一对多转换"><a class="header" href="#一对多转换">一对多转换</a></h3>
<p><code>flatMap</code>：自动转换</p>
<p><code>handle</code>：编程式自定义,一对一转换</p>
<p>异步任务：</p>
<ul>
<li>在 flatMap中不想返回数据：则 返回 Mono.empty()</li>
<li>在异步过程中保持 原有序列的顺序 <code>Flux#flatMapSequential</code>，会立即触发产生无序数据，然后对结果重新排序</li>
<li>如果返回多个值：则 <em>Mono#flatMapMany</em> ， <code>Mono#flatMap</code>只能返回 Mono,相比 <code>Mono.map</code> 多了一个异步过程</li>
</ul>
<h2 id="对现有序列添加预设元素"><a class="header" href="#对现有序列添加预设元素">对现有序列添加预设元素</a></h2>
<h3 id="前置添加"><a class="header" href="#前置添加">前置添加</a></h3>
<p>在 前面添加元素：<em>Flux#startWith(T…)</em></p>
<h3 id="后置添加"><a class="header" href="#后置添加">后置添加</a></h3>
<p>在后面添加元素：<code>Flux#concatWithValues(T…)</code></p>
<h2 id="收集flux"><a class="header" href="#收集flux">收集Flux</a></h2>
<h3 id="list"><a class="header" href="#list">List</a></h3>
<p>into a List: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectList--">collectList</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectSortedList--">collectSortedList</a></p>
<h3 id="map"><a class="header" href="#map">Map</a></h3>
<ul>
<li>into a Map: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectMap-java.util.function.Function-">collectMap</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectMultimap-java.util.function.Function-">collectMultiMap</a></li>
</ul>
<h3 id="任意容器"><a class="header" href="#任意容器">任意容器</a></h3>
<ul>
<li><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collect-java.util.stream.Collector-">collect</a></li>
<li>配合 <em>Collectors</em></li>
</ul>
<h3 id="统计sequence-size"><a class="header" href="#统计sequence-size">统计Sequence size</a></h3>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#count--">count</a></p>
<h3 id="合并-1"><a class="header" href="#合并-1">合并</a></h3>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#reduce-A-java.util.function.BiFunction-">reduce</a></p>
<p>合并：但把中间值也会产生  <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#scan-A-java.util.function.BiFunction-">scan</a></p>
<h3 id="收集成bool值"><a class="header" href="#收集成bool值">收集成Bool值</a></h3>
<p>所有值满足同一个条件： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#all-java.util.function.Predicate-">all</a></p>
<p>至少有一个条件满足： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#any-java.util.function.Predicate-">any</a></p>
<p>序列中至少有一个元素： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#hasElements--">hasElements</a> </p>
<h2 id="组合publishers"><a class="header" href="#组合publishers">组合publishers</a></h2>
<h3 id="组合publisher"><a class="header" href="#组合publisher">组合<em>publisher</em></a></h3>
<p><strong>按序列的顺序组合</strong></p>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher...-">Flux#concat</a> or <code>.concatWith(other)</code></p>
<ul>
<li>
<p>按序列出现的先后顺序组合，并延迟错误：<code>Flux#concatDelayError</code></p>
</li>
<li>
<p>急切的订阅 publishers：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#mergeSequential-int-org.reactivestreams.Publisher...-">Flux#mergeSequential</a></p>
</li>
</ul>
<p><strong>按产生元素的顺序：</strong></p>
<ul>
<li><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#merge-int-org.reactivestreams.Publisher...-">Flux#merge</a> / <code>.mergeWith(other)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#mergeWith-org.reactivestreams.Publisher-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#mergeWith-org.reactivestreams.Publisher-">Mono</a>)：主要是为了异步 元素产生，和无限流准备的</li>
<li>with different types (transforming merge): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zip-java.util.function.Function-org.reactivestreams.Publisher...-">Flux#zip</a> / <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zipWith-org.reactivestreams.Publisher-">Flux#zipWith</a> ：将两个序列 合并成 一个 <em>Tuple</em></li>
</ul>
<p><strong>对合并的序列组队</strong></p>
<ul>
<li><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zip-java.util.function.Function-org.reactivestreams.Publisher...-">Flux#zip</a> / <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zipWith-org.reactivestreams.Publisher-">Flux#zipWith</a> </li>
<li>from 2 Monos into a <a href="https://projectreactor.io/docs/core/release/api/reactor/util/function/Tuple2.html">Tuple2</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#zipWith-reactor.core.publisher.Mono-">Mono#zipWith</a></li>
<li>from n Monos when they all completed: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#zip-java.util.function.Function-reactor.core.publisher.Mono...-">Mono#zip</a></li>
</ul>
<p><strong>等待其他序列完成</strong></p>
<ul>
<li>
<p>等待一个来源：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#and-org.reactivestreams.Publisher-">Mono#and</a></p>
</li>
<li>
<p>等待n个来源：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#when-java.lang.Iterable-">Mono#when</a></p>
</li>
<li>
<p>合并来源成为其他元素</p>
<ul>
<li>按元素产生顺序 依次合并  <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zip-java.util.function.Function-org.reactivestreams.Publisher...-">Flux#zip</a></li>
<li>按最近<em>Publishe</em> 时间合并： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#combineLatest-java.util.function.Function-int-org.reactivestreams.Publisher...-">Flux#combineLatest</a></li>
</ul>
</li>
<li>
<p>选中第一个产生元素的发布者</p>
<ul>
<li><code>firstWithValue</code></li>
<li><code>firstWithSignal</code> 第一个返回任何信号的</li>
</ul>
</li>
<li>
<p>每个元素产生一个 <em>Publisher</em></p>
<ul>
<li><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchMap-java.util.function.Function-">switchMap</a></li>
</ul>
</li>
<li>
<p>每个元素是一个Publisher</p>
<ul>
<li><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchOnNext-org.reactivestreams.Publisher-">switchOnNext</a></li>
</ul>
</li>
</ul>
<h3 id="重复publiser"><a class="header" href="#重复publiser">重复Publiser</a></h3>
<p><strong>重复已有序列</strong></p>
<ul>
<li>
<p><code>repeat</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#repeat--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#repeat--">Mono</a>)</p>
</li>
<li>
<p>定时重复：<code>Flux.interval(duration).flatMap(tick → myExistingPublisher)</code></p>
</li>
</ul>
<p><strong>空值处理</strong></p>
<ul>
<li>默认值：<code>defaultIfEmpty</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defaultIfEmpty-T-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defaultIfEmpty-T-">Mono</a>)</li>
<li>切换到另一个序列： <code>switchIfEmpty</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchIfEmpty-org.reactivestreams.Publisher-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#switchIfEmpty-reactor.core.publisher.Mono-">Mono</a>)</li>
</ul>
<p><strong>对值不敢兴趣</strong></p>
<ul>
<li><code>ignoreElements</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ignoreElements--">Flux.ignoreElements()</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ignoreElement--">Mono.ignoreElement()</a>)</li>
<li>转换为另一个Mono对象 ： <code>then</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#then--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#then--">Mono</a>)</li>
<li>等待另一个任何 完成：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenReturn-V-">Mono#thenReturn(T)</a></li>
<li>转换成 <code>Flux</code> ：<code>thenMany</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#thenMany-org.reactivestreams.Publisher-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenMany-org.reactivestreams.Publisher-">Mono</a>)</li>
</ul>
<p><strong>延迟完成</strong></p>
<ul>
<li>延迟指定时间：<code>Flux#delaySequence</code></li>
<li>延迟等待另一个：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delayUntil-java.util.function.Function-">Mono#delayUntil(Function)</a></li>
</ul>
<p><strong>递归展开</strong></p>
<ul>
<li>广度优先：<code>expand(Function)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expand-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#expand-java.util.function.Function-">Mono</a>)</li>
<li>深度优先：<code>expandDeep(Function)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expandDeep-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#expandDeep-java.util.function.Function-">Mono</a>)</li>
</ul>
<h1 id="查看序列"><a class="header" href="#查看序列">查看序列</a></h1>
<p>在不修改 最终sequence的情况下，可以被其他行为通知到</p>
<h2 id="其他信号的回调"><a class="header" href="#其他信号的回调"><strong>其他信号的回调</strong></a></h2>
<h3 id="信号的产生"><a class="header" href="#信号的产生"><strong>信号的产生</strong></a></h3>
<p>emissions: <code>doOnNext</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnNext-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnNext-java.util.function.Consumer-">Mono</a>)</p>
<h3 id="完成"><a class="header" href="#完成">完成</a></h3>
<p>completion: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnComplete-java.lang.Runnable-">Flux#doOnComplete</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnSuccess-java.util.function.Consumer-">Mono#doOnSuccess</a> (includes the result, if any)</p>
<h3 id="错误"><a class="header" href="#错误">错误</a></h3>
<p>error termination: <code>doOnError</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnError-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnError-java.util.function.Consumer-">Mono</a>)</p>
<h3 id="取消"><a class="header" href="#取消">取消</a></h3>
<p>cancellation: <code>doOnCancel</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnCancel-java.lang.Runnable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnCancel-java.lang.Runnable-">Mono</a>)</p>
<h3 id="序列开始"><a class="header" href="#序列开始">序列开始</a></h3>
<p>&quot;start&quot; of the sequence: <code>doFirst</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFirst-java.lang.Runnable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFirst-java.lang.Runnable-">Mono</a>)</p>
<p>this is tied to Publisher#subscribe</p>
<h3 id="订阅后"><a class="header" href="#订阅后">订阅后</a></h3>
<p><code>doOnSubscribe</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnSubscribe-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnSubscribe-java.util.function.Consumer-">Mono</a>)</p>
<p>this is tied to <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true#onSubscribe(org.reactivestreams.Subscription)">Subscriber#onSubscribe(Subscription)</a></p>
<h3 id="请求时"><a class="header" href="#请求时">请求时</a></h3>
<p>request: <code>doOnRequest</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnRequest-java.util.function.LongConsumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnRequest-java.util.function.LongConsumer-">Mono</a>)</p>
<h3 id="序列终止"><a class="header" href="#序列终止">序列终止</a></h3>
<p>completion or error: <code>doOnTerminate</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnTerminate-java.lang.Runnable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnTerminate-java.lang.Runnable-">Mono</a>)</p>
<ul>
<li>but <strong>after</strong> it has been propagated downstream: <code>doAfterTerminate</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doAfterTerminate-java.lang.Runnable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doAfterTerminate-java.lang.Runnable-">Mono</a>)</li>
</ul>
<h3 id="有信号产生"><a class="header" href="#有信号产生">有信号产生</a></h3>
<p>any type of signal, represented as a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Signal.html">Signal</a>: <code>doOnEach</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnEach-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnEach-java.util.function.Consumer-">Mono</a>)</p>
<h3 id="终止"><a class="header" href="#终止">终止</a></h3>
<p>any terminating condition (complete, error, cancel): <code>doFinally</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFinally-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFinally-java.util.function.Consumer-">Mono</a>)</p>
<h2 id="打印日志"><a class="header" href="#打印日志">打印日志</a></h2>
<p>log what happens internally: <code>log</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#log--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#log--">Mono</a>)</p>
<h2 id="所有事件抽象"><a class="header" href="#所有事件抽象">所有事件抽象</a></h2>
<ul>
<li>信号对象：<code>doOnEach</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnEach-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnEach-java.util.function.Consumer-">Mono</a>)</li>
<li>将 onNext、<em>onComplete</em> 、<em>onError</em> 抽象成 <em>SignObject</em> 对象：<code>materialize</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#materialize--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#materialize--">Mono</a>)、<code>dematerialize</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#dematerialize--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#dematerialize--">Mono</a>)</li>
</ul>
<h1 id="过滤序列"><a class="header" href="#过滤序列">过滤序列</a></h1>
<h2 id="过滤-1"><a class="header" href="#过滤-1">过滤</a></h2>
<p><strong>任意过滤序列</strong></p>
<p><code>filter</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filter-java.util.function.Predicate-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#filter-java.util.function.Predicate-">Mono</a>)</p>
<p><strong>异步过滤</strong></p>
<p><code>filterWhen</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filterWhen-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#filterWhen-java.util.function.Function-">Mono</a>)</p>
<p><strong>过滤类别</strong></p>
<p><code>ofType</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ofType-java.lang.Class-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ofType-java.lang.Class-">Mono</a>)</p>
<p><strong>过滤重复数据</strong></p>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#distinct--">Flux#distinct</a></p>
<p>元素本身会使用 HashSet保存</p>
<p>使用 <em>distinct(Object::hashcode)</em> 更加轻量级，不会保存所有元素对象，但是会有 hashCode冲突</p>
<p><strong>过滤相邻之间的重复数据</strong></p>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#distinctUntilChanged--">Flux#distinctUntilChanged</a></p>
<h2 id="取部分序列"><a class="header" href="#取部分序列">取部分序列</a></h2>
<h3 id="取n个元素"><a class="header" href="#取n个元素">取n个元素</a></h3>
<p><strong>从开头取n个元素</strong></p>
<p>limitRequest为true,确保 请求总数被限制在 n</p>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-long-boolean-">Flux#take(long, true)</a></p>
<p><strong>指定延迟</strong></p>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-java.time.Duration-">Flux#take(Duration)</a></p>
<p><strong>只取下一个元素</strong></p>
<p>Flux#next()</p>
<p><strong>取最后n个</strong></p>
<p><strong>Flux#takeLast</strong></p>
<p><strong>直到满足条件后退出</strong></p>
<p>直到满足条件后退出：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeUntil-java.util.function.Predicate-">Flux#takeUntil</a></p>
<p>直到其他订阅者发出元素： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeUntilOther-org.reactivestreams.Publisher-">Flux#takeUntilOther</a> </p>
<p>条件满足直到返回false：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeWhile-java.util.function.Predicate-">Flux#takeWhile</a></p>
<p><strong>最多取一个元素</strong></p>
<p>指定位置：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#elementAt-int-">Flux#elementAt</a></p>
<p>倒数第n个：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeLast-int-">.takeLast(1)</a></p>
<p>最后一个： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#last--">Flux#last()</a></p>
<p>取默认值如果没有： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#last-T-">Flux#last(T)</a></p>
<h3 id="跳过元素"><a class="header" href="#跳过元素"><strong>跳过元素</strong></a></h3>
<p><strong>从开头跳过</strong></p>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skip-long-">Flux#skip(long)</a></p>
<p><strong>基于延迟的跳过</strong></p>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skip-java.time.Duration-">Flux#skip(Duration)</a></p>
<p><strong>跳过尾部元素</strong></p>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipLast-int-">Flux#skipLast</a></p>
<p><strong>一直跳过直到满足条件后不跳过</strong></p>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipUntil-java.util.function.Predicate-">Flux#skipUntil</a> </p>
<p><strong>一直跳过直到其他Publisher产生对象</strong></p>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipUntilOther-org.reactivestreams.Publisher-">Flux#skipUntilOther</a> </p>
<p><strong>一直跳过，直到不满足条件后不跳过</strong></p>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipWhile-java.util.function.Predicate-">Flux#skipWhile</a></p>
<h3 id="取样"><a class="header" href="#取样">取样</a></h3>
<p><strong>按时间间隔取样</strong></p>
<p>取样窗口的最后一个： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sample-java.time.Duration-">Flux#sample(Duration)</a></p>
<p>取样窗口的第一个：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sampleFirst-java.time.Duration-">sampleFirst</a></p>
<p><strong>基于Publiser的 取样器</strong></p>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sample-org.reactivestreams.Publisher-">Flux#sample(Publisher)</a></p>
<p>辅助采样器 发出元素的间隔 作为取样窗口，取最后一个</p>
<p>取样器终止后，当前序列也会终止</p>
<p>如果序列开始前 取样器已经终止，则不会产生任何数据</p>
<p><strong>基于超时的Publisher取样器</strong></p>
<p>based on a publisher &quot;timing out&quot;: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sampleTimeout-java.util.function.Function-">Flux#sampleTimeout</a> (each element triggers a publisher, and is emitted if that publisher does not overlap with the next)</p>
<p>可以认为：将原始序列拆分为 相应 Flux的 start 和 complete 组成的时间窗口</p>
<p>如果 当前元素的 时间窗口 和 下一个元素的 时间窗口 重合：则将当前元素窗口值丢弃</p>
<p><a href="https://stackoverflow.com/questions/44252201/what-is-the-purpose-of-fluxsampletimeout-method-in-the-project-reactor-api">stack_over_flow</a></p>
<h3 id="最多取一个"><a class="header" href="#最多取一个">最多取一个</a></h3>
<p>没有值则报错： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#single--">Flux#single()</a></p>
<p>没有值取默认值： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#single-T-">Flux#single(T)</a></p>
<p>没有值则取空：: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#singleOrEmpty--">Flux#singleOrEmpty</a></p>
<h1 id="handling-errors"><a class="header" href="#handling-errors">Handling Errors</a></h1>
<h2 id="创建错误序列"><a class="header" href="#创建错误序列">创建错误序列</a></h2>
<h3 id="替换成错误序列"><a class="header" href="#替换成错误序列"><strong>替换成错误序列</strong></a></h3>
<p><code>.concat(Flux.error(e))</code></p>
<p><code>.then(Mono.error(e))</code></p>
<h3 id="元素间隔之间发出超时"><a class="header" href="#元素间隔之间发出超时"><strong>元素间隔之间发出超时</strong></a></h3>
<p><code>timeout</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timeout-java.time.Duration-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timeout-java.time.Duration-">Mono</a>)</p>
<h3 id="懒加载异常"><a class="header" href="#懒加载异常">懒加载异常</a></h3>
<p><code>error(Supplier&lt;Throwable&gt;)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.util.function.Supplier-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.util.function.Supplier-">Mono</a>)</p>
<h2 id="trycatch"><a class="header" href="#trycatch">trycatch</a></h2>
<h3 id="抛出异常"><a class="header" href="#抛出异常">抛出异常</a></h3>
<p>throwing: <code>error</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-">Mono</a>)</p>
<h3 id="catch异常"><a class="header" href="#catch异常">catch异常</a></h3>
<p><strong>返回默认值</strong></p>
<p><code>onErrorReturn</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorReturn-java.lang.Class-T-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorReturn-java.lang.Class-T-">Mono</a>)</p>
<p><strong>返回其他序列</strong></p>
<p><code>onErrorResume</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorResume-java.lang.Class-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorResume-java.lang.Class-java.util.function.Function-">Mono</a>)</p>
<p><strong>重新抛出异常</strong></p>
<p><code>.onErrorMap(t → new RuntimeException(t))</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorMap-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorMap-java.util.function.Function-">Mono</a>)</p>
<h3 id="finally块"><a class="header" href="#finally块">finally块</a></h3>
<p><code>doFinally</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFinally-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFinally-java.util.function.Consumer-">Mono</a>)</p>
<h3 id="使用-try-with-resource"><a class="header" href="#使用-try-with-resource">使用 try-with-resource</a></h3>
<p><code>using</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-">Mono</a>) factory method</p>
<h2 id="从异常中恢复"><a class="header" href="#从异常中恢复">从异常中恢复</a></h2>
<h3 id="回滚默认值"><a class="header" href="#回滚默认值"><strong>回滚默认值</strong></a></h3>
<p>返回值：<code>onErrorReturn</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorReturn-java.lang.Class-T-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorReturn-java.lang.Class-T-">Mono</a>)</p>
<p>返回新的Publisher： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorResume-java.lang.Class-java.util.function.Function-">Flux#onErrorResume</a> and <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorResume-java.lang.Class-java.util.function.Function-">Mono#onErrorResume</a></p>
<h3 id="重试"><a class="header" href="#重试">重试</a></h3>
<p><strong>简单次数重试</strong></p>
<p><code>retry()</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retry--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retry--">Mono</a>), <code>retry(long)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retry-long-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retry-long-">Mono</a>)</p>
<p><strong>通过 companion Flux 控制重试</strong></p>
<p><code>retryWhen</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retryWhen-reactor.util.retry.Retry-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retryWhen-reactor.util.retry.Retry-">Mono</a>)</p>
<p>…using a standard backoff strategy (exponential backoff with jitter): <code>retryWhen(Retry.backoff(…))</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retryWhen-reactor.util.retry.Retry-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retryWhen-reactor.util.retry.Retry-">Mono</a>) (see also other factory methods in <a href="https://projectreactor.io/docs/core/release/api/reactor/util/retry/Retry.html">Retry</a>)</p>
<h2 id="处理背压错误"><a class="header" href="#处理背压错误">处理背压错误</a></h2>
<p>从上游请求最大值，并且下游未产生足够请求时</p>
<h3 id="抛出指定异常"><a class="header" href="#抛出指定异常">抛出指定异常</a></h3>
<p>by throwing a special <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalStateException.html?is-external=true">IllegalStateException</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureError--">Flux#onBackpressureError</a></p>
<h3 id="抛出过量异常"><a class="header" href="#抛出过量异常">抛出过量异常</a></h3>
<p>by dropping excess values: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureDrop--">Flux#onBackpressureDrop</a></p>
<ul>
<li>…except the last one seen: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureLatest--">Flux#onBackpressureLatest</a></li>
</ul>
<h3 id="缓存过量异常"><a class="header" href="#缓存过量异常">缓存过量异常</a></h3>
<p>by buffering excess values (bounded or unbounded): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureBuffer--">Flux#onBackpressureBuffer</a></p>
<p>如果缓存区满了：</p>
<ul>
<li>…and applying a strategy when bounded buffer also overflows: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureBuffer-int-reactor.core.publisher.BufferOverflowStrategy-">Flux#onBackpressureBuffer</a> with a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/BufferOverflowStrategy.html">BufferOverflowStrategy</a></li>
</ul>
<h1 id="working-with-time"><a class="header" href="#working-with-time">Working with Time</a></h1>
<h2 id="测量元素产生的时间"><a class="header" href="#测量元素产生的时间">测量元素产生的时间</a></h2>
<h3 id="最精确"><a class="header" href="#最精确">最精确</a></h3>
<p><code>timed</code></p>
<h3 id="从上次-onnext-距离本次-onnext-时间"><a class="header" href="#从上次-onnext-距离本次-onnext-时间">从上次 <em>onNext</em> 距离本次 <em>onNext</em> 时间</a></h3>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#elapsed--">Timed#elapsed()</a> for <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true">Duration</a> since last <code>onNext</code></p>
<h3 id="返回--epoch-timestamp"><a class="header" href="#返回--epoch-timestamp">返回  epoch timestamp</a></h3>
<p>(milliseconds resolution) ：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#timestamp--">Timed#timestamp()</a> for <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html?is-external=true">Instant</a> </p>
<h3 id="返回自订阅以来的时间"><a class="header" href="#返回自订阅以来的时间">返回自订阅以来的时间</a></h3>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#elapsedSinceSubscription--">Timed#elapsedSinceSubcription()</a> for <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true">Duration</a> since subscription (rather than last onNext)</p>
<h2 id="超时"><a class="header" href="#超时">超时</a></h2>
<p>I want my sequence to be interrupted if there is too much delay between emissions: <code>timeout</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timeout-java.time.Duration-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timeout-java.time.Duration-">Mono</a>)</p>
<h2 id="周期定时"><a class="header" href="#周期定时">周期定时</a></h2>
<p>I want to get ticks from a clock, regular time intervals: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#interval-java.time.Duration-">Flux#interval</a></p>
<h2 id="延迟"><a class="header" href="#延迟">延迟</a></h2>
<h3 id="单值延迟"><a class="header" href="#单值延迟">单值延迟</a></h3>
<p>I want to emit a single <code>0</code> after an initial delay: static <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delay-java.time.Duration-">Mono.delay</a>.</p>
<h3 id="多值延迟"><a class="header" href="#多值延迟">多值延迟</a></h3>
<p>between each onNext signal: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delayElement-java.time.Duration-">Mono#delayElement</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#delayElements-java.time.Duration-">Flux#delayElements</a></p>
<h3 id="订阅延迟"><a class="header" href="#订阅延迟">订阅延迟</a></h3>
<p>before the subscription happens: <code>delaySubscription</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#delaySubscription-java.time.Duration-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delaySubscription-java.time.Duration-">Mono</a>)</p>
<h1 id="splitting-a-flux"><a class="header" href="#splitting-a-flux">Splitting a Flux</a></h1>
<h2 id="将-flux-拆分成-fluxflux"><a class="header" href="#将-flux-拆分成-fluxflux">将 Flux<T> 拆分成 Flux&lt;Flux<T></a></h2>
<h3 id="按照-size拆分"><a class="header" href="#按照-size拆分">按照 size拆分</a></h3>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-int-">window(int)</a></p>
<h3 id="每次窗口丢弃大小"><a class="header" href="#每次窗口丢弃大小">每次窗口丢弃大小</a></h3>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-int-int-">window(int, int)</a></p>
<p>一般来说：maxSize == skipSize </p>
<p>如果 maxSize&gt; skipSize 则元素会重叠</p>
<p>如果 maxSize&lt; skipSize  则会跳过元素</p>
<h3 id="超时窗口"><a class="header" href="#超时窗口">超时窗口</a></h3>
<p>通过元素产生的延迟将 元素划分</p>
<h3 id="每次超时窗口丢弃大小"><a class="header" href="#每次超时窗口丢弃大小">每次超时窗口丢弃大小</a></h3>
<p>…with overlapping or dropping windows: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-java.time.Duration-java.time.Duration-">window(Duration, Duration)</a></p>
<h3 id="计数或超时"><a class="header" href="#计数或超时">计数或超时</a></h3>
<p>当计数达到或超时过去时，窗口关闭</p>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowTimeout-int-java.time.Duration-">windowTimeout(int, Duration)</a></p>
<h3 id="条件拆分"><a class="header" href="#条件拆分">条件拆分</a></h3>
<p>每当返回true时新开一个窗口： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-">windowUntil</a></p>
<p>每当返回false时新开一个窗口：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowWhile-java.util.function.Predicate-">windowWhile</a> </p>
<h3 id="通过-publisher控制"><a class="header" href="#通过-publisher控制">通过 Publisher控制</a></h3>
<p>通过元素发出之间的时间间隔 拆分： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-org.reactivestreams.Publisher-">window(Publisher)</a></p>
<p>driven by an arbitrary boundary represented by onNexts in a control Publisher: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-org.reactivestreams.Publisher-">window(Publisher)</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowWhen-org.reactivestreams.Publisher-java.util.function.Function-">windowWhen</a></p>
<h2 id="将fluxt-拆分成-fluxcollectiont"><a class="header" href="#将fluxt-拆分成-fluxcollectiont">将Flux&lt;T&gt; 拆分成 Flux&lt;Collection&lt;T&gt;</a></h2>
<h3 id="拆分成list"><a class="header" href="#拆分成list">拆分成List</a></h3>
<p>大小边界： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-">buffer(int)</a></p>
<p>大小边界丢弃： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-int-">buffer(int, int)</a></p>
<p>超时边界： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-java.time.Duration-java.time.Duration-">buffer(Duration)</a></p>
<p>超时边界丢弃： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-java.time.Duration-java.time.Duration-">buffer(Duration, Duration)</a></p>
<p>大小与超时：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferTimeout-int-java.time.Duration-">bufferTimeout(int, Duration)</a></p>
<p>直到满足条件边界： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferUntil-java.util.function.Predicate-">bufferUntil(Predicate)</a></p>
<p>Publisher边界：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-org.reactivestreams.Publisher-">buffer(Publisher)</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferWhen-org.reactivestreams.Publisher-java.util.function.Function-">bufferWhen</a></p>
<p>自定义边界集合： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-java.util.function.Supplier-">buffer(int, Supplier)</a></p>
<h2 id="同一性质元素放置在同一个flux"><a class="header" href="#同一性质元素放置在同一个flux">同一性质元素放置在同一个Flux</a></h2>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#groupBy-java.util.function.Function-">groupBy(Function)</a>  返回 <code>Flux&lt;GroupedFlux&lt;K, T&gt;</code></p>
<h1 id="going-back-to-the-synchronous-world"><a class="header" href="#going-back-to-the-synchronous-world">Going Back to the Synchronous World</a></h1>
<p>Note: all of these methods except <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#toFuture--">Mono#toFuture</a> will throw an <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html?is-external=true">UnsupportedOperatorException</a> if called from within a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html">Scheduler</a> </p>
<p>marked as &quot;non-blocking only&quot; (by default <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html#parallel--">parallel()</a> and <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html#single--">single()</a>).</p>
<h2 id="阻塞直到获取第一个元素"><a class="header" href="#阻塞直到获取第一个元素">阻塞直到获取第一个元素</a></h2>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockFirst--">Flux#blockFirst</a></p>
<p>…with a timeout: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockFirst-java.time.Duration-">Flux#blockFirst(Duration)</a></p>
<p>对于 <code>Mono</code></p>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#block--">Mono#block</a></p>
<p>…with a timeout: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#block-java.time.Duration-">Mono#block(Duration)</a></p>
<h2 id="阻塞直到获取最后一个元素"><a class="header" href="#阻塞直到获取最后一个元素">阻塞直到获取最后一个元素</a></h2>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockLast--">Flux#blockLast</a></p>
<p>…with a timeout: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockLast-java.time.Duration-">Flux#blockLast(Duration)</a></p>
<h2 id="同步的切换到迭代器"><a class="header" href="#同步的切换到迭代器">同步的切换到迭代器</a></h2>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#toIterable--">Flux#toIterable</a></p>
<h2 id="同步的切换到-stream"><a class="header" href="#同步的切换到-stream">同步的切换到 Stream</a></h2>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#toStream--">Flux#toStream</a></p>
<h2 id="转换成completablefuture"><a class="header" href="#转换成completablefuture">转换成CompletableFuture</a></h2>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#toFuture--">Mono#toFuture</a></p>
<h1 id="multicasting-a-flux-to-several-subscribers"><a class="header" href="#multicasting-a-flux-to-several-subscribers">Multicasting a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> to several <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true">Subscribers</a></a></h1>
<p>一个发布者 对 多个 订阅者</p>
<h2 id="连接多个订阅者"><a class="header" href="#连接多个订阅者">连接多个订阅者</a></h2>
<ol>
<li>调用 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#publish--">publish()</a>  返回 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html">ConnectableFlux</a></li>
<li>调用 <em>subscribe</em> 订阅多个订阅者</li>
<li>调用  <em>connect</em> 触发 资源</li>
<li>调用 <em>share</em> 立即触发资源</li>
<li>指定数量的注册器达到后自动 connect <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#autoConnect-int-">.publish().autoConnect(n)</a> </li>
<li>and automatically connect and cancel the source when subscribers go above/below the threshold: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#refCount-int-">.publish().refCount(n)</a></li>
<li>…but giving a chance for new subscribers to come in before cancelling: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#refCount-int-java.time.Duration-">.publish().refCount(n, Duration)</a></li>
</ol>
<h2 id="缓存数据并重放"><a class="header" href="#缓存数据并重放">缓存数据并重放</a></h2>
<h3 id="缓存n个数据"><a class="header" href="#缓存n个数据">缓存n个数据</a></h3>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-int-">cache(int)</a></p>
<h3 id="缓存指定时间段的元素"><a class="header" href="#缓存指定时间段的元素">缓存指定时间段的元素</a></h3>
<p>cache(Duration)</p>
<p>个数限制：<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-int-java.time.Duration-">cache(int, Duration)</a></p>
<p>不立即触发source： <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#replay--">Flux#replay</a> (returns a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html">ConnectableFlux</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactor-core-features"><a class="header" href="#reactor-core-features">Reactor Core Features</a></h1>
<p>The Reactor project 主要构件 是 <code>reactor-core</code></p>
<p>专注于 reactive library 基于 java8</p>
<p>Reactor 引入 composable reactive types  实现 Publisher，</p>
<p>同时提供了丰富的 操作词汇：<code>Flux</code> and <code>Mono</code></p>
<p>Flux 对象表示 响应式的 序列 从  0..N，而 <em>Mono</em> 对象表示 单值或空 结果</p>
<p>这种区别携带一些语义信息到类型，表示异步处理的粗糙基数（ the rough cardinality）</p>
<p>例如，HTTP 请求只生成一个响应，所以做 &quot;计数&quot; 操作没有多大意义</p>
<p>因此，将 HTTP 调用的结果 表示为<code>Mono&lt;HttpResponse&gt;</code>  比 <code>Flux&lt;HttpResponse&gt;</code> 更有意义</p>
<p>因为它只提供与零或一个item 上下文相关的Operator。</p>
<p>改变 最大的基数 的处理   的Operator   同样 切换到了 相应的类别 </p>
<p>例如 count 计数 返回 <code>Mono&lt;Long&gt;</code></p>
<p>包括以下内容</p>
<ul>
<li><a href="18.%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/ProjectReactor/core-features/FluxAndMono.html">FluxAndMono</a></li>
<li><a href="18.%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/ProjectReactor/core-features/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%BA%8F%E5%88%97.html">编程式创建序列</a></li>
<li><a href="18.%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/ProjectReactor/core-features/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html">错误处理</a></li>
<li><a href="18.%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/ProjectReactor/core-features/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%B0%83%E5%BA%A6.html">线程和调度</a></li>
<li><a href="18.%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/ProjectReactor/core-features/ProcessorOrSinks.html">ProcessorOrSinks</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flux"><a class="header" href="#flux"><code>Flux</code></a></h1>
<blockquote>
<p>an Asynchronous Sequence of 0-N Items</p>
</blockquote>
<p>The following image shows how a <code>Flux</code> transforms items:</p>
<p><img src="18.%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/ProjectReactor/core-features/%5Cimages%5Cflux.svg" alt="" /></p>
<ol>
<li>Flux发出的元素</li>
<li>水平线：从左到右的  flux 时间流 </li>
<li>垂直线表明：Flux成功完成</li>
<li>虚点线和 box 表明 正在对 Flux执行 转换</li>
<li>盒子中的 文字 展示了 转换规则</li>
<li>下方是 Flux的转换后的结果 </li>
<li>如果 处于某种原因 转换失败 ，垂直线 会被 x替代</li>
</ol>
<p><code>Flux&lt;T&gt;</code> 是 标准的 <em>Publiser<T></em> 表明 异步 0~N 的  发出项的 异步序列，可选的被 完成 或 error 总结</p>
<p>As in the Reactive Streams spec， 这三种类型的信号转换为 对 下游 订阅者的 <code>onNext onComplete onError</code>的调用</p>
<p>在这种大范围的可能信号下，&quot;Flux&quot;是通用反应类型。</p>
<p>请注意：所有事件 甚至 终止 是 可选的</p>
<p>no <code>onNext</code> event but an <code>onComplete</code> event represents an <em>empty</em> finite sequence, </p>
<p>but remove the <code>onComplete</code> and you have an <em>infinite</em> empty sequence (not particularly useful, except for tests around cancellation). </p>
<p>Similarly, infinite sequences are not necessarily empty. For example, <code>Flux.interval(Duration)</code> produces a <code>Flux&lt;Long&gt;</code> that is infinite and emits regular ticks from a clock.</p>
<h1 id="mono"><a class="header" href="#mono"><code>Mono</code></a></h1>
<blockquote>
<p>an Asynchronous 0-1 Result</p>
</blockquote>
<p><img src="18.%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/ProjectReactor/core-features/%5Cimages%5Cmono.svg" alt="Mono" /></p>
<p>A <code>Mono&lt;T&gt;</code> is a specialized <code>Publisher&lt;T&gt;</code> that emits at most one item <em>via</em> the <code>onNext</code> signal then terminates with an <code>onComplete</code> signal (successful <code>Mono</code>, with or without value), or only emits a single <code>onError</code> signal (failed <code>Mono</code>).</p>
<p><code>Mono&lt;T&gt;</code> 是 <code>Publisher&lt;T&gt;</code> 的特化 ，通过 <em>onNext</em>  最多产生 一个 <em>item</em>  然后 使用 <em>onComplete</em> 终止，或者产生 <em>onEror</em> 信号</p>
<p>在调用 <em>onNext</em> 之后 <em>Mono</em> 的实现应该 立即调用 <em>onComplete</em></p>
<p><code>Mono.never()</code> 是一个 outlier。不发出任何信号</p>
<p>请注意，您可以使用&quot;Mono&quot;表示只有完成概念的无值异步过程（类似于&quot;runnable&quot;）。</p>
<p>To create one, you can use an empty <code>Mono&lt;Void&gt;</code>.</p>
<h1 id="flux-mono使用"><a class="header" href="#flux-mono使用">Flux Mono使用</a></h1>
<h2 id="subscribe-method-examples"><a class="header" href="#subscribe-method-examples"><code>subscribe</code> Method <code>Examples</code></a></h2>
<p><strong>No-op订阅</strong></p>
<pre><code class="language-java">Flux&lt;Integer&gt; ints = Flux.range(1, 3); 
ints.subscribe(); 
</code></pre>
<p><strong>处理元素订阅</strong></p>
<pre><code class="language-java">Flux&lt;Integer&gt; ints = Flux.range(1, 3); 
ints.subscribe(i -&gt; System.out.println(i)); 
</code></pre>
<p><strong>异常处理</strong></p>
<pre><code class="language-java">Flux&lt;Integer&gt; ints = Flux.range(1, 4) 
      .map(i -&gt; { 
        if (i &lt;= 3) return i; 
        throw new RuntimeException(&quot;Got to 4&quot;); 
      });
ints.subscribe(i -&gt; System.out.println(i), 
      error -&gt; System.err.println(&quot;Error: &quot; + error));
</code></pre>
<p><strong>完成处理</strong></p>
<pre><code class="language-java">Flux&lt;Integer&gt; ints = Flux.range(1, 4); 
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println(&quot;Error &quot; + error),
    () -&gt; System.out.println(&quot;Done&quot;)); 
</code></pre>
<p><strong>Subscription消费</strong></p>
<p>这个变体 方法可以 使你 对 Subscription做一些事情（request(n)） 或者取消它， Otherwise the <code>Flux</code> hangs.</p>
<pre><code class="language-java">Flux&lt;Integer&gt; ints = Flux.range(1, 4);
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println(&quot;Error &quot; + error),
    () -&gt; System.out.println(&quot;Done&quot;),
    sub -&gt; sub.request(10)); 
</code></pre>
<pre><code class="language-java">Flux&lt;Integer&gt; ints = Flux.range(1, 4);
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println(&quot;Error &quot; + error),
    () -&gt; System.out.println(&quot;Done&quot;),
    sub -&gt; sub.request(10)); 
</code></pre>
<h2 id="cancelling-a-subscribe-with-its-disposable"><a class="header" href="#cancelling-a-subscribe-with-its-disposable">Cancelling a <code>subscribe()</code> with Its <code>Disposable</code></a></h2>
<p>所有以上的 Lambada 变体的 <em>subscribe</em> 都有 Disposable 返回值</p>
<p>在这种情况下，the <code>Disposable</code>接口 表示 可以 通过 调用 <code>dispost()</code> 取消 订阅的事实</p>
<p>对于 Flux or Mono 取消是一个 信号，源应该停止生产元素 ，但是不能立即保证，某些源可能会产生 如此之快的元素  以至于 在收到取消指令前已完成</p>
<p>Disposable的一些工具方法 也是可用的。</p>
<p><code>Disposables.swap()</code>  创建一个  Disposable 包装器 ，让你自动取消 并 替换具体的 <em>Disposable</em> </p>
<p>在UI场景下，当用户单击按钮时，您需要取消请求，然后用新请求替换请求</p>
<p>Disposing the wrapper itself closes it. Doing so disposes the current concrete value and all future attempted replacements.</p>
<p>Another interesting utility is <code>Disposables.composite(…)</code>. This composite lets you collect several <code>Disposable</code> — for instance, multiple in-flight requests associated with a service call — and dispose all of them at once later on. Once the composite’s <code>dispose()</code> method has been called, any attempt to add another <code>Disposable</code> immediately disposes it.</p>
<h2 id="an-alternative-to-lambdas-basesubscriber"><a class="header" href="#an-alternative-to-lambdas-basesubscriber">An Alternative to Lambdas: <code>BaseSubscriber</code></a></h2>
<p>还有一个额外的订阅方法,更通用，采取成熟的订阅者,而不是通过Lamba组合。为了帮助 编写 <em>Subscriber</em> 我们提供了 可扩展的类  <code>BaseSubscriber</code> </p>
<p><code>BaseSubscriber</code> 的实例 是一次性的，意味着：</p>
<ul>
<li><code>BaseSubscriber</code>  在订阅第二个 <em>Publisher</em> 时 会 取消第一个</li>
<li>这是因为 多次使用 实例，会 违反  Reactive Streams rule ：一个 <em>Subscriber</em> 的 <em>onNext</em> 方法  不能被并行调用</li>
<li>因此 只有直接声明在 <code>Publisher#subscribe(Subscriber)</code> 的调用中 匿名实现 才行</li>
</ul>
<pre><code class="language-java">SampleSubscriber&lt;Integer&gt; ss = new SampleSubscriber&lt;Integer&gt;();
Flux&lt;Integer&gt; ints = Flux.range(1, 4);
ints.subscribe(ss);

package io.projectreactor.samples;

import org.reactivestreams.Subscription;

import reactor.core.publisher.BaseSubscriber;

public class SampleSubscriber&lt;T&gt; extends BaseSubscriber&lt;T&gt; {

	public void hookOnSubscribe(Subscription subscription) {
		System.out.println(&quot;Subscribed&quot;);
		request(1);
	}

	public void hookOnNext(T value) {
		System.out.println(value);
		request(1);
	}
}
</code></pre>
<p>该类提供可以覆盖的 <em>hook</em> ，以调整 subscriber的行为</p>
<p>默认情况下 会触发  无界请求 与 <code>subscribe()</code> 行为一致</p>
<p>但是，当您想要自定义请求数量时，扩展 BaseSubscriber 更有用</p>
<p>对于自定义 请求数量，最小限度是 实现： <code>hookOnSubscribe(Subscription subscription)</code>  <code>hookOnNext(T value)</code> </p>
<p>在上述例子中：the <code>hookOnSubscribe</code> 方法 发出第一个 请求，然后：<code>hookOnNext</code> 放出额外的 <em>request</em> </p>
<p><code>BaseSubscriber</code> 同样 提供了   <code>requestUnbounded()</code> 方法 请求 无界模式 等价于 <code>request(Long.MAX_VALUE)</code>) </p>
<p>和 <code>cancel方法</code></p>
<p>它也有额外的  <em>hooks</em>   <code>hookOnComplete</code>, <code>hookOnError</code>, <code>hookOnCancel</code> <code>hookFinally</code> （当序列终止时，总是调用，终止类型作为  <code>SignalType</code>  参数传递）</p>
<h2 id="on-backpressure-and-ways-to-reshape-requests"><a class="header" href="#on-backpressure-and-ways-to-reshape-requests">On Backpressure and Ways to Reshape Requests</a></h2>
<p>Reactor 在 实现 背压时，消费者压力传回源头的 方式是 ：发送 <em>request</em> 请求给 上游</p>
<p>当前请求的 总数 有时被引用为 当前 <em>demand</em> 或者 pending request</p>
<p>Long.MAX_VALUE 的demand 表示 无限制的 请求（意味着：尽可能快的生产）</p>
<p>第一个请求来自 订阅时 最终的订阅者</p>
<p>所有最直接的 订阅方式 立即 触发了  无界的  <code>Long.MAX_VALUE</code> 的 <em>request</em></p>
<ul>
<li><strong>subscribe()</strong>，以及大部分 lambada 变体（除了：具有 <code>Consumer&lt;Subscription&gt;</code> 的变体） </li>
<li><code>block()</code>, <code>blockFirst()</code> and <code>blockLast()</code></li>
<li>iterating over a <code>toIterable()</code> or <code>toStream()</code></li>
</ul>
<p>最简单的 自定义 原始 <em>request</em>的方式是： 使用 <code>BaseSubscriber</code> <em>subcribe</em> ，覆盖 <code>hookOnSubscribe</code>  方法</p>
<pre><code class="language-java">Flux.range(1, 10)
    .doOnRequest(r -&gt; System.out.println(&quot;request of &quot; + r))
    .subscribe(new BaseSubscriber&lt;Integer&gt;() {

      @Override
      public void hookOnSubscribe(Subscription subscription) {
        request(1);
      }

      @Override
      public void hookOnNext(Integer integer) {
        System.out.println(&quot;Cancelling after having received &quot; + integer);
        cancel();
      }
    });
</code></pre>
<p>当修改 request时，你必须 小心，产生足够的 <em>demand</em>  以进行推进，否则 你的 <em>Flux</em> 会被卡住</p>
<p>这也是为什么  <code>BaseSubscriber</code>  默认 在 <code>hookOnSubscribe</code> 中 请求 无限制的 <em>request</em></p>
<p>当覆盖此钩子函数时，你必须 至少 调用一次 <em>request</em></p>
<h2 id="operators-that-change-the-demand-from-downstream"><a class="header" href="#operators-that-change-the-demand-from-downstream"><strong>Operators that Change the Demand from Downstream</strong></a></h2>
<h3 id="buffer"><a class="header" href="#buffer">buffer</a></h3>
<p>需求记住的是：上游链条 中 每个运营商 都可以 在 订阅级别上 重塑  表达的需求</p>
<p>一个教科书案例是： <code>buffer(N)</code>  操作：</p>
<p>如果它收到 <code>request(2)</code>  ，它被解释为 填满  <strong>two full buffers</strong>.</p>
<p>因此 缓冲区需要 n个元素填满，而需要2个缓冲区，所以 buffer操作将 元素个数 重塑为 <code>mxn</code> m是请求的缓冲区的个数，n是缓冲区的大小</p>
<h3 id="prefetch"><a class="header" href="#prefetch">prefetch</a></h3>
<p>你可能会注意到： <code>prefetch(int)</code>，这是修改下游请求的另一个 操作，</p>
<p>这通常是 处理内部序列，从每个 输入的元素中  提取 <em>Publisher</em> 像flatMap</p>
<p><em>Prefetch</em> 是一种   微调 初始化请求的方式，在其内部完成</p>
<p>如果未指定，大多数 操作start with a demand of <code>32</code></p>
<p>这些操作的通常 实现了 <strong>replenishing optimization</strong>: </p>
<p>一旦操作员看到 75%的 prefetch 填充完毕，它将重新向上游请求 75%</p>
<p>这是一个 启发式优化，使得操作 能够 主动预测 即将到来的请求</p>
<h3 id="limit"><a class="header" href="#limit">limit</a></h3>
<p>最后，几个操作允许您直接调整请求： <code>limitRate</code> and <code>limitRequest</code></p>
<p><code>limitRate(N)</code>   将下游请求 拆分，以便以较小的 批次向下游传播</p>
<p>例如：<code>request(100)</code>，和 <code>limitRate(10)</code> 会导致：最多 10个请求被传播到上游</p>
<p>注意：<code>limitRate</code> 也实现了 <code>replenishing optimization</code> 该 操作也有一个变体，允许调整 请求数量，称作：<em>lowTide</em> : <code>limitRate(highTide, lowTide)</code>. </p>
<p>如果 lowTide为 0，则在每批次中 使用 严格的  <em>highTide</em> 请求数 。而不是 根据补充策略，批次进一步返工</p>
<p><code>limitRequest(N)</code>, 在另一个方面， 将下游请求限制为最大总需求。</p>
<p>它加起来 请求 高达 N</p>
<p>如果单个 请求 没有超过 N的 需求，则该请求  完全传播到 上游，在源发出该数量之后，</p>
<p><code>limitRequest</code> 认为序列已完成，向下游发 <em>onComplete</em> 信号，并取消源</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="processors-and-sinks"><a class="header" href="#processors-and-sinks">Processors and Sinks</a></h1>
<p>Processors是 一种特殊的 Publisher ，同样也是 Subscriber</p>
<p>它们最初是 在Reactive Streams 的不同实现中 作为 中间步骤的 可能 表示</p>
<p>在Reactor中，这些步骤 相当由 Publiser 表示</p>
<p><em>Processor</em> 的常见误区是 直接调用 <em>Subscriber</em> 上 暴露的 <code>onNext onComplete onError</code> 方法</p>
<p>这样直接调用需要小心：</p>
<p>特别是 关于 Reactive Streams specification 考虑到 调用之间的外部同步。Processors 可能会稍有用，除非遇到 基于 Reactive Streams的API，该API需要 Subscriber传入，而不是暴露发 <em>Publisher</em></p>
<p>Sinks是更好的选择，在 Reactor中，sink是一个 安全的手动的 触发 信号的类，它既可以于 Subscription 关联（从操作内部） 也可以完全独立</p>
<p>Since <code>3.4.0</code>, sinks 成为 一等公民，<code>Processor</code> 淘汰了</p>
<ul>
<li>抽象的  或 具体的 <code>FluxProcessor</code> and <code>MonoProcessor</code>  过时了，预计在3.5.0 中删除</li>
<li>sink不是由 操作 产生的，而是通过 <em>Sinks</em> 的工厂方法 构建的</li>
</ul>
<h2 id="safely-produce-from-multiple-threads-by-using-sinksone-and-sinksmany"><a class="header" href="#safely-produce-from-multiple-threads-by-using-sinksone-and-sinksmany">Safely Produce from Multiple Threads by Using <code>Sinks.One</code> and <code>Sinks.Many</code></a></h2>
<p>reactor-core 暴露出来的  <em>Sinks</em>  确保 在多线程使用，不会违反规范 或者 未定义的行为，从下游的角度看</p>
<p>当使用 <code>tryEmit*</code>  API 时，并行调用 会 fail fast </p>
<p>当使用 <code>emit*</code> API 时，提供的 <code>EmissionFailureHandler</code> 可以允许 在竞争中 重试（例如：忙碌轮询），否则 sink会以失败终止</p>
<p>这对于 <code>Processor.onNext</code> 是一个提升，它 必须外部同步，否则就会 导致未定义的行为，从下游Subscribers的视角来看</p>
<p><em>Sinks</em> 构建起 为主要支持的 producer types 提供引导API</p>
<p>你将会发现 Flux中 的一些行为 例如：<code>onBackpressureBuffer</code></p>
<pre><code class="language-java">Sinks.Many&lt;Integer&gt; replaySink = Sinks.many().replay().all();
</code></pre>
<p>多个生产者线程可以通过以下工作同时 在 sink 上生成数据：</p>
<pre><code>//thread1
sink.emitNext(1, FAIL_FAST);

//thread2, later
sink.emitNext(2, FAIL_FAST);

//thread3, concurrently with thread 2
EmitResult result = sink.tryEmitNext(3); //would return FAIL_NON_SERIALIZED
</code></pre>
<p><code>Sinks.Many</code> 可以作为 <em>Flux</em></p>
<pre><code class="language-java">Flux&lt;Integer&gt; fluxView = replaySink.asFlux();
fluxView
	.takeWhile(i -&gt; i &lt; 10)
	.log()
	.blockLast();
</code></pre>
<p>Similarly, the <code>Sinks.Empty</code> and <code>Sinks.One</code> flavors can be viewed as a <code>Mono</code> with the <code>asMono()</code> method.</p>
<p>The <code>Sinks</code> categories are:</p>
<ol>
<li><code>many().multicast()</code>: 只传输 新推的 数据给其 subscribers，遵循背压，（newly pushed as in &quot;after the subscriber’s subscription&quot;）</li>
<li><code>many().unicast()</code>: 与上述相同, with the twist that data pushed before the first subscriber registers is buffered.</li>
<li><code>many().replay()</code>: a sink that will replay a specified history size of pushed data to new subscribers then continue pushing new data live.</li>
<li><code>one()</code>: a sink that will play a single element to its subscribers</li>
<li><code>empty()</code>: a sink that will play a terminal signal only to its subscribers (error or complete), but can still be viewed as a <code>Mono&lt;T&gt;</code> (notice the generic type <code>&lt;T&gt;</code>).</li>
</ol>
<h2 id="overview-of-available-sinks"><a class="header" href="#overview-of-available-sinks">Overview of Available Sinks</a></h2>
<h3 id="sinksmanyunicastonbackpressurebufferargs"><a class="header" href="#sinksmanyunicastonbackpressurebufferargs">Sinks.many().unicast().onBackpressureBuffer(args?)</a></h3>
<p>Sinks.many().unicast() 使用 内部缓冲区 处理 背压，作为权衡：只能有一个 <em>Subscriber</em></p>
<p><strong>Sinks.many().unicast().onBackpressureBuffer()</strong> 是基本的 sink创建方法</p>
<p>还有其他变体微调</p>
<p>例如，默认情况下，它是无限制的：</p>
<p>如果您在其 Subscriber 尚未请求数据时，推送任意数量的 数据时，它会缓冲数据数据</p>
<p>你可以为内部 缓冲区 提供自定义队列的 实现来改变此情况 <code>Sinks.many().unicast().onBackpressureBuffer(Queue)</code> </p>
<p>如果队列是有界的，缓冲区已满，未收到来自下游足够的请求，sink可能会 拒绝 数据的推送</p>
<h3 id="sinksmanymulticastonbackpressurebufferargs"><a class="header" href="#sinksmanymulticastonbackpressurebufferargs">Sinks.many().multicast().onBackpressureBuffer(args?)</a></h3>
<p>Sinks.many().multicast() 可以 触发 多个 subscribers ，同时处理 为每一个 subscriber 处理 背压</p>
<p>subscribers 订阅后，只接收 通过 sink的 push 信号</p>
<p>创建 sink的 基本方法  <code>Sinks.many().multicast().onBackpressureBuffer()</code>. </p>
<p>默认情况下，所有 subscribers  取消了（这基本意味着 它们 都有未订阅）</p>
<p>它会 清除其 内部缓冲区，并停止接受新的 subscribers</p>
<p>你可以在 <code>multicast</code>  静态工厂方法中 使用<code>autoCancel</code>  参数微调，位于 <code>Sinks.many().multicast()</code></p>
<h3 id="sinksmanymulticastdirectallornothing"><a class="header" href="#sinksmanymulticastdirectallornothing">Sinks.many().multicast().directAllOrNothing()</a></h3>
<p>处理背压很简单：如果有一个 subscribers  很慢例如 0 demand, 则 onNext 方法 会被 所有subscribers drop掉</p>
<p>但是，慢subscribers  没有终止， 一旦 慢 subscribers  再次开始请求，所有subscribers  都将恢复 接收 从那里推送的数据</p>
<p>一旦 Sinks.many 终止了 （通常是 调用<code>emitError(Throwable)</code> or <code>emitComplete()</code> ）</p>
<p>它仍允许 更多的 subscribers subscribe  但是 会立即重播 终止信号给他们</p>
<h3 id="sinksmanymulticastdirectbesteffort"><a class="header" href="#sinksmanymulticastdirectbesteffort">Sinks.many().multicast().directBestEffort()</a></h3>
<ul>
<li>
<p>最大努力的处理背压：只 drop掉 慢 subscriber  的 <em>onNext</em></p>
</li>
<li>
<p>如果慢 subscribers  恢复速度，会重新 push 元素</p>
</li>
<li>
<p>Sinks.many 终止，允许新的 subscribers 加入，并重放 终止信号</p>
</li>
</ul>
<h3 id="sinksmanyreplay"><a class="header" href="#sinksmanyreplay">Sinks.many().replay()</a></h3>
<p>缓存 产生的元素，并重播给 后续的 订阅者</p>
<p>它有以下配置</p>
<ul>
<li>Caching a limited history (<code>Sinks.many().replay().limit(int)</code>) or an unbounded history (<code>Sinks.many().replay().all()</code>). 基于个数的缓存</li>
<li>Caching a time-based replay window (<code>Sinks.many().replay().limit(Duration)</code>).  基于时间的缓存</li>
<li>Caching a combination of history size and time window (<code>Sinks.many().replay().limit(int, Duration)</code>). 综合</li>
</ul>
<p>还有其他的重载方法 微调</p>
<p>例如 <code>latest()</code> and <code>latestOrDefault(T)</code></p>
<h3 id="sinksunsafemany"><a class="header" href="#sinksunsafemany">Sinks.unsafe().many()</a></h3>
<p>与 <code>Sinks.Many</code>  相比 没有额外的 producer 线程安全，也就意味着更小的开销</p>
<p>根据 the Reactive Streams specification.可以确保  <code>onNext</code>, <code>onComplete</code> and <code>onError</code>  在外部同步</p>
<h3 id="sinksone"><a class="header" href="#sinksone">Sinks.one()</a></h3>
<p>Sinks的使用 是 Mono的 视图 ，通过 <code>asMono()</code> </p>
<p>and has slightly different <code>emit</code> methods to better convey this Mono-like semantics:</p>
<p>并有稍微不同的 <code>emit</code> 方法， 以更好地传达这种单一(Mono-like)的语义：</p>
<ul>
<li><code>emitValue(T value)</code> generates an <code>onNext(value)</code> signal and - in most implementations - will also trigger an implicit <code>onComplete()</code></li>
<li><code>emitEmpty()</code> generates an isolated <code>onComplete()</code> signal, intended as generating the equivalent of an empty <code>Mono</code></li>
<li><code>emitError(Throwable t)</code> generates an <code>onError(t)</code> signal</li>
</ul>
<p><code>Sinks.one()</code> accepts <em>one</em> call of any of these methods, effectively generating a <code>Mono</code> that either completed with a value, completed empty or failed.</p>
<h3 id="sinksempty"><a class="header" href="#sinksempty">Sinks.empty()</a></h3>
<p>This flavor of <code>Sinks</code> is like <code>Sinks.One&lt;T&gt;</code>, except it doesn’t offer the <code>emitValue</code> method.</p>
<p>As a result, it can only generates a <code>Mono</code> that completes empty or fails.</p>
<p>The sink is still typed with a generic <code>&lt;T&gt;</code> despite being unable to trigger an <code>onNext</code>, because it allows easy composition and inclusion in chains of operators that require a specific type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threading-and-schedulers"><a class="header" href="#threading-and-schedulers">Threading and Schedulers</a></h1>
<p>Reactor 并不强制使用 并发模型，但也提供 并发帮助</p>
<p>获取 Flux Mono 并不意味着 在专用 线程中 运行</p>
<p>相反，大多数操作 运行在前面 操作的线程中，如果没有特别指定，最顶层的 操作：source 自身 运行在 <em>subscribe</em>的 调用线程上。</p>
<p>以下示例显示 在 Mono中运行在新线程上</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    //主线程 组装
  final Mono&lt;String&gt; mono = Mono.just(&quot;hello &quot;); 
                        //其他线程订阅
  Thread t = new Thread(() -&gt; mono
                        //map onNext 回调 实际上 都在 其他线程执行
      .map(msg -&gt; msg + &quot;thread &quot;)
      .subscribe(v -&gt; 
          System.out.println(v + Thread.currentThread().getName()) 
      )
  )
  t.start();
  t.join();
}
</code></pre>
<p>在Reactor中，执行模型 执行线程 取决于使用的 <code>Scheduler</code> </p>
<p>A <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html"><code>Scheduler</code></a>  承担 调度 职责，类似于 <code>ExecutorService</code></p>
<p>但是有专门的抽象，让它做得更多。</p>
<p>特别是 作为 时钟 并使更广泛的实现：虚拟时间测试， trampolining ，立即调度 等</p>
<p>The <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html"><code>Schedulers</code></a> class 的静态方法 可以访问 以下 执行上下文</p>
<ul>
<li>
<p>No execution context (<code>Schedulers.immediate()</code>): 在 处理时，已提交的 <em>Runnable</em> 会 直接执行，有效的运行在 当前线程（可以视为 空对象，或无操作的 <em>Scheduler</em>）</p>
</li>
<li>
<p>A single, reusable thread (<code>Schedulers.single()</code>). 对于所有调用者使用一个线程你想每一个调用一个线程 则 使用  <code>Schedulers.newSingle()</code></p>
</li>
<li>
<p>An unbounded elastic thread pool (<code>Schedulers.elastic()</code>). 引入 <code>Schedulers.boundedElastic()</code> 之后 不在首选, 因为它有隐藏背压问题并导致太多线程的倾向</p>
</li>
<li>
<p>A bounded elastic thread pool (<code>Schedulers.boundedElastic()</code>). Like its predecessor <code>elastic()</code>, </p>
<p>它根据需要创建新的 工作线程池，重用 空闲线程，闲置线程闲置超过60s，会被回收，创建的线程有上限（默认是 CPU 核数 x10），线程池达到 上限后 ，提交多达 100 000 的任务 会被入队列等待，直到线程池可用（如果延迟调用，则延迟从 线程可用时开始计算）</p>
<p>This is a better choice for I/O blocking work.</p>
<p>对于 阻塞式 I/O 工作来说，这是一个更好的选择。</p>
<p><code>Schedulers.boundedElastic()</code> 是一种方便的方式，在自己的线程中阻塞，一遍不会绑定其他资源</p>
<p>See <a href="https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking">How Do I Wrap a Synchronous, Blocking Call?</a>, 但不会给系统产生太多线程的压力</p>
</li>
</ul>
<ul>
<li>A fixed pool of workers that is tuned for parallel work (<code>Schedulers.parallel()</code>). 固定工作线程池，线程的个数和CPU的 核心数一样多</li>
</ul>
<p>另外，通过 <code>Schedulers.fromExecutorService(ExecutorService)</code>  从  <code>ExecutorService</code>  创建 Scheduler</p>
<p>也可以 从 <em>Executor</em> 创建，这并不推荐</p>
<p>也可以 通过 newXXX 方法   创建 不同调度类型的  Scheduler 实例</p>
<p>例如： <code>Schedulers.newParallel(yourScheduleName)</code>  创建一个 并行的 命名的  Scheduler </p>
<p><code>boundedElastic</code>  用来帮助 旧的阻塞式代码（如果没法避免）</p>
<p><code>single</code> and <code>parallel</code> are not. </p>
<p>As a consequence, </p>
<p>因此，Reactor blocing APis的使用 （<code>block()</code>, <code>blockFirst()</code>, <code>blockLast()</code> as well as iterating over <code>toIterable()</code> or <code>toStream()</code>） </p>
<p>the use of Reactor blocking APIs (<code>block()</code>, <code>blockFirst()</code>, <code>blockLast()</code> (as well as iterating over <code>toIterable()</code> or <code>toStream()</code>) inside the default single and parallel schedulers) results in an <code>IllegalStateException</code> being thrown.</p>
<p>自定义 <em>Schedulers</em> 同样能 被标记为 &quot;non blocking only&quot; ，只要 创建的 Thread 实现了  <em>NonBlocking</em> 标记接口</p>
<p>一些操作 默认的 使用 来自 <code>Schedulers</code>  的指定 的<em>Scheduler</em> （这通常会提供不同的 选择 ）</p>
<p>例如 调用   <code>Flux.interval(Duration.ofMillis(300))</code>   工厂方法 产生 一个 <code>Flux&lt;Long&gt;</code> 每300ms 滴答一下。默认的 使用 <code>Schedulers.parallel()</code>  以下代码 修改 <em>Scheduler</em> 成 <code>Schedulers.single()</code></p>
<pre><code class="language-java">Flux.interval(Duration.ofMillis(300), Schedulers.newSingle(&quot;test&quot;))`
</code></pre>
<p>Reactor 提供 两种办法 在reactive chain种  切换 执行上下文（Scheduler） ：<code>publishOn</code> and <code>subscribeOn</code></p>
<p>都有一个 Scheduler参数</p>
<p>但是  <code>publishOn</code> 在链条中的位置很重要，而<code>subscribeOn</code> 不重要</p>
<p>To understand that difference, you first have to remember that <a href="https://projectreactor.io/docs/core/release/reference/#reactive.subscribe">nothing happens until you subscribe</a>.</p>
<p>在Reactor中，当你 链接操作时，你可以 将 尽可能多的 <code>Flux</code> and <code>Mono</code>  实现 包裹 在 彼此的内部 </p>
<p>订阅后，<code>Subscriber</code> objects 对象链 已经创建好，向后 到 第一个 <em>Publiser</em></p>
<p>对用户是透明的，你能看见的是 外层的 Flux or Mono 和 <em>Subscription</em> 但是 这些中间 特定操作的 Subscribers 才是实际工作发生的地方，有了这些认知后，我们可以更仔细的了解 <em>publishOn</em> <em>subscription</em> 操作</p>
<h2 id="the-publishon-method"><a class="header" href="#the-publishon-method">The <code>publishOn</code> Method</a></h2>
<p><code>publishOn</code>  同其他 操作 一样 以同样的方式 适用</p>
<p>它接收来自上游的信号，并 执行回调时 重播它们( 回调的执行是在 相关联的 <em>Scheduler</em> )</p>
<p>因此。它影响 后续 操作的  执行上下文（知道 另一个 publishOn 链入进来）</p>
<ul>
<li>Changes the execution context to one <code>Thread</code> picked by the <code>Scheduler</code></li>
<li>as per the specification, <code>onNext</code> calls happen in sequence, so this uses up a single thread</li>
<li>unless they work on a specific <code>Scheduler</code>, operators after <code>publishOn</code> continue execution on that same thread</li>
</ul>
<pre><code class="language-java">//创建 新的 Scheduler
Scheduler s = Schedulers.newParallel(&quot;parallel-scheduler&quot;, 4); 


final Flux&lt;String&gt; flux = Flux
    .range(1, 2)
    .map(i -&gt; 10 + i)   //The first map runs on the anonymous thread
    //切换到 Scheduler s
    .publishOn(s)  
    //继承上一个 Scheduler
    .map(i -&gt; &quot;value &quot; + i);  

//订阅发生在该线程， print发生于 最近的执行上下文
new Thread(() -&gt; flux.subscribe(System.out::println));  
</code></pre>
<h2 id="the-subscribeon-method"><a class="header" href="#the-subscribeon-method">The <code>subscribeOn</code> Method</a></h2>
<p>当构建 后向链条时，<code>subscribeOn</code>  用于订阅过程 </p>
<p>因此 无论您将 <code>subscribeOn</code>  放在链条的哪里，它总是 因是影响 源的产生的执行上下文</p>
<p>但是，这不会影响后续 <code>publishOn</code>  的行为，它们仍然会切换执行上下文的链条部分</p>
<ul>
<li>改变 操作的整条链条的订阅的线程</li>
<li>从调度器 中选择一个线程 </li>
</ul>
<p>Only the earliest <code>subscribeOn</code> call in the chain is actually taken into account.</p>
<pre><code class="language-java">//创建 Scheduler
Scheduler s = Schedulers.newParallel(&quot;parallel-scheduler&quot;, 4); 

final Flux&lt;String&gt; flux = Flux
    .range(1, 2)
    //在 s中运行
    .map(i -&gt; 10 + i)  
    //切换整个链条的上下文到 s中
    .subscribeOn(s)  
    .map(i -&gt; &quot;value &quot; + i);  

new Thread(() -&gt; flux.subscribe(System.out::println));  
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programmatically-creating-a-sequence"><a class="header" href="#programmatically-creating-a-sequence">Programmatically creating a sequence</a></h1>
<p>在此章节，我们将 介绍，Flux、Mono的编程式创建 ，定义关联事件（<code>onNext</code>, <code>onError</code>, and <code>onComplete</code>）</p>
<p>所有这些方法都 体现了一个事实： 它们暴露了 API，去触发事件，我们称之为 <em>sink</em></p>
<p>实际上有几个 <em>sink</em> 的变体，</p>
<h2 id="synchronous-generate"><a class="header" href="#synchronous-generate">Synchronous <code>generate</code></a></h2>
<p>最简单的编程式 创建 <em>Flux</em>的 方式是 ：通过 <em>generate</em> 方法</p>
<p>这是用于同步 的 一个个的  产生，这意味着 sink 是一个 SynchronousSink 他的 next 方法 在每次回调中只能被调用 一次，你可以 调用 <code>error(Throwable)</code>  或者 <code>complete</code>  这是可选的</p>
<p>最有用的变体可能是 让你保持 一个状态，你可以 在你的 sink 使用中 引用这个 状态，以决定 下一步 产生什么</p>
<p>generator 函数 形式为： <code>BiFunction&lt;S, SynchronousSink&lt;T&gt;, S&gt;</code> s是状态对象，必须提供初始化状态，<code>Supplier&lt;S&gt;</code> ，你的 generator 函数 现在 返回每轮的 新状态</p>
<pre><code class="language-java">Flux&lt;String&gt; flux = Flux.generate(
    () -&gt; 0, 
    (state, sink) -&gt; {
      sink.next(&quot;3 x &quot; + state + &quot; = &quot; + 3*state); 
      if (state == 10) sink.complete(); 
      return state + 1; 
    });
</code></pre>
<pre><code class="language-java">Flux&lt;String&gt; flux = Flux.generate(
    AtomicLong::new, 
    (state, sink) -&gt; {
      long i = state.getAndIncrement(); 
      sink.next(&quot;3 x &quot; + i + &quot; = &quot; + 3*i);
      if (i == 10) sink.complete();
      return state; 
    });
</code></pre>
<p>如果状态包含数据库连接或其他资源,需要在流程结束时处理,the <em>consumer</em> lamba 可以关闭连接，或者其他 在进程结束时，需要处理的任务</p>
<h2 id="asynchronous-and-multi-threadedcreate"><a class="header" href="#asynchronous-and-multi-threadedcreate">Asynchronous and Multi-threaded:create</a></h2>
<blockquote>
<p>异步跟多线程 create</p>
</blockquote>
<p><em>create</em> 是更高级的 编程创建 <em>Flux</em> 的形式， 适合 每轮产生多个元素，甚至来自多线程</p>
<p>它暴露  <em>FluxSink</em> 对象，这个对象有 next、error、complete 方法 </p>
<p>与 <em>generate</em> 相反，它没有基于状态的变体，另一方面，它可以触发 回调中的多线程事件</p>
<p><em>create</em> 对于 桥接 已有API到 响应式 世界 很有用，例如基于监听器的 异步API</p>
<p><code>create</code> 不会串行化 你的 代码，也不会使之异步,但他能用于异步API</p>
<p>如果你 在 <em>create</em> lamba 阻塞，你可能会面临 死锁或类似的副作用</p>
<p>甚至使用 <em>subscribeOn</em> </p>
<p>对于长阻塞的 <em>create</em> <em>lamba</em> 方法（例如 无限循环调用 sink.next(t) ）会锁住 <em>pipeline</em> </p>
<p>请求永远不会执行 ，因为循环饿死了他们应该运行的同一个线程。</p>
<p>Use the <code>subscribeOn(Scheduler, false)</code> variant: <code>requestOnSeparateThread = false</code> will use the <code>Scheduler</code> thread for the <code>create</code> and still let data flow by performing <code>request</code> in the original thread.</p>
<p>你有一个基于 监听器的 API，它按块处理数据，并具有两个事件在 <code>MyEventListener</code>  接口：</p>
<ol>
<li>a chunk of data is ready and </li>
<li>the processing is complete </li>
</ol>
<pre><code class="language-java">interface MyEventListener&lt;T&gt; {
    void onDataChunk(List&lt;T&gt; chunk);
    void processComplete();
}
</code></pre>
<p><strong>使用create桥接</strong></p>
<pre><code class="language-java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    myEventProcessor.register( 
      new MyEventListener&lt;String&gt;() { 

        public void onDataChunk(List&lt;String&gt; chunk) {
          for(String s : chunk) {
            sink.next(s); 
          }
        }

        public void processComplete() {
            sink.complete(); 
        }
    });
});
</code></pre>
<p>此外 由于 <code>create</code>  可以 桥接 异步API 并管理 背压</p>
<p>您可以通过 指示 <code>OverflowStrategy</code> 来改进 如何 进行背压</p>
<ul>
<li><code>IGNORE</code> 完全忽略下游背压请求，当 排队者占满 下游 ，可能会产生<code>IllegalStateException</code></li>
<li><code>ERROR</code> 当下游跟不上时， 发出 <code>IllegalStateException</code> 的信号</li>
<li><code>DROP</code> 如果下游未准备好接收来信，则丢弃传入信号。.</li>
<li>`LATEST 让下游只从上游获得最新信号.</li>
<li><code>BUFFER</code> （默认值）缓冲所有信号，如果下游跟不上 (这确实有无限制的缓冲， 并可能导致 <code>OutOfMemoryError</code>).</li>
</ul>
<p><code>Mono</code> also has a <code>create</code> generator. The <code>MonoSink</code> of Mono’s create doesn’t allow several emissions. It will drop all signals after the first one.</p>
<h2 id="asynchronous-but-single-threaded-push"><a class="header" href="#asynchronous-but-single-threaded-push">Asynchronous but single-threaded: <code>push</code></a></h2>
<p><code>push</code> 是 <em>generate</em> 跟 <em>create</em>的 中间地带，适合于 来自单个 生产者的 事件处理</p>
<p>与 <code>create</code> 类似 ，它同样可以 异步、使用  overflow strategies  管理背压，然后，只能来自一个生产线程，可能会 同时调用 <code>next</code> <code>complete</code> <code>error</code> </p>
<pre><code class="language-java">Flux&lt;String&gt; bridge = Flux.push(sink -&gt; {
    myEventProcessor.register(
      new SingleThreadEventListener&lt;String&gt;() { 

        public void onDataChunk(List&lt;String&gt; chunk) {
          for(String s : chunk) {
            sink.next(s); 
          }
        }

        public void processComplete() {
            sink.complete(); 
        }

        public void processError(Throwable e) {
            sink.error(e); 
        }
    });
});
</code></pre>
<p><strong>A hybrid push/pull model</strong></p>
<p>Most Reactor operators, like <code>create</code>, follow a hybrid <strong>push/pull</strong> model. </p>
<p>大多数 Reactor 操作，比如 <em>create</em> 遵循 混合的 <code>push/pull</code> 模型，</p>
<p>意思是：尽管大多是处理是异步的（建议采用 push方法），有一个小的 <em>pull</em>  组件：<em>request</em></p>
<p><em>consumer</em> 从源 pull 数据，直到第一次请求，它才会产生任何东西</p>
<p><em>source</em> 推送数据 给 <em>consumer</em> 在其请求的数量范围内</p>
<p>Note that <code>push()</code> and <code>create()</code> both allow to set up an <code>onRequest</code> consumer in order to manage the request amount and to ensure that data is pushed through the sink only when there is pending request.</p>
<p>注意：<code>push() creat()</code> 都 允许 设置 onRequest consumer 为了 管理请求数量，以确保 存在 pending 的request 时 数据被推送</p>
<pre><code class="language-java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    myMessageProcessor.register(
      new MyMessageListener&lt;String&gt;() {

        public void onMessage(List&lt;String&gt; messages) {
            //The remaining messages that arrive asynchronously later are also delivered.
          for(String s : messages) {
            sink.next(s); 
          }
        }
    });
    sink.onRequest(n -&gt; {
        //	Poll for messages when requests are made.
        List&lt;String&gt; messages = myMessageProcessor.getHistory(n); 
        //If messages are available immediately, push them to the sink.
        for(String s : messages) {
           sink.next(s); 
        }
    });
});
</code></pre>
<p><strong>Cleaning up after <code>push()</code> or <code>create()</code></strong></p>
<p>Two callbacks, <code>onDispose</code> and <code>onCancel</code>, perform any cleanup on cancellation or termination. </p>
<p><code>onCancel</code> can be used to perform any action specific to cancellation prior to cleanup with <code>onDispose</code>.</p>
<p>两个回调 <em>onDispose</em> <em>onCancel</em> 在 终止或 取消时 执行清理动作，</p>
<p>当 Flux completes,、错误或取消时，OnDispose 可用于执行清理</p>
<p>&quot;onCancel&quot; 可用于在   <code>onDispose</code> 之前执行任何特定于 cancellation   的&quot;操作&quot;。</p>
<pre><code class="language-java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    sink.onRequest(n -&gt; channel.poll(n))
        //onCancel is invoked first, for cancel signal only.
        .onCancel(() -&gt; channel.cancel()) 
        //onDispose is invoked for complete, error, or cancel signals.
        .onDispose(() -&gt; channel.close())  
    });
</code></pre>
<h2 id="handle"><a class="header" href="#handle">Handle</a></h2>
<p><em>handle</em> 方法 有一点不同，实例 方法，意思是他被 链接在 现有源上（普通操作也是）在 <code>Mono Flux</code> 都有</p>
<p>与 <em>generate</em> 相近，使用 <code>SynchronousSink</code>  只允许 一个个的产生,<em>handle</em> 可用于从每个 元素 中生成 任意值，</p>
<p>可以跳过 元素，它可以看作是 map 和 filter 的 组合</p>
<pre><code class="language-java">Flux&lt;R&gt; handle(BiConsumer&lt;T, SynchronousSink&lt;R&gt;&gt;);
</code></pre>
<p>The reactive streams specification 不允许 null值，你想要执行 map，但是想要使用预存在的 方法作为 map function 这个方法有时返回null,例如 以下方法 可以 安全的 应用于 整数源</p>
<pre><code class="language-java">public String alphabet(int letterNumber) {
	if (letterNumber &lt; 1 || letterNumber &gt; 26) {
		return null;
	}
	int letterIndexAscii = 'A' + letterNumber - 1;
	return &quot;&quot; + (char) letterIndexAscii;
}
</code></pre>
<p>这时我们可以 <em>handle</em> 处理null值</p>
<pre><code class="language-java">Flux&lt;String&gt; alphabet = Flux.just(-1, 30, 13, 9, 20)
    .handle((i, sink) -&gt; {
        String letter = alphabet(i); 
        if (letter != null) 
            sink.next(letter); 
    });

alphabet.subscribe(System.out::println);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-errors-1"><a class="header" href="#handling-errors-1">Handling Errors</a></h1>
<blockquote>
<p>要快速查看可用于错误处理的操作  see <a href="https://projectreactor.io/docs/core/release/reference/#which.errors">the relevant operator decision tree</a>.</p>
</blockquote>
<p>In Reactive Streams,错误是 终止事件，一旦错误发生，它会终止序列，传播 到 操作链的最后一个、the <code>Subscriber</code> 、以及其 <em>onError</em> 方法。这类错误 应该 在应用级别处理</p>
<p>如果没有定义  onError 抛出一个 <strong>UnsupportedOperationException</strong>  可以通过  <code>Exceptions.isErrorCallbackNotImplemented</code> 检测跟 分类</p>
<p>作为错误处理 操作，Reactor 还提供了 在链条中 处理错误的 方法</p>
<pre><code class="language-java">Flux.just(1, 2, 0)
    .map(i -&gt; &quot;100 / &quot; + i + &quot; = &quot; + (100 / i)) //this triggers an error with 0
    .onErrorReturn(&quot;Divided by zero :(&quot;); // error handling example
</code></pre>
<p>错误处理操作 是一个终止序列，即使使用了 error-handling operator ，并不会让 序列继续，相反它将 onError信号 转换成 了 一个新序列的开始 ，换句话说：它替代了 原始序列</p>
<p>现在，我们可以逐一考虑各种错误处理方法。当相关时，我们与命令式编程的 try pattenr 进行并行。</p>
<h2 id="error-handling-operators"><a class="header" href="#error-handling-operators">Error Handling Operators</a></h2>
<p><strong>try catch的错误处理模型</strong></p>
<ul>
<li>Catch and return a static default value: catch 并返回静态默认值</li>
<li>Catch and execute an alternative path with a fallback method：  catch，使用fallback 方法 执行替代路径</li>
<li>Catch and dynamically compute a fallback value. catch 动态计算 fallback value</li>
<li>Catch, wrap to a <code>BusinessException</code>, and re-throw.  catch,重新抛出</li>
<li>Catch, log an error-specific message, and re-throw. catch 记录日志 重新抛出</li>
<li>Use the <code>finally</code> block to clean up resources or a Java 7 “try-with-resource” construct. finally 执行资源清理</li>
</ul>
<p>上述所有这些情况都在 Reactor中都有等价API，以 error-handling 操作形式</p>
<p><strong>try catch与 Reactor error-handling的对照</strong></p>
<p>订阅时，the <code>onError</code>  callback 回调 类似于 catch块，当异常抛出 会直接调到 catch块执行</p>
<pre><code class="language-java">Flux&lt;String&gt; s = Flux.range(1, 10)
    .map(v -&gt; doSomethingDangerous(v)) 
    .map(v -&gt; doSecondTransform(v)); 
s.subscribe(value -&gt; System.out.println(&quot;RECEIVED &quot; + value), 
            error -&gt; System.err.println(&quot;CAUGHT &quot; + error) 
);
</code></pre>
<h3 id="static-fallback-value"><a class="header" href="#static-fallback-value">Static Fallback Value</a></h3>
<p><strong>trycatch模型</strong></p>
<pre><code class="language-java">try {
  return doSomethingDangerous(10);
}
catch (Throwable error) {
  return &quot;RECOVERED&quot;;
}
</code></pre>
<p><strong>Reactor模型</strong></p>
<pre><code class="language-java">Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn(&quot;RECOVERED&quot;);
</code></pre>
<p><strong>Reactor Predict模型</strong></p>
<pre><code class="language-java">//Recover only if the message of the exception is &quot;boom10&quot;

Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn(e -&gt; e.getMessage().equals(&quot;boom10&quot;), &quot;recovered10&quot;); 
</code></pre>
<h3 id="fallback-method"><a class="header" href="#fallback-method">Fallback Method</a></h3>
<p><strong>trycatch模型</strong></p>
<pre><code class="language-java">String v1;
try {
  v1 = callExternalService(&quot;key1&quot;);
}
catch (Throwable error) {
  v1 = getFromCache(&quot;key1&quot;);
}

String v2;
try {
  v2 = callExternalService(&quot;key2&quot;);
}
catch (Throwable error) {
  v2 = getFromCache(&quot;key2&quot;);
}
</code></pre>
<p><strong>Reactor模型</strong></p>
<pre><code class="language-java">Flux.just(&quot;key1&quot;, &quot;key2&quot;)
    .flatMap(k -&gt; callExternalService(k) 
        .onErrorResume(e -&gt; getFromCache(k)) 
    );
</code></pre>
<p><strong>Reactor Predict模型</strong></p>
<pre><code class="language-java">Flux.just(&quot;timeout1&quot;, &quot;unknown&quot;, &quot;key2&quot;)
    .flatMap(k -&gt; callExternalService(k)
        .onErrorResume(error -&gt; { 
            if (error instanceof TimeoutException) 
                return getFromCache(k);
            else if (error instanceof UnknownKeyException)  
                return registerNewEntry(k, &quot;DEFAULT&quot;);
            else
                return Flux.error(error); 
        })
    );
</code></pre>
<h3 id="dynamic-fallback-value"><a class="header" href="#dynamic-fallback-value">Dynamic Fallback Value</a></h3>
<p><strong>trycatch模型</strong></p>
<pre><code class="language-java">try {
  Value v = erroringMethod();
  return MyWrapper.fromValue(v);
}
catch (Throwable error) {
  return MyWrapper.fromError(error);
}
</code></pre>
<p><strong>Reactor模型</strong></p>
<pre><code class="language-java">erroringFlux.onErrorResume(error -&gt; Mono.just( 
        MyWrapper.fromError(error) 
));
</code></pre>
<h3 id="catch-and-rethrow"><a class="header" href="#catch-and-rethrow">Catch and Rethrow</a></h3>
<p><strong>trycatch模型</strong></p>
<pre><code class="language-java">try {
  return callExternalService(k);
}
catch (Throwable error) {
  throw new BusinessException(&quot;oops, SLA exceeded&quot;, error);
}
</code></pre>
<p><strong>Reactor模型</strong></p>
<pre><code class="language-java">Flux.just(&quot;timeout1&quot;)
    .flatMap(k -&gt; callExternalService(k))
    .onErrorResume(original -&gt; Flux.error(
            new BusinessException(&quot;oops, SLA exceeded&quot;, original))
    );

Flux.just(&quot;timeout1&quot;)
    .flatMap(k -&gt; callExternalService(k))
    .onErrorMap(original -&gt; new BusinessException(&quot;oops, SLA exceeded&quot;, original));
</code></pre>
<h3 id="log-or-react-on-the-side"><a class="header" href="#log-or-react-on-the-side">Log or React on the Side</a></h3>
<p><strong>trycatch模型</strong></p>
<pre><code class="language-java">try {
  return callExternalService(k);
}
catch (RuntimeException error) {
  //make a record of the error
  log(&quot;uh oh, falling back, service failed for key &quot; + k);
  throw error;
}
</code></pre>
<p><strong>Reactor模型</strong></p>
<pre><code class="language-java">LongAdder failureStat = new LongAdder();
Flux&lt;String&gt; flux =
Flux.just(&quot;unknown&quot;)
    .flatMap(k -&gt; callExternalService(k) 
        .doOnError(e -&gt; {
            failureStat.increment();
            log(&quot;uh oh, falling back, service failed for key &quot; + k); 
        })
        
    );
</code></pre>
<h3 id="using-resources-and-the-finally-block"><a class="header" href="#using-resources-and-the-finally-block">Using Resources and the Finally Block</a></h3>
<p><strong>trycatch模型</strong></p>
<pre><code class="language-java">Stats stats = new Stats();
stats.startTimer();
try {
  doSomethingDangerous();
}
finally {
  stats.stopTimerAndRecordTiming();
}
try (SomeAutoCloseable disposableInstance = new SomeAutoCloseable()) {
  return disposableInstance.toString();
}

</code></pre>
<p><strong>Reactor模型</strong></p>
<p>Both have their Reactor equivalents: <code>doFinally</code> and <code>using</code>.</p>
<p><strong>doFinally()</strong></p>
<pre><code class="language-java">Stats stats = new Stats();
LongAdder statsCancel = new LongAdder();

Flux&lt;String&gt; flux =
Flux.just(&quot;foo&quot;, &quot;bar&quot;)
    .doOnSubscribe(s -&gt; stats.startTimer())
    .doFinally(type -&gt; { 
        stats.stopTimerAndRecordTiming();
        if (type == SignalType.CANCEL) 
          statsCancel.increment();
    })
    .take(1); 
</code></pre>
<p><strong>Reactive try-with-resource</strong></p>
<pre><code class="language-java">Flux&lt;String&gt; flux =
Flux.using(
    //产生资源
        () -&gt; disposableInstance, 
    //通过资源产生 元素对象
        disposable -&gt; Flux.just(disposable.toString()), 
    // 清理资源的方式
        Disposable::dispose 
);
</code></pre>
<h3 id="证明-onerror-信号-导致终止"><a class="header" href="#证明-onerror-信号-导致终止">证明 <em>onError</em> 信号 导致终止</a></h3>
<pre><code class="language-java">Flux&lt;String&gt; flux =
Flux.interval(Duration.ofMillis(250))
    .map(input -&gt; {
        if (input &lt; 3) return &quot;tick &quot; + input;
        throw new RuntimeException(&quot;boom&quot;);
    })
    .onErrorReturn(&quot;Uh oh&quot;);

flux.subscribe(System.out::println);
Thread.sleep(2100); 
</code></pre>
<p>interval 在默认在 定时器上 执行 ，如果我们想在主类中运行该示例，</p>
<p>我们需要在此处添加 <code>Sleep</code>  调用，以便应用程序不会立即退出，而不产生任何元素</p>
<h3 id="retrying"><a class="header" href="#retrying">Retrying</a></h3>
<p>错误处理的另一种方式 <code>retry</code> 可以 重试 一个 正 产生错误的 序列</p>
<p>原理是：重新订阅 上游 <em>Flux</em>，原始的仍然终止了</p>
<pre><code class="language-java">Flux.interval(Duration.ofMillis(250))
    .map(input -&gt; {
        if (input &lt; 3) return &quot;tick &quot; + input;
        throw new RuntimeException(&quot;boom&quot;);
    })
    .retry(1)
    .elapsed() //将每个值 与 自上一个值发出依赖的持续时间 关联在一起
    .subscribe(System.out::println, System.err::println); 

Thread.sleep(2100); 
</code></pre>
<pre><code class="language-java">259,tick 0
249,tick 1
251,tick 2
506,tick 0 
248,tick 1
253,tick 2
java.lang.RuntimeException: boom
</code></pre>
<p>新的 interval 开始了，tick从0开始，在恢复的时候，需要额外等 250ms</p>
<p><code>retry(1)</code>  只是 仅仅 重订阅上游  <em>interval</em> ,第二轮仍会 发生异常，再次发生异常会 将错误 传播给 下游</p>
<h3 id="retrywhen"><a class="header" href="#retrywhen">RetryWhen</a></h3>
<p><strong>Retry.from</strong></p>
<p>接收 <code>Flux&lt;Retry.RetrySignal&gt;</code> 返回 <code>Publisher&lt;?&gt;</code></p>
<p>重试周期如下：</p>
<ol>
<li>当 error 发生时，会给 <code>Flux&lt;RetrySignal&gt;</code> 发送 信号，可以纵览所有 重试，RetrySignal 提供对 错误的访问和 相关的元信息</li>
<li>如果 <code>Flux&lt;RetrySignal&gt;</code>  产生一个 值，则重试发生</li>
<li>如果 <code>Flux&lt;RetrySignal&gt;</code>   complete 完成了，则错误会被吞并，重试周期会 停止，结果序列 也会完成</li>
<li>如果 <code>Flux&lt;RetrySignal&gt;</code>    产生错误，重试周期 停止，使得序列 产生错误</li>
</ol>
<p>使用 retryWhen 模拟 retry(3)</p>
<pre><code class="language-java">//这不断产生错误，要求重试尝试。
Flux&lt;String&gt; flux = Flux
    .&lt;String&gt;error(new IllegalArgumentException()) 
//doOnError before the retry lets us log and see all failures.
    .doOnError(System.out::println) 
//The Retry is adapted from a very simple Function lambda
    .retryWhen(Retry.from(companion -&gt; 
//我们认为前三个错误是可重复尝试的（takle(3)，然后放弃
        companion.take(3))); 
</code></pre>
<h2 id="handling-exceptions-in-operators-or-functions"><a class="header" href="#handling-exceptions-in-operators-or-functions">Handling Exceptions in Operators or Functions</a></h2>
<blockquote>
<p>操作中处理异常</p>
</blockquote>
<p>所有操作 和自定义的回调 都可能产生异常，惯例：未检查的异常 会被传播到 <em>onError</em></p>
<pre><code class="language-java">Flux.just(&quot;foo&quot;)
    .map(s -&gt; { throw new IllegalArgumentException(s); })
    .subscribe(v -&gt; System.out.println(&quot;GOT VALUE&quot;),
               e -&gt; System.out.println(&quot;ERROR: &quot; + e));
</code></pre>
<p>在传递给 onError之前，你可以通过 <em>hook</em> 调整异常</p>
<p>Reactor定义了一些 必定失败的 异常，例如 <code>OutOfMemoryError</code>  ，详见<em>Exceptions.throwIfFatal</em> ，这些错误意味着 Reactor不能继续运行。</p>
<p>在内部，存在一些场景 ，未检查的异常 不能被传播，因为并发竞争导致的  多次触发 </p>
<p><em>onError</em> <em>onComplete</em> ，无法被传播的  异常 会被 dropp掉，这种情况 可以在一定程度上 通过 使用 自定义的  hook来惯例See <a href="https://projectreactor.io/docs/core/release/reference/#hooks-dropping">Dropping Hooks</a>.</p>
<p>对于已检查的异常，同样需要 <em>try-catch</em> 块</p>
<ol>
<li>catch异常，从异常中恢复</li>
<li>catch异常，使用 <em>Exceptions</em> 包装成  <em>unchecked</em> exception，抛出</li>
<li>对于 <em>flatmap</em> 使用<code>Flux.error(checkedException)</code></li>
</ol>
<p>Reactor 定义了 Exceptions 工具类</p>
<ol>
<li>使用 <code>Exceptions.propagate</code>  包装异常，可以 先 调用 <em>thrwoIfFatal</em> 不包装 <code>RuntimeException</code></li>
<li>使用  <code>Exceptions.unwrap</code>  方法 获取 原始异常（回到 recactor-specific 专有异常的继承机构种的  根原因）</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-9"><a class="header" href="#概述-9">概述</a></h1>
<p>在java的世界里有许多实现日志功能的工具，最早得到广泛使用的是 log4j，现在比较流行的是slf4j+logback。</p>
<p>作为开发人员，我们有时候需要封装一些组件（二方包）提供给其他人员使用，但是那么多的日志工具，根本没法保证每个组件里都能使用约定好的日志工具，况且还有很多第三方的包，鬼知道他会用什么日志工具。</p>
<p>假如一个应用程序用到了两个组件，恰好两个组件使用不同的日志工具，那么应用程序就会有两份日志输出了，蛋疼吧。。
下面简单介绍下常见的日志工具：</p>
<h1 id="日志的核心功能"><a class="header" href="#日志的核心功能">日志的核心功能</a></h1>
<p>日志系统核心时记录日志，以方便排查问题或作为其他系统进行统计。其核心功能如下</p>
<ul>
<li>1 支持多渠道输出</li>
<li>2 日志信息支持多等级</li>
<li>3 渠道,日志和等级做关联，以支持渠道过滤不必要的日志信息</li>
</ul>
<h1 id="日志原理简述"><a class="header" href="#日志原理简述">日志原理简述</a></h1>
<h2 id="日志组件"><a class="header" href="#日志组件">日志组件</a></h2>
<p>日志功能的实现基本靠一下几个组件来完成：</p>
<p><strong>Loggers：</strong></p>
<p>Logger负责捕捉事件并将其发送给合适的Appender
<strong>Appenders：</strong></p>
<p>也称为Handlers，负责从Logger中取出日志消息，并使用Layout来格式化消息，然后将消息发送出去，比如发送到控制台、文件或其他日志收集系统。</p>
<p><strong>Layouts：</strong></p>
<p>也称为Formatters，负责对日志事件进中的数据进行转换和格式化。</p>
<p><strong>Filters：</strong></p>
<p>过滤器，根据需要定制哪些信息会被记录，哪些信息会被放过。</p>
<h2 id="总结-17"><a class="header" href="#总结-17">总结</a></h2>
<p>总结一下就是：用户使用Logger来进行日志记录，Logger持有若干个Handler，日志的输出操作是由Handler完成的。在Handler在输出日志前，会经过Filter的过滤，判断代码是否可以继续执行，Filter返回false，日志方法return，Handler不会处理；Filter返回true，则继续向下执行，Handler会将日志内容输出到指定位置（日志文件、控制台等）。Handler在输出日志时会使用Layout，将输出内容进行排版。</p>
<div style="break-before: page; page-break-before: always;"></div><p>{% raw %}</p>
<h1 id="jul"><a class="header" href="#jul">JUL</a></h1>
<h2 id="使用-4"><a class="header" href="#使用-4">使用</a></h2>
<p>JUL 全称 java.util.logging.Logger，JDK 自带的日志系统，从 JDK1.4 就有了。因为 log4j 的存在，这个 logger 一直沉默着，其实在一些测试性的代码中，jdk自带的 logger 比 log4j 更方便。JUL是自带具体实现的，与 log4j、logback 等类似，而不是像 JCL、slf4j 那样的日志接口封装。</p>
<pre><code>import java.util.logging.Level;
import java.util.logging.Logger;

private static final Logger LOGGER = Logger.getLogger(MyClass.class.getName());
</code></pre>
<h2 id="日志级别"><a class="header" href="#日志级别">日志级别</a></h2>
<ul>
<li>日志级别由高到低依次为：
<ul>
<li><strong>SEVERE</strong>（严重）</li>
<li><strong>WARNING</strong>（警告）</li>
<li><strong>INFO</strong>（信息）</li>
<li><strong>CONFIG</strong>（配置）</li>
<li><strong>FINE</strong>（详细）</li>
<li><strong>FINER</strong>（较详细）</li>
<li><strong>FINEST</strong>（非常详细）</li>
</ul>
</li>
</ul>
<p>另外还有两个全局开关：OFF「关闭日志记录」和ALL「启用所有消息日志记录」。</p>
<h2 id="loggingproperties文件"><a class="header" href="#loggingproperties文件">logging.properties文件</a></h2>
<p><strong>默认日志级别</strong></p>
<p>默认日志级别可以通过.level= ALL来控制，也可以基于层次命名空间来控制，按照Logger名字进行前缀匹配，匹配度最高的优先采用，<strong>日志级别只认大写；</strong></p>
<p>JUL通过handler来完成实际的日志输出，可以通过配置文件指定一个或者多个hanlder，多个handler之间使用逗号分隔；handler上也有一个日志级别，作为该handler可以接收的日志最低级别，低于该级别的日志，将不进行实际的输出；</p>
<p>handler上可以绑定日志格式化器，比如java.util.logging.ConsoleHandler就是使用的String.format来支持的；</p>
<h2 id="关于构造函数中defaultbundle的解释"><a class="header" href="#关于构造函数中defaultbundle的解释">关于构造函数中defaultBundle的解释</a></h2>
<pre><code class="language-java">// 默认资源包位置
private static final String defaultBundle = &quot;sun.util.logging.resources.logging&quot;;
// 用于本地化级别名称的资源包名称
private final String resourceBundleName;
</code></pre>
<p>resourceBundleName是用来指定外部资源包的，如果不指定，会默认用defaultBundle指定的资源包，资源包是干嘛的呢，我在rt.jar包下找到了这个资源。</p>
<pre><code class="language-java">package sun.util.logging.resources;

import java.util.ListResourceBundle;

public final class logging extends ListResourceBundle {
    public logging() {
    }

    protected final Object[][] getContents() {
        return new Object[][]{{&quot;ALL&quot;, &quot;All&quot;}, {&quot;CONFIG&quot;, &quot;Config&quot;}, {&quot;FINE&quot;, &quot;Fine&quot;}, {&quot;FINER&quot;, &quot;Finer&quot;}, {&quot;FINEST&quot;, &quot;Finest&quot;}, {&quot;INFO&quot;, &quot;Info&quot;}, {&quot;OFF&quot;, &quot;Off&quot;}, {&quot;SEVERE&quot;, &quot;Severe&quot;}, {&quot;WARNING&quot;, &quot;Warning&quot;}};
    }
}

</code></pre>
<p>原来就是控制台输出日志时，<strong>定义本地化后的级别名称</strong>。或许你会有疑问，明明在控制台上看到的是警告、信息等中文的Level，这实际上是SimpleFormatter进行的处理。</p>
<pre><code class="language-java">public synchronized String format(LogRecord record) {
	// 省略方法前半部分的代码
	return String.format(format,
                             dat,
                             source,
                             record.getLoggerName(),
                             record.getLevel().getLocalizedLevelName(),
                             message,
                             throwable);
}

</code></pre>
<h2 id="logmanager对象的初始化"><a class="header" href="#logmanager对象的初始化">LogManager对象的初始化</a></h2>
<ul>
<li>
<p>从类加载日志配置文件</p>
<p>从图中代码可以看出 <em>java.util.logging.config.class</em> 中实例化类，用户并从构造函数中加载 配置类，通过调用   <em>readConfiguration(InputStream)</em></p>
</li>
<li>
<p>从指定的 系统环境变量中加载，<em>java.util.logging.config.file</em></p>
<p>注意这里的 路径是绝对路径，默认路径是 <code>${java.home}\lib\logging.properties</code></p>
</li>
</ul>
<pre><code class="language-java">    public void readConfiguration() throws IOException, SecurityException {
        checkPermission();

        // if a configuration class is specified, load it and use it.
        String cname = System.getProperty(&quot;java.util.logging.config.class&quot;);
        if (cname != null) {
            try {
                // Instantiate the named class.  It is its constructor's
                // responsibility to initialize the logging configuration, by
                // calling readConfiguration(InputStream) with a suitable stream.
                try {
                    Class&lt;?&gt; clz = ClassLoader.getSystemClassLoader().loadClass(cname);
                    clz.newInstance();
                    return;
                } catch (ClassNotFoundException ex) {
                    Class&lt;?&gt; clz = Thread.currentThread().getContextClassLoader().loadClass(cname);
                    clz.newInstance();
                    return;
                }
            } catch (Exception ex) {
                System.err.println(&quot;Logging configuration class \&quot;&quot; + cname + &quot;\&quot; failed&quot;);
                System.err.println(&quot;&quot; + ex);
                // keep going and useful config file.
            }
        }

        String fname = System.getProperty(&quot;java.util.logging.config.file&quot;);
        if (fname == null) {
            fname = System.getProperty(&quot;java.home&quot;);
            if (fname == null) {
                throw new Error(&quot;Can't find java.home ??&quot;);
            }
            File f = new File(fname, &quot;lib&quot;);
            f = new File(f, &quot;logging.properties&quot;);
            fname = f.getCanonicalPath();
        }
        try (final InputStream in = new FileInputStream(fname)) {
            final BufferedInputStream bin = new BufferedInputStream(in);
            readConfiguration(bin);
        }
    }
</code></pre>
<h2 id="logmanager中的loggercontext"><a class="header" href="#logmanager中的loggercontext">LogManager中的LoggerContext</a></h2>
<p>LoggerContext为每个context的Logger提供命名空间。</p>
<p>默认的LogManager对象有一个系统上下文SystemLoggerContext和一个用户上下文LoggerContext。</p>
<p>系统上下文用于维护所有系统Logger的命名空间，并由系统代码查询。</p>
<p>如果系统Logger不存在于用户上下文中，它也将被添加到用户上下文中。</p>
<p>用户代码查询用户上下文，并在用户上下文中添加所有Logger。</p>
<p>Logger对象维护了 直接<em>Parent</em></p>
<pre><code class="language-java">    /**
     * 日志之间存在父子关系，最顶层的日志类型为LogManager$RootLogger,命名为&quot;&quot;
     */
    @Test
    public void test() throws IOException {
        Logger logger = Logger.getLogger(&quot;com.wuhao.log&quot;);
        Logger logger1 = Logger.getLogger(&quot;com.wuhao&quot;);
        Logger logger2 = Logger.getLogger(&quot;com&quot;);
        System.out.println(logger);
        System.out.println(logger1.equals(logger.getParent()));
        System.out.println(logger2.equals(logger1.getParent()));
        System.out.println(logger2.getParent());
    }
    
java.util.logging.Logger@7fbe847c
true
true
java.util.logging.LogManager$RootLogger@41975e01
</code></pre>
<h2 id="handler"><a class="header" href="#handler">Handler</a></h2>
<p>JUL提供多种日志处理器。</p>
<ul>
<li>StreamHandler：用于将格式化记录写入OutputStream的简单处理程序。</li>
<li>ConsoleHandler：用于将格式化记录写入System.err的简单处理程序</li>
<li>FileHandler：将格式化日志记录写入单个文件或一组旋转日志文件的处理程序。</li>
<li>SocketHandler：将格式化日志记录写入远程TCP端口的处理程序。</li>
<li>MemoryHandler：缓冲内存中日志记录的处理程序</li>
</ul>
<h2 id="formatter"><a class="header" href="#formatter">Formatter</a></h2>
<p>JUL提供了2种日志格式处理器</p>
<ul>
<li>SimpleFormatter：写简短的“人类可读”日志记录摘要。</li>
<li>XMLFormatter：写入详细的XML结构信息。</li>
</ul>
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-10"><a class="header" href="#概述-10">概述</a></h1>
<p>使用过 Log4J 和 LogBack 的同学肯定能发现，这两个框架的设计理念极为相似，使用方法也如出一辙。</p>
<p>其实这个两个框架的作者都是一个人，Ceki Gülcü，俄罗斯程序员。</p>
<p>Log4J 最初是基于Java开发的日志框架，发展一段时间后，作者Ceki Gülcü将 Log4j 捐献给了Apache软件基金会，使之成为了Apache日志服务的一个子项目。 又由于 Log4J 出色的表现，后续又被孵化出了支持C, C++, C#, Perl, Python, Ruby等语言的子框架。</p>
<p>然而，伟大的程序员好像都比较有个性。Ceki Gülcü由于不满Apache对 Log4J 的管理，决定不再参加 Log4J 的开发维护。“出走”后的Ceki Gülcü另起炉灶，开发出了 LogBack 这个框架（ SLF4J 是和 LogBack 一起开发出来的）。</p>
<p>LogBack 改进了很多 Log4J 的缺点，在性能上有了很大的提升，同时使用方式几乎和 Log4J 一样，许多用户开始慢慢开始使用 LogBack 。</p>
<p>由于受到 LogBack 的冲击， Log4J 开始式微。终于，2015年9月，Apache软件基金业宣布， Log4j 不在维护，建议所有相关项目升级到 Log4j2 。</p>
<p>Log4J2 是Apache开发的一个新的日志框架，改进了很多 Log4J 的缺点，同时也借鉴了 LogBack ，号称在性能上也是完胜 LogBack</p>
<h1 id="门面模式如何动态替换日志实现"><a class="header" href="#门面模式如何动态替换日志实现">门面模式如何动态替换日志实现</a></h1>
<h2 id="sl4j-api18以前"><a class="header" href="#sl4j-api18以前">sl4j-api1.8以前</a></h2>
<pre><code class="language-java">public static ILoggerFactory getILoggerFactory() {
       //双重检查
       if (INITIALIZATION_STATE == UNINITIALIZED) {
           synchronized (LoggerFactory.class) {
               if (INITIALIZATION_STATE == UNINITIALIZED) {
                   INITIALIZATION_STATE = ONGOING_INITIALIZATION;
                   //初始化工厂类，进去后就会发现会用到下面几行的StaticLoggerBinder类
                   performInitialization();
               }
           }
       }
       switch (INITIALIZATION_STATE) {
       case SUCCESSFUL_INITIALIZATION:
           //关键所在，StaticLoggerBinder这个类是logback的（slf4j-log4j12中也有同名类）
           return StaticLoggerBinder.getSingleton().getLoggerFactory();
       。。。
   }
</code></pre>
<ul>
<li>
<p>上述代码还是在slf4j-api中，说到这有个疑问，那么在slf4j-api这个包中，不存在这个StaticLoggerBinder类，是怎么打包出来的呢？查看源码，发现其实源码中有这个类。只是在pom打包时将这个impl包整个删掉了。非常粗暴（1.8之后不再使用这种方式了）</p>
</li>
<li>
<p><strong>原理是</strong> ：在代码中写死了，利用类加载机制，只会加载一个 同名的类，其余实现类则忽略 掉</p>
<p><code>org.slf4j.impl.StaticLoggerBinder</code></p>
</li>
</ul>
<pre><code>if (!isAndroid()) {
            // We need to use the name of the StaticLoggerBinder class, but we can't
            // reference
            // the class itself.
            //private static String STATIC_LOGGER_BINDER_PATH = &quot;org/slf4j/impl/StaticLoggerBinder.class&quot;;
            staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();
            reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);
        }
        // the next line does the binding
        StaticLoggerBinder.getSingleton();
</code></pre>
<h2 id="sl4j-api18之后"><a class="header" href="#sl4j-api18之后">sl4j-api1.8之后</a></h2>
<blockquote>
<p><strong>使用<em>SPI</em>机制</strong></p>
</blockquote>
<h2 id="核心绑定逻辑"><a class="header" href="#核心绑定逻辑">核心绑定逻辑</a></h2>
<ul>
<li>根据SPI机制 进行类发现</li>
<li>如果发现多个实现类则 输出日志</li>
<li>默认选择 第一个实例化，并报告被实例化的 那个实现类</li>
<li>进行其他初始化动作</li>
<li>如果 SPI类发现机制 没有发现，则  使用 旧版本的 类发现机制，报告当前的 <em>StaticLoggerBinder</em> binder</li>
</ul>
<pre><code class="language-java">private final static void bind() {
    try {
        List&lt;SLF4JServiceProvider&gt; providersList = findServiceProviders();
        reportMultipleBindingAmbiguity(providersList);
        if (providersList != null &amp;&amp; !providersList.isEmpty()) {
           PROVIDER = providersList.get(0);
           PROVIDER.initialize();
           INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;
            reportActualBinding(providersList);
            fixSubstituteLoggers();
            replayEvents();
            // release all resources in SUBST_FACTORY
            SUBST_PROVIDER.getSubstituteLoggerFactory().clear();
        } else {
            INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;
            Util.report(&quot;No SLF4J providers were found.&quot;);
            Util.report(&quot;Defaulting to no-operation (NOP) logger implementation&quot;);
            Util.report(&quot;See &quot; + NO_PROVIDERS_URL + &quot; for further details.&quot;);

            Set&lt;URL&gt; staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();
            reportIgnoredStaticLoggerBinders(staticLoggerBinderPathSet);
        }
    } catch (Exception e) {
        failedBinding(e);
        throw new IllegalStateException(&quot;Unexpected initialization failure&quot;, e);
    }
}
</code></pre>
<pre><code class="language-java">private static List&lt;SLF4JServiceProvider&gt; findServiceProviders() {
    ServiceLoader&lt;SLF4JServiceProvider&gt; serviceLoader = ServiceLoader.load(SLF4JServiceProvider.class);
    List&lt;SLF4JServiceProvider&gt; providerList = new ArrayList&lt;SLF4JServiceProvider&gt;();
    for (SLF4JServiceProvider provider : serviceLoader) {
        providerList.add(provider);
    }
    return providerList;
}
</code></pre>
<h1 id="父类委托机制"><a class="header" href="#父类委托机制">父类委托机制</a></h1>
<p>如果 当前 logger没有配置 <em>LEVEL</em> 或者没有配置 APPEND，则会往向上一级父级 寻找</p>
<pre><code class="language-java">public void callAppenders(ILoggingEvent event) {
       int writes = 0;
       for (Logger l = this; l != null; l = l.parent) {
           writes += l.appendLoopOnAppenders(event);
           //这里能看到日志会不断寻找其父级logger，并且把logevent交给父级的appender，除非additive为false，这也和我们配置中的&lt;logger additive&gt;属性对应上了
           if (!l.additive) {
               break;
           }
       }
       // No appenders in hierarchy
       if (writes == 0) {
           loggerContext.noAppenderDefinedWarning(this);
       }
   }
</code></pre>
<p>所以这里我们明白一点：<strong>未专门配置appender的logger，且additive为true</strong>的（默认就是），实际上最终都是由root的appender完成的日志输出。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一阶段"><a class="header" href="#第一阶段">第一阶段</a></h1>
<ol>
<li>
<p><strong>使用日志库</strong></p>
</li>
<li>
<p>用 Linux 命令过滤出带 “ERROR” 字段的日志行就行了</p>
</li>
</ol>
<h1 id="第二阶段"><a class="header" href="#第二阶段">第二阶段</a></h1>
<ol>
<li><strong>日志分级</strong></li>
<li>将 ERROR（错误）级别的日志单独输出到 error.log 文件中</li>
</ol>
<h1 id="第三阶段"><a class="header" href="#第三阶段"><strong>第三阶段</strong></a></h1>
<ol>
<li><strong>按类隔离</strong></li>
<li>按功能分文件</li>
</ol>
<h1 id="第四阶段"><a class="header" href="#第四阶段">第四阶段</a></h1>
<p>自动刷新日志配置</p>
<h1 id="第五阶段"><a class="header" href="#第五阶段">第五阶段</a></h1>
<p>MDC 链路追踪</p>
<h1 id="第六阶段"><a class="header" href="#第六阶段">第六阶段</a></h1>
<p>日志收集</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日志介绍"><a class="header" href="#日志介绍">日志介绍</a></h1>
<p>​	几乎每个大型应用程序都包含自己的日志记录或跟踪 API，the E.U. <a href="http://www.semper.org/">SEMPER</a> project  决定实现自己记录API、这是1996年初，经过无数次的改进、several incarnations 和大量工作，API 已经演变成 log4j，一个流行的 Java 日志记录包，该软件包是在 <a href="https://logging.apache.org/log4j/2.x/LICENSE">Apache 软件许可证</a>下分发的，</p>
<p>​	Apache 软件许可证是由<a href="http://www.opensource.org/">开源计划</a>认证的成熟的开源许可证。可以在 http://logging.apache.org/log4j/2.x/index.html 找到最新的 log4j 版本，包括完整的源代码、类文件和文档</p>
<p>​		将日志语句插入代码是一种低技术的调试方法。这也可能是唯一的方法，因为调试器并不总是可用的。这通常适用于多线程应用程序和整个分布式应用程序。</p>
<p>​		经验表明，日志记录是开发周期的重要组成部分。它提供了几个优点。</p>
<ol>
<li>它提供有关应用程序运行的精确上下文</li>
<li>一旦插入到代码中，日志输出的生成就不需要人工干预</li>
<li>此外，日志输出可以保存在持久性介质中，以备日后研究</li>
<li>除了在开发周期中使用之外，一个足够丰富的日志包也可以被视为一个审计工具</li>
</ol>
<h1 id="log4j-2介绍"><a class="header" href="#log4j-2介绍">Log4j 2介绍</a></h1>
<p>Log4j 1.x 已被广泛采用并用于许多应用程序。然而，多年来它的发展已经放缓。</p>
<p>由于需要兼容非常旧的 Java 版本，它变得更加难以维护，并于 2015 年 8 月终止。它的替代方案 SLF4J/Logback 对该框架进行了许多必要的改进。那么为什么要为 Log4j 2 烦恼呢？</p>
<ol>
<li>Log4j 2 旨在用作审计日志记录框架。 Log4j 1.x 和 Logback 在重新配置时都会丢失事件。 Log4j 2 不会。</li>
<li>Log4j 2 包含基于 <a href="https://lmax-exchange.github.io/disruptor/">LMAX Disruptor</a> 库的下一代异步记录器。在多线程场景中，异步 Logger 的吞吐量比 Log4j 1.x 和 Logback 高 10 倍，延迟低几个数量级。</li>
<li>Log4j 2 对于独立应用程序是 <a href="https://logging.apache.org/log4j/2.x/manual/garbagefree.html">garbage free</a>，在稳定状态日志记录期间对于 Web 应用程序来说是低垃圾。这减少了垃圾收集器的压力，并且可以提供更好的响应时间性能。</li>
<li>Log4j 2 使用<a href="https://logging.apache.org/log4j/2.x/manual/plugins.html">插件系统</a>，通过添加新的 <a href="https://logging.apache.org/log4j/2.x/manual/appenders.html">Appenders</a>, <a href="https://logging.apache.org/log4j/2.x/manual/filters.html">Filters</a>, <a href="https://logging.apache.org/log4j/2.x/manual/layouts.html">Layouts</a>, <a href="https://logging.apache.org/log4j/2.x/manual/lookups.html">Lookups</a>  and Pattern Converters ，无需对 Log4j 进行任何更改，就可以非常轻松地<a href="https://logging.apache.org/log4j/2.x/manual/extending.html">扩展框架</a>。</li>
<li>由于插件系统配置更简单。配置中的条目不需要指定类名。</li>
<li>支持<a href="https://logging.apache.org/log4j/2.x/manual/customloglevels.html">自定义日志级别</a>。自定义日志级别可以在代码或配置中定义。</li>
<li>支持 lambda 表达式。仅当启用了请求的日志级别时，在 Java 8 上运行的客户端代码才能使用 lambda 表达式来延迟构建日志消息。不需要显式级别检查，从而使代码更清晰。</li>
<li>支持<a href="https://logging.apache.org/log4j/2.x/manual/messages.html">消息对象</a>。消息允许通过日志系统传递有趣和复杂的结构并进行有效操作。 Users are free to create their own <a href="https://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/message/Message.html">Message</a> types and write custom <a href="https://logging.apache.org/log4j/2.x/manual/layouts.html">Layouts</a>, <a href="https://logging.apache.org/log4j/2.x/manual/filters.html">Filters</a> and <a href="https://logging.apache.org/log4j/2.x/manual/lookups.html">Lookups</a> to manipulate them.</li>
<li>Log4j 1.x supports Filters on Appenders. Logback added TurboFilters to allow filtering of events before they are processed by a Logger. Log4j 2 supports Filters that can be configured to process events before they are handled by a Logger, as they are processed by a Logger or on an Appender.</li>
<li>大多数 Log4j 2 Appender 接受 Layout，允许以任何所需的格式传输数据。</li>
<li>Log4j 1.x 和 Logback 中的布局返回一个字符串。这导致了 Logback Encoders 中讨论的问题。 Log4j 2 采用更简单的方法，即 Layouts 总是返回一个字节数组。这样做的好处是，意味着它们几乎可以在任何 Appender 中使用，而不仅仅是写入 OutputStream Appender。</li>
<li>Syslog Appender 支持 TCP 和 UDP，并支持 BSD syslog 和 RFC 5424 格式。</li>
<li>Log4j 2 利用 Java 5 并发支持并在可能的最低级别执行锁定</li>
<li>它是一个 Apache 软件基金会项目，遵循所有 ASF 项目使用的社区和支持模型。如果您想贡献或获得提交更改的权利，只需遵循<a href="http://jakarta.apache.org/site/contributing.html">贡献</a>中概述的路径即可。</li>
</ol>
<h1 id="架构"><a class="header" href="#架构">架构</a></h1>
<p><img src="19.%E6%97%A5%E5%BF%97/log4j2/....%5Cimages%5Clog4j2-architecture.png" alt="image-20210817202907031" /></p>
<ol>
<li>使用 Log4j 2 API 的应用程序将从 LogManager 请求具有特定名称的 Logger。 </li>
<li>LogManager 将定位适当的 LoggerContext，然后从中获取 Logger。</li>
<li>如果必须创建 Logger，它将与包含 a) 与 Logger 相同的名称，b) 父包的名称或 c) 根 LoggerConfig 的 LoggerConfig 相关联。 </li>
<li>LoggerConfig 对象是从配置中的 Logger 声明创建的。 </li>
<li>LoggerConfig 与实际交付 LogEvents 的 Appender 相关联。</li>
</ol>
<h2 id="logger-hierarchy"><a class="header" href="#logger-hierarchy">Logger Hierarchy</a></h2>
<p>在 Log4j 1.x 中，Logger Hierarchy 是通过 Logger 之间的关系维护的。在 Log4j 2 中，这种关系不再存在。</p>
<p>相反，层次结构在 LoggerConfig 对象之间的关系中维护。</p>
<p>Loggers 和 LoggerConfigs 是命名实体。 Logger 名称区分大小写，并遵循分层命名规则：</p>
<p><strong>Named Hierarchy</strong></p>
<ol>
<li>
<p>通过 点分命名</p>
</li>
<li>
<p>com.foo 是 com.foo.Bar 的祖先</p>
</li>
<li>
<p>根Config位于 LoggerConfig层级结构的顶部，它的特殊之处在于它始终存在并且它是每个层次结构的一部分</p>
</li>
<li>
<p>直接 获取 根LoggerConfig的Logger可以通过如下方式获取 </p>
<pre><code class="language-java">Logger logger = LogManager.getLogger(LogManager.ROOT_LOGGER_NAME);
//或者
Logger logger = LogManager.getRootLogger();
</code></pre>
</li>
</ol>
<h2 id="loggercontext"><a class="header" href="#loggercontext">LoggerContext</a></h2>
<p>LoggerContext 作为 Logging 系统的锚点。但是，根据情况，应用程序中可能有多个活动的 LoggerContexts。</p>
<p>有关 LoggerContext 的更多详细信息，请参见日志分离部分</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>每个 LoggerContext 都有一个活动配置。</p>
<p>配置包含所有 Appender、上下文范围的过滤器、LoggerConfig 并包含对 StrSubstitutor 的引用。</p>
<p>在重新配置期间，将存在两个 Configuration 对象。一旦所有记录器都被重定向到新配置，旧配置将被停止并丢弃。</p>
<h2 id="logger"><a class="header" href="#logger">Logger</a></h2>
<p>如前所述，Logger 是通过调用 LogManager.getLogger 创建的。 </p>
<p>Logger 本身不执行任何直接操作。</p>
<p>它只有一个名称并与 LoggerConfig 相关联。</p>
<p>它扩展了 AbstractLogger 并实现了所需的方法。</p>
<p>随着配置被修改，Logger 可能会与不同的 LoggerConfig 相关联，从而导致它们的行为被修改。</p>
<h2 id="loggerconfig"><a class="header" href="#loggerconfig">LoggerConfig</a></h2>
<ol>
<li>LoggerConfig 对象是在日志配置中声明 Logger 时创建的。 LoggerConfig 包含一组过滤器，必须允许 LogEvent 在它被传递给任何 Appender 之前通过。它包含对应该用于处理事件的 Appender 集的引用。</li>
<li>oggerConfigs 将被分配一个日志级别。内置级别集包括 TRACE、DEBUG、INFO、WARN、ERROR 和 FATAL。 Log4j 2 还支持自定义日志级别。</li>
<li>另一种获得更多粒度的机制是改用标记。 Log4j 1.x 和 Logback 都有“级别继承”的概念。在 Log4j 2 中，Loggers 和 LoggerConfigs 是两个不同的对象，因此这个概念的实现方式不同。每个 Logger 引用适当的 LoggerConfig，后者又可以引用其父级，从而达到相同的效果</li>
</ol>
<p><strong>日志级别默认支持自动级别过滤</strong></p>
<p>横坐标是日志事件的级别、纵坐标是日志配置的级别</p>
<table><thead><tr><th style="text-align: left">Event Level</th><th style="text-align: left">LoggerConfig Level</th><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"></td><td style="text-align: left">TRACE</td><td style="text-align: left">DEBUG</td><td style="text-align: left">INFO</td><td style="text-align: left">WARN</td><td style="text-align: left">ERROR</td><td style="text-align: left">FATAL</td><td style="text-align: left">OFF</td></tr>
<tr><td style="text-align: left">ALL</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">NO</td></tr>
<tr><td style="text-align: left">TRACE</td><td style="text-align: left">YES</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td></tr>
<tr><td style="text-align: left">DEBUG</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td></tr>
<tr><td style="text-align: left">INFO</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td></tr>
<tr><td style="text-align: left">WARN</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td></tr>
<tr><td style="text-align: left">ERROR</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td></tr>
<tr><td style="text-align: left">FATAL</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">YES</td><td style="text-align: left">NO</td></tr>
<tr><td style="text-align: left">OFF</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td><td style="text-align: left">NO</td></tr>
</tbody></table>
<h2 id="filter"><a class="header" href="#filter">Filter</a></h2>
<p>除了上一节中描述的自动日志级别过滤之外，Log4j 还提供了过滤器，</p>
<ol>
<li>这些过滤器可以在控制传递给任何 LoggerConfig 之前，</li>
<li>在控制传递给 LoggerConfig 之后但在调用任何 Appenders 之前</li>
<li>在控制传递之后应用到 LoggerConfig 但在调用特定 Appender 之前，</li>
<li>以及在每个 Appender 上。</li>
</ol>
<p>以与防火墙过滤器非常相似的方式，每个过滤器可以返回三个结果之一，接受、拒绝或中立。 </p>
<p>Accept, Deny or Neutral</p>
<ul>
<li>
<p>Accept 的响应意味着不应调用其他过滤器并且事件应该进行。</p>
</li>
<li>
<p>拒绝响应意味着应立即忽略该事件并将控制权返回给调用者。 </p>
</li>
<li>
<p>Neutral 响应表示该事件应传递给其他过滤器。</p>
</li>
</ul>
<p>如果没有其他过滤器，则将处理该事件。</p>
<h2 id="appender"><a class="header" href="#appender">Appender</a></h2>
<p>目前，存在用于控制台、文件、远程套接字服务器、Apache Flume、JMS、远程 UNIX Syslog 守护进程和各种数据库 API 的附加程序。</p>
<p>有关可用的各种类型的更多详细信息，请参阅 Appenders 部分。一个 Logger 可以附加多个 Appender。可以通过调用当前 Configuration 的 addLoggerAppender 方法将 Appender 添加到 Logger。如果与 Logger 名称匹配的 LoggerConfig 不存在，则将创建一个，将 Appender 附加到它，然后将通知所有 Loggers 更新它们的 LoggerConfig 引用。</p>
<p><strong>appender可加性原则</strong></p>
<p>给定记录器的每个启用的日志记录请求都将转发到该 Logger 的 LoggerConfig 中的所有 appender 以及 LoggerConfig 父级的 Appender。</p>
<p>换句话说，Appender 从 LoggerConfig 层次结构中附加地继承。</p>
<p>例如，如果将控制台 appender 添加到根记录器，则所有启用的日志记录请求至少会在控制台上打印。</p>
<p>如果另外将文件附加程序添加到 LoggerConfig，例如 C，则为 C 和 C 的子项启用的日志记录请求将打印在文件和控制台上。</p>
<p>可以通过在配置文件中的 Logger 声明中设置 additivity=&quot;false&quot; 来覆盖此默认行为，以便 Appender 累积不再是可加的。</p>
<p>下面总结了管理 appender 可加性的规则。</p>
<p><strong>L 的一条日志语句的输出将转到与 L 关联的 LoggerConfig 中的所有 Appender 以及该 LoggerConfig 的祖先。</strong></p>
<p>这就是术语“appender 可加性”的含义。</p>
<p>但是，如果与 Logger L 关联的 LoggerConfig 的祖先，例如 P，将可加性标志设置为 false，那么 L 的输出将被定向到 L 的 LoggerConfig 中的所有 appender，并且它的祖先一直到并包括 P，但不包括在 </p>
<p>The table below shows an example:</p>
<table><thead><tr><th style="text-align: left">Logger Name</th><th style="text-align: left">Added Appenders</th><th style="text-align: left">Additivity Flag</th><th style="text-align: left">Output Targets</th><th style="text-align: left">Comment</th></tr></thead><tbody>
<tr><td style="text-align: left">root</td><td style="text-align: left">A1</td><td style="text-align: left">not applicable</td><td style="text-align: left">A1</td><td style="text-align: left">The root logger has no parent so additivity does not apply to it.</td></tr>
<tr><td style="text-align: left">x</td><td style="text-align: left">A-x1, A-x2</td><td style="text-align: left">true</td><td style="text-align: left">A1, A-x1, A-x2</td><td style="text-align: left">Appenders of &quot;x&quot; and root.</td></tr>
<tr><td style="text-align: left">x.y</td><td style="text-align: left">none</td><td style="text-align: left">true</td><td style="text-align: left">A1, A-x1, A-x2</td><td style="text-align: left">Appenders of &quot;x&quot; and root. It would not be typical to configure a Logger with no Appenders.</td></tr>
<tr><td style="text-align: left">x.y.z</td><td style="text-align: left">A-xyz1</td><td style="text-align: left">true</td><td style="text-align: left">A1, A-x1, A-x2, A-xyz1</td><td style="text-align: left">Appenders in &quot;x.y.z&quot;, &quot;x&quot; and root.</td></tr>
<tr><td style="text-align: left">security</td><td style="text-align: left">A-sec</td><td style="text-align: left">false</td><td style="text-align: left">A-sec</td><td style="text-align: left">No appender accumulation since the additivity flag is set to false.</td></tr>
<tr><td style="text-align: left">security.access</td><td style="text-align: left">none</td><td style="text-align: left">true</td><td style="text-align: left">A-sec</td><td style="text-align: left">Only appenders of &quot;security&quot; because the additivity flag in &quot;security&quot; is set to false.</td></tr>
</tbody></table>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p>通常情况下，用户不仅希望自定义输出目的地，还希望自定义输出格式。</p>
<p>这是通过将 Layout 与 Appender 相关联来实现的。 </p>
<p>Layout 负责根据用户的意愿格式化 LogEvent，而 appender 负责将格式化的输出发送到其目的地。 </p>
<p>PatternLayout 是标准 log4j 发行版的一部分，它允许用户根据类似于 C 语言 printf 函数的转换模式来指定输出格式。</p>
<p>例如，具有转换模式“%r [%t] %-5p %c - %m%n”的 PatternLayout 将输出类似于：</p>
<pre><code>176 [main] INFO  org.foo.Bar - Located nearest gas station.
</code></pre>
<p>第一个字段是自程序启动以来经过的毫秒数。</p>
<p>第二个字段是发出日志请求的线程。</p>
<p>第三个字段是日志语句的级别。</p>
<p>第四个字段是与日志请求关联的记录器的名称。 </p>
<p>“-”后面的文字是语句的信息。</p>
<p>Log4j 为各种用例提供了许多不同的布局，例如 JSON、XML、HTML 和 Syslog（包括新的 RFC 5424 版本）。</p>
<p>其他附加程序（例如数据库连接器）填充指定的字段而不是特定的文本布局。</p>
<p>同样重要的是，log4j 将根据用户指定的标准呈现日志消息的内容。</p>
<p>例如，如果您经常需要记录当前项目中使用的对象类型 Oranges，那么您可以创建一个接受 Orange 实例的 OrangeMessage 并将其传递给 Log4j，以便在以下情况下可以将 Orange 对象格式化为适当的字节数组</p>
<h2 id="strsubstitutor-and-strlookup"><a class="header" href="#strsubstitutor-and-strlookup">StrSubstitutor and StrLookup</a></h2>
<p>StrSubstitutor 类和 StrLookup 接口是从 Apache Commons Lang 借来的，然后经过修改以支持评估 LogEvents。</p>
<p>此外，Interpolator 类是从 Apache Commons Configuration 借来的，以允许 StrSubstitutor 评估来自多个 StrLookups 的变量。</p>
<p>它也经过修改以支持评估 LogEvents。</p>
<p>这些共同提供了一种机制，允许配置引用来自系统属性、配置文件、ThreadContext Map、LogEvent 中的 StructuredData 的变量。</p>
<p>如果组件能够处理它，则可以在处理配置时或在处理每个事件时解析变量。</p>
<p>有关详细信息，请参阅查找。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>Log4j 2 API 提供应用程序应编码到的接口，并提供实现者创建日志记录实现所需的适配器组件。</p>
<p>尽管 Log4j 2 在 API 和实现之间被分解，但这样做的主要目的不是允许多个实现，尽管这当然是可能的，</p>
<p><strong>但要明确定义在“正常”应用程序代码中可以安全使用哪些类和方法</strong></p>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h2>
<pre><code class="language-java">import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
 
public class HelloWorld {
    private static final Logger logger = LogManager.getLogger(&quot;HelloWorld&quot;);
    public static void main(String[] args) {
        logger.info(&quot;Hello, World!&quot;);
    }
}
</code></pre>
<h2 id="substituting-parameters"><a class="header" href="#substituting-parameters">Substituting Parameters</a></h2>
<pre><code class="language-java">logger.debug(&quot;Logging in user {} with birthday {}&quot;, user.getName(), user.getBirthdayCalendar());
</code></pre>
<h2 id="formatting-parameters"><a class="header" href="#formatting-parameters">Formatting Parameters</a></h2>
<p>如果 toString() 不是您想要的，格式化程序记录器将格式化由您决定。</p>
<p>为了便于格式化，您可以使用与 Java 的 Formatter 相同的格式字符串。</p>
<pre><code class="language-java">public static Logger logger = LogManager.getFormatterLogger(&quot;Foo&quot;);
 
logger.debug(&quot;Logging in user %s with birthday %s&quot;, user.getName(), user.getBirthdayCalendar());
logger.debug(&quot;Logging in user %1$s with birthday %2$tm %2$te,%2$tY&quot;, user.getName(), user.getBirthdayCalendar());
logger.debug(&quot;Integer.MAX_VALUE = %,d&quot;, Integer.MAX_VALUE);
logger.debug(&quot;Long.MAX_VALUE = %,d&quot;, Long.MAX_VALUE);
</code></pre>
<p>要使用格式化程序 Logger，您必须调用 LogManager getFormatterLogger 方法之一。此示例的输出显示 Calendar toString() 与自定义格式相比更为冗长：</p>
<h2 id="mixing-loggers-with-formatter-loggers"><a class="header" href="#mixing-loggers-with-formatter-loggers">Mixing Loggers with Formatter Loggers</a></h2>
<p>格式化程序记录器对输出格式进行细粒度控制，但缺点是必须指定正确的类型（例如，为 %d 格式参数传递除十进制整数以外的任何内容都会导致异常）。</p>
<p>如果您的主要用途是使用 {} 样式的参数，但偶尔需要对输出格式进行细粒度控制，则可以使用 printf 方法：</p>
<pre><code class="language-java">public static Logger logger = LogManager.getLogger(&quot;Foo&quot;);
 
logger.debug(&quot;Opening connection to {}...&quot;, someDataSource);
logger.printf(Level.INFO, &quot;Logging in user %1$s with birthday %2$tm %2$te,%2$tY&quot;, user.getName(), user.getBirthdayCalendar());
</code></pre>
<h2 id="java-8-lambda-support-for-lazy-logging"><a class="header" href="#java-8-lambda-support-for-lazy-logging">Java 8 lambda support for lazy logging</a></h2>
<p>在 2.4 版中，Logger 接口添加了对 lambda 表达式的支持。这允许客户端代码延迟记录消息，而无需显式检查请求的日志级别是否已启用。</p>
<pre><code class="language-java">// pre-Java 8 style optimization: explicitly check the log level
// to make sure the expensiveOperation() method is only called if necessary
if (logger.isTraceEnabled()) {
    logger.trace(&quot;Some long-running operation returned {}&quot;, expensiveOperation());
}
</code></pre>
<pre><code class="language-java">// Java-8 style optimization: no need to explicitly check the log level:
// the lambda expression is not evaluated if the TRACE level is not enabled
logger.trace(&quot;Some long-running operation returned {}&quot;, () -&gt; expensiveOperation());
</code></pre>
<h2 id="logger-names"><a class="header" href="#logger-names">Logger Names</a></h2>
<p>大多数日志实现使用分层方案来匹配日志名称和日志配置。</p>
<p>在此方案中，记录器名称层次结构由“.”表示。</p>
<p>记录器名称中的字符，其方式与用于 Java 包名称的层次结构非常相似。</p>
<p>例如，org.apache.logging.appender 和 org.apache.logging.filter 都将 org.apache.logging 作为它们的父级。</p>
<p>在大多数情况下，应用程序通过将当前类的名称传递给 LogManager.getLogger(...) 来命名它们的记录器。</p>
<p>因为这种用法非常普遍，所以 Log4j 2 提供了当 logger name 参数被省略或为 null 时的默认值。</p>
<p>例如，在下面的所有示例中，Logger 的名称都为“org.apache.test.MyTest”。</p>
<pre><code class="language-java">package org.apache.test; 
public class MyTest {    
    private static final Logger logger = LogManager.getLogger(MyTest.class);
}
package org.apache.test; 
public class MyTest {    
    private static final Logger logger = LogManager.getLogger(MyTest.class.getName());
}
package org.apache.test; 
public class MyTest {    
    private static final Logger logger = LogManager.getLogger();
}
</code></pre>
<h1 id="log-builder"><a class="header" href="#log-builder">Log Builder</a></h1>
<p>Log4j 传统上与日志语句一起使用，例如</p>
<pre><code class="language-java">logger.error(&quot;Unable to process request due to {}&quot;, code, exception);
</code></pre>
<p>这导致了一些关于异常是否应该作为消息的参数或 Log4j 是否应该将其作为 throwable 处理的混淆。</p>
<p>为了使日志记录更清晰，API 中添加了一个构建器模式。</p>
<p>使用构建器语法，上述内容将被处理为：</p>
<pre><code class="language-java"> logger.atError().withThrowable(exception).log(&quot;Unable to process request due to {}&quot;, code);
</code></pre>
<p>现在，当调用任何 atTrace、atDebug、atInfo、atWarn、atError、atFatal、always 或 atLevel(Level) 方法时，Logger 类将返回一个 LogBuilder。</p>
<p><strong>然后 logBuilder 允许在记录事件之前将标记、Throwable 和/或位置添加到事件中。</strong></p>
<p><strong>对 log 方法的调用总是导致日志事件被最终确定和发送。</strong></p>
<p>带有标记、Throwable 和位置的日志记录语句如下所示：</p>
<pre><code class="language-java">logger.atInfo().withMarker(marker).withLocation().withThrowable(exception).log(&quot;Login for user {} failed&quot;, userId);
</code></pre>
<p>在 LogBuilder 上提供 location 方法有两个明显的优势：</p>
<ol>
<li>Logging 包装器可以使用它来提供 Log4j 使用的位置信息。</li>
<li>使用不带参数的位置方法时捕获位置信息的开销比需要时必须计算位置信息要好得多。 Log4j 可以简单地在固定索引处请求堆栈跟踪条目，而不必遍历堆栈跟踪来确定调用类。</li>
</ol>
<p>正如预期的那样，当使用 LogBuilder 并调用 withLocation() 方法时，当输出中使用位置信息时，日志记录速度要快得多，但如果不使用，则速度要慢得多。</p>
<h1 id="flow-tracing"><a class="header" href="#flow-tracing">Flow Tracing</a></h1>
<p>Logger 类提供了对跟踪应用程序的执行路径非常有用的日志记录方法。</p>
<p>这些方法生成可以与其他调试日志分开过滤的日志事件。</p>
<ul>
<li>
<p>无需调试会话即可帮助开发中的问题诊断</p>
</li>
<li>
<p>帮助无法进行调试的生产中的问题</p>
</li>
<li>
<p>诊断有助于教育新开发人员学习应用程序。</p>
</li>
</ul>
<p>最常用的方法是 traceEntry() 和 traceExit() 方法。 记录方法进入与出去</p>
<h1 id="markers"><a class="header" href="#markers">Markers</a></h1>
<p>日志框架的主要目的之一是提供仅在需要时生成调试和诊断信息的方法，并允许过滤该信息，以免系统或需要使用的个人不堪重负</p>
<p>例如，应用程序希望将其进入、退出和其他操作与正在执行的 SQL 语句分开记录，并希望能够将查询与更新分开记录。实现此目的的一种方法如下所示：</p>
<p><strong>使用标记过滤器 过滤日志</strong></p>
<pre><code class="language-java">public class MyApp {
 
    private Logger logger = LogManager.getLogger(MyApp.class.getName());
    private static final Marker SQL_MARKER = MarkerManager.getMarker(&quot;SQL&quot;);
    private static final Marker UPDATE_MARKER = MarkerManager.getMarker(&quot;SQL_UPDATE&quot;).setParents(SQL_MARKER);
    private static final Marker QUERY_MARKER = MarkerManager.getMarker(&quot;SQL_QUERY&quot;).setParents(SQL_MARKER);
 
    public String doQuery(String table) {
        logger.traceEntry();
 
        logger.debug(QUERY_MARKER, &quot;SELECT * FROM {}&quot;, table);
 
        String result = ... 
 
        return logger.traceExit(result);
    }
 
    public String doUpdate(String table, Map&lt;String, String&gt; params) {
        logger.traceEntry();
 
        if (logger.isDebugEnabled()) {
            logger.debug(UPDATE_MARKER, &quot;UPDATE {} SET {}&quot;, table, formatCols());
        }
	
        String result = ... 
 
        return logger.traceExit(result);
    }
 
    private String formatCols(Map&lt;String, String&gt; cols) {
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (Map.Entry&lt;String, String&gt; entry : cols.entrySet()) {
            if (!first) {
                sb.append(&quot;, &quot;);
            }
            sb.append(entry.getKey()).append(&quot;=&quot;).append(entry.getValue());
            first = false;
        }
        return sb.toString();
    }
}
</code></pre>
<h1 id="event-logging"><a class="header" href="#event-logging">Event Logging</a></h1>
<p>EventLogger 类提供了一种简单的机制来记录应用程序中发生的事件。</p>
<p>虽然 EventLogger 作为启动应由审计日志系统处理的事件的一种方式很有用，但它本身并没有实现审计日志系统所需的任何功能，例如保证交付。</p>
<p>在典型的 Web 应用程序中使用 EventLogger 的推荐方法是使用与请求的整个生命周期相关的数据填充 ThreadContext Map，例如用户的 id、用户的 IP 地址、产品名称等。这很容易</p>
<p>在 servlet 过滤器中完成，其中也可以在请求结束时清除 ThreadContext Map。</p>
<p>当需要记录的事件发生时，应创建并填充 StructuredDataMessage。</p>
<p>然后调用 EventLogger.logEvent(msg)，其中 msg 是对 StructuredDataMessage 的引用。</p>
<pre><code class="language-java">public class RequestFilter implements Filter {
    private FilterConfig filterConfig;
    private static String TZ_NAME = &quot;timezoneOffset&quot;;
 
    public void init(FilterConfig filterConfig) throws ServletException {
        this.filterConfig = filterConfig;
    }
 
    /**
     * Sample filter that populates the MDC on every request.
     */
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)
            throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest)servletRequest;
        HttpServletResponse response = (HttpServletResponse)servletResponse;
        ThreadContext.put(&quot;ipAddress&quot;, request.getRemoteAddr());
        HttpSession session = request.getSession(false);
        TimeZone timeZone = null;
        if (session != null) {
            // Something should set this after authentication completes
            String loginId = (String)session.getAttribute(&quot;LoginId&quot;);
            if (loginId != null) {
                ThreadContext.put(&quot;loginId&quot;, loginId);
            }
            // This assumes there is some javascript on the user's page to create the cookie.
            if (session.getAttribute(TZ_NAME) == null) {
                if (request.getCookies() != null) {
                    for (Cookie cookie : request.getCookies()) {
                        if (TZ_NAME.equals(cookie.getName())) {
                            int tzOffsetMinutes = Integer.parseInt(cookie.getValue());
                            timeZone = TimeZone.getTimeZone(&quot;GMT&quot;);
                            timeZone.setRawOffset((int)(tzOffsetMinutes * DateUtils.MILLIS_PER_MINUTE));
                            request.getSession().setAttribute(TZ_NAME, tzOffsetMinutes);
                            cookie.setMaxAge(0);
                            response.addCookie(cookie);
                        }
                    }
                }
            }
        }
        ThreadContext.put(&quot;hostname&quot;, servletRequest.getServerName());
        ThreadContext.put(&quot;productName&quot;, filterConfig.getInitParameter(&quot;ProductName&quot;));
        ThreadContext.put(&quot;locale&quot;, servletRequest.getLocale().getDisplayName());
        if (timeZone == null) {
            timeZone = TimeZone.getDefault();
        }
        ThreadContext.put(&quot;timezone&quot;, timeZone.getDisplayName());
        filterChain.doFilter(servletRequest, servletResponse);
        ThreadContext.clear();
    }
 
    public void destroy() {
    }
}
</code></pre>
<pre><code class="language-java">import org.apache.logging.log4j.StructuredDataMessage;
import org.apache.logging.log4j.EventLogger;
 
import java.util.Date;
import java.util.UUID;
 
public class MyApp {
 
    public String doFundsTransfer(Account toAccount, Account fromAccount, long amount) {
        toAccount.deposit(amount);
        fromAccount.withdraw(amount);
        String confirm = UUID.randomUUID().toString();
        StructuredDataMessage msg = new StructuredDataMessage(confirm, null, &quot;transfer&quot;);
        msg.put(&quot;toAccount&quot;, toAccount);
        msg.put(&quot;fromAccount&quot;, fromAccount);
        msg.put(&quot;amount&quot;, amount);
        EventLogger.logEvent(msg);
        return confirm;
    }
}
</code></pre>
<h1 id="messages"><a class="header" href="#messages">Messages</a></h1>
<p>尽管 Log4j 2 提供了接受字符串和对象的 Logger 方法，但所有这些最终都在 Message 对象中捕获，然后与日志事件关联。</p>
<p>应用程序可以自由地构建自己的消息并将它们传递给记录器。</p>
<p>尽管看起来比将消息格式和参数直接传递给事件更昂贵，但测试表明，使用现代 JVM，创建和销毁事件的成本很小，尤其是当复杂的任务封装在消息而不是应用程序中时。</p>
<p><strong>此外，当使用接受字符串和参数的方法时，只有在任何配置的全局过滤器或 Logger 的日志级别允许处理消息时，才会创建底层 Message 对象。</strong></p>
<pre><code>考虑一个应用程序，它有一个包含 {&quot;Name&quot; = &quot;John Doe&quot;, &quot;Address&quot; = &quot;123 Main St.&quot;, &quot;Phone&quot; = &quot;(999) 555-1212&quot;} 的 Map 对象和一个具有

返回“jdoe”的 getId 方法。

开发人员想要添加返回“用户 John Doe 已使用 id jdoe 登录”的信息性消息。

实现这一点的方法是：
logger.info(&quot;User {} has logged in using id {}&quot;, map.get(&quot;Name&quot;), user.getId());

</code></pre>
<p>虽然这本身没有任何问题，但随着对象的复杂性和所需输出的增加，这种技术变得更难使用。</p>
<p><strong>作为替代方案，使用 Messages 允许：</strong></p>
<pre><code class="language-java">logger.info(new LoggedInMessage(map, user));
</code></pre>
<p>在此替代方案中，格式化委托给 LoggedInMessage 对象的 getFormattedMessage 方法。</p>
<p>尽管在此替代方案中创建了一个新对象，但在格式化 LoggedInMessage 之前，不会调用传递给 LoggedInMessage 的对象上的任何方法。</p>
<p>当对象的 toString 方法不产生您希望出现在日志中的信息时，这尤其有用。</p>
<p>Messages 的另一个优点是它们简化了编写布局。在其他日志框架中，布局必须单独遍历参数并根据遇到的对象确定要执行的操作。<strong>对于消息，布局可以选择将格式委托给消息或根据遇到的消息类型执行其格式。</strong></p>
<p>借用前面说明标记以识别正在记录的 SQL 语句的示例，还可以利用消息。首先，定义消息。</p>
<pre><code class="language-java">public class SQLMessage implements Message {
  public enum SQLType {
      UPDATE,
      QUERY
  };
 
  private final SQLType type;
  private final String table;
  private final Map&lt;String, String&gt; cols;
 
  public SQLMessage(SQLType type, String table) {
      this(type, table, null);
  }
 
  public SQLMessage(SQLType type, String table, Map&lt;String, String&gt; cols) {
      this.type = type;
      this.table = table;
      this.cols = cols;
  }
 
  public String getFormattedMessage() {
      switch (type) {
          case UPDATE:
            return createUpdateString();
            break;
          case QUERY:
            return createQueryString();
            break;
          default;
      }
  }
 
  public String getMessageFormat() {
      return type + &quot; &quot; + table;
  }
 
  public Object getParameters() {
      return cols;
  }
 
  private String createUpdateString() {
  }
 
  private String createQueryString() {
  }
 
  private String formatCols(Map&lt;String, String&gt; cols) {
      StringBuilder sb = new StringBuilder();
      boolean first = true;
      for (Map.Entry&lt;String, String&gt; entry : cols.entrySet()) {
          if (!first) {
              sb.append(&quot;, &quot;);
          }
          sb.append(entry.getKey()).append(&quot;=&quot;).append(entry.getValue());
          first = false;
      }
      return sb.toString();
  }
}
</code></pre>
<p><strong>接下来我们可以在我们的应用程序中使用消息。</strong></p>
<pre><code class="language-java">import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import java.util.Map;
 
public class MyApp {
 
    private Logger logger = LogManager.getLogger(MyApp.class.getName());
    private static final Marker SQL_MARKER = MarkerManager.getMarker(&quot;SQL&quot;);
    private static final Marker UPDATE_MARKER = MarkerManager.getMarker(&quot;SQL_UPDATE&quot;, SQL_MARKER);
    private static final Marker QUERY_MARKER = MarkerManager.getMarker(&quot;SQL_QUERY&quot;, SQL_MARKER);
 
    public String doQuery(String table) {
        logger.entry(param);
 
        logger.debug(QUERY_MARKER, new SQLMessage(SQLMessage.SQLType.QUERY, table));
 
        return logger.exit();
    }
 
    public String doUpdate(String table, Map&lt;String, String&gt; params) {
        logger.entry(param);
 
        logger.debug(UPDATE_MARKER, new SQLMessage(SQLMessage.SQLType.UPDATE, table, parmas);
 
        return logger.exit();
    }
}
</code></pre>
<h2 id="其他消息类"><a class="header" href="#其他消息类">其他消息类</a></h2>
<h3 id="formattedmessage"><a class="header" href="#formattedmessage">FormattedMessage</a></h3>
<p>使用 MessageFormatMessage 对其进行格式化</p>
<h3 id="localizedmessage"><a class="header" href="#localizedmessage">LocalizedMessage</a></h3>
<p>提供 LocalizedMessage 主要是为了提供与 Log4j 1.x 的兼容性。通常，本地化的最佳方法是让客户端 UI 在客户端的语言环境中呈现事件。</p>
<h4 id="loggernameawaremessage"><a class="header" href="#loggernameawaremessage">LoggerNameAwareMessage</a></h4>
<p>此方法将在事件构造期间调用，以便 Message 具有在格式化消息时用于记录事件的 Logger 的名称。</p>
<h3 id="mapmessage"><a class="header" href="#mapmessage">MapMessage</a></h3>
<p>MapMessage 包含字符串键和值的映射。 </p>
<p>MapMessage 实现 FormattedMessage 并接受“XML”、“JSON”或“JAVA”的格式说明符，在这种情况下，Map 将被格式化为 XML、JSON 或 java.util.AbstractMap.toString() 所记录的格式。</p>
<p>否则，地图将被格式化为“key1=value1 key2=value2 ...”。</p>
<h3 id="一些-appender-专门使用-mapmessage-对象"><a class="header" href="#一些-appender-专门使用-mapmessage-对象">一些 Appender 专门使用 MapMessage 对象：</a></h3>
<ol>
<li>当 JMS Appender 配置了 MessageLayout 时，它会将 Log4j MapMessage 转换为 JMS javax.jms.MapMessage。</li>
<li>当 JDBC Appender 配置了 MessageLayout 时，它会将 Log4j MapMessage 转换为 SQL INSERT 语句中的值。</li>
<li>当 MongoDB3 Appender 或 MongoDB4 Appender 配置了 MessageLayout 时，它会将 Log4j MapMessage 转换为 MongoDB 对象中的字段。</li>
</ol>
<p>当 Appender 是 MessageLayout-aware 时，Log4j 发送到目标的对象不是 Log4j 日志事件，而是自定义对象。</p>
<h4 id="messageformatmessage"><a class="header" href="#messageformatmessage">MessageFormatMessage</a></h4>
<p><a href="http://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/message/MessageFormatMessage.html">MessageFormatMessage</a> handles messages that use a <a href="https://docs.oracle.com/javase/7/docs/api/java/text/MessageFormat.html">conversion format</a>. While this Message has more flexibility than ParameterizedMessage, it is also about two times slower.</p>
<h4 id="multiformatmessage"><a class="header" href="#multiformatmessage">MultiformatMessage</a></h4>
<p>A MultiformatMessage will have a getFormats method and a getFormattedMessage method that accepts and array of format Strings. The getFormats method may be called by a Layout to provide it information on what formatting options the Message supports. The Layout may then call getFormattedMessage with one or more for the formats. If the Message doesn't recognize the format name it will simply format the data using its default format. An example of this is the StructuredDataMessage which accepts a format String of &quot;XML&quot; which will cause it to format the event data as XML instead of the RFC 5424 format.</p>
<h4 id="objectmessage"><a class="header" href="#objectmessage">ObjectMessage</a></h4>
<p>Formats an Object by calling its toString method. Since Log4j 2.6, Layouts trying to be low-garbage or garbage-free will call the formatTo(StringBuilder) method instead.</p>
<h4 id="parameterizedmessage"><a class="header" href="#parameterizedmessage">ParameterizedMessage</a></h4>
<p><a href="http://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/message/ParameterizedMessage.html">ParameterizedMessage</a> handles messages that contain &quot;{}&quot; in the format to represent replaceable tokens and the replacement parameters.</p>
<h4 id="reusableobjectmessage"><a class="header" href="#reusableobjectmessage">ReusableObjectMessage</a></h4>
<p>In garbage-free mode, this message is used to pass logged Objects to the Layout and Appenders. Functionally equivalent to <a href="http://logging.apache.org/log4j/2.x/manual/messages.html#ObjectMessage">ObjectMessage</a>.</p>
<h4 id="reusableparameterizedmessage"><a class="header" href="#reusableparameterizedmessage">ReusableParameterizedMessage</a></h4>
<p>In garbage-free mode, this message is used to handle messages that contain &quot;{}&quot; in the format to represent replaceable tokens and the replacement parameters. Functionally equivalent to <a href="http://logging.apache.org/log4j/2.x/manual/messages.html#ParameterizedMessage">ParameterizedMessage</a>.</p>
<h4 id="reusablesimplemessage"><a class="header" href="#reusablesimplemessage">ReusableSimpleMessage</a></h4>
<p>In garbage-free mode, this message is used to pass logged Strings and CharSequences to the Layout and Appenders. Functionally equivalent to <a href="http://logging.apache.org/log4j/2.x/manual/messages.html#SimpleMessage">SimpleMessage</a>.</p>
<h4 id="simplemessage"><a class="header" href="#simplemessage">SimpleMessage</a></h4>
<p>SimpleMessage contains a String or CharSequence that requires no formatting.</p>
<h4 id="stringformattedmessage"><a class="header" href="#stringformattedmessage">StringFormattedMessage</a></h4>
<p><a href="http://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/message/StringFormattedMessage.html">StringFormattedMessage</a> handles messages that use a <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax">conversion format</a> that is compliant with [java.lang.String.format()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#format(java.lang.String, java.lang.Object...)). While this Message has more flexibility than ParameterizedMessage, it is also 5 to 10 times slower.</p>
<h4 id="structureddatamessage"><a class="header" href="#structureddatamessage">StructuredDataMessage</a></h4>
<p><a href="http://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/message/StructuredDataMessage.html">StructuredDataMessage</a> allows applications to add items to a Map as well as set the id to allow a message to be formatted as a Structured Data element in accordance with <a href="http://tools.ietf.org/html/rfc5424">RFC 5424</a>.</p>
<h4 id="threaddumpmessage"><a class="header" href="#threaddumpmessage">ThreadDumpMessage</a></h4>
<p>A ThreadDumpMessage, if logged, will generate stack traces for all threads. The stack traces will include any locks that are held.</p>
<h4 id="timestampmessage"><a class="header" href="#timestampmessage">TimestampMessage</a></h4>
<p>A TimestampMessage will provide a getTimestamp method that is called during event construction. The timestamp in the Message will be used in lieu of the current timestamp.</p>
<h1 id="thread-context"><a class="header" href="#thread-context">Thread Context</a></h1>
<p>Log4j 引入了映射诊断上下文或 MDC 的概念。</p>
<p>Log4j 2 延续了 MDC 和 NDC 的想法，但将它们合并到一个单一的线程上下文中。</p>
<p>线程上下文映射相当于 MDC</p>
<p>线程上下文堆栈相当于 NDC。</p>
<p>两者间的区别是 </p>
<p>至于选择NDC还是MDC要看需要存储的上下文信息是堆栈式的还是key/value形式的。</p>
<p>NDC采用了一个类似栈的机制来push和pop上下文信息，每一个线程都独立地储存上下文信息。比如说一个servlet就可以针对每一个request创建对应的NDC，储存客户端地址等等信息。</p>
<p>当使用的时候，我们要尽可能确保在进入一个context的时候，把相关的信息使用NDC.push(message);在离开这个context的时候使用NDC.pop()将信息删除。另外由于设计上的一些问题，还需要保证在当前thread结束的时候使用NDC.remove()清除内存，否则会产生内存泄漏的问题。</p>
<h2 id="fish-tagging"><a class="header" href="#fish-tagging">Fish Tagging</a></h2>
<p>大多数现实世界的系统必须同时处理多个客户端。在此类系统的典型多线程实现中，不同的线程将处理不同的客户端。日志记录特别适合跟踪和调试复杂的分布式应用程序。区分一个客户端的日志输出与另一个的常用方法是为每个客户端实例化一个新的单独记录器。这促进了记录器的扩散并增加了记录的管理开销。</p>
<p><strong>一种较轻的技术是对从同一客户端交互发起的每个日志请求进行唯一标记。</strong> </p>
<p>Neil Harrison 在由 R. Martin、D. Riehle 和 F. Buschmann 编辑的“程序设计模式语言 3”一书中的“记录诊断消息的模式”一书中描述了这种方法（Addison-Wesley，1997 年）。</p>
<p>就像鱼可以被标记并跟踪其移动一样，使用通用标记或数据元素集标记日志事件允许跟踪事务或请求的完整流程。</p>
<p>我们称之为鱼标记。</p>
<p>log4j 提供了两种执行 Fish Tagging 的机制；</p>
<ol>
<li>
<p>线程上下文映射</p>
</li>
<li>
<p>线程上下文堆栈</p>
</li>
</ol>
<p>线程上下文映射允许使用键/值对添加和识别任意数量的项目。</p>
<p>线程上下文堆栈允许将一个或多个项目压入堆栈，然后通过它们在堆栈中的顺序或数据本身进行标识</p>
<p>由于key/value对更加灵活，当请求的处理过程中可能会添加数据项或者数据项超过一两个时，推荐使用Thread Context Map。</p>
<pre><code class="language-java">ThreadContext.push(UUID.randomUUID().toString()); // Add the fishtag;
 
logger.debug(&quot;Message 1&quot;);
.
.
.
logger.debug(&quot;Message 2&quot;);
.
.
ThreadContext.pop();
</code></pre>
<pre><code class="language-java">ThreadContext.put(&quot;id&quot;, UUID.randomUUID().toString()); // Add the fishtag;
ThreadContext.put(&quot;ipAddress&quot;, request.getRemoteAddr());
ThreadContext.put(&quot;loginId&quot;, session.getAttribute(&quot;loginId&quot;));
ThreadContext.put(&quot;hostName&quot;, request.getServerName());
.
logger.debug(&quot;Message 1&quot;);
.
.
logger.debug(&quot;Message 2&quot;);
.
.
ThreadContext.clear();
</code></pre>
<h2 id="closeablethreadcontext"><a class="header" href="#closeablethreadcontext">CloseableThreadContext</a></h2>
<p>放入堆栈需要清除数据，CloseableThreadContext 实现了 AutoCloseable 接口。</p>
<p>这允许将项目推送到堆栈或放入映射中，并在调用 close() 方法时删除 - 或者作为 try-with-resources 的一部分自动删除。</p>
<pre><code class="language-java">// Add to the ThreadContext stack for this try block only;
try (final CloseableThreadContext.Instance ctc = CloseableThreadContext.push(UUID.randomUUID().toString())) {
 
    logger.debug(&quot;Message 1&quot;);
.
.
    logger.debug(&quot;Message 2&quot;);
.
.
}
// Add to the ThreadContext map for this try block only;
try (final CloseableThreadContext.Instance ctc = CloseableThreadContext.put(&quot;id&quot;, UUID.randomUUID().toString())
                                                                .put(&quot;loginId&quot;, session.getAttribute(&quot;loginId&quot;))) {
 
    logger.debug(&quot;Message 1&quot;);
.
.
    logger.debug(&quot;Message 2&quot;);
.
.
}
</code></pre>
<p>如果您使用线程池，则可以使用 putAll(final Map values) 和/或 pushAll(List messages) 方法初始化 CloseableThreadContext ；</p>
<p>开启线程池时 使用putAll pushAll传值</p>
<pre><code class="language-java">for( final Session session : sessions ) {
    try (final CloseableThreadContext.Instance ctc = CloseableThreadContext.put(&quot;loginId&quot;, session.getAttribute(&quot;loginId&quot;))) {
        logger.debug(&quot;Starting background thread for user&quot;);
        final Map&lt;String, String&gt; values = ThreadContext.getImmutableContext();
        final List&lt;String&gt; messages = ThreadContext.getImmutableStack().asList();
        executor.submit(new Runnable() {
        public void run() {
            try (final CloseableThreadContext.Instance ctc = CloseableThreadContext.putAll(values).pushAll(messages)) {
                logger.debug(&quot;Processing for user started&quot;);
                .
                logger.debug(&quot;Processing for user completed&quot;);
            }
        });
    }
}
</code></pre>
<p>Map 可以配置为使用 <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/InheritableThreadLocal.html">InheritableThreadLocal</a>.以这种方式配置时，Map 的内容将传递给子线程。</p>
<h2 id="配置-1"><a class="header" href="#配置-1">配置</a></h2>
<h4 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h4>
<ul>
<li>Set the system property <code>disableThreadContextMap</code> to <code>true</code> to disable the Thread Context Map.</li>
<li>Set the system property <code>disableThreadContextStack</code> to <code>true</code> to disable the Thread Context Stack.</li>
<li>Set the system property <code>disableThreadContext</code> to <code>true</code> to disable both the Thread Context Map and Stack.</li>
<li>Set the system property <code>log4j2.isThreadContextMapInheritable</code> to <code>true</code> to enable child threads to inherit the Thread Context Map.</li>
</ul>
<h2 id="including-the-threadcontext-when-writing-logs"><a class="header" href="#including-the-threadcontext-when-writing-logs">Including the ThreadContext when writing logs</a></h2>
<p>The <a href="http://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/layout/PatternLayout.html">PatternLayout</a> provides mechanisms to print the contents of the <a href="http://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/ThreadContext.html">ThreadContext</a> Map and Stack.</p>
<ul>
<li>Use %X by itself to include the full contents of the Map.</li>
<li>Use %X{key} to include the specified key.</li>
<li>Use %x to include the full contents of the <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Stack.html">Stack</a>.</li>
</ul>
<h4 id="custom-context-data-injectors-for-non-thread-local-context-data"><a class="header" href="#custom-context-data-injectors-for-non-thread-local-context-data">Custom context data injectors for non thread-local context data</a></h4>
<p>With the ThreadContext logging statements can be tagged so log entries that were related in some way can be linked via these tags. The limitation is that this only works for logging done on the same application thread (or child threads when configured).</p>
<p>Some applications have a thread model that delegates work to other threads, and in such models, tagging attributes that are put into a thread-local map in one thread are not visible in the other threads and logging done in the other threads will not show these attributes.</p>
<p>Log4j 2.7 adds a flexible mechanism to tag logging statements with context data coming from other sources than the ThreadContext. See the manual page on <a href="http://logging.apache.org/log4j/2.x/manual/extending.html#Custom_ContextDataInjector">extending Log4j</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-log4j-2-in-web-applications"><a class="header" href="#using-log4j-2-in-web-applications">Using Log4j 2 in Web Applications</a></h1>
<p>在 Java EE Web 应用程序中使用 Log4j 或任何其他日志记录框架时，您必须特别小心。</p>
<p>当容器关闭或取消部署 Web 应用程序时，正确清理日志资源（关闭数据库连接、关闭文件等）非常重要。</p>
<p>由于 Web 应用程序中类加载器的性质，Log4j 资源无法通过正常方式清理。</p>
<p>当 Web 应用程序部署时 Log4j 必须“启动”，当 Web 应用程序取消部署时必须“关闭”。</p>
<p>它的工作方式取决于您的应用程序是 Servlet 3.0 或更新版本还是 Servlet 2.5 Web 应用程序。</p>
<p>无论哪种情况，您都需要将 log4j-web 模块添加到您的部署中，如 Maven、Ivy 和 Gradle Artifacts 手册页中所述。</p>
<p>为避免出现问题，当包含 log4j-web jar 时，将自动禁用 Log4j 关闭挂钩。</p>
<h1 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h1>
<p>Log4j 允许 在 web.xml 中 使用 log4jConfiguration  context parameter 指定配置文件。 </p>
<p>Log4j 将通过以下方式搜索配置文件</p>
<ol>
<li>
<p>如果提供了位置，它将作为 servlet 上下文资源进行搜索。例如，如果 log4jConfiguration 包含“logging.xml”，那么 Log4j 将在 Web 应用程序的根目录中查找具有该名称的文件。</p>
</li>
<li>
<p>如果没有定义位置，Log4j 将在 WEB-INF 目录中搜索以“log4j2”开头的文件。如果找到多个文件，并且存在以“log4j2-name”开头的文件（其中 name 是 Web 应用程序的名称），则将使用该文件。否则将使用第一个文件。</p>
</li>
<li>
<p>使用类路径和文件 URL 的“正常”搜索序列将用于定位配置文件。</p>
</li>
<li>
<p>使用类路径和文件 URL 的“正常”搜索序列将用于定位配置文件。</p>
</li>
</ol>
<h1 id="servlet-30-and-newer-web-applications"><a class="header" href="#servlet-30-and-newer-web-applications">Servlet 3.0 and Newer Web Applications</a></h1>
<p>Log4j 2 在 Servlet 3.0 和更新的 Web 应用程序中“正常工作”。</p>
<p>它能够在应用程序部署时自动启动并在应用程序取消部署时自动关闭。</p>
<p>由于 ServletContainerInitializer API 添加到 Servlet 3.0，相关的 Filter 和 ServletContextListener 类可以在 web 应用程序启动时动态注册。</p>
<p>重要的提示！</p>
<p>出于性能原因，容器通常会忽略某些已知不包含 TLD 或 ServletContainerInitializers 的 JAR，并且不扫描它们以查找 web 片段和初始化程序。</p>
<p>重要的是，Tomcat 7 &lt;7.0.43 会忽略所有名为 log4j*.jar 的 JAR 文件，这会阻止此功能工作。</p>
<p>这已在 Tomcat 7.0.43、Tomcat 8 及更高版本中修复。</p>
<p>Log4j 2 Web JAR 文件是一个 Web 片段，配置为在应用程序中的任何其他 Web 片段之前排序。</p>
<p>它包含一个容器自动发现和初始化的 ServletContainerInitializer (Log4jServletContainerInitializer)。</p>
<p>这会将 Log4jServletContextListener 和 Log4jServletFilter 添加到 ServletContext。</p>
<p>这些类正确初始化和取消初始化 Log4j 配置。</p>
<p>对于某些用户来说，自动启动 Log4j 是有问题的或不可取的。</p>
<p>您可以使用 isLog4jAutoInitializationDisabled 上下文参数轻松禁用此功能。</p>
<p>只需使用值“true”将其添加到您的部署描述符中即可禁用自动初始化。</p>
<p>您必须在 web.xml 中定义上下文参数。</p>
<p>如果以编程方式设置，Log4j 检测设置为时已晚。</p>
<pre><code class="language-xml">  &lt;context-param&gt;
        &lt;param-name&gt;isLog4jAutoInitializationDisabled&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/context-param&gt;
</code></pre>
<p>禁用自动初始化后，您必须像初始化 Servlet 2.5 Web 应用程序一样初始化 Log4j。</p>
<p>您必须以这种初始化发生在任何其他应用程序代码（例如 Spring Framework 启动代码）执行之前的方式执行此操作。</p>
<p>您可以使用 log4jContextName、log4jConfiguration 和/或 isLog4jContextSelectorNamed 上下文参数自定义侦听器和过滤器的行为。</p>
<p>在下面的上下文参数部分阅读更多相关信息。</p>
<p>除非您使用 isLog4jAutoInitializationDisabled 禁用自动初始化，否则您不得在部署描述符 (web.xml) 或 Servlet 3.0 或更高版本应用程序中的另一个初始化程序或侦听器中手动配置 Log4jServletContextListener 或 Log4jServletFilter。</p>
<p>这样做将导致启动错误和未指定的错误行为。</p>
<h1 id="servlet-25-web-applications"><a class="header" href="#servlet-25-web-applications">Servlet 2.5 Web Applications</a></h1>
<p>Servlet 2.5 Web 应用程序是版本属性值为“2.5”的任何 。 </p>
<p>version 属性是唯一重要的东西；</p>
<p>即使 Web 应用程序运行在 Servlet 3.0 或更新的容器中，如果版本属性为“2.5”，它也是 Servlet 2.5 Web 应用程序。</p>
<p>请注意，Log4j 2 不支持 Servlet 2.4 和更旧的 Web 应用程序。</p>
<p>如果您在 Servlet 2.5 Web 应用程序中使用 Log4j，或者您已使用 isLog4jAutoInitializationDisabled 上下文参数禁用自动初始化，则必须在部署描述符中或以编程方式配置 Log4jServletContextListener 和 Log4jServletFilter。</p>
<p>过滤器应匹配任何类型的所有请求。</p>
<p>监听器应该是应用程序中定义的第一个监听器，过滤器应该是应用程序中定义和映射的第一个过滤器。</p>
<p>这可以使用以下 web.xml 代码轻松完成：</p>
<pre><code class="language-xml">    &lt;listener&gt;
        &lt;listener-class&gt;org.apache.logging.log4j.web.Log4jServletContextListener&lt;/listener-class&gt;
    &lt;/listener&gt;
 
    &lt;filter&gt;
        &lt;filter-name&gt;log4jServletFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.apache.logging.log4j.web.Log4jServletFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;log4jServletFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
        &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;
        &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;
        &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;
        &lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;&lt;!-- Servlet 3.0 w/ disabled auto-initialization only; not supported in 2.5 --&gt;
    &lt;/filter-mapping&gt;
</code></pre>
<p>您可以使用 log4jContextName、log4jConfiguration 和/或 isLog4jContextSelectorNamed 上下文参数自定义侦听器和过滤器的行为。</p>
<p>在下面的上下文参数部分阅读更多相关信息</p>
<h1 id="context-parameters"><a class="header" href="#context-parameters">Context Parameters</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lookups"><a class="header" href="#lookups">Lookups</a></h1>
<p><strong>Lookups</strong>  提供了一种在任意位置向 Log4j 配置添加值的方法。它们是实现 StrLookup 接口的特殊类型的插件</p>
<p>关于如何在配置文件中使用查找的信息可以在  <a href="https://logging.apache.org/log4j/2.x/manual/configuration.html">configuration</a> 页面的  <a href="https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution">Property Substitution</a> 部分找到。</p>
<h1 id="context-map-lookup"><a class="header" href="#context-map-lookup">Context Map Lookup</a></h1>
<p>ContextMapLookup 允许应用程序将数据存储在 Log4j ThreadContext Map 中，然后在Log4j 配置 检索值。</p>
<p>在下面的示例中，应用程序将使用键“loginId”将当前用户的登录 ID 存储在 ThreadContext Map 中。</p>
<p>在初始配置处理期间，第一个“$”将被删除。 </p>
<p>PatternLayout 支持使用 Lookups 进行插值，然后将为每个事件解析变量。</p>
<p>请注意，模式 &quot;%X{loginId}&quot; 将获得相同的结果。</p>
<pre><code class="language-xml">&lt;File name=&quot;Application&quot; fileName=&quot;application.log&quot;&gt;
  &lt;PatternLayout&gt;
    &lt;pattern&gt;%d %p %c{1.} [%t] $${ctx:loginId} %m%n&lt;/pattern&gt;
  &lt;/PatternLayout&gt;
&lt;/File&gt;
</code></pre>
<h1 id="date-lookup"><a class="header" href="#date-lookup">Date Lookup</a></h1>
<p>DateLookup 与其他查找有些不同，因为它不使用键来定位项目。</p>
<p>相反，该键可用于指定对 SimpleDateFormat 有效的日期格式字符串。</p>
<p>当前日期或与当前日志事件关联的日期将按照指定的格式进行格式化。</p>
<pre><code class="language-xml">&lt;RollingFile name=&quot;Rolling-${map:type}&quot; fileName=&quot;${filename}&quot; filePattern=&quot;target/rolling1/test1-$${date:MM-dd-yyyy}.%i.log.gz&quot;&gt;
  &lt;PatternLayout&gt;
    &lt;pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/pattern&gt;
  &lt;/PatternLayout&gt;
  &lt;SizeBasedTriggeringPolicy size=&quot;500&quot; /&gt;
&lt;/RollingFile&gt;
</code></pre>
<h1 id="docker-lookup"><a class="header" href="#docker-lookup">Docker Lookup</a></h1>
<p>DockerLookup 可用于从运行应用程序的 Docker 容器中查找属性。</p>
<p>Log4j Docker provides access to the following container attributes:</p>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>containerId</td><td>The full id assigned to the container.</td></tr>
<tr><td>containerName</td><td>The name assigned to the container.</td></tr>
<tr><td>imageId</td><td>The id assigned to the image.</td></tr>
<tr><td>imageName</td><td>The name assigned to the image.</td></tr>
<tr><td>shortContainerId</td><td>The first 12 characters of the container id.</td></tr>
<tr><td>shortImageId</td><td>The first 12 characters of the image id.</td></tr>
</tbody></table>
<pre><code class="language-xml">&lt;JsonLayout properties=&quot;true&quot; compact=&quot;true&quot; eventEol=&quot;true&quot;&gt;
  &lt;KeyValuePair key=&quot;containerId&quot; value=&quot;${docker:containerId}&quot;/&gt;
  &lt;KeyValuePair key=&quot;containerName&quot; value=&quot;${docker:containerName}&quot;/&gt;
  &lt;KeyValuePair key=&quot;imageName&quot; value=&quot;${docker:imageName}&quot;/&gt;
&lt;/JsonLayout&gt;
</code></pre>
<p>This Lookup is subject to the requirements listed at <a href="https://logging.apache.org/log4j/2.x/log4j-docker/index.html">Log4j Docker Support</a></p>
<h1 id="environment-lookup"><a class="header" href="#environment-lookup">Environment Lookup</a></h1>
<p>EnvironmentLookup 允许系统在全局文件（如 /etc/profile）或应用程序的启动脚本中配置环境变量，然后从日志配置中检索这些变量。</p>
<pre><code class="language-xml">&lt;File name=&quot;Application&quot; fileName=&quot;application.log&quot;&gt;
  &lt;PatternLayout&gt;
    &lt;pattern&gt;%d %p %c{1.} [%t] $${env:USER} %m%n&lt;/pattern&gt;
  &lt;/PatternLayout&gt;
&lt;/File&gt;
</code></pre>
<p>此查找还支持默认值语法。</p>
<pre><code class="language-xml">&lt;File name=&quot;Application&quot; fileName=&quot;application.log&quot;&gt;
  &lt;PatternLayout&gt;
    &lt;pattern&gt;%d %p %c{1.} [%t] $${env:USER:-jdoe} %m%n&lt;/pattern&gt;
  &lt;/PatternLayout&gt;
&lt;/File&gt;
</code></pre>
<h1 id="eventlookup"><a class="header" href="#eventlookup">EventLookup</a></h1>
<p>EventLookup 提供对配置中  日志事件中 字段的访问。</p>
<table><thead><tr><th style="text-align: left">Key</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Exception</td><td style="text-align: left">如果事件中包含异常，则返回异常的简单类名。</td></tr>
<tr><td style="text-align: left">Level</td><td style="text-align: left">返回事件的日志记录级别。</td></tr>
<tr><td style="text-align: left">Logger</td><td style="text-align: left">返回记录器的名称。</td></tr>
<tr><td style="text-align: left">Marker</td><td style="text-align: left">返回与日志事件关联的标记的名称（如果存在）。</td></tr>
<tr><td style="text-align: left">Message</td><td style="text-align: left">返回格式化的消息字符串。</td></tr>
<tr><td style="text-align: left">ThreadId</td><td style="text-align: left">返回与日志事件关联的线程 ID。</td></tr>
<tr><td style="text-align: left">ThreadName</td><td style="text-align: left">返回与日志事件关联的线程的名称</td></tr>
<tr><td style="text-align: left">Timestamp</td><td style="text-align: left">返回事件发生的时间（以毫秒为单位）。</td></tr>
</tbody></table>
<p>在此示例中，RoutingAppender 根据日志事件中存在的名为“AUDIT”的标记的存在来选择路由。</p>
<pre><code class="language-xml">          &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
          &lt;Configuration status=&quot;WARN&quot; name=&quot;RoutingTest&quot;&gt;
            &lt;Appenders&gt;
              &lt;Console name=&quot;STDOUT&quot; target=&quot;SYSTEM_OUT&quot; /&gt;
              &lt;Flume name=&quot;AuditLogger&quot; compress=&quot;true&quot;&gt;
                &lt;Agent host=&quot;192.168.10.101&quot; port=&quot;8800&quot;/&gt;
                &lt;Agent host=&quot;192.168.10.102&quot; port=&quot;8800&quot;/&gt;
                &lt;RFC5424Layout enterpriseNumber=&quot;18060&quot; includeMDC=&quot;true&quot; appName=&quot;MyApp&quot;/&gt;
              &lt;/Flume&gt;
              &lt;Routing name=&quot;Routing&quot;&gt;
                &lt;Routes&gt;
                  &lt;Route pattern=&quot;$${event:Marker}&quot;&gt;
                    &lt;RollingFile
                        name=&quot;Rolling-${mdc:UserId}&quot;
                        fileName=&quot;${mdc:UserId}.log&quot;
                        filePattern=&quot;${mdc:UserId}.%i.log.gz&quot;&gt;
                      &lt;PatternLayout&gt;
                        &lt;pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/pattern&gt;
                      &lt;/PatternLayout&gt;
                      &lt;SizeBasedTriggeringPolicy size=&quot;500&quot; /&gt;
                    &lt;/RollingFile&gt;
                  &lt;/Route&gt;
                  &lt;Route ref=&quot;AuditLogger&quot; key=&quot;AUDIT&quot;/&gt;
                  &lt;Route ref=&quot;STDOUT&quot; key=&quot;STDOUT&quot;/&gt;
                &lt;/Routes&gt;
                &lt;IdlePurgePolicy timeToLive=&quot;15&quot; timeUnit=&quot;minutes&quot;/&gt;
              &lt;/Routing&gt;
            &lt;/Appenders&gt;
            &lt;Loggers&gt;
              &lt;Root level=&quot;error&quot;&gt;
                &lt;AppenderRef ref=&quot;Routing&quot; /&gt;
              &lt;/Root&gt;
            &lt;/Loggers&gt;
          &lt;/Configuration&gt;
</code></pre>
<h1 id="java-lookup"><a class="header" href="#java-lookup">Java Lookup</a></h1>
<p>JavaLookup 允许使用 java: 前缀在方便的预格式化字符串中检索 Java 环境信息。</p>
<table><thead><tr><th style="text-align: left">Key</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">version</td><td style="text-align: left">The short Java version, like:Java version 1.7.0_67</td></tr>
<tr><td style="text-align: left">runtime</td><td style="text-align: left">The Java runtime version, like:Java(TM) SE Runtime Environment (build 1.7.0_67-b01) from Oracle Corporation</td></tr>
<tr><td style="text-align: left">vm</td><td style="text-align: left">The Java VM version, like:Java HotSpot(TM) 64-Bit Server VM (build 24.65-b04, mixed mode)</td></tr>
<tr><td style="text-align: left">os</td><td style="text-align: left">The OS version, like:Windows 7 6.1 Service Pack 1, architecture: amd64-64</td></tr>
<tr><td style="text-align: left">locale</td><td style="text-align: left">Hardware information, like:default locale: en_US, platform encoding: Cp1252</td></tr>
<tr><td style="text-align: left">hw</td><td style="text-align: left">Hardware information, like:processors: 4, architecture: amd64-64, instruction sets: amd64</td></tr>
</tbody></table>
<pre><code class="language-java">&lt;File name=&quot;Application&quot; fileName=&quot;application.log&quot;&gt;
  &lt;PatternLayout header=&quot;${java:runtime} - ${java:vm} - ${java:os}&quot;&gt;
    &lt;Pattern&gt;%d %m%n&lt;/Pattern&gt;
  &lt;/PatternLayout&gt;
&lt;/File&gt;
</code></pre>
<h1 id="jndi-lookup"><a class="header" href="#jndi-lookup">Jndi Lookup</a></h1>
<p>JndiLookup 允许通过 JNDI 检索变量。</p>
<p>默认情况下，键将以 java:comp/env/ 为前缀，但是如果键包含“:”，则不会添加前缀。</p>
<pre><code class="language-xml">&lt;File name=&quot;Application&quot; fileName=&quot;application.log&quot;&gt;
  &lt;PatternLayout&gt;
    &lt;pattern&gt;%d %p %c{1.} [%t] $${jndi:logging/context-name} %m%n&lt;/pattern&gt;
  &lt;/PatternLayout&gt;
&lt;/File&gt;
</code></pre>
<p>Java 的 JNDI 模块在 Android 上不可用。</p>
<h1 id="log4j-configuration-location-lookup"><a class="header" href="#log4j-configuration-location-lookup">Log4j Configuration Location Lookup</a></h1>
<p>Log4j 配置属性。</p>
<p>表达式 ${log4j:configLocation} 和 ${log4j:configParentLocation} 分别提供 log4j 配置文件及其父文件夹的绝对路径。</p>
<pre><code class="language-xml">&lt;File name=&quot;Application&quot; fileName=&quot;${log4j:configParentLocation}/logs/application.log&quot;&gt;
  &lt;PatternLayout&gt;
    &lt;pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/pattern&gt;
  &lt;/PatternLayout&gt;
&lt;/File&gt;
</code></pre>
<h1 id="lower-lookup"><a class="header" href="#lower-lookup">Lower Lookup</a></h1>
<p>LowerLookup 将传入的参数转换为小写。据推测，该值将是嵌套查找的结果。</p>
<pre><code class="language-xml">&lt;File name=&quot;Application&quot; fileName=&quot;application.log&quot;&gt;
  &lt;PatternLayout&gt;
    &lt;pattern&gt;%d %p %c{1.} [%t] $${lower:{${spring:spring.application.name}} %m%n&lt;/pattern&gt;
  &lt;/PatternLayout&gt;
&lt;/File&gt;
</code></pre>
<h3 id="upper-lookup"><a class="header" href="#upper-lookup">Upper Lookup</a></h3>
<p>The UpperLookup converts the passed in argument to upper case. Presumably the value will be the result of a nested lookup.</p>
<pre><code class="language-xml">&lt;File name=&quot;Application&quot; fileName=&quot;application.log&quot;&gt;  &lt;PatternLayout&gt;    &lt;pattern&gt;%d %p %c{1.} [%t] $$upper{${spring:spring.application.name}} %m%n&lt;/pattern&gt;  &lt;/PatternLayout&gt;&lt;/File&gt;
</code></pre>
<h1 id="main-arguments-lookup-application"><a class="header" href="#main-arguments-lookup-application">Main Arguments Lookup (Application)</a></h1>
<p>此查找要求您手动向 Log4j 提供应用程序的主要参数：</p>
<pre><code class="language-xml">import org.apache.logging.log4j.core.lookup.MainMapLookup;
 
public static void main(String args[]) {
  MainMapLookup.setMainArguments(args);
  ...
}
</code></pre>
<p>如果已设置主要参数，则此查找允许应用程序从日志记录配置中检索这些主要参数值。 </p>
<p>main: 前缀后面的键可以是参数列表中从 0 开始的索引，也可以是字符串，其中 ${main:myString} 替换为 main 参数列表中 myString 后面的值。</p>
<p>注意：许多应用程序使用前导破折号来标识命令参数。</p>
<p>指定 ${main:--file} 将导致查找失败，因为它会查找名为“main”的变量，默认值为“-file”。</p>
<p>为避免这种情况，将 Lookup 名称与键分开的“:”必须后跟反斜杠作为转义字符，如 ${main:--file}</p>
<p>Then the following substitutions are possible:</p>
<pre><code>--file foo.txt --verbose -x bar
</code></pre>
<table><thead><tr><th style="text-align: left">Expression</th><th style="text-align: left">Result</th></tr></thead><tbody>
<tr><td style="text-align: left">${main:0}</td><td style="text-align: left">--file</td></tr>
<tr><td style="text-align: left">${main:1}</td><td style="text-align: left">foo.txt</td></tr>
<tr><td style="text-align: left">${main:2}</td><td style="text-align: left">--verbose</td></tr>
<tr><td style="text-align: left">${main:3}</td><td style="text-align: left">-x</td></tr>
<tr><td style="text-align: left">${main:4}</td><td style="text-align: left">bar</td></tr>
<tr><td style="text-align: left">${main:--file}</td><td style="text-align: left">foo.txt</td></tr>
<tr><td style="text-align: left">${main:-x}</td><td style="text-align: left">bar</td></tr>
<tr><td style="text-align: left">${main:bar}</td><td style="text-align: left">null</td></tr>
<tr><td style="text-align: left">${main:--quiet:-true}</td><td style="text-align: left">true</td></tr>
</tbody></table>
<pre><code class="language-xml">&lt;File name=&quot;Application&quot; fileName=&quot;application.log&quot;&gt;
  &lt;PatternLayout header=&quot;File: ${main:--file}&quot;&gt;
    &lt;Pattern&gt;%d %m%n&lt;/Pattern&gt;
  &lt;/PatternLayout&gt;
&lt;/File&gt;
</code></pre>
<h1 id="map-lookup"><a class="header" href="#map-lookup">Map Lookup</a></h1>
<p>MapLookup 有多种用途</p>
<ol>
<li>
<p>为配置文件中声明的属性 提供 存储。</p>
</li>
<li>
<p>从 LogEvents 中的 MapMessages 中检索值。</p>
</li>
<li>
<p>检索使用 MapLookup.setMainArguments(String[]) 设置的值</p>
</li>
<li>
<p>第一项仅表示 MapLookup 用于替换配置文件中定义的属性。这些变量没有前缀指定</p>
</li>
<li>
<p>第二种用法允许替换当前 MapMessage 中的值（如果一个值是当前日志事件的一部分）。</p>
<p>RoutingAppender 将为 MapMessage 中名为“type”的键的每个唯一值使用不同的 RollingFileAppender</p>
<p>当以这种方式使用时，应在属性声明中声明“type”的值，以在消息不是 MapMessage 或 MapMessage 不包含键的情况下提供默认值。</p>
<pre><code class="language-xml">&lt;Routing name=&quot;Routing&quot;&gt;
  &lt;Routes pattern=&quot;$${map:type}&quot;&gt;
    &lt;Route&gt;
      &lt;RollingFile name=&quot;Rolling-${map:type}&quot; fileName=&quot;${filename}&quot;
                   filePattern=&quot;target/rolling1/test1-${map:type}.%i.log.gz&quot;&gt;
        &lt;PatternLayout&gt;
          &lt;pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/pattern&gt;
        &lt;/PatternLayout&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;500&quot; /&gt;
      &lt;/RollingFile&gt;
    &lt;/Route&gt;
  &lt;/Routes&gt;
&lt;/Routing&gt;
</code></pre>
</li>
</ol>
<h1 id="marker-lookup"><a class="header" href="#marker-lookup">Marker Lookup</a></h1>
<p>标记查找允许您在有趣的配置中使用标记，例如路由附加程序。</p>
<p>考虑以下基于标记记录到不同文件的 YAML 配置和代码：</p>
<pre><code class="language-xml">Configuration:
  status: debug
 
  Appenders:
    Console:
    RandomAccessFile:
      - name: SQL_APPENDER
        fileName: logs/sql.log
        PatternLayout:
          Pattern: &quot;%d{ISO8601_BASIC} %-5level %logger{1} %X %msg%n&quot;
      - name: PAYLOAD_APPENDER
        fileName: logs/payload.log
        PatternLayout:
          Pattern: &quot;%d{ISO8601_BASIC} %-5level %logger{1} %X %msg%n&quot;
      - name: PERFORMANCE_APPENDER
        fileName: logs/performance.log
        PatternLayout:
          Pattern: &quot;%d{ISO8601_BASIC} %-5level %logger{1} %X %msg%n&quot;
 
    Routing:
      name: ROUTING_APPENDER
      Routes:
        pattern: &quot;$${marker:}&quot;
        Route:
        - key: PERFORMANCE
          ref: PERFORMANCE_APPENDER
        - key: PAYLOAD
          ref: PAYLOAD_APPENDER
        - key: SQL
          ref: SQL_APPENDER
 
  Loggers:
    Root:
      level: trace
      AppenderRef:
        - ref: ROUTING_APPENDER
</code></pre>
<pre><code class="language-xml">public static final Marker SQL = MarkerFactory.getMarker(&quot;SQL&quot;);
public static final Marker PAYLOAD = MarkerFactory.getMarker(&quot;PAYLOAD&quot;);
public static final Marker PERFORMANCE = MarkerFactory.getMarker(&quot;PERFORMANCE&quot;);
 
final Logger logger = LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
 
logger.info(SQL, &quot;Message in Sql.log&quot;);
logger.info(PAYLOAD, &quot;Message in Payload.log&quot;);
logger.info(PERFORMANCE, &quot;Message in Performance.log&quot;);
</code></pre>
<p>注意配置的关键部分是模式：“$${marker:}”。</p>
<p>这将产生三个日志文件，每个文件都有一个特定标记的日志事件。 </p>
<p>Log4j 会将带有 SQL 标记的日志事件路由到 sql.log，将带有 PAYLOAD 标记的日志事件路由到 payload.log，依此类推。</p>
<p>您可以使用符号“${marker:name}”和“$${marker:name}”来检查是否存在名称为标记名称的标记。</p>
<p>如果标记存在，则表达式返回名称，否则返回 null。</p>
<h1 id="spring-boot-lookup"><a class="header" href="#spring-boot-lookup">Spring Boot Lookup</a></h1>
<p>Spring Boot Lookup 从 Spring 配置中检索 Spring 属性的值以及活动和默认配置文件的值。</p>
<p>指定“profiles.active”键将返回活动配置文件，而“profiles.default”键将返回默认配置文件。</p>
<p>默认和活动配置文件可以是一个数组。</p>
<p>如果存在多个配置文件，它们将作为逗号分隔列表返回。</p>
<p>要从数组中检索单个项目，请将“[{index}]”附加到键。</p>
<p>例如，要返回列表中的第一个活动配置文件，请指定“profiles.active[0]”。</p>
<pre><code class="language-xml">&lt;File name=&quot;Application&quot; fileName=&quot;application-${spring:profiles.active[0]}.log&quot;&gt;
  &lt;PatternLayout&gt;
    &lt;pattern&gt;%d %p %c{1.} [%t] $${spring:spring.application.name} %m%n&lt;/pattern&gt;
  &lt;/PatternLayout&gt;
&lt;/File&gt;
</code></pre>
<h1 id="structured-data-lookup"><a class="header" href="#structured-data-lookup">Structured Data Lookup</a></h1>
<p>StructuredDataLookup 与 MapLookup 非常相似，因为它将从 StructuredDataMessages 中检索值。</p>
<p>除了 Map 值，它还将返回 id 的名称部分（不包括企业编号）和类型字段。</p>
<p>下面的示例与 MapMessage 示例之间的主要区别在于，“type”是 StructuredDataMessage 的一个属性，而“type”必须是 MapMessage 中 Map 中的一个 item。</p>
<pre><code class="language-xml">&lt;Routing name=&quot;Routing&quot;&gt;
  &lt;Routes pattern=&quot;$${sd:type}&quot;&gt;
    &lt;Route&gt;
      &lt;RollingFile name=&quot;Rolling-${sd:type}&quot; fileName=&quot;${filename}&quot;
                   filePattern=&quot;target/rolling1/test1-${sd:type}.%i.log.gz&quot;&gt;
        &lt;PatternLayout&gt;
          &lt;pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/pattern&gt;
        &lt;/PatternLayout&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;500&quot; /&gt;
      &lt;/RollingFile&gt;
    &lt;/Route&gt;
  &lt;/Routes&gt;
&lt;/Routing&gt;
</code></pre>
<h1 id="system-properties-lookup"><a class="header" href="#system-properties-lookup">System Properties Lookup</a></h1>
<p>由于使用系统属性在应用程序内部和外部定义值是很常见的，因此可以通过查找访问它们是很自然的。</p>
<p>由于系统属性通常是在应用程序之外定义的，因此通常会看到以下内容：</p>
<pre><code class="language-xml">&lt;Appenders&gt;
  &lt;File name=&quot;ApplicationLog&quot; fileName=&quot;${sys:logPath}/app.log&quot;/&gt;
&lt;/Appenders&gt;
</code></pre>
<p>此查找还支持默认值语法。</p>
<p>在下面的示例中，当 logPath 系统属性未定义时，将使用默认值 /var/logs：</p>
<pre><code class="language-xml">&lt;Appenders&gt;
  &lt;File name=&quot;ApplicationLog&quot; fileName=&quot;${sys:logPath:-/var/logs}/app.log&quot;/&gt;
&lt;/Appenders&gt;
</code></pre>
<h1 id="web-lookup"><a class="header" href="#web-lookup">Web Lookup</a></h1>
<p>WebLookup 允许应用程序检索与 ServletContext 关联的变量。</p>
<p>除了能够检索 ServletContext 中的各种字段外，WebLookup 还支持查找存储为属性或配置为初始化参数的值。</p>
<p>下表列出了可以检索的各种键：</p>
<table><thead><tr><th style="text-align: left">Key</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">attr.<em>name</em></td><td style="text-align: left">Returns the ServletContext attribute with the specified name</td></tr>
<tr><td style="text-align: left">contextPath</td><td style="text-align: left">The context path of the web application</td></tr>
<tr><td style="text-align: left">contextPathName</td><td style="text-align: left">The first token in the context path of the web application splitting on &quot;/&quot; characters.</td></tr>
<tr><td style="text-align: left">effectiveMajorVersion</td><td style="text-align: left">Gets the major version of the Servlet specification that the application represented by this ServletContext is based on.</td></tr>
<tr><td style="text-align: left">effectiveMinorVersion</td><td style="text-align: left">Gets the minor version of the Servlet specification that the application represented by this ServletContext is based on.</td></tr>
<tr><td style="text-align: left">initParam.<em>name</em></td><td style="text-align: left">Returns the ServletContext initialization parameter with the specified name</td></tr>
<tr><td style="text-align: left">majorVersion</td><td style="text-align: left">Returns the major version of the Servlet API that this servlet container supports.</td></tr>
<tr><td style="text-align: left">minorVersion</td><td style="text-align: left">Returns the minor version of the Servlet API that this servlet container supports.</td></tr>
<tr><td style="text-align: left">rootDir</td><td style="text-align: left">Returns the result of calling getRealPath with a value of &quot;/&quot;.</td></tr>
<tr><td style="text-align: left">serverInfo</td><td style="text-align: left">Returns the name and version of the servlet container on which the servlet is running.</td></tr>
<tr><td style="text-align: left">servletContextName</td><td style="text-align: left">Returns the name of the web application as defined in the display-name element of the deployment descriptor</td></tr>
</tbody></table>
<p>将首先检查指定的任何其他键名以查看是否存在具有该名称的 ServletContext 属性，然后将检查以查看是否存在该名称的初始化参数。</p>
<p>如果找到了键，则将返回相应的值。</p>
<pre><code class="language-xml">&lt;Appenders&gt;
  &lt;File name=&quot;ApplicationLog&quot; fileName=&quot;${web:rootDir}/app.log&quot;/&gt;
&lt;/Appenders&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maven-ivy-gradle-and-sbt-artifacts"><a class="header" href="#maven-ivy-gradle-and-sbt-artifacts">Maven, Ivy, Gradle, and SBT Artifacts</a></h1>
<p>Log4j 2 分为 API 和实现（核心），其中 API 提供应用程序应编码到的接口。严格来说，Log4j 核心仅在运行时需要，而在编译时不需要。</p>
<p>但是，下面我们将 Log4j 核心列为编译时依赖项，以改善自定义插件的启动时间，因为它提供了一个注释处理器，可生成元数据文件来缓存插件信息以及编译所需的代码以创建自定义插件。</p>
<h1 id="using-log4j-in-your-apache-maven-build"><a class="header" href="#using-log4j-in-your-apache-maven-build">Using Log4j in your Apache Maven build</a></h1>
<pre><code class="language-xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
    &lt;version&gt;2.14.1&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
    &lt;version&gt;2.14.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h1 id="using-log4j-in-your-apache-ivy-build"><a class="header" href="#using-log4j-in-your-apache-ivy-build">Using Log4j in your Apache Ivy build</a></h1>
<p>To build with <a href="https://ant.apache.org/ivy/">Apache Ivy</a>, add the dependencies listed below to your ivy.xml file.</p>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-api&quot; rev=&quot;2.14.1&quot; /&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-core&quot; rev=&quot;2.14.1&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<h1 id="using-log4j-in-your-gradle-build"><a class="header" href="#using-log4j-in-your-gradle-build">Using Log4j in your Gradle build</a></h1>
<p>To build with <a href="https://gradle.org/">Gradle</a>, add the dependencies listed below to your build.gradle file.</p>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-api', version: '2.14.1'
  compile group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.14.1'
}
</code></pre>
<h1 id="using-log4j-in-your-sbt-build"><a class="header" href="#using-log4j-in-your-sbt-build">Using Log4j in your SBT build</a></h1>
<p>To build with <a href="http://www.scala-sbt.org/">SBT</a>, add the dependencies listed below to your build.sbt file.</p>
<p>build.sbt</p>
<pre><code>libraryDependencies += &quot;org.apache.logging.log4j&quot; % &quot;log4j-api&quot; % &quot;2.14.1&quot;
libraryDependencies += &quot;org.apache.logging.log4j&quot; % &quot;log4j-core&quot; % &quot;2.14.1&quot;
</code></pre>
<h1 id="bill-of-material"><a class="header" href="#bill-of-material">Bill of Material</a></h1>
<p>To keep your Log4j module versions in sync with each other, a BOM pom.xml file is provided for your convenience. To use this with <a href="https://maven.apache.org/">Maven</a>, add the dependency listed below to your pom.xml file. When you specify the version identifier in this section, you don’t have to specify the version in your <dependencies/> section.</p>
<p>pom.xml</p>
<pre><code>&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j-bom&lt;/artifactId&gt;
      &lt;version&gt;2.14.1&lt;/version&gt;
      &lt;scope&gt;import&lt;/scope&gt;
      &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<p>To use this with Gradle, an additional <a href="https://github.com/spring-gradle-plugins/dependency-management-plugin">Gradle plugin</a> is required for dependency management functionality.</p>
<p>build.gradle</p>
<pre><code>plugins {
  id 'io.spring.dependency-management' version '1.0.1.RELEASE'
}

dependencyManagement {
  imports {
    mavenBom 'org.apache.logging.log4j:log4j-bom:2.14.1'
  }
}

dependencies {
  compile 'org.apache.logging.log4j:log4j-api'
  compile 'org.apache.logging.log4j:log4j-core'
  // etc.
}
</code></pre>
<h1 id="optional-components"><a class="header" href="#optional-components">Optional Components</a></h1>
<p>可选组件</p>
<h2 id="log4j-1x-api-bridge"><a class="header" href="#log4j-1x-api-bridge">Log4j 1.x API Bridge</a></h2>
<p>If existing components use Log4j 1.x and you want to have this logging routed to Log4j 2, then remove any log4j 1.x dependencies and add the following.</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-1.2-api&lt;/artifactId&gt;
    &lt;version&gt;2.14.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-1.2-api&quot; rev=&quot;2.14.1&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-1.2-api', version: '2.14.1'
}
</code></pre>
<p>build.sbt</p>
<pre><code>libraryDependencies += &quot;org.apache.logging.log4j&quot; % &quot;log4j-1.2-api&quot; % &quot;2.14.1&quot;
</code></pre>
<h2 id="apache-commons-logging-bridge"><a class="header" href="#apache-commons-logging-bridge">Apache Commons Logging Bridge</a></h2>
<p>If existing components use Apache Commons Logging 1.x and you want to have this logging routed to Log4j 2, then add the following but do not remove any Commons Logging 1.x dependencies.</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-jcl&lt;/artifactId&gt;
    &lt;version&gt;2.14.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-jcl&quot; rev=&quot;2.14.1&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-jcl', version: '2.14.1'
}
</code></pre>
<p>build.sbt</p>
<pre><code>libraryDependencies += &quot;org.apache.logging.log4j&quot; % &quot;log4j-jcl&quot; % &quot;2.14.1&quot;
</code></pre>
<h2 id="slf4j-bridge"><a class="header" href="#slf4j-bridge">SLF4J Bridge</a></h2>
<p>If existing components use SLF4J and you want to have this logging routed to Log4j 2, then add the following but do not remove any SLF4J dependencies.</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;
    &lt;version&gt;2.14.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-slf4j-impl&quot; rev=&quot;2.14.1&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-slf4j-impl', version: '2.14.1'
}
</code></pre>
<p>build.sbt</p>
<pre><code>libraryDependencies += &quot;org.apache.logging.log4j&quot; % &quot;log4j-slf4j-impl&quot; % &quot;2.14.1&quot;
</code></pre>
<h2 id="jul-adapter"><a class="header" href="#jul-adapter">JUL Adapter</a></h2>
<p>If existing components use Java Util Logging and you want to have this logging routed to Log4j 2, then add the following.</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-jul&lt;/artifactId&gt;
    &lt;version&gt;2.14.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-jul&quot; rev=&quot;2.14.1&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-jul', version: '2.14.1'
}
</code></pre>
<p>build.sbt</p>
<pre><code>libraryDependencies += &quot;org.apache.logging.log4j&quot; % &quot;log4j-jul&quot; % &quot;2.14.1&quot;
</code></pre>
<h2 id="web-servlet-support"><a class="header" href="#web-servlet-support">Web Servlet Support</a></h2>
<p>为了正确支持和处理 Web 应用程序的 ClassLoader 环境和容器生命周期，需要一个额外的模块。</p>
<p>该模块仅在运行时需要。</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-web&lt;/artifactId&gt;
    &lt;version&gt;2.14.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-web&quot; rev=&quot;2.14.1&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-web', version: '2.14.1'
}
</code></pre>
<p>build.sbt</p>
<pre><code>libraryDependencies += &quot;org.apache.logging.log4j&quot; % &quot;log4j-web&quot; % &quot;2.14.1&quot;
</code></pre>
<h2 id="tag-library"><a class="header" href="#tag-library">Tag Library</a></h2>
<p>Log4j 日志标记库创建了在不使用 Java 脚本的情况下在 JSP 中插入日志语句的功能。</p>
<p>它使用标准的 Log4j 2 API 根据您的 Log4j 配置记录消息。</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-taglib&lt;/artifactId&gt;
    &lt;version&gt;2.14.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-taglib&quot; rev=&quot;2.14.1&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-taglib', version: '2.14.1'
}
</code></pre>
<p>build.sbt</p>
<pre><code>libraryDependencies += &quot;org.apache.logging.log4j&quot; % &quot;log4j-taglib&quot; % &quot;2.14.1&quot;
</code></pre>
<h2 id="apache-flume-appender"><a class="header" href="#apache-flume-appender">Apache Flume Appender</a></h2>
<p>The Flume Appender allows applications to send events to Flume Agents.</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-flume-ng&lt;/artifactId&gt;
    &lt;version&gt;2.14.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-flume-ng&quot; rev=&quot;2.14.1&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-flume-ng', version: '2.14.1'
}
</code></pre>
<p>build.sbt</p>
<pre><code>libraryDependencies += &quot;org.apache.logging.log4j&quot; % &quot;log4j-flume-ng&quot; % &quot;2.14.1&quot;
</code></pre>
<h2 id="log4j-to-slf4j-adapter"><a class="header" href="#log4j-to-slf4j-adapter">Log4j to SLF4J Adapter</a></h2>
<p>Log4j 2 到 SLF4J 适配器允许将编码到 Log4j 2 API 的应用程序路由到 SLF4J。</p>
<p>使用此适配器可能会导致一些性能损失，因为必须先格式化 Log4j 2 消息才能将它们传递给 SLF4J。</p>
<p>使用时，SLF4J Bridge 不能在类路径上。</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt;
    &lt;version&gt;2.14.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-to-slf4j&quot; rev=&quot;2.14.1&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-to-slf4j', version: '2.14.1'
}
</code></pre>
<p>build.sbt</p>
<pre><code>libraryDependencies += &quot;org.apache.logging.log4j&quot; % &quot;log4j-to-slf4j&quot; % &quot;2.14.1&quot;
</code></pre>
<h3 id="couchdb"><a class="header" href="#couchdb">CouchDB</a></h3>
<p>If your configuration uses the NoSQL CouchDB appender, then add the following.</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-couchdb&lt;/artifactId&gt;
    &lt;version&gt;2.14.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-couchdb&quot; rev=&quot;2.14.1&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-couchdb', version: '2.14.1'
}
</code></pre>
<p>build.sbt</p>
<pre><code>libraryDependencies += &quot;org.apache.logging.log4j&quot; % &quot;log4j-couchdb&quot; % &quot;2.14.1&quot;
</code></pre>
<h3 id="mongodb"><a class="header" href="#mongodb">MongoDB</a></h3>
<p>If your configuration uses the NoSQL MongoDB appender, then add the following.</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-mongodb&lt;/artifactId&gt;
    &lt;version&gt;2.14.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-mongodb&quot; rev=&quot;2.14.1&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-mongodb', version: '2.14.1'
}
</code></pre>
<p>build.sbt</p>
<pre><code>libraryDependencies += &quot;org.apache.logging.log4j&quot; % &quot;log4j-mongodb&quot; % &quot;2.14.1&quot;
</code></pre>
<h3 id="cassandra"><a class="header" href="#cassandra">Cassandra</a></h3>
<p>If your configuration uses the Cassandra appender, then add the following.</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-cassandra&lt;/artifactId&gt;
    &lt;version&gt;2.14.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-cassandra&quot; rev=&quot;2.14.1&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-cassandra', version: '2.14.1'
}
</code></pre>
<p>build.sbt</p>
<pre><code>libraryDependencies += &quot;org.apache.logging.log4j&quot; % &quot;log4j-cassandra&quot; % &quot;2.14.1&quot;
</code></pre>
<h3 id="io-streams"><a class="header" href="#io-streams">IO Streams</a></h3>
<p>Log4j IO Streams allow applications to have data that is written to an OutputStream or a Writer be redirected to a Logger, or have data that is read from an InputStream or a Reader be wiretapped by a Logger. To use IO Streams, add the following.</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-iostreams&lt;/artifactId&gt;
    &lt;version&gt;2.14.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-iostreams&quot; rev=&quot;2.14.1&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-iostreams', version: '2.14.1'
}
</code></pre>
<p>build.sbt</p>
<pre><code>libraryDependencies += &quot;org.apache.logging.log4j&quot; % &quot;log4j-iostreams&quot; % &quot;2.14.1&quot;
</code></pre>
<h3 id="scala-api"><a class="header" href="#scala-api">Scala API</a></h3>
<p>A convenient Scala wrapper for the Logger API. SBT users can add the following to their build.sbt:</p>
<p>build.sbt</p>
<pre><code>libraryDependencies += &quot;org.apache.logging.log4j&quot; %% &quot;log4j-api-scala&quot; % &quot;11.0&quot;
</code></pre>
<p>Maven, Ivy, and Gradle users need to add the Scala version to the artifact name.</p>
<p>Scala 2.12 users can use the following:</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-api-scala_2.12&lt;/artifactId&gt;
    &lt;version&gt;11.0&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-api-scala_2.12&quot; rev=&quot;11.0&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-api-scala_2.12', version: '11.0'
}
</code></pre>
<p>Scala 2.11 users can use the following:</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-api-scala_2.11&lt;/artifactId&gt;
    &lt;version&gt;11.0&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-api-scala_2.11&quot; rev=&quot;11.0&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-api-scala_2.11', version: '11.0'
}
</code></pre>
<p>Scala 2.10 users can use the following:</p>
<p>pom.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j-api-scala_2.10&lt;/artifactId&gt;
    &lt;version&gt;11.0&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>ivy.xml</p>
<pre><code>&lt;dependencies&gt;
  &lt;dependency org=&quot;org.apache.logging.log4j&quot; name=&quot;log4j-api-scala_2.10&quot; rev=&quot;11.0&quot; /&gt;
&lt;/dependencies&gt;
</code></pre>
<p>build.gradle</p>
<pre><code>dependencies {
  compile group: 'org.apache.logging.log4j', name: 'log4j-api-scala_2.10', version: '11.0'
}
</code></pre>
<h2 id="snapshot-builds"><a class="header" href="#snapshot-builds">Snapshot builds</a></h2>
<p>您可以使用 Maven 存储库 https://repository.apache.org/snapshots 和当前的 SNAPSHOT 版本访问最新的开发快照。</p>
<p>通常，无论 Log4j 的下一个实际版本是什么，master 分支都会使用下一个补丁版本作为其快照版本。</p>
<p>例如，如果最新版本是 2.0，那么 master 将使用 2.0.1-SNAPSHOT 版本。</p>
<p>始终按照源存储库页面中的说明在 master 分支中使用 pom.xml 进行验证。</p>
<h3 id="maven-1"><a class="header" href="#maven-1">Maven</a></h3>
<p>Maven users can add the following to their pom.xml to enable snapshots:</p>
<pre><code>&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;apache.snapshots&lt;/id&gt;
    &lt;name&gt;Apache Snapshot Repository&lt;/name&gt;
    &lt;url&gt;https://repository.apache.org/snapshots&lt;/url&gt;
    &lt;releases&gt;
      &lt;enabled&gt;false&lt;/enabled&gt;
    &lt;/releases&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<h3 id="gradle"><a class="header" href="#gradle">Gradle</a></h3>
<p>Gradle users can add the following to their build.gradle to enable snapshots:</p>
<pre><code>repositories {
  mavenCentral()
  maven { url 'https://repository.apache.org/snapshots' }
}
</code></pre>
<h3 id="sbt"><a class="header" href="#sbt">SBT</a></h3>
<p>SBT users can add the following to their build.sbt to enable snapshots:</p>
<pre><code>resolvers += &quot;Apache Snapshot Repository&quot; at &quot;https://repository.apache.org/snapshots&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appenders-1"><a class="header" href="#appenders-1">Appenders</a></h1>
<ol>
<li>
<p>Appenders 负责将 LogEvents 传送到目的地。</p>
</li>
<li>
<p>每个 Appender 都必须实现 Appender 接口。</p>
</li>
<li>
<p>大多数 Appender 将扩展 AbstractAppender，它添加 Lifecycle 和可过滤支持。</p>
</li>
<li>
<p>Lifecycle 允许组件在配置完成后完成初始化并在关闭期间执行清理。 </p>
</li>
<li>
<p>Filterable 允许组件附加过滤器，这些过滤器在事件处理期间进行过滤 。</p>
</li>
</ol>
<p>Appender 通常只负责将事件数据写入目标目的地。</p>
<p>在大多数情况下，他们将事件格式化的责任委托给布局。</p>
<p>一些 appender 包装其他 appender，以便它们可以 <strong>修改 LogEvent</strong>，<strong>处理 Appender 中的故障</strong>，</p>
<p>根据高级过滤器标准将事件 路由 到下级 Appender，或提供类似功能但  不直接格式化事件</p>
<p>Appenders 总是有一个名称，以便它们可以从 Loggers 中引用。</p>
<p>在下表中，“类型”列对应于预期的 Java 类型。</p>
<p>对于非 JDK 类，除非另有说明，否则这些类通常应位于 Log4j Core 中。</p>
<h1 id="预定义的appenders"><a class="header" href="#预定义的appenders">预定义的Appenders</a></h1>
<h2 id="asyncappender"><a class="header" href="#asyncappender">AsyncAppender</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncappender-1"><a class="header" href="#asyncappender-1">AsyncAppender</a></h1>
<ol>
<li>
<p>AsyncAppender 接受对其他 Appender 的引用，并在单独的线程上将 LogEvents 写入它们。</p>
</li>
<li>
<p>请注意，写入这些 Appender 时的异常将对应用程序隐藏。 </p>
</li>
<li>
<p>AsyncAppender 应该在它引用的 appender 之后配置，以允许它正确关闭。</p>
</li>
</ol>
<p>默认情况下，AsyncAppender 使用不需要任何外部库的 java.util.concurrent.ArrayBlockingQueue。</p>
<p>请注意，多线程应用程序在使用这个 appender 时应该小心</p>
<p>阻塞队列容易受到锁争用的影响，我们的测试表明，当更多线程同时记录时，性能可能会变得更糟。</p>
<p>考虑使用 <a href="https://logging.apache.org/log4j/2.x/manual/async.html">无锁异步记录器</a> 以获得最佳性能。</p>
<p>AsyncAppender Parameters</p>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th><th>默认值</th></tr></thead><tbody>
<tr><td style="text-align: left">AppenderRef</td><td style="text-align: left">String</td><td style="text-align: left">要异步调用的 Appender 的名称。<br/>可以配置多个 AppenderRef 元素</td><td></td></tr>
<tr><td style="text-align: left">blocking</td><td style="text-align: left">boolean</td><td style="text-align: left">如果为 true，appender 将等到队列中有空闲插槽。<br />如果为 false，则如果队列已满，则事件将写入错误附加程序。</td><td>true</td></tr>
<tr><td style="text-align: left">shutdownTimeout</td><td style="text-align: left">integer</td><td style="text-align: left">在关闭时   Appender 应该等待多少毫秒 才能刷新队列中的未完成日志事件</td><td>默认值为零，这意味着永远等待</td></tr>
<tr><td style="text-align: left">bufferSize</td><td style="text-align: left">integer</td><td style="text-align: left">指定可以排队的最大事件数。. 请注意，当使用 a disruptor-style BlockingQueue, 此缓冲区大小必须是 2 的幂. 当记录日志过快导致底层异步记录器队列满了时 其行为决定于 <a href="https://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/async/AsyncQueueFullPolicy.html">AsyncQueueFullPolicy</a>.</td><td>1024</td></tr>
<tr><td style="text-align: left">errorRef</td><td style="text-align: left">String</td><td style="text-align: left">如果由于 appender 中的错误或队列已满而无法调用任何appender，则该值为要调用的appender的名称。. 如果未指定，则将忽略错误。</td><td></td></tr>
<tr><td style="text-align: left">filter</td><td style="text-align: left">Filter</td><td style="text-align: left">一个过滤器，用于确定事件是否应该由这个 Appender 处理。使用 CompositeFilter 可以使用多个过滤器。</td><td></td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">String</td><td style="text-align: left">Appender 的名称。</td><td></td></tr>
<tr><td style="text-align: left">ignoreExceptions</td><td style="text-align: left">boolean</td><td style="text-align: left">设置为true,导致在附加事件时遇到异常被内部记录然后被忽略  当设置为 false 时，异常将传播给调用者。将此 Appender 包装在 <a href="https://logging.apache.org/log4j/2.x/manual/appenders.html#FailoverAppender">FailoverAppender</a> 中时，您必须将此设置为 false。</td><td>true</td></tr>
<tr><td style="text-align: left">includeLocation</td><td style="text-align: left">boolean</td><td style="text-align: left">提取位置是一项昂贵的操作（它可以使日志记录速度慢 5 - 20 倍）。. 为了提高性能，将日志事件添加到队列时，默认情况下不包括位置. 您可以通过设置 includeLocation=&quot;true&quot; 来更改此设置。</td><td>false</td></tr>
<tr><td style="text-align: left">BlockingQueueFactory</td><td style="text-align: left">BlockingQueueFactory</td><td style="text-align: left">This element overrides what type of BlockingQueue to use. See <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#BlockingQueueFactory">below documentation</a> for more details.</td><td></td></tr>
</tbody></table>
<p>还有一些系统属性可用于维持应用程序吞吐量，即使底层 appender 无法跟上日志记录速率并且队列正在填满。</p>
<p>请参阅系统属性 <a href="http://logging.apache.org/log4j/2.x/manual/configuration.html#log4j2.AsyncQueueFullPolicy">log4j2.AsyncQueueFullPolicy 和 log4j2.DiscardThreshold</a> 的详细信息。</p>
<h1 id="example-2"><a class="header" href="#example-2">Example</a></h1>
<h2 id="标准写法"><a class="header" href="#标准写法">标准写法</a></h2>
<p>A typical AsyncAppender configuration might look like:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Appenders&gt;
    &lt;File name=&quot;MyFile&quot; fileName=&quot;logs/app.log&quot;&gt;
      &lt;PatternLayout&gt;
        &lt;Pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/Pattern&gt;
      &lt;/PatternLayout&gt;
    &lt;/File&gt;
    &lt;Async name=&quot;Async&quot;&gt;
      &lt;AppenderRef ref=&quot;MyFile&quot;/&gt;
    &lt;/Async&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;Async&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<h2 id="覆盖默认队列"><a class="header" href="#覆盖默认队列">覆盖默认队列</a></h2>
<pre><code class="language-xml">&lt;Configuration name=&quot;LinkedTransferQueueExample&quot;&gt;
  &lt;Appenders&gt;
    &lt;List name=&quot;List&quot;/&gt;
    &lt;Async name=&quot;Async&quot; bufferSize=&quot;262144&quot;&gt;
      &lt;AppenderRef ref=&quot;List&quot;/&gt;
      &lt;LinkedTransferQueue/&gt;
    &lt;/Async&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root&gt;
      &lt;AppenderRef ref=&quot;Async&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<h1 id="默认队列实现内置实现"><a class="header" href="#默认队列实现内置实现"><strong>默认队列实现内置实现</strong></a></h1>
<table><thead><tr><th style="text-align: left">Plugin Name</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">ArrayBlockingQueue</td><td style="text-align: left">默认实现</td></tr>
<tr><td style="text-align: left">DisruptorBlockingQueue</td><td style="text-align: left">This uses the <a href="https://github.com/conversant/disruptor">Conversant Disruptor</a> implementation of BlockingQueue. 这个插件有一个可选的属性，spinPolicy</td></tr>
<tr><td style="text-align: left">JCToolsBlockingQueue</td><td style="text-align: left">This uses <a href="https://jctools.github.io/JCTools/">JCTools</a>, specifically the MPSC bounded lock-free queue.</td></tr>
<tr><td style="text-align: left">LinkedTransferQueue</td><td style="text-align: left">这使用了 Java 7 中的新实现 LinkedTransferQueue。<br/><br/>请注意，此队列不使用 AsyncAppender 的 bufferSize 配置属性，因为 LinkedTransferQueue 不支持最大容量。</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-7"><a class="header" href="#前言-7">前言</a></h1>
<p>CassandraAppender 将其输出写入 <a href="https://cassandra.apache.org/">Apache Cassandra</a> 数据库。</p>
<p>A keyspace and table must be configured ahead of time, and the columns of that table are mapped in a configuration file</p>
<p>Each column can specify either a <a href="http://logging.apache.org/log4j/2.x/manual/layouts.html">StringLayout</a> (e.g., a <a href="http://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout">PatternLayout</a>) along with an optional conversion type, or only a conversion type for org.apache.logging.log4j.spi.ThreadContextMap or org.apache.logging.log4j.spi.ThreadContextStack to store the <a href="http://logging.apache.org/log4j/2.x/manual/thread-context.html">MDC or NDC</a> in a map or list column respectively</p>
<p>与 java.util.Date 兼容的转换类型将使用转换为该类型的日志事件时间戳（例如，在 Cassandra 中使用 java.util.Date 填充时间戳列类型）。</p>
<h1 id="cassandraappender-parameters"><a class="header" href="#cassandraappender-parameters">CassandraAppender Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">batched</td><td style="text-align: left">boolean</td><td style="text-align: left">Whether or not to use batch statements to write log messages to Cassandra. By default, this is false.</td></tr>
<tr><td style="text-align: left">batchType</td><td style="text-align: left"><a href="http://docs.datastax.com/en/drivers/java/3.0/com/datastax/driver/core/BatchStatement.Type.html">BatchStatement.Type</a></td><td style="text-align: left">The batch type to use when using batched writes. By default, this is LOGGED.</td></tr>
<tr><td style="text-align: left">bufferSize</td><td style="text-align: left">int</td><td style="text-align: left">The number of log messages to buffer or batch before writing. By default, no buffering is done.</td></tr>
<tr><td style="text-align: left">clusterName</td><td style="text-align: left">String</td><td style="text-align: left">The name of the Cassandra cluster to connect to.</td></tr>
<tr><td style="text-align: left">columns</td><td style="text-align: left">ColumnMapping[]</td><td style="text-align: left">A list of column mapping configurations. Each column must specify a column name. Each column can have a conversion type specified by its fully qualified class name. By default, the conversion type is String. If the configured type is assignment-compatible with <a href="http://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/util/ReadOnlyStringMap.html">ReadOnlyStringMap</a> / <a href="http://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/spi/ThreadContextMap.html">ThreadContextMap</a> or <a href="http://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/spi/ThreadContextStack.html">ThreadContextStack</a>, then that column will be populated with the MDC or NDC respectively. If the configured type is assignment-compatible with java.util.Date, then the log timestamp will be converted to that configured date type. If a literal attribute is given, then its value will be used as is in the INSERT query without any escaping. Otherwise, the layout or pattern specified will be converted into the configured type and stored in that column.</td></tr>
<tr><td style="text-align: left">contactPoints</td><td style="text-align: left">SocketAddress[]</td><td style="text-align: left">A list of hosts and ports of Cassandra nodes to connect to. These must be valid hostnames or IP addresses. By default, if a port is not specified for a host or it is set to 0, then the default Cassandra port of 9042 will be used. By default, localhost:9042 will be used.</td></tr>
<tr><td style="text-align: left">filter</td><td style="text-align: left">Filter</td><td style="text-align: left">A Filter to determine if the event should be handled by this Appender. More than one Filter may be used by using a CompositeFilter.</td></tr>
<tr><td style="text-align: left">ignoreExceptions</td><td style="text-align: left">boolean</td><td style="text-align: left">The default is true, causing exceptions encountered while appending events to be internally logged and then ignored. When set to false exceptions will be propagated to the caller, instead. You must set this to false when wrapping this Appender in a <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#FailoverAppender">FailoverAppender</a>.</td></tr>
<tr><td style="text-align: left">keyspace</td><td style="text-align: left">String</td><td style="text-align: left">The name of the keyspace containing the table that log messages will be written to.</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">String</td><td style="text-align: left">The name of the Appender.</td></tr>
<tr><td style="text-align: left">password</td><td style="text-align: left">String</td><td style="text-align: left">The password to use (along with the username) to connect to Cassandra.</td></tr>
<tr><td style="text-align: left">table</td><td style="text-align: left">String</td><td style="text-align: left">The name of the table to write log messages to.</td></tr>
<tr><td style="text-align: left">useClockForTimestampGenerator</td><td style="text-align: left">boolean</td><td style="text-align: left">Whether or not to use the configured org.apache.logging.log4j.core.util.Clock as a <a href="http://docs.datastax.com/en/drivers/java/3.0/com/datastax/driver/core/TimestampGenerator.html">TimestampGenerator</a>. By default, this is false.</td></tr>
<tr><td style="text-align: left">username</td><td style="text-align: left">String</td><td style="text-align: left">The username to use to connect to Cassandra. By default, no username or password is used.</td></tr>
<tr><td style="text-align: left">useTls</td><td style="text-align: left">boolean</td><td style="text-align: left">Whether or not to use TLS/SSL to connect to Cassandra. This is false by default.</td></tr>
</tbody></table>
<h1 id="exampleconfiguration"><a class="header" href="#exampleconfiguration">ExampleConfiguration</a></h1>
<pre><code class="language-xml">&lt;Configuration name=&quot;CassandraAppenderTest&quot;&gt;
  &lt;Appenders&gt;
    &lt;Cassandra name=&quot;Cassandra&quot; clusterName=&quot;Test Cluster&quot; keyspace=&quot;test&quot; table=&quot;logs&quot; bufferSize=&quot;10&quot; batched=&quot;true&quot;&gt;
      &lt;SocketAddress host=&quot;localhost&quot; port=&quot;9042&quot;/&gt;
      &lt;ColumnMapping name=&quot;id&quot; pattern=&quot;%uuid{TIME}&quot; type=&quot;java.util.UUID&quot;/&gt;
      &lt;ColumnMapping name=&quot;timeid&quot; literal=&quot;now()&quot;/&gt;
      &lt;ColumnMapping name=&quot;message&quot; pattern=&quot;%message&quot;/&gt;
      &lt;ColumnMapping name=&quot;level&quot; pattern=&quot;%level&quot;/&gt;
      &lt;ColumnMapping name=&quot;marker&quot; pattern=&quot;%marker&quot;/&gt;
      &lt;ColumnMapping name=&quot;logger&quot; pattern=&quot;%logger&quot;/&gt;
      &lt;ColumnMapping name=&quot;timestamp&quot; type=&quot;java.util.Date&quot;/&gt;
      &lt;ColumnMapping name=&quot;mdc&quot; type=&quot;org.apache.logging.log4j.spi.ThreadContextMap&quot;/&gt;
      &lt;ColumnMapping name=&quot;ndc&quot; type=&quot;org.apache.logging.log4j.spi.ThreadContextStack&quot;/&gt;
    &lt;/Cassandra&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Logger name=&quot;org.apache.logging.log4j.cassandra&quot; level=&quot;DEBUG&quot;&gt;
      &lt;AppenderRef ref=&quot;Cassandra&quot;/&gt;
    &lt;/Logger&gt;
    &lt;Root level=&quot;ERROR&quot;/&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<p>This example configuration uses the following table schema:</p>
<pre><code class="language-sql">CREATE TABLE logs (
    id timeuuid PRIMARY KEY,
    timeid timeuuid,
    message text,
    level text,
    marker text,
    logger text,
    timestamp timestamp,
    mdc map&lt;text,text&gt;,
    ndc list&lt;text&gt;
);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="consoleappender"><a class="header" href="#consoleappender">ConsoleAppender</a></h1>
<p>正如人们所料，ConsoleAppender 将其输出写入 System.out 或 System.err，其中 System.out 是默认目标。</p>
<p><strong>必须提供布局来格式化 LogEvent。</strong></p>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">filter</td><td style="text-align: left">Filter</td><td style="text-align: left">个过滤器，用于确定事件是否应该由这个 Appender 处理。<br/>使用 CompositeFilter 可以使用多个过滤器。</td></tr>
<tr><td style="text-align: left">layout</td><td style="text-align: left">Layout</td><td style="text-align: left">用于格式化 LogEvent 的布局。<br/><br/>如果未提供布局，则将使用“%m%n”的默认模式布局。</td></tr>
<tr><td style="text-align: left">follow</td><td style="text-align: left">boolean</td><td style="text-align: left">标识 appender在配置后  是否通过 System.setOut 或 System.setErr对  System.out 或 System.err 的重新分配<br />请注意，follow 属性不能与 Windows 上的 Jansi 一起使用，不能与 <code>direct</code> 一起使用。</td></tr>
<tr><td style="text-align: left">direct</td><td style="text-align: left">boolean</td><td style="text-align: left">直接写入java.io.FileDescriptor，绕过java.lang.System.out/.err.当输出被重定向到文件或其他进程时，可以提供高达 10 倍的性能提升.不能在 Windows 上与 Jansi 一起使用。<br/>不能与 <code>follow</code>一起使用. 输出将不尊重 java.lang.System.setOut()/.setErr() 并且可能会与多线程应用程序中 java.lang.System.out/.err 的其他输出交织在一起. 自 2.6.2 以来的新功能 目前仅在 Linux 和 Windows 上使用 Oracle JVM 进行过测试</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">String</td><td style="text-align: left">Appender 的名称</td></tr>
<tr><td style="text-align: left">ignoreExceptions</td><td style="text-align: left">boolean</td><td style="text-align: left">The default is true, 致在附加事件时遇到异常被内部记录然后被忽略. 当设置为 false 时，异常将传播给调用者<br /> You must set this to false when wrapping this Appender in a <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#FailoverAppender">FailoverAppender</a>.</td></tr>
<tr><td style="text-align: left">target</td><td style="text-align: left">String</td><td style="text-align: left">Either &quot;SYSTEM_OUT&quot; or &quot;SYSTEM_ERR&quot;. The default is &quot;SYSTEM_OUT&quot;.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="failoverappender"><a class="header" href="#failoverappender">FailoverAppender</a></h1>
<p>FailoverAppender 包装了一组 appender。如果主要 Appender 失败，则将按顺序尝试次要 Appender，直到成功或没有更多次要 Appender 可以尝试。</p>
<h1 id="failoverappender-parameters"><a class="header" href="#failoverappender-parameters">FailoverAppender Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">filter</td><td style="text-align: left">Filter</td><td style="text-align: left">一个过滤器，用于确定事件是否应该由这个 Appender 处理。使用 CompositeFilter 可以使用多个过滤器</td></tr>
<tr><td style="text-align: left">primary</td><td style="text-align: left">String</td><td style="text-align: left">要使用的主要 Appender 的名称</td></tr>
<tr><td style="text-align: left">failovers</td><td style="text-align: left">String[]</td><td style="text-align: left">要使用的辅助 Appender 的名称</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">String</td><td style="text-align: left">The name of the Appender.</td></tr>
<tr><td style="text-align: left">retryIntervalSeconds</td><td style="text-align: left">integer</td><td style="text-align: left">在重试主 Appender 之前应该经过的秒数。默认值为 60</td></tr>
<tr><td style="text-align: left">ignoreExceptions</td><td style="text-align: left">boolean</td><td style="text-align: left">默认值为 true，导致在附加事件时遇到异常以进行内部记录然后被忽略。当设置为 false 时，异常将传播给调用者。</td></tr>
<tr><td style="text-align: left">target</td><td style="text-align: left">String</td><td style="text-align: left">Either &quot;SYSTEM_OUT&quot; or &quot;SYSTEM_ERR&quot;. The default is &quot;SYSTEM_ERR&quot;.</td></tr>
</tbody></table>
<h1 id="配置-2"><a class="header" href="#配置-2">配置</a></h1>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Appenders&gt;
    &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;logs/app.log&quot; filePattern=&quot;logs/app-%d{MM-dd-yyyy}.log.gz&quot;
                 ignoreExceptions=&quot;false&quot;&gt;
      &lt;PatternLayout&gt;
        &lt;Pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/Pattern&gt;
      &lt;/PatternLayout&gt;
      &lt;TimeBasedTriggeringPolicy /&gt;
    &lt;/RollingFile&gt;
    &lt;Console name=&quot;STDOUT&quot; target=&quot;SYSTEM_OUT&quot; ignoreExceptions=&quot;false&quot;&gt;
      &lt;PatternLayout pattern=&quot;%m%n&quot;/&gt;
    &lt;/Console&gt;
    &lt;Failover name=&quot;Failover&quot; primary=&quot;RollingFile&quot;&gt;
      &lt;Failovers&gt;
        &lt;AppenderRef ref=&quot;Console&quot;/&gt;
      &lt;/Failovers&gt;
    &lt;/Failover&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;Failover&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fileappender"><a class="header" href="#fileappender">FileAppender</a></h1>
<p>FileAppender 是一个 OutputStreamAppender，它写入 fileName 参数中命名的 File。 FileAppender 使用 FileManager（它扩展了 OutputStreamManager）来实际执行文件 I/O。虽然不能共享来自不同配置的 FileAppender，但如果 Manager 可访问，则可以共享 FileManager。</p>
<p>例如，servlet 容器中的两个 Web 应用程序可以有自己的配置，并且如果 Log4j 位于它们公共的 ClassLoader 中，则可以安全地写入同一个文件。</p>
<h1 id="fileappender-parameters"><a class="header" href="#fileappender-parameters">FileAppender Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">append</td><td style="text-align: left">boolean</td><td style="text-align: left">当 true - 默认值时，记录将被附加到文件的末尾。设置为 false 时，将在写入新记录之前清除文件</td></tr>
<tr><td style="text-align: left">bufferedIO</td><td style="text-align: left">boolean</td><td style="text-align: left">当为 true - 默认值时，记录将被写入缓冲区，当缓冲区已满时，数据将写入磁盘，如果设置了 immediateFlush，则在写入记录时将数据写入磁盘。文件锁定不能与 bufferedIO 一起使用。性能测试表明，即使启用了即时刷新，使用缓冲 I/O 也能显着提高性能。</td></tr>
<tr><td style="text-align: left">bufferSize</td><td style="text-align: left">int</td><td style="text-align: left">当 bufferedIO 为 true 时，这是缓冲区大小，默认为 8192 字节</td></tr>
<tr><td style="text-align: left">createOnDemand</td><td style="text-align: left">boolean</td><td style="text-align: left">按需创建文件. 仅当日志事件通过所有过滤器并路由到此 appender 时，appender 才会创建文件. Defaults to false.</td></tr>
<tr><td style="text-align: left">filter</td><td style="text-align: left">Filter</td><td style="text-align: left">一个过滤器，用于确定事件是否应该由这个 Appender 处理。使用 CompositeFilter 可以使用多个过滤器。</td></tr>
<tr><td style="text-align: left">fileName</td><td style="text-align: left">String</td><td style="text-align: left">要写入的文件的名称。如果文件或其任何父目录不存在，则将创建它们</td></tr>
<tr><td style="text-align: left">immediateFlush</td><td style="text-align: left">boolean</td><td style="text-align: left">当设置为 true - 默认值时，每次写入后都会进行刷新。这将保证将数据写入磁盘，但可能会影响性能. 每次写入后刷新仅在同步记录器中有用. 异步记录器和附加器将在一批事件结束时自动刷新，即使immediateFlush 设置为false。这也保证了将数据写入磁盘但效率更高。</td></tr>
<tr><td style="text-align: left">layout</td><td style="text-align: left">Layout</td><td style="text-align: left">The Layout to use to format the LogEvent. If no layout is supplied the default pattern layout of &quot;%m%n&quot; will be used.</td></tr>
<tr><td style="text-align: left">locking</td><td style="text-align: left">boolean</td><td style="text-align: left">当设置为 true 时，I/O 操作只会在持有文件锁时发生，允许多个 JVM 中的 FileAppenders 和潜在的多个主机同时写入同一个文件. 这将显着影响性能，因此应谨慎使用。.此外，在许多系统上，文件锁是“建议性的”，这意味着其他应用程序可以在不获取锁的情况下对文件执行操作。默认值为假。</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">String</td><td style="text-align: left">The name of the Appender.</td></tr>
<tr><td style="text-align: left">ignoreExceptions</td><td style="text-align: left">boolean</td><td style="text-align: left">The default is true, causing exceptions encountered while appending events to be internally logged and then ignored. When set to false exceptions will be propagated to the caller, instead. You must set this to false when wrapping this Appender in a <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#FailoverAppender">FailoverAppender</a>.</td></tr>
<tr><td style="text-align: left">filePermissions</td><td style="text-align: left">String</td><td style="text-align: left">POSIX 格式的文件属性权限在创建文件时应用。底层文件系统应支持 [POSIX](https://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFileAttributeView .html) 文件属性视图。示例：rw------- 或 rw-rw-rw- 等...</td></tr>
<tr><td style="text-align: left">fileOwner</td><td style="text-align: left">String</td><td style="text-align: left">文件所有者在创建文件时定义。出于安全原因，可能会限制更改文件的所有者，并且操作不允许，抛出 IOException. Only processes with an effective user ID equal to the user ID of the file or with appropriate privileges may change the ownership of a file if <a href="http://www.gnu.org/software/libc/manual/html_node/Options-for-Files.html">_POSIX_CHOWN_RESTRICTED</a> is in effect for path.Underlying files system shall support file <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/FileOwnerAttributeView.html">owner</a> attribute view.</td></tr>
<tr><td style="text-align: left">fileGroup</td><td style="text-align: left">String</td><td style="text-align: left">File group to define whenever the file is created.Underlying files system shall support <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFileAttributeView.html">POSIX</a> file attribute view.</td></tr>
</tbody></table>
<h1 id="example-3"><a class="header" href="#example-3">Example</a></h1>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Appenders&gt;
    &lt;File name=&quot;MyFile&quot; fileName=&quot;logs/app.log&quot;&gt;
      &lt;PatternLayout&gt;
        &lt;Pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/Pattern&gt;
      &lt;/PatternLayout&gt;
    &lt;/File&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;MyFile&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jdbcappender"><a class="header" href="#jdbcappender">JDBCAppender</a></h1>
<p>JDBCAppender 使用标准 JDBC 将日志事件写入关系数据库表</p>
<p>它可以配置为使用 JNDI 数据源或自定义工厂方法获取 JDBC 连接。无论您采用哪种方法，它都必须由连接池支持,否则，日志性能将受到很大影响</p>
<p>如果配置的 JDBC 驱动程序支持批处理语句并且 bufferSize 配置为正数，则日志事件将被批处理</p>
<p>从 Log4j 2.8 开始，有两种方法可以将日志事件配置为列映射：仅允许字符串和时间戳的原始 ColumnConfig 样式，以及使用 Log4j 的内置类型转换以允许更多数据类型的新 ColumnMapping 插件（这与 Cassandra Appender 中的插件相同）。</p>
<p>为了在开发过程中快速起步，使用基于 JNDI 的连接源的替代方法是使用非池化DriverManager 连接源。</p>
<p>此连接源使用 JDBC 连接字符串、用户名和密码。或者，您还可以使用属性。</p>
<h1 id="jdbcappender-parameters"><a class="header" href="#jdbcappender-parameters">JDBCAppender Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">name</td><td style="text-align: left">String</td><td style="text-align: left"><em>Required.</em> The name of the Appender.</td></tr>
<tr><td style="text-align: left">ignoreExceptions</td><td style="text-align: left">boolean</td><td style="text-align: left">The default is true, causing exceptions encountered while appending events to be internally logged and then ignored. When set to false exceptions will be propagated to the caller, instead. You must set this to false when wrapping this Appender in a <a href="https://logging.apache.org/log4j/2.x/manual/appenders.html#FailoverAppender">FailoverAppender</a>.</td></tr>
<tr><td style="text-align: left">filter</td><td style="text-align: left">Filter</td><td style="text-align: left">A Filter to determine if the event should be handled by this Appender. More than one Filter may be used by using a CompositeFilter.</td></tr>
<tr><td style="text-align: left">bufferSize</td><td style="text-align: left">int</td><td style="text-align: left">If an integer greater than 0, this causes the appender to buffer log events and flush whenever the buffer reaches this size.</td></tr>
<tr><td style="text-align: left">connectionSource</td><td style="text-align: left">ConnectionSource</td><td style="text-align: left"><em>Required.</em> The connections source from which database connections should be retrieved.</td></tr>
<tr><td style="text-align: left">tableName</td><td style="text-align: left">String</td><td style="text-align: left"><em>Required.</em> The name of the database table to insert log events into.</td></tr>
<tr><td style="text-align: left">columnConfigs</td><td style="text-align: left">ColumnConfig[]</td><td style="text-align: left"><em>Required (and/or columnMappings).</em> 有关应插入记录事件数据的列以及如何插入该数据的信息。这用多个 <code>&lt;Column&gt;</code> 元素表示。</td></tr>
<tr><td style="text-align: left">columnMappings</td><td style="text-align: left">ColumnMapping[]</td><td style="text-align: left"><em>Required (and/or columnConfigs).</em> 列映射配置列表. 每列必须指定一个列名. 每个列都可以具有由其完全限定的类名指定的转换类型。默认情况下，转换类型为 String. If the configured type is assignment-compatible with <a href="https://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/util/ReadOnlyStringMap.html">ReadOnlyStringMap</a> / <a href="https://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/spi/ThreadContextMap.html">ThreadContextMap</a> or <a href="https://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/spi/ThreadContextStack.html">ThreadContextStack</a>, 然后该列将分别用 MDC 或 NDC 填充（这是特定于数据库的，它们处理插入 Map 或 List 值的方式）.如果配置的类型与 java.util.Date 的赋值兼容，则日志时间戳将转换为该配置的日期类型. If the configured type is assignment-compatible with java.sql.Clob or java.sql.NClob, then the formatted event will be set as a Clob or NClob respectively (similar to the traditional ColumnConfig plugin). 如果给出了文字属性，则其值将在 INSERT 查询中按原样使用，而不会进行任何转义。否则，指定的布局或模式将转换为配置的类型并存储在该列中。</td></tr>
<tr><td style="text-align: left">immediateFail</td><td style="text-align: left">boolean</td><td style="text-align: left">设置为 true 时，日志事件不会等待尝试重新连接，如果 JDBC 资源不可用，则会立即失败。 2.11.2 新功能</td></tr>
<tr><td style="text-align: left">reconnectIntervalMillis</td><td style="text-align: left">long</td><td style="text-align: left">如果设置为大于 0 的值，则在发生错误后，JDBCDatabaseManager 将在等待指定的毫秒数后尝试重新连接到数据库<br />如果重新连接失败，则会抛出异常（如果 ignoreExceptions 设置为 false，则应用程序可以捕获该异常） 2.11.2 中的新功能</td></tr>
</tbody></table>
<h1 id="connectionsource-implementation"><a class="header" href="#connectionsource-implementation">ConnectionSource implementation</a></h1>
<p>在配置 JDBCAppender 时，您必须指定一个 ConnectionSource implementation，Appender 从中获取 JDBC 连接。您必须恰好使用以下嵌套元素之一：</p>
<ul>
<li>&lt;DataSource&gt;: Uses JNDI.</li>
<li>&lt;ConnectionFactory&gt;: Points to a class-method pair to provide JDBC connections.</li>
<li>&lt;DriverManager&gt;: A quick and dirty way to get off the ground, no connection pooling.</li>
<li>&lt;PoolingDriver&gt;: Uses Apache Commons DBCP to provide connection pooling</li>
</ul>
<h1 id="datasource-parameters"><a class="header" href="#datasource-parameters">DataSource Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">jndiName</td><td style="text-align: left">String</td><td style="text-align: left"><em>Required.</em> The full, prefixed JNDI name that the javax.sql.DataSource is bound to, such as java:/comp/env/jdbc/LoggingDatabase. The DataSource must be backed by a connection pool; otherwise, logging will be very slow.</td></tr>
</tbody></table>
<h1 id="connectionfactory-parameters"><a class="header" href="#connectionfactory-parameters">ConnectionFactory Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">class</td><td style="text-align: left">Class</td><td style="text-align: left">*Required. 包含用于获取 JDBC 连接的静态工厂方法的类的完全限定名称。</td></tr>
<tr><td style="text-align: left">method</td><td style="text-align: left">Method</td><td style="text-align: left"><em>Required.</em> 用于获取 JDBC 连接的静态工厂方法的名称。此方法必须没有参数，并且其返回类型必须是 java.sql.Connection 或 DataSource。如果该方法返回连接，则必须从连接池中获取它们（并且它们会在 Log4j 完成时返回到连接池中）；否则，日志记录会很慢。如果该方法返回一个 DataSource，则该 DataSource 只会被检索一次，并且出于同样的原因，它必须由连接池支持。</td></tr>
</tbody></table>
<h1 id="drivermanager-parameters"><a class="header" href="#drivermanager-parameters">DriverManager Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">connectionString</td><td style="text-align: left">String</td><td style="text-align: left"><em>Required.</em> 特定于驱动程序的 JDBC 连接字符串。</td></tr>
<tr><td style="text-align: left">userName</td><td style="text-align: left">String</td><td style="text-align: left">The database user name. 数据库用户名。您不能同时指定 <code>properties</code> 和 <code>userName</code>或 <code>password</code></td></tr>
<tr><td style="text-align: left">password</td><td style="text-align: left">String</td><td style="text-align: left">数据库密码。您不能同时指定属性和用户名或密码</td></tr>
<tr><td style="text-align: left">driverClassName</td><td style="text-align: left">String</td><td style="text-align: left">JDBC 驱动程序类名称。某些旧的 JDBC 驱动程序只能通过按类名显式加载它们来发现</td></tr>
<tr><td style="text-align: left">properties</td><td style="text-align: left">Property[]</td><td style="text-align: left">属性列表。您不能同时指定属性和用户名或密码。</td></tr>
</tbody></table>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">DriverManager parameters</td><td style="text-align: left">DriverManager parameters</td><td style="text-align: left">This connection source inherits all parameter from the DriverManager connection source.</td></tr>
<tr><td style="text-align: left">poolName</td><td style="text-align: left">String</td><td style="text-align: left">The pool name used to pool JDBC Connections. Defaults to example. You can use the JDBC connection string prefix jdbc:apache:commons:dbcp: followed by the pool name if you want to use a pooled connection elsewhere. For example: jdbc:apache:commons:dbcp:example.</td></tr>
<tr><td style="text-align: left">PoolableConnectionFactory</td><td style="text-align: left">PoolableConnectionFactory element</td><td style="text-align: left">Defines a PoolableConnectionFactory.</td></tr>
</tbody></table>
<h1 id="poolingdriver-parameters-apache-commons-dbcp"><a class="header" href="#poolingdriver-parameters-apache-commons-dbcp">PoolingDriver Parameters (Apache Commons DBCP)</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">DriverManager parameters</td><td style="text-align: left">DriverManager parameters</td><td style="text-align: left">此连接源继承了 DriverManager 连接源的所有参数</td></tr>
<tr><td style="text-align: left">poolName</td><td style="text-align: left">String</td><td style="text-align: left">用于池化 JDBC 连接的池名称。默认为示例。如果要在其他地方使用池连接，可以使用 JDBC 连接字符串前缀 jdbc:apache:commons:dbcp: 后跟池名称。例如：jdbc:apache:commons:dbcp:example。</td></tr>
</tbody></table>
<h1 id="poolableconnectionfactory-parameters-apache-commons-dbcp"><a class="header" href="#poolableconnectionfactory-parameters-apache-commons-dbcp">PoolableConnectionFactory Parameters (Apache Commons DBCP)</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">autoCommitOnReturn</td><td style="text-align: left">boolean</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">cacheState</td><td style="text-align: left">boolean</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">ConnectionInitSqls</td><td style="text-align: left">Strings</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">defaultAutoCommit</td><td style="text-align: left">boolean</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">defaultCatalog</td><td style="text-align: left">String</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">defaultQueryTimeoutSeconds</td><td style="text-align: left">integer</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">defaultReadOnly</td><td style="text-align: left">boolean</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">defaultTransactionIsolation</td><td style="text-align: left">integer</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">disconnectionSqlCodes</td><td style="text-align: left">Strings</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">fastFailValidation</td><td style="text-align: left">boolean</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">maxConnLifetimeMillis</td><td style="text-align: left">long</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">maxOpenPreparedStatements</td><td style="text-align: left">integer</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">poolStatements</td><td style="text-align: left">boolean</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">rollbackOnReturn</td><td style="text-align: left">boolean</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">validationQuery</td><td style="text-align: left">String</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
<tr><td style="text-align: left">validationQueryTimeoutSeconds</td><td style="text-align: left">integer</td><td style="text-align: left">See <a href="http://commons.apache.org/proper/commons-dbcp/api-2.4.0/org/apache/commons/dbcp2/PoolableConnectionFactory.html">Apache Commons DBCP PoolableConnectionFactory.</a></td></tr>
</tbody></table>
<p>配置 JDBCAppender 时，使用嵌套的 <code>&lt;Column&gt;</code> 元素指定应写入表中的哪些列以及如何写入它们。 JDBCAppender 使用此信息制定 PreparedStatement 以插入没有 SQL 注入漏洞的记录。</p>
<h1 id="column-parameters"><a class="header" href="#column-parameters">Column Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">name</td><td style="text-align: left">String</td><td style="text-align: left"><em>Required.</em> The name of the database column.</td></tr>
<tr><td style="text-align: left">pattern</td><td style="text-align: left">String</td><td style="text-align: left">Use this attribute to insert a value or values from the log event in this column using a PatternLayout pattern. Simply specify any legal pattern in this attribute. Either this attribute, literal, or isEventTimestamp=&quot;true&quot; must be specified, but not more than one of these.</td></tr>
<tr><td style="text-align: left">literal</td><td style="text-align: left">String</td><td style="text-align: left">Use this attribute to insert a literal value in this column. The value will be included directly in the insert SQL, without any quoting (which means that if you want this to be a string, your value should contain single quotes around it like this: literal=&quot;'Literal String'&quot;). This is especially useful for databases that don't support identity columns. For example, if you are using Oracle you could specify literal=&quot;NAME_OF_YOUR_SEQUENCE.NEXTVAL&quot; to insert a unique ID in an ID column. Either this attribute, pattern, or isEventTimestamp=&quot;true&quot; must be specified, but not more than one of these.</td></tr>
<tr><td style="text-align: left">parameter</td><td style="text-align: left">String</td><td style="text-align: left">Use this attribute to insert an expression with a parameter marker '?' in this column. The value will be included directly in the insert SQL, without any quoting (which means that if you want this to be a string, your value should contain single quotes around it like this:<ColumnMapping name="instant" parameter="TIMESTAMPADD('MILLISECOND', ?, TIMESTAMP '1970-01-01')"/>You can only specify one of literal or parameter.</td></tr>
<tr><td style="text-align: left">isEventTimestamp</td><td style="text-align: left">boolean</td><td style="text-align: left">Use this attribute to insert the event timestamp in this column, which should be a SQL datetime. The value will be inserted as a java.sql.Types.TIMESTAMP. Either this attribute (equal to true), pattern, or isEventTimestamp must be specified, but not more than one of these.</td></tr>
<tr><td style="text-align: left">isUnicode</td><td style="text-align: left">boolean</td><td style="text-align: left">This attribute is ignored unless pattern is specified. If true or omitted (default), the value will be inserted as unicode (setNString or setNClob). Otherwise, the value will be inserted non-unicode (setString or setClob).</td></tr>
<tr><td style="text-align: left">isClob</td><td style="text-align: left">boolean</td><td style="text-align: left">This attribute is ignored unless pattern is specified. Use this attribute to indicate that the column stores Character Large Objects (CLOBs). If true, the value will be inserted as a CLOB (setClob or setNClob). If false or omitted (default), the value will be inserted as a VARCHAR or NVARCHAR (setString or setNString).</td></tr>
</tbody></table>
<h1 id="columnmapping-parameters"><a class="header" href="#columnmapping-parameters">ColumnMapping Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">name</td><td style="text-align: left">String</td><td style="text-align: left"><em>Required.</em> The name of the database column.</td></tr>
<tr><td style="text-align: left">pattern</td><td style="text-align: left">String</td><td style="text-align: left">Use this attribute to insert a value or values from the log event in this column using a PatternLayout pattern. Simply specify any legal pattern in this attribute. Either this attribute, literal, or isEventTimestamp=&quot;true&quot; must be specified, but not more than one of these.</td></tr>
<tr><td style="text-align: left">literal</td><td style="text-align: left">String</td><td style="text-align: left">Use this attribute to insert a literal value in this column. The value will be included directly in the insert SQL, without any quoting (which means that if you want this to be a string, your value should contain single quotes around it like this: literal=&quot;'Literal String'&quot;). This is especially useful for databases that don't support identity columns. For example, if you are using Oracle you could specify literal=&quot;NAME_OF_YOUR_SEQUENCE.NEXTVAL&quot; to insert a unique ID in an ID column. Either this attribute, pattern, or isEventTimestamp=&quot;true&quot; must be specified, but not more than one of these.</td></tr>
<tr><td style="text-align: left">layout</td><td style="text-align: left">Layout</td><td style="text-align: left">The Layout to format the LogEvent.</td></tr>
<tr><td style="text-align: left">type</td><td style="text-align: left">String</td><td style="text-align: left">Conversion type name, a fully-qualified class name.</td></tr>
</tbody></table>
<h1 id="example-4"><a class="header" href="#example-4">Example</a></h1>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;error&quot;&gt;
  &lt;Appenders&gt;
    &lt;JDBC name=&quot;databaseAppender&quot; tableName=&quot;dbo.application_log&quot;&gt;
      &lt;DataSource jndiName=&quot;java:/comp/env/jdbc/LoggingDataSource&quot; /&gt;
      &lt;Column name=&quot;eventDate&quot; isEventTimestamp=&quot;true&quot; /&gt;
      &lt;Column name=&quot;level&quot; pattern=&quot;%level&quot; /&gt;
      &lt;Column name=&quot;logger&quot; pattern=&quot;%logger&quot; /&gt;
      &lt;Column name=&quot;message&quot; pattern=&quot;%message&quot; /&gt;
      &lt;Column name=&quot;exception&quot; pattern=&quot;%ex{full}&quot; /&gt;
    &lt;/JDBC&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;warn&quot;&gt;
      &lt;AppenderRef ref=&quot;databaseAppender&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;error&quot;&gt;
  &lt;Appenders&gt;
    &lt;JDBC name=&quot;databaseAppender&quot; tableName=&quot;LOGGING.APPLICATION_LOG&quot;&gt;
      &lt;ConnectionFactory class=&quot;net.example.db.ConnectionFactory&quot; method=&quot;getDatabaseConnection&quot; /&gt;
      &lt;Column name=&quot;EVENT_ID&quot; literal=&quot;LOGGING.APPLICATION_LOG_SEQUENCE.NEXTVAL&quot; /&gt;
      &lt;Column name=&quot;EVENT_DATE&quot; isEventTimestamp=&quot;true&quot; /&gt;
      &lt;Column name=&quot;LEVEL&quot; pattern=&quot;%level&quot; /&gt;
      &lt;Column name=&quot;LOGGER&quot; pattern=&quot;%logger&quot; /&gt;
      &lt;Column name=&quot;MESSAGE&quot; pattern=&quot;%message&quot; /&gt;
      &lt;Column name=&quot;THROWABLE&quot; pattern=&quot;%ex{full}&quot; /&gt;
    &lt;/JDBC&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;warn&quot;&gt;
      &lt;AppenderRef ref=&quot;databaseAppender&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<pre><code class="language-java">package net.example.db;
 
import java.sql.Connection;
import java.sql.SQLException;
import java.util.Properties;
 
import javax.sql.DataSource;
 
import org.apache.commons.dbcp.DriverManagerConnectionFactory;
import org.apache.commons.dbcp.PoolableConnection;
import org.apache.commons.dbcp.PoolableConnectionFactory;
import org.apache.commons.dbcp.PoolingDataSource;
import org.apache.commons.pool.impl.GenericObjectPool;
 
public class ConnectionFactory {
    private static interface Singleton {
        final ConnectionFactory INSTANCE = new ConnectionFactory();
    }
 
    private final DataSource dataSource;
 
    private ConnectionFactory() {
        Properties properties = new Properties();
        properties.setProperty(&quot;user&quot;, &quot;logging&quot;);
        properties.setProperty(&quot;password&quot;, &quot;abc123&quot;); // or get properties from some configuration file
 
        GenericObjectPool&lt;PoolableConnection&gt; pool = new GenericObjectPool&lt;PoolableConnection&gt;();
        DriverManagerConnectionFactory connectionFactory = new DriverManagerConnectionFactory(
                &quot;jdbc:mysql://example.org:3306/exampleDb&quot;, properties
        );
        new PoolableConnectionFactory(
                connectionFactory, pool, null, &quot;SELECT 1&quot;, 3, false, false, Connection.TRANSACTION_READ_COMMITTED
        );
 
        this.dataSource = new PoolingDataSource(pool);
    }
 
    public static Connection getDatabaseConnection() throws SQLException {
        return Singleton.INSTANCE.dataSource.getConnection();
    }
}
</code></pre>
<p>The following configuration uses a MessageLayout to indicate that the Appender should match the keys of a MapMessage to the names of ColumnMappings when setting the values of the Appender's SQL INSERT statement. This let you insert rows for custom values in a database table based on a Log4j MapMessage instead of values from LogEvents.</p>
<pre><code class="language-xml">&lt;Configuration status=&quot;debug&quot;&gt;
 
  &lt;Appenders&gt;
    &lt;Console name=&quot;STDOUT&quot;&gt;
      &lt;PatternLayout pattern=&quot;%C{1.} %m %level MDC%X%n&quot;/&gt;
    &lt;/Console&gt;
    &lt;Jdbc name=&quot;databaseAppender&quot; tableName=&quot;dsLogEntry&quot; ignoreExceptions=&quot;false&quot;&gt;
      &lt;DataSource jndiName=&quot;java:/comp/env/jdbc/TestDataSourceAppender&quot; /&gt;
      &lt;ColumnMapping name=&quot;Id&quot; /&gt;
      &lt;ColumnMapping name=&quot;ColumnA&quot; /&gt;
      &lt;ColumnMapping name=&quot;ColumnB&quot; /&gt;
      &lt;MessageLayout /&gt;
    &lt;/Jdbc&gt;
  &lt;/Appenders&gt;
 
  &lt;Loggers&gt;
    &lt;Logger name=&quot;org.apache.logging.log4j.core.appender.db&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;
      &lt;AppenderRef ref=&quot;databaseAppender&quot; /&gt;
    &lt;/Logger&gt;
 
    &lt;Root level=&quot;fatal&quot;&gt;
      &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
 
&lt;/Configuration&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>The OutputStreamAppender provides the base for many of the other Appenders such as the File and Socket appenders that write the event to an Output Stream. It cannot be directly configured. Support for immediateFlush and buffering is provided by the OutputStreamAppender. The OutputStreamAppender uses an OutputStreamManager to handle the actual I/O, allowing the stream to be shared by Appenders in multiple configurations.</p>
<p>OutputStreamAppender 为许多其他 Appender 提供了基础，例如将事件写入输出流的 File 和 Socket appender。不能直接配置。 OutputStreamAppender 提供了对即时刷新和缓冲的支持。 OutputStreamAppender 使用 OutputStreamManager 来处理实际的 I/O，允许在多个配置中由 Appender 共享流。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="randomaccessfileappender"><a class="header" href="#randomaccessfileappender">RandomAccessFileAppender</a></h1>
<p>RandomAccessFileAppender 类似于标准的 FileAppender，除了它总是被缓冲（不能关闭），并且在内部它使用 ByteBuffer + RandomAccessFile 而不是 BufferedOutputStream</p>
<p>在我们的 <a href="https://logging.apache.org/log4j/2.x/performance.html#whichAppender">measurements</a> 中，与带有“bufferedIO=true”的 FileAppender 相比，我们看到了 20-200% 的性能提升。</p>
<p>与 FileAppender 类似，RandomAccessFileAppender 使用 RandomAccessFileManager 来实际执行文件 I/O。</p>
<p>虽然无法共享来自不同配置的 RandomAccessFileAppender，但如果 Manager 可访问，则可以共享 RandomAccessFileManagers</p>
<p>例如，servlet 容器中的两个 Web 应用程序可以有自己的配置，并且如果 Log4j 位于它们公共的 ClassLoader 中，则可以安全地写入同一个文件。</p>
<h1 id="paramter"><a class="header" href="#paramter">Paramter</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">append</td><td style="text-align: left">boolean</td><td style="text-align: left">当 true - 默认值时，记录将被附加到文件的末尾。<br/>设置为 false 时，将在写入新记录之前清除文件。</td></tr>
<tr><td style="text-align: left">fileName</td><td style="text-align: left">String</td><td style="text-align: left">要写入的文件的名称。<br/>如果文件或其任何父目录不存在，则将创建它们。</td></tr>
<tr><td style="text-align: left">filters</td><td style="text-align: left">Filter</td><td style="text-align: left">一个过滤器，用于确定事件是否应该由这个 Appender 处理。<br/>使用 CompositeFilter 可以使用多个过滤器。</td></tr>
<tr><td style="text-align: left">immediateFlush</td><td style="text-align: left">boolean</td><td style="text-align: left">当设置为 true - 默认值时，每次写入后都会进行刷新。这将保证将数据写入磁盘，但可能会影响性能。每次写入后刷新仅在将此 appender 与同步记录器一起使用时才有用。异步记录器和附加器将在一批事件结束时自动刷新，即使immediateFlush 设置为false。<br/>这也保证了将数据写入磁盘但效率更高。</td></tr>
<tr><td style="text-align: left">bufferSize</td><td style="text-align: left">int</td><td style="text-align: left">The buffer size, defaults to 262,144 bytes (256 * 1024).</td></tr>
<tr><td style="text-align: left">layout</td><td style="text-align: left">Layout</td><td style="text-align: left">用于格式化 LogEvent 的布局。<br/>如果未提供布局，则将使用“%m%n”的默认模式布局。</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">String</td><td style="text-align: left">The name of the Appender.</td></tr>
<tr><td style="text-align: left">ignoreExceptions</td><td style="text-align: left">boolean</td><td style="text-align: left">The default is true, causing exceptions encountered while appending events to be internally logged and then ignored. When set to false exceptions will be propagated to the caller, instead. You must set this to false when wrapping this Appender in a <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#FailoverAppender">FailoverAppender</a>.</td></tr>
</tbody></table>
<h1 id="example-5"><a class="header" href="#example-5">Example</a></h1>
<p>Here is a sample RandomAccessFile configuration:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Appenders&gt;
    &lt;RandomAccessFile name=&quot;MyFile&quot; fileName=&quot;logs/app.log&quot;&gt;
      &lt;PatternLayout&gt;
        &lt;Pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/Pattern&gt;
      &lt;/PatternLayout&gt;
    &lt;/RandomAccessFile&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;MyFile&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rewriteappender"><a class="header" href="#rewriteappender">RewriteAppender</a></h1>
<p>RewriteAppender 允许在 LogEvent 被另一个 Appender 处理之前对其进行操作。</p>
<p>这可用于屏蔽敏感信息（例如密码）或将信息注入每个事件。 </p>
<p>RewriteAppender 必须配置有 RewritePolicy。 </p>
<h1 id="parameters"><a class="header" href="#parameters">Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">AppenderRef</td><td style="text-align: left">String</td><td style="text-align: left">在操作 LogEvent 后要调用的 Appender 的名称。<br/>可以配置多个 AppenderRef 元素。</td></tr>
<tr><td style="text-align: left">filter</td><td style="text-align: left">Filter</td><td style="text-align: left">一个过滤器，用于确定事件是否应该由这个 Appender 处理。<br/>使用 CompositeFilter 可以使用多个过滤器。</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">String</td><td style="text-align: left">The name of the Appender.</td></tr>
<tr><td style="text-align: left">rewritePolicy</td><td style="text-align: left">RewritePolicy</td><td style="text-align: left">将操作 LogEvent 的 RewritePolicy。</td></tr>
<tr><td style="text-align: left">ignoreExceptions</td><td style="text-align: left">boolean</td><td style="text-align: left">The default is true, causing exceptions encountered while appending events to be internally logged and then ignored. When set to false exceptions will be propagated to the caller, instead. You must set this to false when wrapping this Appender in a <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#FailoverAppender">FailoverAppender</a>.</td></tr>
</tbody></table>
<h1 id="rewritepolicy"><a class="header" href="#rewritepolicy">RewritePolicy</a></h1>
<p>RewritePolicy 是一个接口，它允许实现在传递给 Appender 之前检查并可能修改 LogEvent。 </p>
<p>RewritePolicy 声明了一个必须实现的名为 rewrite 的方法。</p>
<p>该方法通过 LogEvent 传递，可以返回相同的事件或创建一个新的事件。</p>
<h5 id="maprewritepolicy"><a class="header" href="#maprewritepolicy">MapRewritePolicy</a></h5>
<p>MapRewritePolicy will evaluate LogEvents that contain a MapMessage and will add or update elements of the Map.</p>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">mode</td><td style="text-align: left">String</td><td style="text-align: left">&quot;Add&quot; or &quot;Update&quot;</td></tr>
<tr><td style="text-align: left">keyValuePair</td><td style="text-align: left">KeyValuePair[]</td><td style="text-align: left">An array of keys and their values.</td></tr>
</tbody></table>
<p>以下配置显示了一个 RewriteAppender 配置为将产品密钥及其值添加到 MapMessage。：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Appenders&gt;
    &lt;Console name=&quot;STDOUT&quot; target=&quot;SYSTEM_OUT&quot;&gt;
      &lt;PatternLayout pattern=&quot;%m%n&quot;/&gt;
    &lt;/Console&gt;
    &lt;Rewrite name=&quot;rewrite&quot;&gt;
      &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;
      &lt;MapRewritePolicy mode=&quot;Add&quot;&gt;
        &lt;KeyValuePair key=&quot;product&quot; value=&quot;TestProduct&quot;/&gt;
      &lt;/MapRewritePolicy&gt;
    &lt;/Rewrite&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;Rewrite&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<p><strong>PropertiesRewritePolicy</strong></p>
<p>PropertiesRewritePolicy 会将在策略上配置的属性添加到正在记录的 ThreadContext Map。</p>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">properties</td><td style="text-align: left">Property[]</td><td style="text-align: left">One of more Property elements to define the keys and values to be added to the ThreadContext Map.</td></tr>
</tbody></table>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Appenders&gt;
    &lt;Console name=&quot;STDOUT&quot; target=&quot;SYSTEM_OUT&quot;&gt;
      &lt;PatternLayout pattern=&quot;%m%n&quot;/&gt;
    &lt;/Console&gt;
    &lt;Rewrite name=&quot;rewrite&quot;&gt;
      &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;
      &lt;PropertiesRewritePolicy&gt;
        &lt;Property name=&quot;user&quot;&gt;${sys:user.name}&lt;/Property&gt;
        &lt;Property name=&quot;env&quot;&gt;${sys:environment}&lt;/Property&gt;
      &lt;/PropertiesRewritePolicy&gt;
    &lt;/Rewrite&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;Rewrite&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<p><strong>LoggerNameLevelRewritePolicy</strong></p>
<p>您可以使用此策略通过更改事件级别来减少第三方代码中的记录器</p>
<p>LoggerNameLevelRewritePolicy 将重写给定记录器名称前缀的日志事件级别。</p>
<p>您可以使用记录器名称前缀和一对级别配置 LoggerNameLevelRewritePolicy，其中一对定义源级别和目标级别。</p>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">logger</td><td style="text-align: left">String</td><td style="text-align: left">A logger name used as a prefix to test each event's logger name.</td></tr>
<tr><td style="text-align: left">LevelPair</td><td style="text-align: left">KeyValuePair[]</td><td style="text-align: left">An array of keys and their values, each key is a source level, each value a target level.</td></tr>
</tbody></table>
<p>以下配置显示了一个 RewriteAppender，配置为将级别 INFO 映射到 DEBUG，并将级别 WARN 映射到以 com.foo.bar 开头的所有记录器的 INFO。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot;&gt;
  &lt;Appenders&gt;
    &lt;Console name=&quot;STDOUT&quot; target=&quot;SYSTEM_OUT&quot;&gt;
      &lt;PatternLayout pattern=&quot;%m%n&quot;/&gt;
    &lt;/Console&gt;
    &lt;Rewrite name=&quot;rewrite&quot;&gt;
      &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;
      &lt;LoggerNameLevelRewritePolicy logger=&quot;com.foo.bar&quot;&gt;
        &lt;KeyValuePair key=&quot;INFO&quot; value=&quot;DEBUG&quot;/&gt;
        &lt;KeyValuePair key=&quot;WARN&quot; value=&quot;INFO&quot;/&gt;
      &lt;/LoggerNameLevelRewritePolicy&gt;
    &lt;/Rewrite&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;Rewrite&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rollingfileappender"><a class="header" href="#rollingfileappender">RollingFileAppender</a></h1>
<p>RollingFileAppender 是一个 OutputStreamAppender，它写入 fileName 参数中命名的 File 并根据 <strong>TriggeringPolicy</strong> 和 <strong>RolloverPolicy</strong> 滚动文件</p>
<p>RollingFileAppender 使用 RollingFileManager（它扩展了 OutputStreamManager）来实际执行文件 I/O 并执行翻转。</p>
<p>虽然无法共享来自不同配置的 RolloverFileAppender，但如果 Manager 可访问，则可以共享 RollingFileManagers。</p>
<p>例如，servlet 容器中的两个 Web 应用程序可以有自己的配置，并且如果 Log4j 位于它们公共的 ClassLoader 中，则可以安全地写入同一个文件。</p>
<h1 id="triggeringpolicy-与rolloverstrategy"><a class="header" href="#triggeringpolicy-与rolloverstrategy">TriggeringPolicy 与RolloverStrategy</a></h1>
<ol>
<li>
<p>RollingFileAppender 需要一个 TriggeringPolicy 和一个 RolloverStrategy。</p>
</li>
<li>
<p>触发策略确定是否应该执行翻转，而 RolloverStrategy 定义应该如何完成翻转。</p>
</li>
<li>
<p>如果没有配置 RolloverStrategy，RollingFileAppender 将使用 DefaultRolloverStrategy。</p>
</li>
<li>
<p>从 log4j-2.5 开始，可以在 DefaultRolloverStrategy 中配置自定义删除操作以在翻转时运行。</p>
</li>
<li>
<p>从 2.8 开始，如果没有配置文件名，那么将使用 DirectWriteRolloverStrategy 而不是 DefaultRolloverStrategy。</p>
</li>
<li>
<p>从 log4j-2.9 开始，可以在 DefaultRolloverStrategy 中配置自定义 POSIX 文件属性视图操作以在翻转时运行，如果未定义，将从 RollingFileAppender 继承的 POSIX 文件属性视图将被应用。</p>
</li>
<li>
<p>RollingFileAppender 不支持文件锁定。</p>
</li>
</ol>
<h1 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">append</td><td style="text-align: left">boolean</td><td style="text-align: left">When true - the default, records will be appended to the end of the file. When set to false, the file will be cleared before new records are written.</td></tr>
<tr><td style="text-align: left">bufferedIO</td><td style="text-align: left">boolean</td><td style="text-align: left">When true - the default, records will be written to a buffer and the data will be written to disk when the buffer is full or, if immediateFlush is set, when the record is written. File locking cannot be used with bufferedIO. Performance tests have shown that using buffered I/O significantly improves performance, even if immediateFlush is enabled.</td></tr>
<tr><td style="text-align: left">bufferSize</td><td style="text-align: left">int</td><td style="text-align: left">When bufferedIO is true, this is the buffer size, the default is 8192 bytes.</td></tr>
<tr><td style="text-align: left">createOnDemand</td><td style="text-align: left">boolean</td><td style="text-align: left">The appender creates the file on-demand. The appender only creates the file when a log event passes all filters and is routed to this appender. Defaults to false.</td></tr>
<tr><td style="text-align: left">filter</td><td style="text-align: left">Filter</td><td style="text-align: left">A Filter to determine if the event should be handled by this Appender. More than one Filter may be used by using a CompositeFilter.</td></tr>
<tr><td style="text-align: left">fileName</td><td style="text-align: left">String</td><td style="text-align: left">The name of the file to write to. If the file, or any of its parent directories, do not exist, they will be created.</td></tr>
<tr><td style="text-align: left">filePattern</td><td style="text-align: left">String</td><td style="text-align: left">归档日志文件的文件名模式。模式的格式取决于所使用的 RolloverPolicy。 .DefaultRolloverPolicy 将接受与 <a href="http://download.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat</a> 兼容的日期/时间模式和 或  %i 计算器. 该模式还支持运行时插值，因此任何 任何 Lookups (such as the <a href="http://logging.apache.org/log4j/2.x/manual/lookups.html#DateLookup">DateLookup</a>) can be included in the pattern.</td></tr>
<tr><td style="text-align: left">immediateFlush</td><td style="text-align: left">boolean</td><td style="text-align: left">When set to true - the default, each write will be followed by a flush. This will guarantee the data is written to disk but could impact performance.Flushing after every write is only useful when using this appender with synchronous loggers. Asynchronous loggers and appenders will automatically flush at the end of a batch of events, even if immediateFlush is set to false. This also guarantees the data is written to disk but is more efficient.</td></tr>
<tr><td style="text-align: left">layout</td><td style="text-align: left">Layout</td><td style="text-align: left">用于格式化 LogEvent 的布局。<br/><br/>如果未提供布局，则将使用“%m%n”的默认模式布局。</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">String</td><td style="text-align: left">The name of the Appender.</td></tr>
<tr><td style="text-align: left">policy</td><td style="text-align: left">TriggeringPolicy</td><td style="text-align: left">用于确定是否应发生翻转的策略。</td></tr>
<tr><td style="text-align: left">strategy</td><td style="text-align: left">RolloverStrategy</td><td style="text-align: left">用于确定存档文件的名称和位置的策略</td></tr>
<tr><td style="text-align: left">ignoreExceptions</td><td style="text-align: left">boolean</td><td style="text-align: left">The default is true, causing exceptions encountered while appending events to be internally logged and then ignored. When set to false exceptions will be propagated to the caller, instead. You must set this to false when wrapping this Appender in a <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#FailoverAppender">FailoverAppender</a>.</td></tr>
<tr><td style="text-align: left">filePermissions</td><td style="text-align: left">String</td><td style="text-align: left">File attribute permissions in POSIX format to apply whenever the file is created.Underlying files system shall support <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFileAttributeView.html">POSIX</a> file attribute view.Examples: rw------- or rw-rw-rw- etc...</td></tr>
<tr><td style="text-align: left">fileOwner</td><td style="text-align: left">String</td><td style="text-align: left">File owner to define whenever the file is created.Changing file's owner may be restricted for security reason and Operation not permitted IOException thrown. Only processes with an effective user ID equal to the user ID of the file or with appropriate privileges may change the ownership of a file if <a href="http://www.gnu.org/software/libc/manual/html_node/Options-for-Files.html">_POSIX_CHOWN_RESTRICTED</a> is in effect for path.Underlying files system shall support file <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/FileOwnerAttributeView.html">owner</a> attribute view.</td></tr>
<tr><td style="text-align: left">fileGroup</td><td style="text-align: left">String</td><td style="text-align: left">File group to define whenever the file is created.Underlying files system shall support <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFileAttributeView.html">POSIX</a> file attribute view.</td></tr>
</tbody></table>
<h1 id="triggering-policies"><a class="header" href="#triggering-policies">Triggering Policies</a></h1>
<h2 id="composite-triggering-policy"><a class="header" href="#composite-triggering-policy">Composite Triggering Policy</a></h2>
<p>CompositeTriggeringPolicy 组合了多个触发策略，如果任何配置的策略返回 true，则返回 true。</p>
<p>CompositeTriggeringPolicy 只需将其他策略包装在 Policies 元素中即可配置。</p>
<p>例如，以下 XML 片段定义了在 JVM 启动、日志大小达到 20 兆字节、以及当前日期不再与日志的开始日期匹配时滚动日志的策略。</p>
<pre><code class="language-xml">&lt;Policies&gt;
  &lt;OnStartupTriggeringPolicy /&gt;
  &lt;SizeBasedTriggeringPolicy size=&quot;20 MB&quot; /&gt;
  &lt;TimeBasedTriggeringPolicy /&gt;
&lt;/Policies&gt;
</code></pre>
<h2 id="cron-triggering-policy"><a class="header" href="#cron-triggering-policy">Cron Triggering Policy</a></h2>
<p>CronTriggeringPolicy 基于 cron 表达式触发翻转</p>
<h3 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h3>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">schedule</td><td style="text-align: left">String</td><td style="text-align: left">cron 表达式。该表达式与 Quartz 调度程序中允许的表达式相同。 See <a href="http://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/util/CronExpression.html">CronExpression</a> for a full description of the expression.</td></tr>
<tr><td style="text-align: left">evaluateOnStartup</td><td style="text-align: left">boolean</td><td style="text-align: left">启动时，cron 表达式将根据文件的最后修改时间戳进行评估。<br/>如果 cron 表达式指示在该时间和当前时间之间应该发生翻转，则文件将立即翻转。</td></tr>
</tbody></table>
<h2 id="onstartup-triggering-policy"><a class="header" href="#onstartup-triggering-policy">OnStartup Triggering Policy</a></h2>
<p>如果日志文件早于当前 JVM 的启动时间并且达到或超过最小文件大小，则 OnStartupTriggeringPolicy 策略会导致翻转。</p>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">minSize</td><td style="text-align: left">long</td><td style="text-align: left">文件必须翻转的最小大小。<br/>无论文件大小如何，大小为零都会导致翻转。<br/>默认值为 1，这将防止滚动空文件。</td></tr>
</tbody></table>
<h2 id="sizebased-triggering-policy"><a class="header" href="#sizebased-triggering-policy">SizeBased Triggering Policy</a></h2>
<p>一旦文件达到指定的大小，SizeBasedTriggeringPolicy 会导致翻转。</p>
<p>大小可以以字节为单位指定，后缀为 KB、MB 或 GB，例如 20MB。</p>
<p>当与基于时间的触发策略结合使用时，文件模式必须包含 %i 否则目标文件将在每次翻转时被覆盖，因为 SizeBased 触发策略不会导致文件名中的时间戳值发生更改。</p>
<p>当在没有基于时间的触发策略的情况下使用时，SizeBased 触发策略将导致时间戳值发生变化。</p>
<h2 id="timebased-triggering-policy"><a class="header" href="#timebased-triggering-policy">TimeBased Triggering Policy</a></h2>
<p>一旦日期/时间模式不再适用于活动文件， TimeBasedTriggeringPolicy 会导致翻转。</p>
<p>此策略接受一个间隔属性，该属性指示基于时间模式和  一个boolean属性指示是否 应该调整间隔以使得下一次翻转发生在边界上。</p>
<h3 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h3>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">interval</td><td style="text-align: left">integer</td><td style="text-align: left">根据日期模式中最具体的时间单位，应多久进行一次翻转。.例如，日期模式以小时为最具体的项目，并且每 4 小时会发生 4 次翻转。. The default value is 1.</td></tr>
<tr><td style="text-align: left">modulate</td><td style="text-align: left">boolean</td><td style="text-align: left">指示是否应调整间隔以使下一次翻转发生在间隔边界上。. 例如，如果项目是小时，当前小时是凌晨 3 点，间隔是 4，那么第一次翻转将在凌晨 4 点发生，然后下一次翻转将在上午 8 点、中午、下午 4 点等发生。</td></tr>
<tr><td style="text-align: left">maxRandomDelay</td><td style="text-align: left">integer</td><td style="text-align: left">Indicates the maximum number of seconds to randomly delay a rollover. By default, this is 0 which indicates no delay. This setting is useful on servers where multiple applications are configured to rollover log files at the same time and can spread the load of doing so across time.</td></tr>
</tbody></table>
<h1 id="rollover-strategies"><a class="header" href="#rollover-strategies">Rollover Strategies</a></h1>
<h2 id="default-rollover-strategy"><a class="header" href="#default-rollover-strategy">Default Rollover Strategy</a></h2>
<p>默认翻转策略接受日期/时间模式和一个在整数 </p>
<p>上述属性在 RollingFileAppender  本身上指定该</p>
<p>如果存在日期/时间模式，它将被当前的日期和时间值替换。</p>
<p>如果模式包含一个整数，它将在每次翻转时递增。</p>
<p>如果模式中同时包含日期/时间和整数，则整数将递增，直到日期/时间模式的结果发生变化。</p>
<p>如果文件模式以“.gz”、“.zip”、“.bz2”、“.deflate”、“.pack200”或“.xz”结尾，则生成的存档将使用与后缀匹配的压缩方案进行压缩</p>
<p>bzip2、Deflate、Pack200 和 XZ 格式需要 Apache Commons Compress。</p>
<p>此外，XZ 需要 XZ for Java。</p>
<p>该模式还可能包含可以在运行时解析的查找引用，如下例所示。</p>
<p>默认翻转策略支持三种递增计数器的变体。</p>
<p>假设 min 属性设置为 1，max 属性设置为 3，文件名为“foo.log”，文件名模式为“foo-%i.log”。</p>
<table><thead><tr><th style="text-align: left">Number of rollovers</th><th style="text-align: left">Active output target</th><th style="text-align: left">Archived log files</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">0</td><td style="text-align: left">foo.log</td><td style="text-align: left">-</td><td style="text-align: left">All logging is going to the initial file.</td></tr>
<tr><td style="text-align: left">1</td><td style="text-align: left">foo.log</td><td style="text-align: left">foo-1.log</td><td style="text-align: left">在第一次翻转期间，foo.log 被重命名为 foo-1.log。一个新的 foo.log 文件被创建并开始写入。</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left">foo.log</td><td style="text-align: left">foo-2.log, foo-1.log</td><td style="text-align: left">在第二次翻转期间，foo.log 被重命名为 foo-2.log。<br />一个新的 foo.log 文件被创建并开始写入。</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left">foo.log</td><td style="text-align: left">foo-3.log, foo-2.log, foo-1.log</td><td style="text-align: left">在第三次翻转期间，foo.log 被重命名为 foo-3.log。一个新的 foo.log 文件被创建并开始写入。</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left">foo.log</td><td style="text-align: left">foo-3.log, foo-2.log, foo-1.log</td><td style="text-align: left">在第四次及以后的翻转中，foo-1.log被删除，foo-2.log被重命名为foo-1.log，foo-3.log被重命名为foo-2.log，foo.log被重命名为foo-3.日志。<br/>一个新的 foo.log 文件被创建并开始写入。</td></tr>
</tbody></table>
<p>相比之下，当 fileIndex 属性设置为“min”但所有其他设置都相同时，将执行“固定窗口”策略。</p>
<table><thead><tr><th style="text-align: left">Number of rollovers</th><th style="text-align: left">Active output target</th><th style="text-align: left">Archived log files</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">0</td><td style="text-align: left">foo.log</td><td style="text-align: left">-</td><td style="text-align: left">All logging is going to the initial file.</td></tr>
<tr><td style="text-align: left">1</td><td style="text-align: left">foo.log</td><td style="text-align: left">foo-1.log</td><td style="text-align: left">During the first rollover foo.log is renamed to foo-1.log. A new foo.log file is created and starts being written to.</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left">foo.log</td><td style="text-align: left">foo-1.log, foo-2.log</td><td style="text-align: left">During the second rollover foo-1.log is renamed to foo-2.log and foo.log is renamed to foo-1.log. A new foo.log file is created and starts being written to.</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left">foo.log</td><td style="text-align: left">foo-1.log, foo-2.log, foo-3.log</td><td style="text-align: left">During the third rollover foo-2.log is renamed to foo-3.log, foo-1.log is renamed to foo-2.log and foo.log is renamed to foo-1.log. A new foo.log file is created and starts being written to.</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left">foo.log</td><td style="text-align: left">foo-1.log, foo-2.log, foo-3.log</td><td style="text-align: left">In the fourth and subsequent rollovers, foo-3.log is deleted, foo-2.log is renamed to foo-3.log, foo-1.log is renamed to foo-2.log and foo.log is renamed to foo-1.log. A new foo.log file is created and starts being written to.</td></tr>
</tbody></table>
<p>最后，从 2.8 版开始，如果 fileIndex 属性设置为“nomax”，那么最小值和最大值将被忽略，文件编号将增加 1，并且每次翻转都会有一个递增的更高值，没有最大文件数。</p>
<h3 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h3>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">fileIndex</td><td style="text-align: left">String</td><td style="text-align: left">If set to &quot;max&quot; (the default), files with a higher index will be newer than files with a smaller index. If set to &quot;min&quot;, file renaming and the counter will follow the Fixed Window strategy described above.</td></tr>
<tr><td style="text-align: left">min</td><td style="text-align: left">integer</td><td style="text-align: left">The minimum value of the counter. The default value is 1.</td></tr>
<tr><td style="text-align: left">max</td><td style="text-align: left">integer</td><td style="text-align: left">The maximum value of the counter. Once this values is reached older archives will be deleted on subsequent rollovers. The default value is 7.</td></tr>
<tr><td style="text-align: left">compressionLevel</td><td style="text-align: left">integer</td><td style="text-align: left">Sets the compression level, 0-9, where 0 = none, 1 = best speed, through 9 = best compression. Only implemented for ZIP files.</td></tr>
<tr><td style="text-align: left">tempCompressedFilePattern</td><td style="text-align: left">String</td><td style="text-align: left">The pattern of the file name of the archived log file during compression.</td></tr>
</tbody></table>
<h2 id="directwrite-rollover-strategy"><a class="header" href="#directwrite-rollover-strategy">DirectWrite Rollover Strategy</a></h2>
<p>DirectWriteRolloverStrategy 使日志事件直接写入由文件模式表示的文件。</p>
<p>使用此策略不会执行文件重命名。</p>
<p>如果基于大小的触发策略导致在指定时间段内写入多个文件，它们将从 1 开始编号并不断递增，直到发生基于时间的翻转。</p>
<p>警告：如果文件模式有一个表示应该进行压缩的后缀，则当应用程序关闭时，当前文件将不会被压缩。</p>
<p>此外，如果时间改变以致文件模式不再与当前文件匹配，则它也不会在启动时被压缩。</p>
<h3 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h3>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">maxFiles</td><td style="text-align: left">String</td><td style="text-align: left">The maximum number of files to allow in the time period matching the file pattern. If the number of files is exceeded the oldest file will be deleted. If specified, the value must be greater than 1. If the value is less than zero or omitted then the number of files will not be limited.</td></tr>
<tr><td style="text-align: left">compressionLevel</td><td style="text-align: left">integer</td><td style="text-align: left">Sets the compression level, 0-9, where 0 = none, 1 = best speed, through 9 = best compression. Only implemented for ZIP files.</td></tr>
<tr><td style="text-align: left">tempCompressedFilePattern</td><td style="text-align: left">String</td><td style="text-align: left">The pattern of the file name of the archived log file during compression.</td></tr>
</tbody></table>
<p>下面是一个示例配置，它使用具有基于时间和大小的触发策略的 RollingFileAppender，将在同一天 (1-7) 创建多达 7 个存档，这些存档存储在基于当前年和月的目录中，并将</p>
<p>使用 gzip 压缩每个存档：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Appenders&gt;
    &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;logs/app.log&quot;
                 filePattern=&quot;logs/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz&quot;&gt;
      &lt;PatternLayout&gt;
        &lt;Pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/Pattern&gt;
      &lt;/PatternLayout&gt;
      &lt;Policies&gt;
        &lt;TimeBasedTriggeringPolicy /&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;250 MB&quot;/&gt;
      &lt;/Policies&gt;
    &lt;/RollingFile&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;

</code></pre>
<p>第二个示例显示了一个翻转策略，该策略将在删除之前最多保留 20 个文件。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Appenders&gt;
    &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;logs/app.log&quot;
                 filePattern=&quot;logs/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz&quot;&gt;
      &lt;PatternLayout&gt;
        &lt;Pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/Pattern&gt;
      &lt;/PatternLayout&gt;
      &lt;Policies&gt;
        &lt;TimeBasedTriggeringPolicy /&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;250 MB&quot;/&gt;
      &lt;/Policies&gt;
      &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt;
    &lt;/RollingFile&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<p>下面是一个示例配置，它使用具有基于时间和大小的触发策略的 RollingFileAppender，将在同一天 (1-7) 创建多达 7 个存档，这些存档存储在基于当前年和月的目录中，并将</p>
<p>使用 gzip 压缩每个存档，当小时可被 6 整除时，将每 6 小时滚动一次：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Appenders&gt;
    &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;logs/app.log&quot;
                 filePattern=&quot;logs/$${date:yyyy-MM}/app-%d{yyyy-MM-dd-HH}-%i.log.gz&quot;&gt;
      &lt;PatternLayout&gt;
        &lt;Pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/Pattern&gt;
      &lt;/PatternLayout&gt;
      &lt;Policies&gt;
        &lt;TimeBasedTriggeringPolicy interval=&quot;6&quot; modulate=&quot;true&quot;/&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;250 MB&quot;/&gt;
      &lt;/Policies&gt;
    &lt;/RollingFile&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<p>此示例配置使用具有基于 cron 和大小的触发策略的 RollingFileAppender，并直接写入无限数量的存档文件。 </p>
<p>cron 触发器每小时导致一次翻转，而文件大小限制为 250MB</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Appenders&gt;
    &lt;RollingFile name=&quot;RollingFile&quot; filePattern=&quot;logs/app-%d{yyyy-MM-dd-HH}-%i.log.gz&quot;&gt;
      &lt;PatternLayout&gt;
        &lt;Pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/Pattern&gt;
      &lt;/PatternLayout&gt;
      &lt;Policies&gt;
        &lt;CronTriggeringPolicy schedule=&quot;0 0 * * * ?&quot;/&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;250 MB&quot;/&gt;
      &lt;/Policies&gt;
    &lt;/RollingFile&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<p>此示例配置与前面的相同，但将每小时保存的文件数限制为 10：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Appenders&gt;
    &lt;RollingFile name=&quot;RollingFile&quot; filePattern=&quot;logs/app-%d{yyyy-MM-dd-HH}-%i.log.gz&quot;&gt;
      &lt;PatternLayout&gt;
        &lt;Pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/Pattern&gt;
      &lt;/PatternLayout&gt;
      &lt;Policies&gt;
        &lt;CronTriggeringPolicy schedule=&quot;0 0 * * * ?&quot;/&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;250 MB&quot;/&gt;
      &lt;/Policies&gt;
      &lt;DirectWriteRolloverStrategy maxFiles=&quot;10&quot;/&gt;
    &lt;/RollingFile&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<h2 id="log-archive-retention-policy"><a class="header" href="#log-archive-retention-policy">Log Archive Retention Policy</a></h2>
<blockquote>
<p>Delete on Rollover</p>
</blockquote>
<p>Log4j-2.5 引入了一个 Delete 操作，与 DefaultRolloverStrategy max 属性相比，它使用户可以更好地控制在翻转时删除哪些文件。</p>
<p>删除操作允许用户配置一个或多个条件来选择相对于基本目录删除的文件。</p>
<p>请注意，可以删除任何文件，而不仅仅是滚动日志文件，因此请谨慎使用此操作！</p>
<p>使用 testMode 参数，您可以测试您的配置，而不会意外删除错误的文件。</p>
<h3 id="parameters-6"><a class="header" href="#parameters-6">Parameters</a></h3>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">basePath</td><td style="text-align: left">String</td><td style="text-align: left"><em>Required.</em> Base path from where to start scanning for files to delete.</td></tr>
<tr><td style="text-align: left">maxDepth</td><td style="text-align: left">int</td><td style="text-align: left">要访问的目录的最大级别数。<br/>值 0 表示仅访问起始文件（基本路径本身），除非被安全管理器拒绝。 <br/>Integer.MAX_VALUE 值表示应该访问所有级别。默认值为 1，表示仅指定基目录中的文件。</td></tr>
<tr><td style="text-align: left">followLinks</td><td style="text-align: left">boolean</td><td style="text-align: left">Whether to follow symbolic links. Default is false.</td></tr>
<tr><td style="text-align: left">testMode</td><td style="text-align: left">boolean</td><td style="text-align: left">如果为 true，则不会删除文件，而是在 INFO 级别将消息打印到 <a href="http://logging.apache.org/log4j/2.x/manual/configuration.html#StatusMessages">状态记录器</a>。</td></tr>
<tr><td style="text-align: left">pathSorter</td><td style="text-align: left">PathSorter</td><td style="text-align: left">实现 <a href="http://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/appender/rolling/action/PathSorter.html">PathSorter</a><br/>在选择要删除的文件之前对文件进行排序的界面。<br/>默认设置是首先对最近修改的文件进行排序。</td></tr>
<tr><td style="text-align: left">pathConditions</td><td style="text-align: left">PathCondition[]</td><td style="text-align: left">如果未指定 ScriptCondition 则为必需 ,一个或多个 PathCondition 元素。如果指定了多个条件，则它们都需要接受条件才能删除, 条件可以嵌套，在这种情况下，仅当外部条件接受路径时才评估内部条件.如果条件不是嵌套的，它们可以按任何顺序进行计算。条件也可以通过使用 IfAll、IfAny 和 IfNot 复合条件与逻辑运算符 AND、OR 和 NOT 组合。.Users can create custom conditions or use the built-in conditions:<a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#DeleteIfFileName">IfFileName</a> - accepts files whose path (relative to the base path) matches a <a href="https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html">regular expression</a> or a <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/FileSystem.html#getPathMatcher(java.lang.String)">glob</a>.<a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#DeleteIfLastModified">IfLastModified</a> - accepts files that are as old as or older than the specified <a href="http://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/appender/rolling/action/Duration.html#parseCharSequence">duration</a>.<a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#DeleteIfAccumulatedFileCount">IfAccumulatedFileCount</a> - accepts paths after some count threshold is exceeded during the file tree walk.<a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#DeleteIfAccumulatedFileSize">IfAccumulatedFileSize</a> - accepts paths after the accumulated file size threshold is exceeded during the file tree walk.IfAll - accepts a path if all nested conditions accept it (logical AND). Nested conditions may be evaluated in any order.IfAny - accepts a path if one of the nested conditions accept it (logical OR). Nested conditions may be evaluated in any order.IfNot - accepts a path if the nested condition does not accept it (logical NOT).</td></tr>
<tr><td style="text-align: left">scriptCondition</td><td style="text-align: left">ScriptCondition</td><td style="text-align: left"><em>Required if no PathConditions are specified.</em> A ScriptCondition element specifying a script.The ScriptCondition should contain a <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#ScriptCondition">Script, ScriptRef or ScriptFile</a> element that specifies the logic to be executed. (See also the <a href="http://logging.apache.org/log4j/2.x/manual/filters.html#Script">ScriptFilter</a> documentation for more examples of configuring ScriptFiles and ScriptRefs.)The script is passed a number of <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#ScriptParameters">parameters</a>, including a list of paths found under the base path (up to maxDepth) and must return a list with the paths to delete.</td></tr>
</tbody></table>
<h3 id="iffilename-condition-parameters"><a class="header" href="#iffilename-condition-parameters">IfFileName Condition Parameters</a></h3>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">glob</td><td style="text-align: left">String</td><td style="text-align: left"><em>Required if regex not specified.</em> Matches the relative path (relative to the base path) using a limited pattern language that resembles regular expressions but with a <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/FileSystem.html#getPathMatcher(java.lang.String)">simpler syntax</a>.</td></tr>
<tr><td style="text-align: left">regex</td><td style="text-align: left">String</td><td style="text-align: left"><em>Required if glob not specified.</em> Matches the relative path (relative to the base path) using a regular expression as defined by the <a href="https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html">Pattern</a> class.</td></tr>
<tr><td style="text-align: left">nestedConditions</td><td style="text-align: left">PathCondition[]</td><td style="text-align: left">An optional set of nested <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#DeletePathCondition">PathConditions</a>. If any nested conditions exist they all need to accept the file before it is deleted. Nested conditions are only evaluated if the outer condition accepts a file (if the path name matches).</td></tr>
</tbody></table>
<h3 id="iflastmodified-condition-parameters"><a class="header" href="#iflastmodified-condition-parameters">IfLastModified Condition Parameters</a></h3>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">age</td><td style="text-align: left">String</td><td style="text-align: left"><em>Required.</em> Specifies a <a href="http://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/appender/rolling/action/Duration.html#parseCharSequence">duration</a>. The condition accepts files that are as old or older than the specified duration.</td></tr>
<tr><td style="text-align: left">nestedConditions</td><td style="text-align: left">PathCondition[]</td><td style="text-align: left">An optional set of nested <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#DeletePathCondition">PathConditions</a>. If any nested conditions exist they all need to accept the file before it is deleted. Nested conditions are only evaluated if the outer condition accepts a file (if the file is old enough).</td></tr>
</tbody></table>
<h3 id="ifaccumulatedfilecount-condition-parameters"><a class="header" href="#ifaccumulatedfilecount-condition-parameters">IfAccumulatedFileCount Condition Parameters</a></h3>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">exceeds</td><td style="text-align: left">int</td><td style="text-align: left"><em>Required.</em> The threshold count from which files will be deleted.</td></tr>
<tr><td style="text-align: left">nestedConditions</td><td style="text-align: left">PathCondition[]</td><td style="text-align: left">An optional set of nested <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#DeletePathCondition">PathConditions</a>. If any nested conditions exist they all need to accept the file before it is deleted. Nested conditions are only evaluated if the outer condition accepts a file (if the threshold count has been exceeded).</td></tr>
</tbody></table>
<h3 id="ifaccumulatedfilesize-condition-parameters"><a class="header" href="#ifaccumulatedfilesize-condition-parameters">IfAccumulatedFileSize Condition Parameters</a></h3>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">exceeds</td><td style="text-align: left">String</td><td style="text-align: left"><em>Required.</em> The threshold accumulated file size from which files will be deleted. The size can be specified in bytes, with the suffix KB, MB or GB, for example 20MB.</td></tr>
<tr><td style="text-align: left">nestedConditions</td><td style="text-align: left">PathCondition[]</td><td style="text-align: left">An optional set of nested <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#DeletePathCondition">PathConditions</a>. If any nested conditions exist they all need to accept the file before it is deleted. Nested conditions are only evaluated if the outer condition accepts a file (if the threshold accumulated file size has been exceeded).</td></tr>
</tbody></table>
<p>下面是一个示例配置，它使用 RollingFileAppender 和配置为每天午夜触发的 cron 触发策略。</p>
<p>档案存储在基于当前年份和月份的目录中。</p>
<p>基目录下与“<em>/app-</em>.log.gz”glob 匹配且存在于 60 天或更旧的所有文件将在翻转时被删除。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Properties&gt;
    &lt;Property name=&quot;baseDir&quot;&gt;logs&lt;/Property&gt;
  &lt;/Properties&gt;
  &lt;Appenders&gt;
    &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;${baseDir}/app.log&quot;
          filePattern=&quot;${baseDir}/$${date:yyyy-MM}/app-%d{yyyy-MM-dd}.log.gz&quot;&gt;
      &lt;PatternLayout pattern=&quot;%d %p %c{1.} [%t] %m%n&quot; /&gt;
      &lt;CronTriggeringPolicy schedule=&quot;0 0 0 * * ?&quot;/&gt;
      &lt;DefaultRolloverStrategy&gt;
        &lt;Delete basePath=&quot;${baseDir}&quot; maxDepth=&quot;2&quot;&gt;
          &lt;IfFileName glob=&quot;*/app-*.log.gz&quot; /&gt;
          &lt;IfLastModified age=&quot;60d&quot; /&gt;
        &lt;/Delete&gt;
      &lt;/DefaultRolloverStrategy&gt;
    &lt;/RollingFile&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<p>下面是一个示例配置，它使用具有基于时间和大小的触发策略的 RollingFileAppender，将在同一天 (1-100) 创建多达 100 个存档，这些存档存储在基于当前年和月的目录中，并将</p>
<p>使用 gzip 压缩每个存档，并将每小时滚动一次。</p>
<p>在每次翻转期间，此配置将删除与“<em>/app-</em>.log.gz”匹配且 30 天或更旧的文件，但保留最近的 100 GB 或最近的 10 个文件，以先到者为准。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Properties&gt;
    &lt;Property name=&quot;baseDir&quot;&gt;logs&lt;/Property&gt;
  &lt;/Properties&gt;
  &lt;Appenders&gt;
    &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;${baseDir}/app.log&quot;
          filePattern=&quot;${baseDir}/$${date:yyyy-MM}/app-%d{yyyy-MM-dd-HH}-%i.log.gz&quot;&gt;
      &lt;PatternLayout pattern=&quot;%d %p %c{1.} [%t] %m%n&quot; /&gt;
      &lt;Policies&gt;
        &lt;TimeBasedTriggeringPolicy /&gt;
        &lt;SizeBasedTriggeringPolicy size=&quot;250 MB&quot;/&gt;
      &lt;/Policies&gt;
      &lt;DefaultRolloverStrategy max=&quot;100&quot;&gt;
        &lt;!--
        Nested conditions: the inner condition is only evaluated on files
        for which the outer conditions are true.
        --&gt;
        &lt;Delete basePath=&quot;${baseDir}&quot; maxDepth=&quot;2&quot;&gt;
          &lt;IfFileName glob=&quot;*/app-*.log.gz&quot;&gt;
            &lt;IfLastModified age=&quot;30d&quot;&gt;
              &lt;IfAny&gt;
                &lt;IfAccumulatedFileSize exceeds=&quot;100 GB&quot; /&gt;
                &lt;IfAccumulatedFileCount exceeds=&quot;10&quot; /&gt;
              &lt;/IfAny&gt;
            &lt;/IfLastModified&gt;
          &lt;/IfFileName&gt;
        &lt;/Delete&gt;
      &lt;/DefaultRolloverStrategy&gt;
    &lt;/RollingFile&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<h3 id="scriptcondition-parameters"><a class="header" href="#scriptcondition-parameters">ScriptCondition Parameters</a></h3>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">script</td><td style="text-align: left">Script, ScriptFile or ScriptRef</td><td style="text-align: left">The Script element that specifies the logic to be executed. The script is passed a list of paths found under the base path and must return the paths to delete as a java.util.List&lt;<a href="http://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/appender/rolling/action/PathWithAttributes.html">PathWithAttributes</a>&gt;. See also the <a href="http://logging.apache.org/log4j/2.x/manual/filters.html#Script">ScriptFilter</a> documentation for an example of how ScriptFiles and ScriptRefs can be configured.</td></tr>
</tbody></table>
<h3 id="script-parameters"><a class="header" href="#script-parameters">Script Parameters</a></h3>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">basePath</td><td style="text-align: left">java.nio.file.Path</td><td style="text-align: left">The directory from where the Delete action started scanning for files to delete. Can be used to relativize the paths in the pathList.</td></tr>
<tr><td style="text-align: left">pathList</td><td style="text-align: left">java.util.List&lt;<a href="http://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/appender/rolling/action/PathWithAttributes.html">PathWithAttributes</a>&gt;</td><td style="text-align: left">The list of paths found under the base path up to the specified max depth, sorted most recently modified files first. The script is free to modify and return this list.</td></tr>
<tr><td style="text-align: left">statusLogger</td><td style="text-align: left">StatusLogger</td><td style="text-align: left">The StatusLogger that can be used to log internal events during script execution.</td></tr>
<tr><td style="text-align: left">configuration</td><td style="text-align: left">Configuration</td><td style="text-align: left">The Configuration that owns this ScriptCondition.</td></tr>
<tr><td style="text-align: left">substitutor</td><td style="text-align: left">StrSubstitutor</td><td style="text-align: left">The StrSubstitutor used to replace lookup variables.</td></tr>
<tr><td style="text-align: left">?</td><td style="text-align: left">String</td><td style="text-align: left">Any properties declared in the configuration.</td></tr>
</tbody></table>
<p>下面是一个示例配置，它使用 RollingFileAppender 和配置为每天午夜触发的 cron 触发策略。</p>
<p>档案存储在基于当前年份和月份的目录中。</p>
<p>该脚本返回日期为 13 日星期五的基本目录下的滚动文件列表。</p>
<p>删除操作将删除脚本返回的所有文件。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;trace&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Properties&gt;
    &lt;Property name=&quot;baseDir&quot;&gt;logs&lt;/Property&gt;
  &lt;/Properties&gt;
  &lt;Appenders&gt;
    &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;${baseDir}/app.log&quot;
          filePattern=&quot;${baseDir}/$${date:yyyy-MM}/app-%d{yyyyMMdd}.log.gz&quot;&gt;
      &lt;PatternLayout pattern=&quot;%d %p %c{1.} [%t] %m%n&quot; /&gt;
      &lt;CronTriggeringPolicy schedule=&quot;0 0 0 * * ?&quot;/&gt;
      &lt;DefaultRolloverStrategy&gt;
        &lt;Delete basePath=&quot;${baseDir}&quot; maxDepth=&quot;2&quot;&gt;
          &lt;ScriptCondition&gt;
            &lt;Script name=&quot;superstitious&quot; language=&quot;groovy&quot;&gt;&lt;![CDATA[
                import java.nio.file.*;
 
                def result = [];
                def pattern = ~/\d*\/app-(\d*)\.log\.gz/;
 
                pathList.each { pathWithAttributes -&gt;
                  def relative = basePath.relativize pathWithAttributes.path
                  statusLogger.trace 'SCRIPT: relative path=' + relative + &quot; (base=$basePath)&quot;;
 
                  // remove files dated Friday the 13th
 
                  def matcher = pattern.matcher(relative.toString());
                  if (matcher.find()) {
                    def dateString = matcher.group(1);
                    def calendar = Date.parse(&quot;yyyyMMdd&quot;, dateString).toCalendar();
                    def friday13th = calendar.get(Calendar.DAY_OF_MONTH) == 13 \
                                  &amp;&amp; calendar.get(Calendar.DAY_OF_WEEK) == Calendar.FRIDAY;
                    if (friday13th) {
                      result.add pathWithAttributes;
                      statusLogger.trace 'SCRIPT: deleting path ' + pathWithAttributes;
                    }
                  }
                }
                statusLogger.trace 'SCRIPT: returning ' + result;
                result;
              ]] &gt;
            &lt;/Script&gt;
          &lt;/ScriptCondition&gt;
        &lt;/Delete&gt;
      &lt;/DefaultRolloverStrategy&gt;
    &lt;/RollingFile&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<h2 id="log-archive-file-attribute-view-policy"><a class="header" href="#log-archive-file-attribute-view-policy">Log Archive File Attribute View Policy</a></h2>
<blockquote>
<p>Custom file attribute on Rollover</p>
</blockquote>
<p>og4j-2.9 引入了 PosixViewAttribute 操作，使用户可以更好地控制应应用哪些文件属性权限、所有者和组。 </p>
<p>PosixViewAttribute 操作允许用户配置一个或多个条件来选择相对于基目录的合格文件。</p>
<h3 id="posixviewattribute-parameters"><a class="header" href="#posixviewattribute-parameters">PosixViewAttribute Parameters</a></h3>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">basePath</td><td style="text-align: left">String</td><td style="text-align: left"><em>Required.</em> Base path from where to start scanning for files to apply attributes.</td></tr>
<tr><td style="text-align: left">maxDepth</td><td style="text-align: left">int</td><td style="text-align: left">The maximum number of levels of directories to visit. A value of 0 means that only the starting file (the base path itself) is visited, unless denied by the security manager. A value of Integer.MAX_VALUE indicates that all levels should be visited. The default is 1, meaning only the files in the specified base directory.</td></tr>
<tr><td style="text-align: left">followLinks</td><td style="text-align: left">boolean</td><td style="text-align: left">Whether to follow symbolic links. Default is false.</td></tr>
<tr><td style="text-align: left">pathConditions</td><td style="text-align: left">PathCondition[]</td><td style="text-align: left">see <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#DeletePathCondition">DeletePathCondition</a></td></tr>
<tr><td style="text-align: left">filePermissions</td><td style="text-align: left">String</td><td style="text-align: left">File attribute permissions in POSIX format to apply when action is executed.Underlying files system shall support <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFileAttributeView.html">POSIX</a> file attribute view.Examples: rw------- or rw-rw-rw- etc...</td></tr>
<tr><td style="text-align: left">fileOwner</td><td style="text-align: left">String</td><td style="text-align: left">File owner to define when action is executed.Changing file's owner may be restricted for security reason and Operation not permitted IOException thrown. Only processes with an effective user ID equal to the user ID of the file or with appropriate privileges may change the ownership of a file if <a href="http://www.gnu.org/software/libc/manual/html_node/Options-for-Files.html">_POSIX_CHOWN_RESTRICTED</a> is in effect for path.Underlying files system shall support file <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/FileOwnerAttributeView.html">owner</a> attribute view.</td></tr>
<tr><td style="text-align: left">fileGroup</td><td style="text-align: left">String</td><td style="text-align: left">File group to define when action is executed.Underlying files system shall support <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFileAttributeView.html">POSIX</a> file attribute view.</td></tr>
</tbody></table>
<p>以下是使用 RollingFileAppender 并为当前和滚动日志文件定义不同 POSIX 文件属性视图的示例配置。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;trace&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Properties&gt;
    &lt;Property name=&quot;baseDir&quot;&gt;logs&lt;/Property&gt;
  &lt;/Properties&gt;
  &lt;Appenders&gt;
    &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;${baseDir}/app.log&quot;
          		 filePattern=&quot;${baseDir}/$${date:yyyy-MM}/app-%d{yyyyMMdd}.log.gz&quot;
                 filePermissions=&quot;rw-------&quot;&gt;
      &lt;PatternLayout pattern=&quot;%d %p %c{1.} [%t] %m%n&quot; /&gt;
      &lt;CronTriggeringPolicy schedule=&quot;0 0 0 * * ?&quot;/&gt;
      &lt;DefaultRolloverStrategy stopCustomActionsOnError=&quot;true&quot;&gt;
        &lt;PosixViewAttribute basePath=&quot;${baseDir}/$${date:yyyy-MM}&quot; filePermissions=&quot;r--r--r--&quot;&gt;
        	&lt;IfFileName glob=&quot;*.gz&quot; /&gt;
        &lt;/PosixViewAttribute&gt;
      &lt;/DefaultRolloverStrategy&gt;
    &lt;/RollingFile&gt;
  &lt;/Appenders&gt;
 
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
 
&lt;/Configuration&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rollingrandomaccessfileappender"><a class="header" href="#rollingrandomaccessfileappender">RollingRandomAccessFileAppender</a></h1>
<p>RollingRandomAccessFileAppender 类似于标准的 RollingFileAppender，除了它总是被缓冲（不能关闭）并且在内部它使用 ByteBuffer + RandomAccessFile 而不是 BufferedOutputStream。</p>
<p>在我们的测量中，与使用“bufferedIO=true”的 RollingFileAppender 相比，我们看到了 20-200% 的性能提升。 </p>
<p>RollingRandomAccessFileAppender 写入在 fileName 参数中命名的 File 并根据 TriggeringPolicy 和 RolloverPolicy 滚动文件。</p>
<p>与 RollingFileAppender 类似，RollingRandomAccessFileAppender 使用 RollingRandomAccessFileManager 来实际执行文件 I/O 并执行翻转。</p>
<p>虽然无法共享来自不同配置的 RollingRandomAccessFileAppender，但如果 Manager 可访问，则 RollingRandomAccessFileManagers 可以共享。</p>
<p>例如，servlet 容器中的两个 Web 应用程序可以有自己的配置，并且如果 Log4j 位于它们公共的 ClassLoader 中，则可以安全地写入同一个文件。</p>
<p>RollingRandomAccessFileAppender 需要 TriggeringPolicy 和 RolloverStrategy。</p>
<p>触发策略确定是否应该执行翻转，而 RolloverStrategy 定义应该如何完成翻转。</p>
<p>如果没有配置 RolloverStrategy，RollingRandomAccessFileAppender 将使用 DefaultRolloverStrategy。</p>
<p>从 log4j-2.5 开始，可以在 DefaultRolloverStrategy 中配置自定义删除操作以在翻转时运行。</p>
<p>RollingRandomAccessFileAppender 不支持文件锁定。</p>
<h1 id="rollingrandomaccessfileappender-parameters"><a class="header" href="#rollingrandomaccessfileappender-parameters">RollingRandomAccessFileAppender Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">append</td><td style="text-align: left">boolean</td><td style="text-align: left">When true - the default, records will be appended to the end of the file. When set to false, the file will be cleared before new records are written.</td></tr>
<tr><td style="text-align: left">filter</td><td style="text-align: left">Filter</td><td style="text-align: left">A Filter to determine if the event should be handled by this Appender. More than one Filter may be used by using a CompositeFilter.</td></tr>
<tr><td style="text-align: left">fileName</td><td style="text-align: left">String</td><td style="text-align: left">The name of the file to write to. If the file, or any of its parent directories, do not exist, they will be created.</td></tr>
<tr><td style="text-align: left">filePattern</td><td style="text-align: left">String</td><td style="text-align: left">The pattern of the file name of the archived log file. The format of the pattern should is dependent on the RolloverStrategu that is used. The DefaultRolloverStrategy will accept both a date/time pattern compatible with <a href="http://download.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat</a> and/or a %i which represents an integer counter. The integer counter allows specifying a padding, like %3i for space-padding the counter to 3 digits or (usually more useful) %03i for zero-padding the counter to 3 digits. The pattern also supports interpolation at runtime so any of the Lookups (such as the <a href="http://logging.apache.org/log4j/2.x/manual/lookups.html#DateLookup">DateLookup</a> can be included in the pattern.</td></tr>
<tr><td style="text-align: left">immediateFlush</td><td style="text-align: left">boolean</td><td style="text-align: left">When set to true - the default, each write will be followed by a flush. This will guarantee the data is written to disk but could impact performance.Flushing after every write is only useful when using this appender with synchronous loggers. Asynchronous loggers and appenders will automatically flush at the end of a batch of events, even if immediateFlush is set to false. This also guarantees the data is written to disk but is more efficient.</td></tr>
<tr><td style="text-align: left">bufferSize</td><td style="text-align: left">int</td><td style="text-align: left">The buffer size, defaults to 262,144 bytes (256 * 1024).</td></tr>
<tr><td style="text-align: left">layout</td><td style="text-align: left">Layout</td><td style="text-align: left">The Layout to use to format the LogEvent. If no layout is supplied the default pattern layout of &quot;%m%n&quot; will be used.</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">String</td><td style="text-align: left">The name of the Appender.</td></tr>
<tr><td style="text-align: left">policy</td><td style="text-align: left">TriggeringPolicy</td><td style="text-align: left">The policy to use to determine if a rollover should occur.</td></tr>
<tr><td style="text-align: left">strategy</td><td style="text-align: left">RolloverStrategy</td><td style="text-align: left">The strategy to use to determine the name and location of the archive file.</td></tr>
<tr><td style="text-align: left">ignoreExceptions</td><td style="text-align: left">boolean</td><td style="text-align: left">The default is true, causing exceptions encountered while appending events to be internally logged and then ignored. When set to false exceptions will be propagated to the caller, instead. You must set this to false when wrapping this Appender in a <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#FailoverAppender">FailoverAppender</a>.</td></tr>
<tr><td style="text-align: left">filePermissions</td><td style="text-align: left">String</td><td style="text-align: left">File attribute permissions in POSIX format to apply whenever the file is created.Underlying files system shall support <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFileAttributeView.html">POSIX</a> file attribute view.Examples: rw------- or rw-rw-rw- etc...</td></tr>
<tr><td style="text-align: left">fileOwner</td><td style="text-align: left">String</td><td style="text-align: left">File owner to define whenever the file is created.Changing file's owner may be restricted for security reason and Operation not permitted IOException thrown. Only processes with an effective user ID equal to the user ID of the file or with appropriate privileges may change the ownership of a file if <a href="http://www.gnu.org/software/libc/manual/html_node/Options-for-Files.html">_POSIX_CHOWN_RESTRICTED</a> is in effect for path.Underlying files system shall support file <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/FileOwnerAttributeView.html">owner</a> attribute view.</td></tr>
<tr><td style="text-align: left">fileGroup</td><td style="text-align: left">String</td><td style="text-align: left">File group to define whenever the file is created.Underlying files system shall support <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/PosixFileAttributeView.html">POSIX</a> file attribute view.</td></tr>
</tbody></table>
<h1 id="triggering-policies-1"><a class="header" href="#triggering-policies-1">Triggering Policies</a></h1>
<p>See <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#TriggeringPolicies">RollingFileAppender Triggering Policies</a>.</p>
<h1 id="rollover-strategies-1"><a class="header" href="#rollover-strategies-1">Rollover Strategies</a></h1>
<p>See <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#RolloverStrategies">RollingFileAppender Rollover Strategies</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="routingappender"><a class="header" href="#routingappender">RoutingAppender</a></h1>
<p>RoutingAppender 评估 LogEvents，然后将它们路由到下级 Appender。</p>
<p>目标 Appender 可能是之前配置的一个 appender，可以通过它的名字来引用，也可以根据需要动态创建 Appender。 </p>
<p>RoutingAppender 应该在它引用的任何 Appender 之后配置，以允许它正确关闭。</p>
<p>您还可以使用脚本配置 RoutingAppender：您可以在 appender 启动以及为日志事件选择路由时运行脚本。</p>
<h1 id="routingappender-parameters"><a class="header" href="#routingappender-parameters">RoutingAppender Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Filter</td><td style="text-align: left">Filter</td><td style="text-align: left">A Filter to determine if the event should be handled by this Appender. More than one Filter may be used by using a CompositeFilter.</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">String</td><td style="text-align: left">The name of the Appender.</td></tr>
<tr><td style="text-align: left">RewritePolicy</td><td style="text-align: left">RewritePolicy</td><td style="text-align: left">The RewritePolicy that will manipulate the LogEvent.</td></tr>
<tr><td style="text-align: left">Routes</td><td style="text-align: left">Routes</td><td style="text-align: left">包含一个或多个 Route 声明以标识选择 Appenders 的标准。</td></tr>
<tr><td style="text-align: left">Script</td><td style="text-align: left">Script</td><td style="text-align: left">This Script runs when Log4j starts the RoutingAppender and returns a String Route key to determine the default Route.This script is passed the following variables:RoutingAppender Script ParametersParameter NameTypeDescriptionconfigurationConfigurationThe active Configuration.staticVariablesMapA Map shared between all script invocations for this appender instance. This is the same map passed to the Routes Script.</td></tr>
<tr><td style="text-align: left">ignoreExceptions</td><td style="text-align: left">boolean</td><td style="text-align: left">The default is true, causing exceptions encountered while appending events to be internally logged and then ignored. When set to false exceptions will be propagated to the caller, instead. You must set this to false when wrapping this Appender in a <a href="http://logging.apache.org/log4j/2.x/manual/appenders.html#FailoverAppender">FailoverAppender</a>.</td></tr>
</tbody></table>
<p>在此示例中，脚本使“ServiceWindows”路由成为 Windows 上的默认路由，而“ServiceOther”则成为所有其他操作系统上的默认路由。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;WARN&quot; name=&quot;RoutingTest&quot;&gt;
  &lt;Appenders&gt;
    &lt;Routing name=&quot;Routing&quot;&gt;
      &lt;Script name=&quot;RoutingInit&quot; language=&quot;JavaScript&quot;&gt;&lt;![CDATA[
        importPackage(java.lang);
        System.getProperty(&quot;os.name&quot;).search(&quot;Windows&quot;) &gt; -1 ? &quot;ServiceWindows&quot; : &quot;ServiceOther&quot;;]]&gt;
      &lt;/Script&gt;
      &lt;Routes&gt;
        &lt;Route key=&quot;ServiceOther&quot;&gt;
          &lt;List name=&quot;List1&quot; /&gt;
        &lt;/Route&gt;
        &lt;Route key=&quot;ServiceWindows&quot;&gt;
          &lt;List name=&quot;List2&quot; /&gt;
        &lt;/Route&gt;
      &lt;/Routes&gt;
    &lt;/Routing&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;Routing&quot; /&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<h1 id="routes-1"><a class="header" href="#routes-1">Routes</a></h1>
<p>Routes 元素接受名为“pattern”的单个属性。</p>
<p>该模式针对所有注册的 lookups 进行评估，结果用于选择路由。</p>
<p>每个路由都可以配置一个 key。</p>
<p>如果key 与评估模式的结果匹配，则将选择该路由。</p>
<p>如果没有在 Route 上指定键，则该 Route 是默认值。</p>
<p>默认只能配置一个Route。</p>
<p>Routes 元素可能包含一个 Script 子元素。</p>
<p>如果指定，则为每个日志事件运行脚本并返回要使用的字符串路由键。</p>
<p>您必须指定模式属性或脚本元素，但不能同时指定两者。</p>
<p>每个 Route 必须引用一个 Appender。</p>
<p>如果 Route 包含 ref 属性，则 Route 将引用在配置中定义的 Appender。</p>
<p>如果 Route 包含 Appender 定义，则 Appender 将在 RoutingAppender 的上下文中创建，并且每次通过 Route 引用匹配的 Appender 名称时都会重用。</p>
<p>该脚本传递了以下变量：</p>
<p>RoutingAppender Routes Script Parameters</p>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">configuration</td><td style="text-align: left">Configuration</td><td style="text-align: left">The active Configuration.</td></tr>
<tr><td style="text-align: left">staticVariables</td><td style="text-align: left">Map</td><td style="text-align: left">A Map shared between all script invocations for this appender instance. This is the same map passed to the Routes Script.</td></tr>
<tr><td style="text-align: left">logEvent</td><td style="text-align: left">LogEvent</td><td style="text-align: left">The log event.</td></tr>
</tbody></table>
<p>在此示例中，脚本针对每个日志事件运行，并根据名为“AUDIT”的标记的存在选择路由。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;WARN&quot; name=&quot;RoutingTest&quot;&gt;
  &lt;Appenders&gt;
    &lt;Console name=&quot;STDOUT&quot; target=&quot;SYSTEM_OUT&quot; /&gt;
    &lt;Flume name=&quot;AuditLogger&quot; compress=&quot;true&quot;&gt;
      &lt;Agent host=&quot;192.168.10.101&quot; port=&quot;8800&quot;/&gt;
      &lt;Agent host=&quot;192.168.10.102&quot; port=&quot;8800&quot;/&gt;
      &lt;RFC5424Layout enterpriseNumber=&quot;18060&quot; includeMDC=&quot;true&quot; appName=&quot;MyApp&quot;/&gt;
    &lt;/Flume&gt;
    &lt;Routing name=&quot;Routing&quot;&gt;
      &lt;Routes&gt;
        &lt;Script name=&quot;RoutingInit&quot; language=&quot;JavaScript&quot;&gt;&lt;![CDATA[
          if (logEvent.getMarker() != null &amp;&amp; logEvent.getMarker().isInstanceOf(&quot;AUDIT&quot;)) {
                return &quot;AUDIT&quot;;
            } else if (logEvent.getContextMap().containsKey(&quot;UserId&quot;)) {
                return logEvent.getContextMap().get(&quot;UserId&quot;);
            }
            return &quot;STDOUT&quot;;]]&gt;
        &lt;/Script&gt;
        &lt;Route&gt;
          &lt;RollingFile
              name=&quot;Rolling-${mdc:UserId}&quot;
              fileName=&quot;${mdc:UserId}.log&quot;
              filePattern=&quot;${mdc:UserId}.%i.log.gz&quot;&gt;
            &lt;PatternLayout&gt;
              &lt;pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/pattern&gt;
            &lt;/PatternLayout&gt;
            &lt;SizeBasedTriggeringPolicy size=&quot;500&quot; /&gt;
          &lt;/RollingFile&gt;
        &lt;/Route&gt;
        &lt;Route ref=&quot;AuditLogger&quot; key=&quot;AUDIT&quot;/&gt;
        &lt;Route ref=&quot;STDOUT&quot; key=&quot;STDOUT&quot;/&gt;
      &lt;/Routes&gt;
      &lt;IdlePurgePolicy timeToLive=&quot;15&quot; timeUnit=&quot;minutes&quot;/&gt;
    &lt;/Routing&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;Routing&quot; /&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<h1 id="purge-policy"><a class="header" href="#purge-policy">Purge Policy</a></h1>
<p>outingAppender 可以配置 PurgePolicy，其目的是停止和删除由 RoutingAppender 动态创建的休眠 Appender。 </p>
<p>Log4j 当前提供 IdlePurgePolicy 作为唯一可用于清理 Appenders 的 PurgePolicy。 </p>
<p>IdlePurgePolicy 接受 2 个属性； </p>
<p>timeToLive，这是 Appender 在没有任何事件发送给它的情况下应该存活的 timeUnits 的数量，以及 timeUnit，java.util.concurrent.TimeUnit 的 String 表示，与 timeToLive 属性一起使用。</p>
<p>下面是一个示例配置，它使用 RoutingAppender 将所有 Audit 事件路由到 FlumeAppender，所有其他事件将路由到仅捕获特定事件类型的 RollingFileAppender。</p>
<p>请注意， AuditAppender 是预定义的，而 RollingFileAppenders 是根据需要创建的。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;warn&quot; name=&quot;MyApp&quot; packages=&quot;&quot;&gt;
  &lt;Appenders&gt;
    &lt;Flume name=&quot;AuditLogger&quot; compress=&quot;true&quot;&gt;
      &lt;Agent host=&quot;192.168.10.101&quot; port=&quot;8800&quot;/&gt;
      &lt;Agent host=&quot;192.168.10.102&quot; port=&quot;8800&quot;/&gt;
      &lt;RFC5424Layout enterpriseNumber=&quot;18060&quot; includeMDC=&quot;true&quot; appName=&quot;MyApp&quot;/&gt;
    &lt;/Flume&gt;
    &lt;Routing name=&quot;Routing&quot;&gt;
      &lt;Routes pattern=&quot;$${sd:type}&quot;&gt;
        &lt;Route&gt;
          &lt;RollingFile name=&quot;Rolling-${sd:type}&quot; fileName=&quot;${sd:type}.log&quot;
                       filePattern=&quot;${sd:type}.%i.log.gz&quot;&gt;
            &lt;PatternLayout&gt;
              &lt;pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/pattern&gt;
            &lt;/PatternLayout&gt;
            &lt;SizeBasedTriggeringPolicy size=&quot;500&quot; /&gt;
          &lt;/RollingFile&gt;
        &lt;/Route&gt;
        &lt;Route ref=&quot;AuditLogger&quot; key=&quot;Audit&quot;/&gt;
      &lt;/Routes&gt;
      &lt;IdlePurgePolicy timeToLive=&quot;15&quot; timeUnit=&quot;minutes&quot;/&gt;
    &lt;/Routing&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;Routing&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layouts"><a class="header" href="#layouts">Layouts</a></h1>
<ol>
<li>
<p>Appender 使用 Layout 将 LogEvent 格式化为满足消费日志事件需求的形式</p>
</li>
<li>
<p>在 Log4j 2 Layouts 中返回一个字节数组。这允许 Layout 的结果在更多类型的 Appender 中有用。但是，这意味着您需要 在大多数布局中配置 Charset ，以确保字节数组包含正确的值。</p>
</li>
<li>
<p>使用字符集的布局的根类是 org.apache.logging.log4j.core.layout.AbstractStringLayout，其中默认值为 UTF-8。每个扩展 AbstractStringLayout 的布局都可以提供自己的默认值。请参阅下面的每个布局。</p>
</li>
</ol>
<p>Log4j 2.4.1 中为 ISO-8859-1 和 US-ASCII 字符集添加了一个自定义字符编码器</p>
<p>以将 Java 8 内置的一些性能改进带到 Log4j 以便在 Java 7 上使用</p>
<p>对于仅记录日志的应用程序ISO-8859-1 字符，指定此字符集将显着提高性能。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="csv-layouts"><a class="header" href="#csv-layouts">CSV Layouts</a></h1>
<p>此布局创建逗号分隔值 (CSV) 记录并需要 Apache Commons CSV 1.4。</p>
<p>可以通过两种方式使用 CSV 布局：</p>
<ol>
<li>使用 CsvParameterLayout 记录事件参数以创建自定义数据库</li>
<li>using CsvParameterLayout to log event parameters to create a custom database, usually to a logger and file appender uniquely configured for this purpose.</li>
<li>其次，使用 CsvLogEventLayout 记录事件以创建数据库，作为使用完整 DBMS 或使用支持 CSV 格式的 JDBC 驱动程序的替代方法。</li>
</ol>
<p>CsvParameterLayout 将事件的参数转换为 CSV 记录，忽略消息。要记录 CSV 记录，您可以使用常用的 Logger 方法 info()、debug() 等：</p>
<pre><code>logger.info(&quot;Ignored&quot;, value1, value2, value3);
</code></pre>
<p>Which will create the CSV record:</p>
<pre><code>value1, value2, value3
</code></pre>
<p>或者，您可以使用仅携带参数的 ObjectArrayMessage：</p>
<pre><code>logger.info(new ObjectArrayMessage(value1, value2, value3));
</code></pre>
<p>CsvParameterLayout and CsvLogEventLayout</p>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">format</td><td style="text-align: left">String</td><td style="text-align: left">One of the predefined formats: Default, Excel, MySQL, RFC4180, TDF. See <a href="https://commons.apache.org/proper/commons-csv/archives/1.4/apidocs/org/apache/commons/csv/CSVFormat.Predefined.html">CSVFormat.Predefined</a>.</td></tr>
<tr><td style="text-align: left">delimiter</td><td style="text-align: left">Character</td><td style="text-align: left">分隔符</td></tr>
<tr><td style="text-align: left">escape</td><td style="text-align: left">Character</td><td style="text-align: left">转义字符</td></tr>
<tr><td style="text-align: left">quote</td><td style="text-align: left">Character</td><td style="text-align: left">quoteChar</td></tr>
<tr><td style="text-align: left">quoteMode</td><td style="text-align: left">String</td><td style="text-align: left">Sets the output quote policy of the format to the specified value. One of: ALL, MINIMAL, NON_NUMERIC, NONE.</td></tr>
<tr><td style="text-align: left">nullString</td><td style="text-align: left">String</td><td style="text-align: left">Writes null as the given nullString when writing records.</td></tr>
<tr><td style="text-align: left">recordSeparator</td><td style="text-align: left">String</td><td style="text-align: left">Sets the record separator of the format to the specified String.</td></tr>
<tr><td style="text-align: left">charset</td><td style="text-align: left">Charset</td><td style="text-align: left">The output Charset.</td></tr>
<tr><td style="text-align: left">header</td><td style="text-align: left">Sets the header to include when the stream is opened.</td><td style="text-align: left">Desc.</td></tr>
<tr><td style="text-align: left">footer</td><td style="text-align: left">Sets the footer to include when the stream is closed.</td><td style="text-align: left">Desc.</td></tr>
</tbody></table>
<p>Logging as a CSV events looks like this:</p>
<pre><code>logger.debug(&quot;one={}, two={}, three={}&quot;, 1, 2, 3);
</code></pre>
<p>生成包含以下字段的 CSV 记录：</p>
<ol>
<li>Time Nanos</li>
<li>Time Millis</li>
<li>Level</li>
<li>Thread ID</li>
<li>Thread Name</li>
<li>Thread Priority</li>
<li>Formatted Message</li>
<li>Logger FQCN</li>
<li>Logger Name</li>
<li>Marker</li>
<li>Thrown Proxy</li>
<li>Source</li>
<li>Context Map</li>
<li>Context Stack</li>
</ol>
<pre><code>0,1441617184044,DEBUG,main,&quot;one=1, two=2, three=3&quot;,org.apache.logging.log4j.spi.AbstractLogger,,,,org.apache.logging.log4j.core.layout.CsvLogEventLayoutTest.testLayout(CsvLogEventLayoutTest.java:98),{},[]
</code></pre>
<p>Additional <a href="https://logging.apache.org/log4j/2.x/runtime-dependencies.html">runtime dependencies</a> are required for using CSV layouts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="html-layout"><a class="header" href="#html-layout">HTML Layout</a></h1>
<p>The HtmlLayout generates an HTML page and adds each LogEvent to a row in a table.</p>
<h1 id="htmllayout-parameters"><a class="header" href="#htmllayout-parameters">HtmlLayout Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">charset</td><td style="text-align: left">String</td><td style="text-align: left">The character set to use when converting the HTML String to a byte array. The value must be a valid <a href="http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html">Charset</a>. If not specified, this layout uses UTF-8.</td></tr>
<tr><td style="text-align: left">contentType</td><td style="text-align: left">String</td><td style="text-align: left">The value to assign to the Content-Type header. The default is &quot;text/html&quot;.</td></tr>
<tr><td style="text-align: left">locationInfo</td><td style="text-align: left">boolean</td><td style="text-align: left">If true, the filename and line number will be included in the HTML output. The default value is false.Generating <a href="https://logging.apache.org/log4j/2.x/manual/layouts.html#LocationInformation">location information</a> is an expensive operation and may impact performance. Use with caution.</td></tr>
<tr><td style="text-align: left">title</td><td style="text-align: left">String</td><td style="text-align: left">A String that will appear as the HTML title.</td></tr>
<tr><td style="text-align: left">fontName</td><td style="text-align: left">String</td><td style="text-align: left">The font-family to use. The default is &quot;arial,sans-serif&quot;.</td></tr>
<tr><td style="text-align: left">fontSize</td><td style="text-align: left">String</td><td style="text-align: left">The font-size to use. The default is &quot;small&quot;.</td></tr>
<tr><td style="text-align: left">datePattern</td><td style="text-align: left">String</td><td style="text-align: left">The date format of the logging event. The default is &quot;JVM_ELAPSE_TIME&quot;, which outputs the milliseconds since JVM started. For other valid values, refer to the <a href="https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternDate">date pattern</a> of PatternLayout.</td></tr>
<tr><td style="text-align: left">timezone</td><td style="text-align: left">String</td><td style="text-align: left">The timezone id of the logging event. If not specified, this layout uses the <a href="http://docs.oracle.com/javase/6/docs/api/java/util/TimeZone.html#getDefault()">java.util.TimeZone.getDefault</a> as default timezone. Like <a href="https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternDate">date pattern</a> of PatternLayout, you can use timezone id from <a href="http://docs.oracle.com/javase/6/docs/api/java/util/TimeZone.html#getTimeZone(java.lang.String)">java.util.TimeZone.getTimeZone</a>.</td></tr>
</tbody></table>
<p>Configure as follows to use dataPattern and timezone in HtmlLayout:</p>
<pre><code class="language-xml">&lt;Appenders&gt;
  &lt;Console name=&quot;console&quot;&gt;
    &lt;HtmlLayout datePattern=&quot;ISO8601&quot; timezone=&quot;GMT+0&quot;/&gt;
  &lt;/Console&gt;
&lt;/Appenders&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-layout"><a class="header" href="#json-layout">JSON Layout</a></h1>
<p>将一系列 JSON 事件附加为序列化为字节的字符串。</p>
<h1 id="complete-well-formed-json-vs-fragment-json"><a class="header" href="#complete-well-formed-json-vs-fragment-json">Complete well-formed JSON vs. fragment JSON</a></h1>
<p>如果配置 complete=&quot;true&quot;，appender 会输出格式良好的 JSON 文档。默认情况下，使用 complete=&quot;false&quot; 时，您应该将输出作为外部文件包含在单独的文件中，以形成格式良好的 JSON 文档。</p>
<p>如果 complete=&quot;false&quot;，appender 不会在文档的开头、“]”和结尾写入 JSON 开放数组字符“[”，也不会在记录之间写入逗号“,”。</p>
<pre><code class="language-xml">{
  &quot;instant&quot; : {
    &quot;epochSecond&quot; : 1493121664,
    &quot;nanoOfSecond&quot; : 118000000
  },
  &quot;thread&quot; : &quot;main&quot;,
  &quot;level&quot; : &quot;INFO&quot;,
  &quot;loggerName&quot; : &quot;HelloWorld&quot;,
  &quot;marker&quot; : {
    &quot;name&quot; : &quot;child&quot;,
    &quot;parents&quot; : [ {
      &quot;name&quot; : &quot;parent&quot;,
      &quot;parents&quot; : [ {
        &quot;name&quot; : &quot;grandparent&quot;
      } ]
    } ]
  },
  &quot;message&quot; : &quot;Hello, world!&quot;,
  &quot;thrown&quot; : {
    &quot;commonElementCount&quot; : 0,
    &quot;message&quot; : &quot;error message&quot;,
    &quot;name&quot; : &quot;java.lang.RuntimeException&quot;,
    &quot;extendedStackTrace&quot; : [ {
      &quot;class&quot; : &quot;logtest.Main&quot;,
      &quot;method&quot; : &quot;main&quot;,
      &quot;file&quot; : &quot;Main.java&quot;,
      &quot;line&quot; : 29,
      &quot;exact&quot; : true,
      &quot;location&quot; : &quot;classes/&quot;,
      &quot;version&quot; : &quot;?&quot;
    } ]
  },
  &quot;contextStack&quot; : [ &quot;one&quot;, &quot;two&quot; ],
  &quot;endOfBatch&quot; : false,
  &quot;loggerFqcn&quot; : &quot;org.apache.logging.log4j.spi.AbstractLogger&quot;,
  &quot;contextMap&quot; : {
    &quot;bar&quot; : &quot;BAR&quot;,
    &quot;foo&quot; : &quot;FOO&quot;
  },
  &quot;threadId&quot; : 1,
  &quot;threadPriority&quot; : 5,
  &quot;source&quot; : {
    &quot;class&quot; : &quot;logtest.Main&quot;,
    &quot;method&quot; : &quot;main&quot;,
    &quot;file&quot; : &quot;Main.java&quot;,
    &quot;line&quot; : 29
  }
}
</code></pre>
<p>如果 complete=&quot;false&quot;，appender 不会在文档的开头、“]”和结尾写入 JSON 开放数组字符“[”，也不会在记录之间写入逗号“,”。</p>
<h1 id="pretty-vs-compact-json"><a class="header" href="#pretty-vs-compact-json">Pretty vs. compact JSON</a></h1>
<p>compact 属性决定输出是否“pretty”。默认值为“false”，这意味着 appender 使用行尾字符和缩进行来格式化文本。如果 compact=&quot;true&quot;，则不使用行尾或缩进，这将导致输出占用更少的空间。当然，消息内容可能包含转义的行尾。</p>
<h1 id="jsonlayout-parameters"><a class="header" href="#jsonlayout-parameters">JsonLayout Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">charset</td><td style="text-align: left">String</td><td style="text-align: left">The character set to use when converting to a byte array. The value must be a valid <a href="http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html">Charset</a>. If not specified, UTF-8 will be used.</td></tr>
<tr><td style="text-align: left">compact</td><td style="text-align: left">boolean</td><td style="text-align: left">If true, the appender does not use end-of-lines and indentation. Defaults to false.</td></tr>
<tr><td style="text-align: left">eventEol</td><td style="text-align: left">boolean</td><td style="text-align: left">If true, the appender appends an end-of-line after each record. Defaults to false. Use with eventEol=true and compact=true to get one record per line.</td></tr>
<tr><td style="text-align: left">endOfLine</td><td style="text-align: left">String</td><td style="text-align: left">If set, overrides the default end-of-line string. E.g. set it to &quot;\n&quot; and use with eventEol=true and compact=true to have one record per line separated by &quot;\n&quot; instead of &quot;\r\n&quot;. Defaults to null (i.e. not set).</td></tr>
<tr><td style="text-align: left">complete</td><td style="text-align: left">boolean</td><td style="text-align: left">If true, the appender includes the JSON header and footer, and comma between records. Defaults to false.</td></tr>
<tr><td style="text-align: left">properties</td><td style="text-align: left">boolean</td><td style="text-align: left">If true, the appender includes the thread context map in the generated JSON. Defaults to false.</td></tr>
<tr><td style="text-align: left">propertiesAsList</td><td style="text-align: left">boolean</td><td style="text-align: left">If true, the thread context map is included as a list of map entry objects, where each entry has a &quot;key&quot; attribute (whose value is the key) and a &quot;value&quot; attribute (whose value is the value). Defaults to false, in which case the thread context map is included as a simple map of key-value pairs.</td></tr>
<tr><td style="text-align: left">locationInfo</td><td style="text-align: left">boolean</td><td style="text-align: left">If true, the appender includes the location information in the generated JSON. Defaults to false.Generating <a href="https://logging.apache.org/log4j/2.x/manual/layouts.html#LocationInformation">location information</a> is an expensive operation and may impact performance. Use with caution.</td></tr>
<tr><td style="text-align: left">includeStacktrace</td><td style="text-align: left">boolean</td><td style="text-align: left">If true, include full stacktrace of any logged <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html">Throwable</a> (optional, default to true).</td></tr>
<tr><td style="text-align: left">includeTimeMillis</td><td style="text-align: left">boolean</td><td style="text-align: left">If true, the timeMillis attribute is included in the Json payload instead of the instant. timeMillis will contain the number of milliseconds since midnight, January 1, 1970 UTC.</td></tr>
<tr><td style="text-align: left">stacktraceAsString</td><td style="text-align: left">boolean</td><td style="text-align: left">Whether to format the stacktrace as a string, and not a nested object (optional, defaults to false).</td></tr>
<tr><td style="text-align: left">includeNullDelimiter</td><td style="text-align: left">boolean</td><td style="text-align: left">Whether to include NULL byte as delimiter after each event (optional, default to false).</td></tr>
<tr><td style="text-align: left">objectMessageAsJsonObject</td><td style="text-align: left">boolean</td><td style="text-align: left">If true, ObjectMessage is serialized as JSON object to the &quot;message&quot; field of the output log. Defaults to false.</td></tr>
</tbody></table>
<p>To include any custom field in the output, use following syntax:</p>
<pre><code>  &lt;JsonLayout&gt;    &lt;KeyValuePair key=&quot;additionalField1&quot; value=&quot;constant value&quot;/&gt;    &lt;KeyValuePair key=&quot;additionalField2&quot; value=&quot;$${ctx:key}&quot;/&gt;  &lt;/JsonLayout&gt;
</code></pre>
<p>Custom fields are always last, in the order they are declared. The values support <a href="https://logging.apache.org/log4j/2.x/manual/lookups.html">lookups</a>.</p>
<p>Additional <a href="https://logging.apache.org/log4j/2.x/runtime-dependencies.html">runtime dependencies</a> are required for using JsonLayout.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-template-layout"><a class="header" href="#json-template-layout">JSON Template Layout</a></h1>
<p>JsonTemplateLayout 是一种可定制、高效且无垃圾的 JSON  emitting layout。它根据提供的 JSON 模板描述的结构对 LogEvents 进行编码。</p>
<p>例如，给定以下 JSON 模板建模官方 Logstash JSONEventLayoutV1</p>
<pre><code class="language-json">{
  &quot;mdc&quot;: {
    &quot;$resolver&quot;: &quot;mdc&quot;
  },
  &quot;exception&quot;: {
    &quot;exception_class&quot;: {
      &quot;$resolver&quot;: &quot;exception&quot;,
      &quot;field&quot;: &quot;className&quot;
    },
    &quot;exception_message&quot;: {
      &quot;$resolver&quot;: &quot;exception&quot;,
      &quot;field&quot;: &quot;message&quot;,
      &quot;stringified&quot;: true
    },
    &quot;stacktrace&quot;: {
      &quot;$resolver&quot;: &quot;exception&quot;,
      &quot;field&quot;: &quot;stackTrace&quot;,
      &quot;stringified&quot;: true
    }
  },
  &quot;line_number&quot;: {
    &quot;$resolver&quot;: &quot;source&quot;,
    &quot;field&quot;: &quot;lineNumber&quot;
  },
  &quot;class&quot;: {
    &quot;$resolver&quot;: &quot;source&quot;,
    &quot;field&quot;: &quot;className&quot;
  },
  &quot;@version&quot;: 1,
  &quot;source_host&quot;: &quot;${hostName}&quot;,
  &quot;message&quot;: {
    &quot;$resolver&quot;: &quot;message&quot;,
    &quot;stringified&quot;: true
  },
  &quot;thread_name&quot;: {
    &quot;$resolver&quot;: &quot;thread&quot;,
    &quot;field&quot;: &quot;name&quot;
  },
  &quot;@timestamp&quot;: {
    &quot;$resolver&quot;: &quot;timestamp&quot;
  },
  &quot;level&quot;: {
    &quot;$resolver&quot;: &quot;level&quot;,
    &quot;field&quot;: &quot;name&quot;
  },
  &quot;file&quot;: {
    &quot;$resolver&quot;: &quot;source&quot;,
    &quot;field&quot;: &quot;fileName&quot;
  },
  &quot;method&quot;: {
    &quot;$resolver&quot;: &quot;source&quot;,
    &quot;field&quot;: &quot;methodName&quot;
  },
  &quot;logger_name&quot;: {
    &quot;$resolver&quot;: &quot;logger&quot;,
    &quot;field&quot;: &quot;name&quot;
  }
}
</code></pre>
<p>in combination with the below Log4j configuration:</p>
<pre><code>&lt;JsonTemplateLayout eventTemplateUri=&quot;classpath:LogstashJsonEventLayoutV1.json&quot;/&gt;

</code></pre>
<p>JSON Template Layout will render JSON documents as follows:</p>
<pre><code class="language-json">{
  &quot;exception&quot;: {
    &quot;exception_class&quot;: &quot;java.lang.RuntimeException&quot;,
    &quot;exception_message&quot;: &quot;test&quot;,
    &quot;stacktrace&quot;: &quot;java.lang.RuntimeException: test\n\tat org.apache.logging.log4j.JsonTemplateLayoutDemo.main(JsonTemplateLayoutDemo.java:11)\n&quot;
  },
  &quot;line_number&quot;: 12,
  &quot;class&quot;: &quot;org.apache.logging.log4j.JsonTemplateLayoutDemo&quot;,
  &quot;@version&quot;: 1,
  &quot;source_host&quot;: &quot;varlik&quot;,
  &quot;message&quot;: &quot;Hello, error!&quot;,
  &quot;thread_name&quot;: &quot;main&quot;,
  &quot;@timestamp&quot;: &quot;2017-05-25T19:56:23.370+02:00&quot;,
  &quot;level&quot;: &quot;ERROR&quot;,
  &quot;file&quot;: &quot;JsonTemplateLayoutDemo.java&quot;,
  &quot;method&quot;: &quot;main&quot;,
  &quot;logger_name&quot;: &quot;org.apache.logging.log4j.JsonTemplateLayoutDemo&quot;
}
</code></pre>
<h1 id="-2"><a class="header" href="#-2"></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-layout"><a class="header" href="#pattern-layout">Pattern Layout</a></h1>
<p>使用模式字符串可配置的灵活布局。此类的目标是格式化 LogEvent 并返回结果。结果的格式取决于转换模式。</p>
<p>转换模式与 C 中 printf 函数的转换模式密切相关。转换模式由称为转换说明符的文字文本和格式控制表达式组成。</p>
<p>请注意，任何文字文本，包括特殊字符，都可以包含在转换模式中。特殊字符包括\t、\n、\r、\f。使用 \ 在输出中插入一个反斜杠。</p>
<p>每个转换说明符都以百分号 (%) 开头，后跟可选的格式修饰符和转换字符。转换字符指定数据的类型，例如类别、优先级、日期、线程名称。格式修饰符控制诸如字段宽度、填充、左右对齐等内容。下面是一个简单的例子。</p>
<p>让转换模式为 &quot;%-5p [%t]: %m%n&quot; 并假设 Log4j 环境设置为使用 PatternLayout。然后声明</p>
<pre><code>Logger logger = LogManager.getLogger(&quot;MyLogger&quot;);
logger.debug(&quot;Message 1&quot;);
logger.warn(&quot;Message 2&quot;);

DEBUG [main]: Message 1
WARN  [main]: Message 2
</code></pre>
<p>请注意，文本和转换说明符之间没有明确的分隔符。模式解析器在读取转换字符时知道它何时到达转换说明符的末尾。在上面的例子中，转换说明符 %-5p 意味着记录事件的优先级应该左对齐到五个字符的宽度。</p>
<p>如果模式字符串不包含处理正在记录的 Throwable 的说明符，则模式的解析将表现为“%xEx”说明符已添加到字符串的末尾。要完全抑制 Throwable 的格式，只需在模式字符串中添加“%ex{0}”作为说明符。</p>
<h1 id="patternlayout-parameters"><a class="header" href="#patternlayout-parameters">PatternLayout Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">charset</td><td style="text-align: left">String</td><td style="text-align: left">The character set to use when converting the syslog String to a byte array. The String must be a valid <a href="http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html">Charset</a>. If not specified, this layout uses the platform default character set.</td></tr>
<tr><td style="text-align: left">pattern</td><td style="text-align: left">String</td><td style="text-align: left">A composite pattern string of one or more conversion patterns from the table below. Cannot be specified with a PatternSelector.</td></tr>
<tr><td style="text-align: left">patternSelector</td><td style="text-align: left">PatternSelector</td><td style="text-align: left">一个组件，用于分析 LogEvent 中的信息并确定应使用哪种模式来格式化事件。 pattern 和 patternSelector 参数是互斥的</td></tr>
<tr><td style="text-align: left">replace</td><td style="text-align: left">RegexReplacement</td><td style="text-align: left">允许替换部分结果字符串。如果已配置，replace 元素必须指定要匹配的正则表达式和替换。这执行类似于 RegexReplacement 转换器的功能，但适用于整个消息，而转换器仅适用于其模式生成的字符串。</td></tr>
<tr><td style="text-align: left">alwaysWriteExceptions</td><td style="text-align: left">boolean</td><td style="text-align: left">If true (it is by default) exceptions are always written even if the pattern contains no exception conversions. This means that if you do not include a way to output exceptions in your pattern, the default exception formatter will be added to the end of the pattern. Setting this to false disables this behavior and allows you to exclude exceptions from your pattern output.</td></tr>
<tr><td style="text-align: left">header</td><td style="text-align: left">String</td><td style="text-align: left">The optional header string to include at the top of each log file.</td></tr>
<tr><td style="text-align: left">footer</td><td style="text-align: left">String</td><td style="text-align: left">The optional footer string to include at the bottom of each log file.</td></tr>
<tr><td style="text-align: left">disableAnsi</td><td style="text-align: left">boolean</td><td style="text-align: left">If true (default is false), do not output ANSI escape codes.</td></tr>
<tr><td style="text-align: left">noConsoleNoAnsi</td><td style="text-align: left">boolean</td><td style="text-align: left">If true (default is false) and System.console() is null, do not output ANSI escape codes.</td></tr>
</tbody></table>
<h1 id="regexreplacement-parameters"><a class="header" href="#regexreplacement-parameters">RegexReplacement Parameters</a></h1>
<table><thead><tr><th style="text-align: left">Parameter Name</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">regex</td><td style="text-align: left">String</td><td style="text-align: left">A Java-compliant regular expression to match in the resulting string. See <a href="http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html">Pattern</a> .</td></tr>
<tr><td style="text-align: left">replacement</td><td style="text-align: left">String</td><td style="text-align: left">The string to replace any matched sub-strings with.</td></tr>
</tbody></table>
<h1 id="pattern表格汇总"><a class="header" href="#pattern表格汇总">Pattern表格汇总</a></h1>
<table><thead><tr><th>转换符</th><th>说明</th><th>示例</th></tr></thead><tbody>
<tr><td><strong>c</strong>{precision}<br/><strong>logger</strong>{precision}</td><td>日志名</td><td>%c{10}</td></tr>
<tr><td><strong>C</strong>{precision}<br/><strong>class</strong>{precision}</td><td>调用者的全限定类名</td><td></td></tr>
<tr><td><strong>d</strong>{pattern}<br/><strong>date</strong>{pattern}</td><td>日志事件的日期</td><td>%d{DEFAULT}、%d{HH:mm:ss,SSS}</td></tr>
<tr><td><strong>F</strong><br/><strong>file</strong></td><td>目标输出文件名</td><td></td></tr>
<tr><td><strong>K</strong>{key}<br/><strong>map</strong>{key}<br/><strong>MAP</strong>{key}</td><td>输出 MapMessage 的 <strong>entries</strong><br /><strong>%K{clientNumber}</strong></td><td>多key的输出格式为： {{key1,val1},{key2,val2}}</td></tr>
<tr><td><strong>L</strong><br/><strong>line</strong></td><td>调用者的行号</td><td>耗时操作</td></tr>
<tr><td><strong>m</strong>{nolookups}{ansi}<br/><strong>msg</strong>{nolookups}{ansi}<br/><strong>message</strong>{nolookups}{ansi}</td><td>输出程序提供的消息</td><td>两个选项：nolookups、ansi</td></tr>
<tr><td><strong>M</strong><br/><strong>method</strong></td><td>发出日志请求的方法名</td><td></td></tr>
<tr><td><strong>marker</strong></td><td>marker全名包括parentName</td><td></td></tr>
<tr><td><strong>markerSimpleName</strong></td><td>简单名（不包括parentName）</td><td></td></tr>
<tr><td><strong>maxLen</strong><br/><strong>maxLength</strong></td><td>限定日志的内容的最大最小</td><td>%maxLen{%m}{20}</td></tr>
<tr><td>n</td><td>换行符</td><td></td></tr>
<tr><td><strong>N</strong><br/><strong>nano</strong></td><td>日志事件产生时间</td><td></td></tr>
<tr><td><strong>pid</strong>{[defaultValue]}<br/><strong>processId</strong>{[defaultValue]}</td><td>进程Id</td><td></td></tr>
<tr><td><strong>p|level</strong></td><td>日志级别</td><td></td></tr>
<tr><td><strong>x</strong><br/><strong>NDC</strong></td><td>NDC</td><td></td></tr>
<tr><td><strong>X</strong>{key[,key2...]}<br/><strong>mdc</strong>{key[,key2...]}<br/><strong>MDC</strong>{key[,key2...]}</td><td>MDC</td><td></td></tr>
<tr><td><strong>u</strong>{&quot;RANDOM&quot;|&quot;TIME&quot;}<br /><strong>uuid</strong></td><td>随机数</td><td></td></tr>
<tr><td><strong>T</strong><br/><strong>tid</strong><br/><strong>threadId</strong></td><td>线程ID</td><td></td></tr>
<tr><td><strong>t</strong><br/><strong>tn</strong><br/><strong>thread</strong><br/><strong>threadName</strong></td><td>线程名</td><td></td></tr>
</tbody></table>
<h1 id="patterns详解"><a class="header" href="#patterns详解">Patterns详解</a></h1>
<p>The conversions that are provided with Log4j are:</p>
<h2 id="输出日志名称"><a class="header" href="#输出日志名称">输出日志名称</a></h2>
<p><strong>c</strong>{precision}
<strong>logger</strong>{precision}</p>
<table><thead><tr><th style="text-align: left">Conversion Pattern</th><th style="text-align: left">Logger Name</th><th style="text-align: left">Result</th></tr></thead><tbody>
<tr><td style="text-align: left">%c{1}</td><td style="text-align: left">org.apache.commons.Foo</td><td style="text-align: left">Foo</td></tr>
<tr><td style="text-align: left">%c{2}</td><td style="text-align: left">org.apache.commons.Foo</td><td style="text-align: left">commons.Foo</td></tr>
<tr><td style="text-align: left">%c{10}</td><td style="text-align: left">org.apache.commons.Foo</td><td style="text-align: left">org.apache.commons.Foo</td></tr>
<tr><td style="text-align: left">%c{-1}</td><td style="text-align: left">org.apache.commons.Foo</td><td style="text-align: left">apache.commons.Foo</td></tr>
<tr><td style="text-align: left">%c{-2}</td><td style="text-align: left">org.apache.commons.Foo</td><td style="text-align: left">commons.Foo</td></tr>
<tr><td style="text-align: left">%c{-10}</td><td style="text-align: left">org.apache.commons.Foo</td><td style="text-align: left">org.apache.commons.Foo</td></tr>
<tr><td style="text-align: left">%c{1.}</td><td style="text-align: left">org.apache.commons.Foo</td><td style="text-align: left">o.a.c.Foo</td></tr>
<tr><td style="text-align: left">%c{1.1.~.~}</td><td style="text-align: left">org.apache.commons.test.Foo</td><td style="text-align: left">o.a.~.~.Foo</td></tr>
<tr><td style="text-align: left">%c{.}</td><td style="text-align: left">org.apache.commons.test.Foo</td><td style="text-align: left">....Foo</td></tr>
</tbody></table>
<h2 id="输出调用类的全限定名"><a class="header" href="#输出调用类的全限定名">输出调用类的全限定名</a></h2>
<p><strong>C</strong>{precision}
<strong>class</strong>{precision}</p>
<p>输出发出日志记录请求的调用者的完全限定类名。此转换说明符可以选择后跟精度说明符，其遵循与记录器名称转换器相同的规则。</p>
<p>生成调用者的类名（位置信息）是一项代价高昂的操作，可能会影响性能。谨慎使用。</p>
<h2 id="输出日志事件的日期"><a class="header" href="#输出日志事件的日期">输出日志事件的日期</a></h2>
<p><strong>d</strong>{pattern}
<strong>date</strong>{pattern}</p>
<p>输出日志事件的日期。日期转换说明符后面可以跟一组包含每个 SimpleDateFormat 的日期和时间模式字符串的大括号。</p>
<table><thead><tr><th style="text-align: left">Pattern</th><th style="text-align: left">Example</th></tr></thead><tbody>
<tr><td style="text-align: left">%d{DEFAULT}</td><td style="text-align: left">2012-11-02 14:34:02,123</td></tr>
<tr><td style="text-align: left">%d{DEFAULT_MICROS}</td><td style="text-align: left">2012-11-02 14:34:02,123456</td></tr>
<tr><td style="text-align: left">%d{DEFAULT_NANOS}</td><td style="text-align: left">2012-11-02 14:34:02,123456789</td></tr>
<tr><td style="text-align: left">%d{ISO8601}</td><td style="text-align: left">2012-11-02T14:34:02,781</td></tr>
<tr><td style="text-align: left">%d{ISO8601_BASIC}</td><td style="text-align: left">20121102T143402,781</td></tr>
<tr><td style="text-align: left">%d{ISO8601_OFFSET_DATE_TIME_HH}</td><td style="text-align: left">2012-11-02'T'14:34:02,781-07</td></tr>
<tr><td style="text-align: left">%d{ISO8601_OFFSET_DATE_TIME_HHMM}</td><td style="text-align: left">2012-11-02'T'14:34:02,781-0700</td></tr>
<tr><td style="text-align: left">%d{ISO8601_OFFSET_DATE_TIME_HHCMM}</td><td style="text-align: left">2012-11-02'T'14:34:02,781-07:00</td></tr>
<tr><td style="text-align: left">%d{ABSOLUTE}</td><td style="text-align: left">14:34:02,781</td></tr>
<tr><td style="text-align: left">%d{ABSOLUTE_MICROS}</td><td style="text-align: left">14:34:02,123456</td></tr>
<tr><td style="text-align: left">%d{ABSOLUTE_NANOS}</td><td style="text-align: left">14:34:02,123456789</td></tr>
<tr><td style="text-align: left">%d{DATE}</td><td style="text-align: left">02 Nov 2012 14:34:02,781</td></tr>
<tr><td style="text-align: left">%d{COMPACT}</td><td style="text-align: left">20121102143402781</td></tr>
<tr><td style="text-align: left">%d{UNIX}</td><td style="text-align: left">1351866842</td></tr>
<tr><td style="text-align: left">%d{UNIX_MILLIS}</td><td style="text-align: left">1351866842781</td></tr>
</tbody></table>
<p>您还可以使用一组包含每个 java.util.TimeZone.getTimeZone 的时区 ID 的大括号。如果未给出日期格式说明符，则使用 DEFAULT 格式。</p>
<h3 id="预定义格式说明符"><a class="header" href="#预定义格式说明符">预定义格式说明符</a></h3>
<table><thead><tr><th style="text-align: left">Pattern</th><th style="text-align: left">Example</th></tr></thead><tbody>
<tr><td style="text-align: left">%d{HH:mm:ss,SSS}</td><td style="text-align: left">14:34:02,123</td></tr>
<tr><td style="text-align: left">%d{HH:mm:ss,nnnn} to %d{HH:mm:ss,nnnnnnnnn}</td><td style="text-align: left">14:34:02,1234 to 14:34:02,123456789</td></tr>
<tr><td style="text-align: left">%d{dd MMM yyyy HH:mm:ss,SSS}</td><td style="text-align: left">02 Nov 2012 14:34:02,123</td></tr>
<tr><td style="text-align: left">%d{dd MMM yyyy HH:mm:ss,nnnn} to %d{dd MMM yyyy HH:mm:ss,nnnnnnnnn}</td><td style="text-align: left">02 Nov 2012 14:34:02,1234 to 02 Nov 2012 14:34:02,123456789</td></tr>
<tr><td style="text-align: left">%d{HH:mm:ss}{GMT+0}</td><td style="text-align: left">18:34:02</td></tr>
</tbody></table>
<p>%d{UNIX} 以秒为单位输出 UNIX 时间。</p>
<p>%d{UNIX_MILLIS} 以毫秒为单位输出 UNIX 时间。 </p>
<p>UNIX 时间是当前时间与 UTC 时间 1970 年 1 月 1 日午夜之间的差异，UNIX 以秒为单位，UNIX_MILLIS 以毫秒为单位。虽然时间单位是毫秒，但粒度取决于操作系统 (Windows)。这是输出事件时间的有效方法，因为只发生从 long 到 String 的转换，不涉及日期格式。</p>
<p>在 Java 9 上运行时，Log4j 2.11 添加了对比毫秒更精确的时间戳的有限支持。请注意，并非所有 DateTimeFormatter 格式都受支持。只有上表中提到的格式的时间戳可以使用“nano-of-second”模式字母 n 而不是“fraction-of-second”模式字母 S。</p>
<h2 id="编码和转义适合以特定标记语言输出的特殊字符"><a class="header" href="#编码和转义适合以特定标记语言输出的特殊字符">编码和转义适合以特定标记语言输出的特殊字符。</a></h2>
<p><strong>enc</strong>{<em>pattern</em>}{[HTML|XML|JSON|CRLF]}
<strong>encode</strong>{<em>pattern</em>}{[HTML|XML|JSON|CRLF]}</p>
<p>默认情况下，如果只指定了一个选项，则此编码为 HTML。</p>
<p>第二个选项用于指定应使用哪种编码格式。该转换器对于对用户提供的数据进行编码特别有用，这样输出数据就不会被错误地或不安全地写入。</p>
<p>典型的用法是对消息 %enc{%m} 进行编码，但用户输入也可能来自其他位置，例如 MDC %enc{%mdc{key}}</p>
<p>使用HTML编码格式，替换如下字符：</p>
<table><thead><tr><th style="text-align: left">Character</th><th style="text-align: left">Replacement</th></tr></thead><tbody>
<tr><td style="text-align: left">'\r', '\n'</td><td style="text-align: left">Converted into escaped strings &quot;\r&quot; and &quot;\n&quot; respectively</td></tr>
<tr><td style="text-align: left">&amp;, &lt;, &gt;, &quot;, ', /</td><td style="text-align: left">Replaced with the corresponding HTML entity</td></tr>
</tbody></table>
<p>使用 XML 编码格式，这遵循 XML 规范指定的转义规则：</p>
<table><thead><tr><th style="text-align: left">Character</th><th style="text-align: left">Replacement</th></tr></thead><tbody>
<tr><td style="text-align: left">&amp;, &lt;, &gt;, &quot;, '</td><td style="text-align: left">Replaced with the corresponding XML entity</td></tr>
</tbody></table>
<p>使用 JSON 编码格式，这遵循 <a href="https://www.ietf.org/rfc/rfc4627.txt">RFC 4627 第 2.5 节</a>指定的转义规则：</p>
<table><thead><tr><th style="text-align: left">Character</th><th style="text-align: left">Replacement</th></tr></thead><tbody>
<tr><td style="text-align: left">U+0000 - U+001F</td><td style="text-align: left">\u0000 - \u001F</td></tr>
<tr><td style="text-align: left">Any other control characters</td><td style="text-align: left">Encoded into its \uABCD equivalent escaped code point</td></tr>
<tr><td style="text-align: left">&quot;</td><td style="text-align: left">&quot;</td></tr>
<tr><td style="text-align: left">\</td><td style="text-align: left">\</td></tr>
</tbody></table>
<p>例如，模式 {&quot;message&quot;: &quot;%enc{%m}{JSON}&quot;} 可用于输出包含作为字符串值的日志消息的有效 JSON 文档。使用CRLF编码格式，替换如下字符：</p>
<table><thead><tr><th style="text-align: left">Character</th><th style="text-align: left">Replacement</th></tr></thead><tbody>
<tr><td style="text-align: left">'\r', '\n'</td><td style="text-align: left">Converted into escaped strings &quot;\r&quot; and &quot;\n&quot; respectively</td></tr>
</tbody></table>
<h2 id="等值替换"><a class="header" href="#等值替换">等值替换</a></h2>
<p><strong>equals</strong>{pattern}{test}{substitution}
<strong>equalsIgnoreCase</strong>{pattern}{test}{substitution}</p>
<p>将字符串中出现的 'test' 替换为由模式评估产生的字符串中的替换 'substitution'。</p>
<p>例如，&quot;%equals{[%marker]}{[]}{}&quot; 将用空字符串替换由没有标记的事件产生的 '[]' 字符串。模式可以是任意复杂的，特别是可以包含多个转换关键字。</p>
<h2 id="throwable"><a class="header" href="#throwable">Throwable</a></h2>
<p><strong>ex</strong>|<strong>exception</strong>|<strong>throwable</strong>
{
[ &quot;none&quot;
| &quot;full&quot;
| depth
| &quot;short&quot;
| &quot;short.className&quot;
| &quot;short.fileName&quot;
| &quot;short.lineNumber&quot;
| &quot;short.methodName&quot;
| &quot;short.message&quot;
| &quot;short.localizedMessage&quot;]
}
{filters(package,package,...)}
{suffix(<em>pattern</em>)}
{separator(<em>separator</em>)}</p>
<p>默认情况下，这将输出完整的跟踪，就像通常通过调用 Throwable.printStackTrace() 找到的那样。</p>
<p>您可以使用 %throwable{option} 形式的选项跟随 throwable 转换词。</p>
<p><code>%throwable{short}</code> outputs the first line of the Throwable.</p>
<p><strong>%throwable{short.className}</strong> outputs the name of the class where the exception occurred.</p>
<p><strong>%throwable{short.methodName}</strong> outputs the method name where the exception occurred.</p>
<p><strong>%throwable{short.fileName}</strong> outputs the name of the class where the exception occurred.</p>
<p><strong>%throwable{short.lineNumber}</strong> outputs the line number where the exception occurred.</p>
<p><strong>%throwable{short.message}</strong> outputs the message.</p>
<p><strong>%throwable{short.localizedMessage}</strong> outputs the localized message.</p>
<p><strong>%throwable{n}</strong> outputs the first n lines of the stack trace.</p>
<p><strong>%throwable{none}</strong> or <strong>%throwable{0}</strong> suppresses output of the exception.</p>
<p>使用 {filters(packages)} ，其中包是包名称列表，以抑制来自堆栈跟踪的匹配堆栈帧。使用 {suffix(pattern)} 在每个堆栈帧的末尾添加模式的输出。使用 {separator(...)} 作为行尾字符串。例如：分隔符(|)。默认值是 line.separator 系统属性，它依赖于操作系统。</p>
<h2 id="输出发出日志记录请求的文件名"><a class="header" href="#输出发出日志记录请求的文件名">输出发出日志记录请求的文件名。</a></h2>
<p><strong>F</strong>
<strong>file</strong></p>
<p>生成文件信息（位置信息）是一项昂贵的操作，可能会影响性能。谨慎使用。</p>
<h2 id="根据当前事件的日志记录级别将-ansi-颜色添加到封闭模式的结果中"><a class="header" href="#根据当前事件的日志记录级别将-ansi-颜色添加到封闭模式的结果中">根据当前事件的日志记录级别将 ANSI 颜色添加到封闭模式的结果中。</a></h2>
<p>The default colors for each level are:</p>
<table><thead><tr><th style="text-align: left">Level</th><th style="text-align: left">ANSI color</th></tr></thead><tbody>
<tr><td style="text-align: left">FATAL</td><td style="text-align: left">Bright red</td></tr>
<tr><td style="text-align: left">ERROR</td><td style="text-align: left">Bright red</td></tr>
<tr><td style="text-align: left">WARN</td><td style="text-align: left">Yellow</td></tr>
<tr><td style="text-align: left">INFO</td><td style="text-align: left">Green</td></tr>
<tr><td style="text-align: left">DEBUG</td><td style="text-align: left">Cyan</td></tr>
<tr><td style="text-align: left">TRACE</td><td style="text-align: left">Black (looks dark grey)</td></tr>
</tbody></table>
<p>The color and attribute names and are standard, but the exact shade, hue, or value.</p>
<table><thead><tr><th style="text-align: left">Intensity Code</th><th style="text-align: left">0</th><th style="text-align: left">1</th><th style="text-align: left">2</th><th style="text-align: left">3</th><th style="text-align: left">4</th><th style="text-align: left">5</th><th style="text-align: left">6</th><th style="text-align: left">7</th></tr></thead><tbody>
<tr><td style="text-align: left">Normal</td><td style="text-align: left">Black</td><td style="text-align: left">Red</td><td style="text-align: left">Green</td><td style="text-align: left">Yellow</td><td style="text-align: left">Blue</td><td style="text-align: left">Magenta</td><td style="text-align: left">Cyan</td><td style="text-align: left">White</td></tr>
<tr><td style="text-align: left">Bright</td><td style="text-align: left">Black</td><td style="text-align: left">Red</td><td style="text-align: left">Green</td><td style="text-align: left">Yellow</td><td style="text-align: left">Blue</td><td style="text-align: left">Magenta</td><td style="text-align: left">Cyan</td><td style="text-align: left">White</td></tr>
</tbody></table>
<p>You can use the default colors with:</p>
<pre><code>%highlight{%d [%t] %-5level: %msg%n%throwable}
</code></pre>
<p>You can override the default colors in the optional {style} option. For example:</p>
<pre><code>%highlight{%d [%t] %-5level: %msg%n%throwable}{FATAL=white, ERROR=red, WARN=blue, INFO=black, DEBUG=green, TRACE=blue}
</code></pre>
<p>You can highlight only the a portion of the log event:</p>
<pre><code>%d [%t] %highlight{%-5level: %msg%n%throwable}
</code></pre>
<p>You can style one part of the message and highlight the rest the log event:</p>
<pre><code>%style{%d [%t]}{black} %highlight{%-5level: %msg%n%throwable}
</code></pre>
<p>You can also use the STYLE key to use a predefined group of colors:</p>
<pre><code>%highlight{%d [%t] %-5level: %msg%n%throwable}{STYLE=Logback}
</code></pre>
<p>The STYLE value can be one of:</p>
<table><thead><tr><th style="text-align: left">Style</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Default</td><td style="text-align: left">See above</td></tr>
<tr><td style="text-align: left">Logback</td><td style="text-align: left">logback desciption</td></tr>
</tbody></table>
<p><strong>logback desciption</strong></p>
<table><thead><tr><th style="text-align: left">Level</th><th style="text-align: left">ANSI color</th></tr></thead><tbody>
<tr><td style="text-align: left">FATAL</td><td style="text-align: left">Blinking bright red</td></tr>
<tr><td style="text-align: left">ERROR</td><td style="text-align: left">Bright red</td></tr>
<tr><td style="text-align: left">WARN</td><td style="text-align: left">Red</td></tr>
<tr><td style="text-align: left">INFO</td><td style="text-align: left">Blue</td></tr>
<tr><td style="text-align: left">DEBUG</td><td style="text-align: left">Normal</td></tr>
<tr><td style="text-align: left">TRACE</td><td style="text-align: left">Normal</td></tr>
</tbody></table>
<h2 id="outputs-the-entries-in-a-mapmessage"><a class="header" href="#outputs-the-entries-in-a-mapmessage">Outputs the entries in a <a href="https://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/message/MapMessage.html">MapMessage</a></a></h2>
<p><strong>K</strong>{key}
<strong>map</strong>{key}
<strong>MAP</strong>{key}</p>
<p>如果没有指定额外的子选项，则使用格式 {{key1,val1},{key2,val2}} 输出 Map 键值对集的全部内容</p>
<h2 id="location-information"><a class="header" href="#location-information">location information</a></h2>
<p><strong>l</strong>
<strong>location</strong></p>
<p>位置信息取决于 JVM 实现，但通常由调用方法的完全限定名称和调用者源文件名和括号之间的行号组成。</p>
<p>Generating <a href="https://logging.apache.org/log4j/2.x/manual/layouts.html#LocationInformation">location information</a> is an expensive operation and may impact performance. Use with caution.</p>
<h2 id="line-number"><a class="header" href="#line-number">line number</a></h2>
<p><strong>L</strong>
<strong>line</strong></p>
<p>Outputs the line number from where the logging request was issued.</p>
<p>Generating line number information (<a href="https://logging.apache.org/log4j/2.x/manual/layouts.html#LocationInformation">location information</a>) is an expensive operation and may impact performance. Use with caution.</p>
<h2 id="application-supplied-message"><a class="header" href="#application-supplied-message">application supplied message</a></h2>
<p><strong>m</strong>{nolookups}{ansi}
<strong>msg</strong>{nolookups}{ansi}
<strong>message</strong>{nolookups}{ansi}</p>
<p>Add {ansi} to render messages with ANSI escape codes (requires JAnsi, see <a href="https://logging.apache.org/log4j/2.x/manual/layouts.html#enable-jansi">configuration</a>.)</p>
<p>The default syntax for embedded ANSI codes is:</p>
<pre><code>@|code(,code)* text|@
</code></pre>
<p>For example, to render the message &quot;Hello&quot; in green, use:</p>
<pre><code>@|green Hello|@
</code></pre>
<p>To render the message &quot;Hello&quot; in bold and red, use:</p>
<pre><code>@|bold,red Warning!|@
</code></pre>
<p>You can also define custom style names in the configuration with the syntax:</p>
<pre><code>%message{ansi}{StyleName=value(,value)*( StyleName=value(,value)*)*}%n
</code></pre>
<p>For example:</p>
<pre><code>%message{ansi}{WarningStyle=red,bold KeyStyle=white ValueStyle=blue}%n
</code></pre>
<p>The call site can look like this:</p>
<pre><code>logger.info(&quot;@|KeyStyle {}|@ = @|ValueStyle {}|@&quot;, entry.getKey(), entry.getValue());
</code></pre>
<p>Use {nolookups} to log messages like &quot;${date:YYYY-MM-dd}&quot; without using any lookups. Normally calling logger.info(&quot;Try ${date:YYYY-MM-dd}&quot;) would replace the date template ${date:YYYY-MM-dd} with an actual date. Using nolookups disables this feature and logs the message string untouched.</p>
<h2 id="调用方法名"><a class="header" href="#调用方法名">调用方法名</a></h2>
<p><strong>M</strong>
<strong>method</strong></p>
<p>生成调用者的方法名称（位置信息）是一项代价高昂的操作，可能会影响性能。谨慎使用。</p>
<h2 id="marker"><a class="header" href="#marker"><strong>marker</strong></a></h2>
<p>The full name of the marker, including parents, if one is present.</p>
<h2 id="markersimplename"><a class="header" href="#markersimplename"><strong>markerSimpleName</strong></a></h2>
<p>The simple name of the marker (not including parents), if one is present</p>
<h2 id="限制输出内容"><a class="header" href="#限制输出内容">限制输出内容</a></h2>
<p><strong>maxLen</strong>
<strong>maxLength</strong></p>
<p>如果长度大于 20，则输出将包含尾随省略号。如果提供的长度无效，则使用默认值 100。示例语法：%maxLen{%p: %c{1} - %m%notEmpty{ =&gt;%ex{short}}}{160} 将被限制为 160 个字符，并带有尾随省略号。</p>
<p>另一个示例： %maxLen{%m}{20} 将被限制为 20 个字符并且没有尾随省略号。</p>
<h2 id="平台无关的换行符"><a class="header" href="#平台无关的换行符">平台无关的换行符</a></h2>
<p>n</p>
<h2 id="log-event-cratedtime"><a class="header" href="#log-event-cratedtime">log event cratedTime</a></h2>
<p><strong>N</strong>
<strong>nano</strong></p>
<p>Outputs the result of System.nanoTime() at the time the log event was created.</p>
<h2 id="进程id"><a class="header" href="#进程id">进程ID</a></h2>
<p><strong>pid</strong>{[defaultValue]}
<strong>processId</strong>{[defaultValue]}</p>
<p>Outputs the process ID if supported by the underlying platform. An optional default value may be specified to be shown if the platform does not support process IDs.</p>
<h2 id="变量存在则打印"><a class="header" href="#变量存在则打印">变量存在则打印</a></h2>
<p>Outputs the result of evaluating the pattern if and only if all variables in the pattern are not empty.</p>
<pre><code>%notEmpty{[%marker]}
</code></pre>
<h2 id="日志级别-1"><a class="header" href="#日志级别-1">日志级别</a></h2>
<p><strong>p</strong>|<strong>level</strong>{<em>level</em>=<em>label</em>, <em>level</em>=<em>label</em>, ...} </p>
<p><strong>p</strong>|<strong>level</strong>{length=<em>n</em>} </p>
<p><strong>p</strong>|<strong>level</strong>{lowerCase=<em>true</em>|<em>false</em>}</p>
<p>输出日志事件的级别。您以“级别=值，级别=值”的形式提供级别名称映射，其中级别是级别的名称，值是应显示的值而不是级别的名称。</p>
<pre><code>%level{WARN=Warning, DEBUG=Debug, ERROR=Error, TRACE=Trace, INFO=Info}

</code></pre>
<p>Alternatively, for the compact-minded:</p>
<pre><code>%level{WARN=W, DEBUG=D, ERROR=E, TRACE=T, INFO=I}
</code></pre>
<p>更简洁地说，对于与上面相同的结果，您可以定义级别标签的长度：</p>
<pre><code>%level{length=1}
</code></pre>
<p>如果长度大于级别名称长度，则布局使用普通级别名称。</p>
<p>You can combine the two kinds of options:</p>
<pre><code>%level{ERROR=Error, length=2}
</code></pre>
<p>这将为您提供错误级别名称和长度为 2 的所有其他级别名称。</p>
<p>您可以输出小写级别的名称（默认为大写）：</p>
<pre><code>%level{lowerCase=true}
</code></pre>
<h2 id="从jvm启动时--日志事件的创建时间"><a class="header" href="#从jvm启动时--日志事件的创建时间">从<strong>JVM</strong>启动时  日志事件的创建时间</a></h2>
<p><strong>r</strong>
<strong>relative</strong></p>
<p>Outputs the number of milliseconds elapsed since the JVM was started until the creation of the logging event.</p>
<h2 id="内容替换"><a class="header" href="#内容替换">内容替换</a></h2>
<p>replace{pattern}{regex}{substitution}	</p>
<p>用它在模式评估产生的字符串中的替换 'substitution' 替换正则表达式 'regex' 的出现。例如，“%replace{%msg}{\s}{}”将删除事件消息中包含的所有空格</p>
<p>模式可以是任意复杂的，特别是可以包含多个转换关键字。例如，“%replace{%logger %msg}{.}{/}”将用正斜杠替换记录器或事件消息中的所有点。</p>
<h2 id="rthrowable"><a class="header" href="#rthrowable">RThrowable</a></h2>
<p><strong>rEx</strong>|<strong>rException</strong>|<strong>rThrowable</strong>
{
[&quot;none&quot; | &quot;short&quot; | &quot;full&quot; | depth]
[,filters(package,package,...)]
[,separator(<em>separator</em>)]
}
{ansi(
Key=Value,Value,...
Key=Value,Value,...
...)
}
{suffix(<em>pattern</em>)}</p>
<p>同 %throwable 转换字</p>
<p>但是堆栈跟踪从抛出的第一个异常开始打印，然后是每个后续的包装异常</p>
<p><strong>%rEx{short}</strong> </p>
<p>输出异常栈的第一行</p>
<p><strong>%rEx{n}</strong></p>
<p>输出栈的前几行</p>
<p><strong>%rEx{none} or %rEx{0}</strong> </p>
<p>禁用异常打印</p>
<p><strong>抑制栈帧</strong></p>
<p><strong>filters(<em>packages</em>)</strong> </p>
<p><em>packages</em> 是一个包名称列表，用于抑制来自堆栈跟踪的匹配堆栈帧。</p>
<p><strong>separator(<em>separator</em>)</strong></p>
<p>使用分隔符字符串来分隔堆栈跟踪的行。例如：分隔符(|)。默认值是 line.separator 系统属性，它依赖于操作系统。</p>
<p><strong>rEx{suffix(<em>pattern</em>)</strong> </p>
<p>to add the output of <em>pattern</em> to the output only when there is a throwable to print.</p>
<h2 id="日志事件自增序列"><a class="header" href="#日志事件自增序列">日志事件自增序列</a></h2>
<p>包括将在每个事件中递增的序列号。计数器是一个静态变量，因此仅在共享相同转换器类对象的应用程序中是唯一的。</p>
<h2 id="线程id"><a class="header" href="#线程id">线程ID</a></h2>
<p><strong>T</strong>
<strong>tid</strong>
<strong>threadId</strong></p>
<p>Outputs the ID of the thread that generated the logging event.</p>
<h2 id="线程名"><a class="header" href="#线程名">线程名</a></h2>
<p><strong>t</strong>
<strong>tn</strong>
<strong>thread</strong>
<strong>threadName</strong></p>
<h2 id="线程优先级-1"><a class="header" href="#线程优先级-1">线程优先级</a></h2>
<p><strong>tp</strong>
<strong>threadPriority</strong></p>
<h2 id="logger的全限定类名"><a class="header" href="#logger的全限定类名">logger的全限定类名</a></h2>
<p><strong>fqcn</strong></p>
<p>Outputs the fully qualified class name of the logger.</p>
<h2 id="endofbatch"><a class="header" href="#endofbatch">EndOfBatch</a></h2>
<p>Outputs the EndOfBatch status of the logging event, as &quot;true&quot; or &quot;false&quot;.</p>
<h2 id="ndc"><a class="header" href="#ndc">NDC</a></h2>
<p><strong>x</strong>
<strong>NDC</strong></p>
<p>Outputs the Thread Context Stack (also known as the Nested Diagnostic Context or NDC) associated with the thread that generated the logging event.</p>
<h2 id="mdc"><a class="header" href="#mdc">MDC</a></h2>
<p><strong>X</strong>{key[,key2...]}
<strong>mdc</strong>{key[,key2...]}
<strong>MDC</strong>{key[,key2...]}</p>
<p>Outputs the Thread Context Map (also known as the Mapped Diagnostic Context or MDC) associated with the thread that generated the logging event. </p>
<p>%X{clientNumber}</p>
<p>%X{name, number} using the format {name=val1, number=val2}</p>
<p>如果未指定子选项，则使用格式 {key1=val1, key2=val2} 输出 MDC 键值对集的全部内容。键/值对将按排序顺序打印。</p>
<p>See the <a href="https://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/ThreadContext.html">ThreadContext</a> class for more details.</p>
<h2 id="随机值"><a class="header" href="#随机值">随机值</a></h2>
<p><strong>u</strong>{&quot;RANDOM&quot; | &quot;TIME&quot;}
<strong>uuid</strong></p>
<p>包括随机或基于时间的 UUID。</p>
<p>The time-based UUID is a Type 1 UUID 每毫秒最多可以生成 10,000 个唯一 ID，</p>
<p>将使用每个主机的 MAC 地址，</p>
<p>并尝试确保同一主机上多个 JVM 和/或类加载器的唯一性</p>
<p>到 16,384 之间的随机数将与 UUID 生成器类的每个实例相关联，并包含在生成的每个基于时间的 UUID 中。</p>
<p>由于基于时间的 UUID 包含 MAC 地址和时间戳，因此应谨慎使用，因为它们可能导致安全漏洞。</p>
<h1 id="格式修饰符"><a class="header" href="#格式修饰符">格式修饰符</a></h1>
<p>默认情况下，相关信息按原样输出。但是，借助格式修饰符，可以更改最小字段宽度、最大字段宽度和对齐方式。</p>
<p>可选的格式修饰符位于百分号和转换字符之间。</p>
<p>第一个可选的格式修饰符是<em>左对齐标志</em>，它只是减号 (-) 字符</p>
<p>然后是可选的 <em>minimum field width</em> 修饰符</p>
<p>这是一个十进制常量，表示要输出的最小字符数。</p>
<p>如果数据项为较少的字符，则在左侧或右侧进行填充，直到达到最小宽度</p>
<p>默认是在左侧填充（右对齐），但您可以使用左对齐标志指定右填充。</p>
<p>填充字符是空格</p>
<p>如果数据项大于最小字段宽度，则扩展字段以容纳数据该值永远不会被截断</p>
<p>要使用零作为填充字符，请在 <em>minimum field width</em> 前面加上零。</p>
<p>可以使用 <em>maximum field width</em> 修饰符更改此行为，该修饰符由句点后跟十进制常量指定。</p>
<p>如果数据项比最大字段长，则从数据项的<em>开头</em>而不是结尾删除多余的字符。</p>
<p>例如，最大字段宽度为 8，数据项长度为 10 个字符，则删除数据项的前两个字符。</p>
<p>此行为不同于 C 中的 printf 函数，其中从末尾开始截断。</p>
<p>通过在句点后附加一个减号，可以从末尾截断。</p>
<p>在这种情况下，如果最大字段宽度为 8 且数据项长度为 10 个字符，则删除数据项的最后两个字符。</p>
<p>以下是类别转换说明符的各种格式修饰符示例。</p>
<p>Pattern Converters</p>
<table><thead><tr><th style="text-align: left">Format modifier</th><th style="text-align: left">left justify</th><th style="text-align: left">minimum width</th><th style="text-align: left">maximum width</th><th style="text-align: left">comment</th></tr></thead><tbody>
<tr><td style="text-align: left">%20c</td><td style="text-align: left">false</td><td style="text-align: left">20</td><td style="text-align: left">none</td><td style="text-align: left">Left pad with spaces if the category name is less than 20 characters long.</td></tr>
<tr><td style="text-align: left">%-20c</td><td style="text-align: left">true</td><td style="text-align: left">20</td><td style="text-align: left">none</td><td style="text-align: left">Right pad with spaces if the category name is less than 20 characters long.</td></tr>
<tr><td style="text-align: left">%.30c</td><td style="text-align: left">NA</td><td style="text-align: left">none</td><td style="text-align: left">30</td><td style="text-align: left">Truncate from the beginning if the category name is longer than 30 characters.</td></tr>
<tr><td style="text-align: left">%20.30c</td><td style="text-align: left">false</td><td style="text-align: left">20</td><td style="text-align: left">30</td><td style="text-align: left">Left pad with spaces if the category name is shorter than 20 characters. However, if category name is longer than 30 characters, then truncate from the beginning.</td></tr>
<tr><td style="text-align: left">%-20.30c</td><td style="text-align: left">true</td><td style="text-align: left">20</td><td style="text-align: left">30</td><td style="text-align: left">Right pad with spaces if the category name is shorter than 20 characters. However, if category name is longer than 30 characters, then truncate from the beginning.</td></tr>
<tr><td style="text-align: left">%-20.-30c</td><td style="text-align: left">true</td><td style="text-align: left">20</td><td style="text-align: left">30</td><td style="text-align: left">Right pad with spaces if the category name is shorter than 20 characters. However, if category name is longer than 30 characters, then truncate from the end.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置方式"><a class="header" href="#配置方式">配置方式</a></h1>
<p>Log4j 2 的配置可以通过以下 4 种方式中的一种来完成： </p>
<ol>
<li>
<p>通过以 XML、JSON、YAML 或属性格式编写的配置文件。</p>
</li>
<li>
<p>以编程方式，通过创建 ConfigurationFactory 和 Configuration 实现。</p>
</li>
<li>
<p>以编程方式，通过调用 Configuration 接口中公开的 API 将组件添加到默认配置中。</p>
</li>
<li>
<p>以编程方式，通过调用内部 Logger 类上的方法。</p>
</li>
</ol>
<h1 id="automatic-configuration"><a class="header" href="#automatic-configuration">Automatic Configuration</a></h1>
<p>Log4j 具有在初始化期间自动配置自身的能力。</p>
<p>当 Log4j 启动时，它会定位所有 ConfigurationFactory 插件，并按从高到低的加权顺序排列它们。</p>
<p>交付时，Log4j 包含四种 ConfigurationFactory 实现：</p>
<ol>
<li>
<p>一种用于 JSON，</p>
</li>
<li>
<p>一种用于 YAML，</p>
</li>
<li>
<p>一种用于 properties，</p>
</li>
<li>
<p>一种用于 XML。</p>
</li>
<li>
<p>Log4j 将检查“log4j2.configurationFile”系统属性，如果设置，将尝试使用与文件扩展名匹配的 ConfigurationFactory 加载配置。请注意，这不限于本地文件系统上的某个位置，并且可能包含一个 URL。</p>
</li>
<li>
<p>如果未设置系统属性，则Properties ConfigurationFactory 将在类路径中查找 log4j2-test.properties。</p>
</li>
<li>
<p>如果未找到此类文件，YAML ConfigurationFactory 将在类路径中查找 log4j2-test.yaml 或 log4j2-test.yml。</p>
</li>
<li>
<p>如果没有找到这样的文件，JSON ConfigurationFactory 将在类路径中查找 log4j2-test.json 或 log4j2-test.jsn。</p>
</li>
<li>
<p>如果没有找到这样的文件，XML ConfigurationFactory 将在类路径中查找 log4j2-test.xml。</p>
</li>
<li>
<p>如果无法找到测试文件，则属性 ConfigurationFactory 将在类路径上查找 log4j2.properties。</p>
</li>
<li>
<p>如果无法找到属性文件，YAML ConfigurationFactory 将在类路径上查找 log4j2.yaml 或 log4j2.yml。</p>
</li>
<li>
<p>如果找不到 YAML 文件，JSON ConfigurationFactory 将在类路径上查找 log4j2.json 或 log4j2.jsn。</p>
</li>
<li>
<p>如果找不到 JSON 文件，XML ConfigurationFactory 将尝试在类路径上定位 log4j2.xml。</p>
</li>
<li>
<p>如果找不到配置文件，则将使用 DefaultConfiguration。这将导致日志输出进入控制台。</p>
</li>
</ol>
<p>DefaultConfiguration 类中提供的默认配置将设置：</p>
<ol>
<li>A <a href="http://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/appender/ConsoleAppender.html">ConsoleAppender</a> attached to the root logger.</li>
<li>A <a href="http://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/layout/PatternLayout.html">PatternLayout</a> set to the pattern &quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot; attached to the ConsoleAppender</li>
</ol>
<p>默认情况下 Log4j 将根记录器分配给 Level.ERROR。</p>
<p>与默认值等效的配置如下所示：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;WARN&quot;&gt;
  &lt;Appenders&gt;
    &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
      &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt;
    &lt;/Console&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;Console&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<h1 id="additivity"><a class="header" href="#additivity">Additivity</a></h1>
<h1 id="automatic-reconfiguration"><a class="header" href="#automatic-reconfiguration">Automatic Reconfiguration</a></h1>
<p>从文件配置时，Log4j 能够自动检测对配置文件的更改并重新配置自身。如果在配置元素上指定了 monitorInterval 属性并将其设置为非零值，则在下次评估和/或记录日志事件时将检查该文件，并且自上次检查以来已经过去了 monitorInterval。下面的示例显示了如何配置属性，以便仅在至少 30 秒过去后才检查配置文件的更改。<strong>最小间隔为 5 秒。</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration monitorInterval=&quot;30&quot;&gt;
...
&lt;/Configuration&gt;
</code></pre>
<h2 id="advertising-appender-配置"><a class="header" href="#advertising-appender-配置">Advertising appender 配置</a></h2>
<p><a href="http://logging.apache.org/chainsaw/index.html">Chainsaw</a> 可以自动处理您的日志文件（Advertising appender 配置）</p>
<p>Log4j 提供了为所有基于文件的appenders以及基于套接字的appenders  “通告”appenders配置细节的能力。</p>
<p>例如，对于基于文件的 appender，文件中的文件位置和模式布局都包含在通告中</p>
<p>Chainsaw 和其他外部系统可以发现这些通告并使用该信息智能地处理日志文件。</p>
<p>展示通告的机制以及通告格式特定于每个通告商实现。</p>
<p>想要使用特定通告商实现的外部系统必须了解如何定位通告配置以及通告格式。</p>
<p>例如，“数据库”广告商可以将配置细节存储在数据库表中。</p>
<p>外部系统可以读取该数据库表以发现文件位置和文件格式。</p>
<p>Log4j 提供了一个 Advertiser 实现，即“multicastdns”Advertiser，它使用 http://jmdns.sourceforge.net 库通过 IP 多播来通告 appender 配置详细信息。</p>
<p>Chainsaw 自动发现 log4j 的多播dns 生成的通告</p>
<p>并在 Chainsaw 的 Zeroconf 选项卡中显示那些发现的通告（如果 jmdns 库在 Chainsaw 的类路径中）</p>
<p>要开始解析和跟踪通告中提供的日志文件，只需双击 Chainsaw 的 Zeroconf 选项卡中的通告条目。</p>
<p>目前，Chainsaw 仅支持 FileAppender通告。</p>
<p>要通告 appender 配置：</p>
<ul>
<li>Add the JmDns library from <a href="http://jmdns.sourceforge.net/">http://jmdns.sourceforge.net</a> to the application classpath</li>
<li>Set the 'advertiser' attribute of the configuration element to 'multicastdns'</li>
<li>Set the 'advertise' attribute on the appender element to 'true'</li>
<li>If advertising a FileAppender-based configuration, set the 'advertiseURI' attribute on the appender element to an appropriate URI</li>
</ul>
<p>基于 FileAppender 的配置需要在 appender 上指定一个额外的“advertiseURI”属性。 </p>
<p>'advertiseURI' 属性为 Chainsaw 提供有关如何访问文件的信息。</p>
<p>例如，通过指定 Commons VFS (http://commons.apache.org/proper/commons-vfs/) sftp:// URI，一个 http:// URI，Chainsaw 可以通过 ssh/sftp 远程访问该文件</p>
<p>如果文件可通过 Web 服务器访问，则可以使用；如果从本地运行的 Chainsaw 实例访问文件，则可以指定 file:// URI。</p>
<p>这是一个启用通告的 appender 配置示例，本地运行的 Chainsaw 可以使用它来自动跟踪日志文件（注意 file://advertiseURI）：</p>
<p>请注意，您必须将来自 http://jmdns.sourceforge.net 的 JmDns 库添加到您的应用程序类路径中，以便通过“multicastdns”通告商进行通告。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration advertiser=&quot;multicastdns&quot;&gt;
...
&lt;/Configuration&gt;
&lt;Appenders&gt;
  &lt;File name=&quot;File1&quot; fileName=&quot;output.log&quot; bufferedIO=&quot;false&quot; advertiseURI=&quot;file://path/to/output.log&quot; advertise=&quot;true&quot;&gt;
  ...
  &lt;/File&gt;
&lt;/Appenders&gt;
</code></pre>
<h1 id="configuration-syntax"><a class="header" href="#configuration-syntax">Configuration Syntax</a></h1>
<p>从 version 2.9 开始，出于安全原因，Log4j 不会处理 XML 文件中的 DTD。</p>
<p>如果要将配置拆分为多个文件，请使用 XInclude 或 Composite Configuration。</p>
<p>Log4j 允许您轻松地重新定义日志记录行为，而无需修改您的应用程序</p>
<ol>
<li>
<p>可以禁用应用程序的某些部分的日志记录，</p>
</li>
<li>
<p>仅在满足特定条件时才记录日志，</p>
</li>
<li>
<p>例如为特定用户执行的操作、路由输出到 Flume 或日志报告系统等。</p>
</li>
</ol>
<p>能够做到这一点需要理解配置文件的语法。 </p>
<h2 id="configuration接受几个属性"><a class="header" href="#configuration接受几个属性"><strong>Configuration接受几个属性：</strong></a></h2>
<table><thead><tr><th style="text-align: left">Attribute Name</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">advertiser</td><td style="text-align: left">将用于通过告单个 FileAppender 或 SocketAppender 配置的通过商插件名称<br />提供的唯一广告商插件是“multicastdns”。</td></tr>
<tr><td style="text-align: left">dest</td><td style="text-align: left">Either &quot;err&quot; for stderr, &quot;out&quot; for stdout, a file path, or a URL.</td></tr>
<tr><td style="text-align: left">monitorInterval</td><td style="text-align: left">在检查文件配置更改之前必须经过的最短时间（以秒为单位）</td></tr>
<tr><td style="text-align: left">name</td><td style="text-align: left">配置的名称。</td></tr>
<tr><td style="text-align: left">packages</td><td style="text-align: left">用于搜索插件的以逗号分隔的软件包名称列表。<br/><br/>每个类加载器只加载一次插件，因此更改此值可能不会对重新配置产生任何影响。</td></tr>
<tr><td style="text-align: left">schema</td><td style="text-align: left">标识用于定位用于验证配置的 XML 架构的类加载器的位置。<br/><br/>仅在strict 设置为true 时有效。<br/><br/>如果未设置，则不会进行架构验证。</td></tr>
<tr><td style="text-align: left">shutdownHook</td><td style="text-align: left">指定当 JVM 关闭时 Log4j 是否应该自动关闭。<br/><br/>关闭挂钩默认启用，但可以通过将此属性设置为“禁用”来禁用</td></tr>
<tr><td style="text-align: left">shutdownTimeout</td><td style="text-align: left">Specifies how many milliseconds appenders and background tasks will get to shutdown when the JVM shuts down. Default is zero which mean that each appender uses its default timeout, and don't wait for background tasks. Not all appenders will honor this, it is a hint and not an absolute guarantee that the shutdown procedure will not take longer. Setting this too low increase the risk of losing outstanding log events not yet written to the final destination. See <a href="http://logging.apache.org/log4j/2.x/log4j-core/target/site/apidocs/org/apache/logging/log4j/core/LoggerContext.html#stoplong_java.util.concurrent.TimeUnit">LoggerContext.stop(long, java.util.concurrent.TimeUnit)</a>. (Not used if shutdownHook is set to &quot;disable&quot;.)</td></tr>
<tr><td style="text-align: left">status</td><td style="text-align: left">应该记录到控制台的<strong>内部 Log4j 事件</strong>的级别。<br/><br/>此属性的有效值为“trace”、“debug”、“info”、“warn”、“error”和“fatal”。 <br/><br/>Log4j 会将有关初始化、翻转和其他内部操作的详细信息记录到状态记录器中。<br/><br/>如果您需要对 log4j 进行故障排除，设置 status=&quot;trace&quot; 是您可以使用的首批工具之一。（或者，设置系统属性 log4j2.debug 也会将内部 Log4j2 日志记录打印到控制台，包括在配置之前发生的内部日志记录<br/><br/>找到了文件。）</td></tr>
<tr><td style="text-align: left">strict</td><td style="text-align: left">允许使用严格的 XML 格式。 <br/><br/>JSON 配置不支持。</td></tr>
<tr><td style="text-align: left">verbose</td><td style="text-align: left">在加载插件时启用诊断信息。</td></tr>
</tbody></table>
<h1 id="configuration-with-xml"><a class="header" href="#configuration-with-xml">Configuration with XML</a></h1>
<p>Log4j 可以使用两种 XML 风格进行配置；</p>
<p>concise and strict.</p>
<p>简洁的格式使配置变得非常容易，因为元素名称与它们所代表的组件相匹配，但无法使用 XML 模式进行验证。</p>
<p>例如，ConsoleAppender 是通过在其父 appenders 元素下声明一个名为 Console 的 XML 元素来配置的</p>
<p>此外，属性可以指定为 XML 属性，也可以指定为没有属性但具有文本值的 XML 元素。</p>
<pre><code class="language-xml">&lt;PatternLayout pattern=&quot;%m%n&quot;/&gt;
与
&lt;PatternLayout&gt;
  &lt;Pattern&gt;%m%n&lt;/Pattern&gt;
&lt;/PatternLayout&gt;
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;;
&lt;Configuration&gt;
  &lt;Properties&gt;
    &lt;Property name=&quot;name1&quot;&gt;value&lt;/property&gt;
    &lt;Property name=&quot;name2&quot; value=&quot;value2&quot;/&gt;
  &lt;/Properties&gt;
  &lt;filter  ... /&gt;
  &lt;Appenders&gt;
    &lt;appender ... &gt;
      &lt;filter  ... /&gt;
    &lt;/appender&gt;
    ...
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Logger name=&quot;name1&quot;&gt;
      &lt;filter  ... /&gt;
    &lt;/Logger&gt;
    ...
    &lt;Root level=&quot;level&quot;&gt;
      &lt;AppenderRef ref=&quot;name&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;;
&lt;Configuration&gt;
  &lt;Properties&gt;
    &lt;Property name=&quot;name1&quot;&gt;value&lt;/property&gt;
    &lt;Property name=&quot;name2&quot; value=&quot;value2&quot;/&gt;
  &lt;/Properties&gt;
  &lt;Filter type=&quot;type&quot; ... /&gt;
  &lt;Appenders&gt;
    &lt;Appender type=&quot;type&quot; name=&quot;name&quot;&gt;
      &lt;Filter type=&quot;type&quot; ... /&gt;
    &lt;/Appender&gt;
    ...
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Logger name=&quot;name1&quot;&gt;
      &lt;Filter type=&quot;type&quot; ... /&gt;
    &lt;/Logger&gt;
    ...
    &lt;Root level=&quot;level&quot;&gt;
      &lt;AppenderRef ref=&quot;name&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;

与
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;debug&quot; strict=&quot;true&quot; name=&quot;XMLConfigTest&quot;
               packages=&quot;org.apache.logging.log4j.test&quot;&gt;
  &lt;Properties&gt;
    &lt;Property name=&quot;filename&quot;&gt;target/test.log&lt;/Property&gt;
  &lt;/Properties&gt;
  &lt;Filter type=&quot;ThresholdFilter&quot; level=&quot;trace&quot;/&gt;
 
  &lt;Appenders&gt;
    &lt;Appender type=&quot;Console&quot; name=&quot;STDOUT&quot;&gt;
      &lt;Layout type=&quot;PatternLayout&quot; pattern=&quot;%m MDC%X%n&quot;/&gt;
      &lt;Filters&gt;
        &lt;Filter type=&quot;MarkerFilter&quot; marker=&quot;FLOW&quot; onMatch=&quot;DENY&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
        &lt;Filter type=&quot;MarkerFilter&quot; marker=&quot;EXCEPTION&quot; onMatch=&quot;DENY&quot; onMismatch=&quot;ACCEPT&quot;/&gt;
      &lt;/Filters&gt;
    &lt;/Appender&gt;
    &lt;Appender type=&quot;Console&quot; name=&quot;FLOW&quot;&gt;
      &lt;Layout type=&quot;PatternLayout&quot; pattern=&quot;%C{1}.%M %m %ex%n&quot;/&gt;&lt;!-- class and line number --&gt;
      &lt;Filters&gt;
        &lt;Filter type=&quot;MarkerFilter&quot; marker=&quot;FLOW&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
        &lt;Filter type=&quot;MarkerFilter&quot; marker=&quot;EXCEPTION&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;
      &lt;/Filters&gt;
    &lt;/Appender&gt;
    &lt;Appender type=&quot;File&quot; name=&quot;File&quot; fileName=&quot;${filename}&quot;&gt;
      &lt;Layout type=&quot;PatternLayout&quot;&gt;
        &lt;Pattern&gt;%d %p %C{1.} [%t] %m%n&lt;/Pattern&gt;
      &lt;/Layout&gt;
    &lt;/Appender&gt;
  &lt;/Appenders&gt;
 
  &lt;Loggers&gt;
    &lt;Logger name=&quot;org.apache.logging.log4j.test1&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;
      &lt;Filter type=&quot;ThreadContextMapFilter&quot;&gt;
        &lt;KeyValuePair key=&quot;test&quot; value=&quot;123&quot;/&gt;
      &lt;/Filter&gt;
      &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;
    &lt;/Logger&gt;
 
    &lt;Logger name=&quot;org.apache.logging.log4j.test2&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;
      &lt;AppenderRef ref=&quot;File&quot;/&gt;
    &lt;/Logger&gt;
 
    &lt;Root level=&quot;trace&quot;&gt;
      &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
 
&lt;/Configuration&gt;
</code></pre>
<h1 id="configuring-loggers"><a class="header" href="#configuring-loggers">Configuring Loggers</a></h1>
<p><strong>配置<em>LoggConfig</em></strong></p>
<p>LoggerConfig 是使用 logger 元素配置的。 </p>
<p>logger 元素必须指定一个 name 属性，通常指定一个 level 属性，也可能指定一个 additivity 属性。</p>
<p>该级别可以配置为 TRACE、DEBUG、INFO、WARN、ERROR、ALL 或 OFF 之一。</p>
<p>如果未指定级别，则默认为 ERROR。</p>
<p><strong>捕获位置信息</strong></p>
<p>捕获位置信息（类名、文件名、方法名和调用者的行号）可能很慢。 </p>
<p>Log4j 试图通过减少必须遍历以找到日志记录方法的调用者的堆栈的大小来优化这一点。</p>
<p>它通过确定可能被访问的任何组件是否需要位置信息来实现这一点。</p>
<p>如果在跟踪或调试等级别配置记录器并期望大多数日志将在 Appender 引用或 Appender 上过滤，则这可能会导致性能问题，因为即使日志事件将被丢弃，Log4j 也会计算位置信息。</p>
<p>要禁用此行为，可以在 LoggerConfig 上将 includeLocation 属性设置为 false。</p>
<p>这将导致 Log4j 推迟计算位置信息，直到绝对必要。</p>
<p><strong>属性替换</strong></p>
<p>LoggerConfig（包括根 LoggerConfig）可以配置属性，这些属性将添加到从 ThreadContextMap 复制的属性中。</p>
<p>这些属性可以从 Appender、过滤器、布局等中引用，就像它们是 ThreadContext Map 的一部分一样。</p>
<p>属性可以包含在解析配置时或在记录每个事件时动态解析的变量。</p>
<p>有关使用变量的更多信息，请参阅属性替换。</p>
<p><strong>配置多个Appender</strong></p>
<ol>
<li>
<p>LoggerConfig 也可以配置一个或多个 AppenderRef 元素。</p>
</li>
<li>
<p>引用的每个 appender 都将与指定的 LoggerConfig 相关联。</p>
</li>
<li>
<p>如果在 LoggerConfig 上配置了多个 appender，则在处理日志事件时会调用它们中的每一个。</p>
</li>
</ol>
<p><strong>默认存在根配置</strong></p>
<p>每个配置都必须有一个根记录器。</p>
<p>如果未配置，则将使用默认根 LoggerConfig，其级别为 ERROR 并附加了 Console appender。</p>
<p>根记录器和其他记录器之间的主要区别是</p>
<ol>
<li>The root logger does not have a name attribute.</li>
<li>The root logger does not support the additivity attribute since it has no parent.</li>
</ol>
<h1 id="configuring-appenders"><a class="header" href="#configuring-appenders">Configuring Appenders</a></h1>
<p>使用特定的 appender 插件的名称或使用 appender 元素和包含 appender 插件名称的 type 属性来配置 appender。</p>
<p>此外，每个 appender 必须有一个 name 属性，指定一个值，该值在 appender 集合中是唯一的。</p>
<p>记录器将使用该名称来引用前一节中所述的附加程序。</p>
<p>大多数 appender 还支持要配置的布局（同样可以使用特定的 Layout 插件的名称作为元素或使用“layout”作为元素名称以及包含布局插件名称的 type 属性来指定。各种 appender 将</p>
<p>包含它们正常运行所需的其他属性或元素。</p>
<h1 id="configuring-filters"><a class="header" href="#configuring-filters">Configuring Filters</a></h1>
<p>Log4j 允许在 4 个位置中的任何一个指定过滤器</p>
<ol>
<li>与 appender、loggers 和 properties 元素处于同一级别。这些过滤器可以在事件被传递到 LoggerConfig 之前接受或拒绝事件。</li>
<li>在logger 元素中。这些过滤器可以接受或拒绝特定loggers的事件。</li>
<li>在 appender 元素中。这些过滤器可以阻止或导致事件被附加程序处理。</li>
<li>在 appender 引用元素中。这些过滤器用于确定 Logger 是否应该将事件路由到 appender。</li>
</ol>
<p>尽管只能配置单个过滤器元素，但该元素可能是表示 CompositeFilter 的过滤器元素。</p>
<p>过滤器元素允许在其中配置任意数量的过滤器元素。</p>
<p>以下示例显示了如何在 ConsoleAppender 上配置多个过滤器。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;debug&quot; name=&quot;XMLConfigTest&quot; packages=&quot;org.apache.logging.log4j.test&quot;&gt;
  &lt;Properties&gt;
    &lt;Property name=&quot;filename&quot;&gt;target/test.log&lt;/Property&gt;
  &lt;/Properties&gt;
  &lt;ThresholdFilter level=&quot;trace&quot;/&gt;
 
  &lt;Appenders&gt;
    &lt;Console name=&quot;STDOUT&quot;&gt;
      &lt;PatternLayout pattern=&quot;%m MDC%X%n&quot;/&gt;
    &lt;/Console&gt;
    &lt;Console name=&quot;FLOW&quot;&gt;
      &lt;!-- this pattern outputs class name and line number --&gt;
      &lt;PatternLayout pattern=&quot;%C{1}.%M %m %ex%n&quot;/&gt;
      &lt;filters&gt;
        &lt;MarkerFilter marker=&quot;FLOW&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;NEUTRAL&quot;/&gt;
        &lt;MarkerFilter marker=&quot;EXCEPTION&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;
      &lt;/filters&gt;
    &lt;/Console&gt;
    &lt;File name=&quot;File&quot; fileName=&quot;${filename}&quot;&gt;
      &lt;PatternLayout&gt;
        &lt;pattern&gt;%d %p %C{1.} [%t] %m%n&lt;/pattern&gt;
      &lt;/PatternLayout&gt;
    &lt;/File&gt;
  &lt;/Appenders&gt;
 
  &lt;Loggers&gt;
    &lt;Logger name=&quot;org.apache.logging.log4j.test1&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;
      &lt;ThreadContextMapFilter&gt;
        &lt;KeyValuePair key=&quot;test&quot; value=&quot;123&quot;/&gt;
      &lt;/ThreadContextMapFilter&gt;
      &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;
    &lt;/Logger&gt;
 
    &lt;Logger name=&quot;org.apache.logging.log4j.test2&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;
      &lt;Property name=&quot;user&quot;&gt;${sys:user.name}&lt;/Property&gt;
      &lt;AppenderRef ref=&quot;File&quot;&gt;
        &lt;ThreadContextMapFilter&gt;
          &lt;KeyValuePair key=&quot;test&quot; value=&quot;123&quot;/&gt;
        &lt;/ThreadContextMapFilter&gt;
      &lt;/AppenderRef&gt;
      &lt;AppenderRef ref=&quot;STDOUT&quot; level=&quot;error&quot;/&gt;
    &lt;/Logger&gt;
 
    &lt;Root level=&quot;trace&quot;&gt;
      &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
 
&lt;/Configuration&gt;
</code></pre>
<h1 id="property-substitution"><a class="header" href="#property-substitution">Property Substitution</a></h1>
<p>Log4j 2 支持在配置中指定 tokens  作为对其他地方定义的属性的引用的能力。</p>
<p>其中一些属性将在解释配置文件时解析，而其他属性可能会传递给组件在运行时解析。</p>
<p>为了实现这一点，Log4j 使用了 Apache Commons Lang 的 StrSubstitutor 和 StrLookup 类的变体</p>
<p>以类似于 Ant 或 Maven 的方式，这允许使用配置本身中声明的属性解析声明为 ${name} 的变量。</p>
<p>例如，以下示例显示了被声明为属性的滚动文件附加程序的文件名。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;debug&quot; name=&quot;RoutingTest&quot; packages=&quot;org.apache.logging.log4j.test&quot;&gt;
  &lt;Properties&gt;
    &lt;Property name=&quot;filename&quot;&gt;target/rolling1/rollingtest-$${sd:type}.log&lt;/Property&gt;
  &lt;/Properties&gt;
  &lt;ThresholdFilter level=&quot;debug&quot;/&gt;
 
  &lt;Appenders&gt;
    &lt;Console name=&quot;STDOUT&quot;&gt;
      &lt;PatternLayout pattern=&quot;%m%n&quot;/&gt;
      &lt;ThresholdFilter level=&quot;debug&quot;/&gt;
    &lt;/Console&gt;
    &lt;Routing name=&quot;Routing&quot;&gt;
      &lt;Routes pattern=&quot;$${sd:type}&quot;&gt;
        &lt;Route&gt;
          &lt;RollingFile name=&quot;Rolling-${sd:type}&quot; fileName=&quot;${filename}&quot;
                       filePattern=&quot;target/rolling1/test1-${sd:type}.%i.log.gz&quot;&gt;
            &lt;PatternLayout&gt;
              &lt;pattern&gt;%d %p %c{1.} [%t] %m%n&lt;/pattern&gt;
            &lt;/PatternLayout&gt;
            &lt;SizeBasedTriggeringPolicy size=&quot;500&quot; /&gt;
          &lt;/RollingFile&gt;
        &lt;/Route&gt;
        &lt;Route ref=&quot;STDOUT&quot; key=&quot;Audit&quot;/&gt;
      &lt;/Routes&gt;
    &lt;/Routing&gt;
  &lt;/Appenders&gt;
 
  &lt;Loggers&gt;
    &lt;Logger name=&quot;EventLogger&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;
      &lt;AppenderRef ref=&quot;Routing&quot;/&gt;
    &lt;/Logger&gt;
 
    &lt;Root level=&quot;error&quot;&gt;
      &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
 
&lt;/Configuration&gt;
</code></pre>
<p>虽然这很有用，但还有更多的地方可以创建属性。</p>
<p>为了适应这一点，Log4j 还支持语法 ${prefix:name} ，其中前缀标识告诉 Log4j 应该在特定上下文中评估变量名称。</p>
<p>Log4j 内置的上下文是：</p>
<table><thead><tr><th style="text-align: left">Prefix</th><th style="text-align: left">Context</th></tr></thead><tbody>
<tr><td style="text-align: left">base64</td><td style="text-align: left">Base64 encoded data. The format is ${base64:Base64_encoded_data}. For example: ${base64:SGVsbG8gV29ybGQhCg==} yields Hello World!.</td></tr>
<tr><td style="text-align: left">bundle</td><td style="text-align: left">Resource bundle. The format is ${bundle:BundleName:BundleKey}. The bundle name follows package naming conventions, for example: ${bundle:com.domain.Messages:MyKey}.</td></tr>
<tr><td style="text-align: left">ctx</td><td style="text-align: left">Thread Context Map (MDC)</td></tr>
<tr><td style="text-align: left">date</td><td style="text-align: left">使用指定格式插入当前日期和/或时间</td></tr>
<tr><td style="text-align: left">env</td><td style="text-align: left">System environment variables. The formats are ${env:ENV_NAME} and ${env:ENV_NAME:-default_value}.</td></tr>
<tr><td style="text-align: left">jndi</td><td style="text-align: left">A value set in the default JNDI Context.</td></tr>
<tr><td style="text-align: left">jvmrunargs</td><td style="text-align: left">A JVM input argument accessed through JMX, but not a main argument; see <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/management/RuntimeMXBean.html#getInputArguments--">RuntimeMXBean.getInputArguments()</a>. Not available on Android.</td></tr>
<tr><td style="text-align: left">log4j</td><td style="text-align: left">Log4j configuration properties. The expressions ${log4j:configLocation} and ${log4j:configParentLocation} respectively provide the absolute path to the log4j configuration file and its parent folder.</td></tr>
<tr><td style="text-align: left">main</td><td style="text-align: left">A value set with [MapLookup.setMainArguments(String<a href="http://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/lookup/MapLookup.html#setMainArguments-java.lang.String:A-">])</a></td></tr>
<tr><td style="text-align: left">map</td><td style="text-align: left">A value from a MapMessage</td></tr>
<tr><td style="text-align: left">sd</td><td style="text-align: left">来自 StructuredDataMessage 的值. The key &quot;id&quot; will return the name of the StructuredDataId without the enterprise number. The key &quot;type&quot; will return the message type. Other keys will retrieve individual elements from the Map.</td></tr>
<tr><td style="text-align: left">sys</td><td style="text-align: left">System properties. The formats are ${sys:some.property} and ${sys:some.property:-default_value}.</td></tr>
</tbody></table>
<h1 id="default-properites"><a class="header" href="#default-properites">Default Properites</a></h1>
<p>通过将 Properties 元素直接放在 Configuration 元素之后和任何 Loggers、Filters、Appenders 等声明之前，可以在配置文件中声明默认属性映射。</p>
<p>如果在指定的查找中无法找到该值，则将使用默认属性映射中的值。</p>
<p>默认映射预先填充了“hostName”的值，它是当前系统的主机名或 IP 地址，“contextName”是当前日志记录上下文的值。</p>
<p>也可以使用语法 ${lookupName:\key:-defaultValue} 在 Lookup 中指定默认属性。</p>
<p>在某些情况下，键可能包含前导“-”。</p>
<p>在这种情况下，必须包含转义字符，例如 ${main:--file:-app.properties}。</p>
<h1 id="disables-message-pattern-lookups"><a class="header" href="#disables-message-pattern-lookups">Disables Message Pattern Lookups</a></h1>
<p>消息由查找处理（默认情况下），例如，如果您定义了 </p>
<pre><code>&lt;Property name=&quot;foo.bar&quot;&gt;FOO_BAR &lt;/Property&gt;
</code></pre>
<p>则 logger.info(&quot;${foo.bar}&quot;) 将输出 FOO_BAR </p>
<p>${foo.bar} 的。</p>
<p>您可以通过将系统属性 log4j2.formatMsgNoLookups 设置为 true 或使用 %m{nolookups} 定义消息模式来全局禁用消息模式查找。</p>
<h1 id="lookup-variables-with-multiple-leading--characters"><a class="header" href="#lookup-variables-with-multiple-leading--characters">Lookup Variables with Multiple Leading '$' Characters</a></h1>
<p>StrLookup 处理的一个有趣特性是，当变量引用在每次解析变量时使用多个前导 '$' 字符声明时，前导 '$' 会被简单地删除。</p>
<p>在前面的示例中，“Routes”元素能够在运行时解析变量。</p>
<p>为此，将前缀值指定为带有两个前导 '$' 字符的变量。</p>
<p>当第一次处理配置文件时，第一个“$”字符被简单地删除。</p>
<p>因此，当 Routes 元素在运行时被评估时，它是变量声明“${sd:type}”，它导致事件被检查 StructuredDataMessage，如果存在，则其类型属性的值将用作路由钥匙。</p>
<p>并非所有元素都支持在运行时解析变量。执行此操作的组件将在其文档中明确指出这一点。</p>
<p>如果在与前缀关联的 Lookup 中找不到键的值，则将使用与配置文件中的属性声明中的键关联的值。</p>
<p>如果没有找到值，变量声明将作为值返回。</p>
<p>可以通过执行以下操作在配置中声明默认值：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration&gt;
  &lt;Properties&gt;
    &lt;Property name=&quot;type&quot;&gt;Audit&lt;/property&gt;
  &lt;/Properties&gt;
  ...
&lt;/Configuration&gt;
</code></pre>
<p>值得指出的是，在处理配置时也不会评估 RollingFile appender 声明中的变量。</p>
<p>这仅仅是因为整个 RollingFile 元素的解析被推迟到匹配发生。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripts"><a class="header" href="#scripts">Scripts</a></h1>
<p>Log4j 支持在其某些组件中使用 JSR 223 脚本语言。</p>
<p>可以使用任何为 <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/scripting/">JSR 223</a> 脚本引擎提供支持的语言。</p>
<p>可以在脚本引擎网站上找到语言和它们的绑定列表。</p>
<p>但是，其中列出的一些语言（例如 JavaScript、Groovy 和 Beanshell）直接支持 JSR 223 脚本框架，并且只需要安装该语言的 jar。</p>
<p>The components that support using scripts do so by allowing a <code>&lt;script&gt;</code>, <code>&lt;scriptFile&gt;</code>, or <code>&lt;scriptRef&gt;</code> element to be configured on them</p>
<ol>
<li>
<p>script元素包含脚本名称、脚本语言和脚本文本。 </p>
</li>
<li>
<p>scriptFile 元素包含脚本的名称、位置、语言、字符集以及是否应监视文件的更改。</p>
</li>
<li>
<p>scriptRef 元素包含在 配置元素中定义的脚本的名称</p>
</li>
<li>
<p>脚本的名称用于存储脚本及其 ScriptEngine，因此每次需要运行脚本时都可以快速定位</p>
</li>
<li>
<p>虽然名称不是必需的，但提供它有助于在脚本运行时调试问题。</p>
</li>
<li>
<p>必须在脚本元素上提供语言，并且必须指定出现在配置状态日志中的语言名称之一，如下一节所述</p>
</li>
<li>
<p>如果未在 scriptFile 元素上指定语言，则语言将由脚本路径的文件扩展名确定</p>
</li>
<li>
<p>如果请求文件监视，则只有在配置元素上指定了非零的 monitorInterval 时才会启用它。该间隔将用于检查文件中的更改。</p>
</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Configuration status=&quot;debug&quot; name=&quot;RoutingTest&quot;&gt;
  &lt;Scripts&gt;
    &lt;Script name=&quot;selector&quot; language=&quot;javascript&quot;&gt;&lt;![CDATA[
            var result;
            if (logEvent.getLoggerName().equals(&quot;JavascriptNoLocation&quot;)) {
                result = &quot;NoLocation&quot;;
            } else if (logEvent.getMarker() != null &amp;&amp; logEvent.getMarker().isInstanceOf(&quot;FLOW&quot;)) {
                result = &quot;Flow&quot;;
            }
            result;
            ]]&gt;&lt;/Script&gt;
    &lt;ScriptFile name=&quot;groovy.filter&quot; path=&quot;scripts/filter.groovy&quot;/&gt;
  &lt;/Scripts&gt;
 
  &lt;Appenders&gt;
    &lt;Console name=&quot;STDOUT&quot;&gt;
      &lt;ScriptPatternSelector defaultPattern=&quot;%d %p %m%n&quot;&gt;
        &lt;ScriptRef ref=&quot;selector&quot;/&gt;
          &lt;PatternMatch key=&quot;NoLocation&quot; pattern=&quot;[%-5level] %c{1.} %msg%n&quot;/&gt;
          &lt;PatternMatch key=&quot;Flow&quot; pattern=&quot;[%-5level] %c{1.} ====== %C{1.}.%M:%L %msg ======%n&quot;/&gt;
      &lt;/ScriptPatternSelector&gt;
      &lt;PatternLayout pattern=&quot;%m%n&quot;/&gt;
    &lt;/Console&gt;
  &lt;/Appenders&gt;
 
  &lt;Loggers&gt;
    &lt;Logger name=&quot;EventLogger&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;
        &lt;ScriptFilter onMatch=&quot;ACCEPT&quot; onMisMatch=&quot;DENY&quot;&gt;
          &lt;Script name=&quot;GroovyFilter&quot; language=&quot;groovy&quot;&gt;&lt;![CDATA[
            if (logEvent.getMarker() != null &amp;&amp; logEvent.getMarker().isInstanceOf(&quot;FLOW&quot;)) {
                return true;
            } else if (logEvent.getContextMap().containsKey(&quot;UserId&quot;)) {
                return true;
            }
            return false;
            ]]&gt;
          &lt;/Script&gt;
        &lt;/ScriptFilter&gt;
      &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;
    &lt;/Logger&gt;
 
    &lt;Root level=&quot;error&quot;&gt;
      &lt;ScriptFilter onMatch=&quot;ACCEPT&quot; onMisMatch=&quot;DENY&quot;&gt;
        &lt;ScriptRef ref=&quot;groovy.filter&quot;/&gt;
      &lt;/ScriptFilter&gt;
      &lt;AppenderRef ref=&quot;STDOUT&quot;/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
 
&lt;/Configuration&gt;
</code></pre>
<p>如果 Configuration 元素上的 status 属性设置为 DEBUG，则会列出当前安装的脚本引擎列表及其属性。</p>
<p>尽管有些引擎可能会说它们不是线程安全的，但如果引擎通告它不是线程安全的，Log4j 会采取措施确保脚本以线程安全的方式运行。</p>
<p>当脚本被执行时，它们将被提供一组变量，这些变量应该允许它们完成预期执行的任何任务。</p>
<p>有关脚本可用的变量列表，请参阅各个组件的文档。</p>
<p>支持脚本编写的组件期望将返回值传递回调用 Java 代码。</p>
<p>这对于一些脚本语言来说不是问题，但 Javascript 不允许 return 语句，除非它在函数内。</p>
<p>但是，Javascript 将返回脚本中执行的最后一条语句的值。</p>
<p>因此，如下所示的代码将导致所需的行为。</p>
<pre><code class="language-js">       var result;
            if (logEvent.getLoggerName().equals(&quot;JavascriptNoLocation&quot;)) {
                result = &quot;NoLocation&quot;;
            } else if (logEvent.getMarker() != null &amp;&amp; logEvent.getMarker().isInstanceOf(&quot;FLOW&quot;)) {
                result = &quot;Flow&quot;;
            }
            result;
</code></pre>
<h1 id="xinclude"><a class="header" href="#xinclude">XInclude</a></h1>
<p>XML 配置文件可以包含其他带有 XInclude 的文件。</p>
<p>这是一个示例 log4j2.xml 文件，其中包含另外两个文件：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;
               status=&quot;warn&quot; name=&quot;XIncludeDemo&quot;&gt;
  &lt;properties&gt;
    &lt;property name=&quot;filename&quot;&gt;xinclude-demo.log&lt;/property&gt;
  &lt;/properties&gt;
  &lt;ThresholdFilter level=&quot;debug&quot;/&gt;
  &lt;xi:include href=&quot;log4j-xinclude-appenders.xml&quot; /&gt;
  &lt;xi:include href=&quot;log4j-xinclude-loggers.xml&quot; /&gt;
&lt;/configuration&gt;
</code></pre>
<p><strong>log4j-xinclude-appenders.xml</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;appenders&gt;
  &lt;Console name=&quot;STDOUT&quot;&gt;
    &lt;PatternLayout pattern=&quot;%m%n&quot; /&gt;
  &lt;/Console&gt;
  &lt;File name=&quot;File&quot; fileName=&quot;${filename}&quot; bufferedIO=&quot;true&quot; immediateFlush=&quot;true&quot;&gt;
    &lt;PatternLayout&gt;
      &lt;pattern&gt;%d %p %C{1.} [%t] %m%n&lt;/pattern&gt;
    &lt;/PatternLayout&gt;
  &lt;/File&gt;
&lt;/appenders&gt;
</code></pre>
<p>log4j-xinclude-loggers.xml:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;loggers&gt;  &lt;logger name=&quot;org.apache.logging.log4j.test1&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;    &lt;ThreadContextMapFilter&gt;      &lt;KeyValuePair key=&quot;test&quot; value=&quot;123&quot; /&gt;    &lt;/ThreadContextMapFilter&gt;    &lt;AppenderRef ref=&quot;STDOUT&quot; /&gt;  &lt;/logger&gt;   &lt;logger name=&quot;org.apache.logging.log4j.test2&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;    &lt;AppenderRef ref=&quot;File&quot; /&gt;  &lt;/logger&gt;   &lt;root level=&quot;error&quot;&gt;    &lt;AppenderRef ref=&quot;STDOUT&quot; /&gt;  &lt;/root&gt;&lt;/loggers&gt;
</code></pre>
<h1 id="composite-configuration"><a class="header" href="#composite-configuration">Composite Configuration</a></h1>
<p>Log4j 允许使用多个配置文件，方法是在 log4j.configurationFile 上将它们指定为逗号分隔的文件路径列表，或者在使用 url 时，通过添加辅助配置位置作为名为“override”的查询参数。</p>
<p>可以通过在 log4j.mergeStrategy 属性上指定实现 MergeStrategy 接口的类来控制合并逻辑。</p>
<p>默认合并策略将使用以下规则合并文件：</p>
<ol>
<li>
<p>全局配置属性与后面配置中的属性聚合，替换以前配置中的属性，但以下情况除外</p>
<ul>
<li>将使用最高状态级别</li>
<li>将使用大于 0 的最低 monitorInterval</li>
<li>packages are joined with comma</li>
</ul>
</li>
<li>
<p>汇总所有配置的属性.重复的属性替换了以前配置中的属性</p>
</li>
<li>
<p>如果定义了多个过滤器，则过滤器将在 CompositeFilter 下聚合。由于过滤器未命名，因此可能存在重复项。</p>
</li>
<li>
<p>脚本和脚本文件引用被聚合。重复的定义取代了先前配置中的定义.</p>
</li>
<li>
<p>Appender 是聚合的。具有相同名称的 Appender 被后面的配置中的 Appender 替换，包括 Appender 的所有子组件</p>
</li>
<li>
<p>记录器都是聚合的。记录器属性单独合并，重复项被后续配置中的那些属性替换。 </p>
<p>Logger 上的 Appender 引用被聚合，重复项被后面的配置中的那些替换。如果定义了多个过滤器，则 Logger 上的过滤器将在 CompositeFilter 下聚合。由于过滤器未命名，因此可能存在重复项。包含或丢弃 Appender 引用下的过滤器取决于是保留还是丢弃其父 Appender 引用。</p>
</li>
</ol>
<h1 id="status-messages"><a class="header" href="#status-messages">Status Messages</a></h1>
<p><strong>Troubleshooting tip for the impatient:</strong></p>
<p>从 log4j-2.9 开始，如果定义了系统属性 log4j2.debug（具有任何值或没有值），log4j2 会将所有内部日志记录打印到控制台。</p>
<p>在 log4j-2.9 之前，有两个地方可以控制内部日志记录： </p>
<ol>
<li>
<p>在找到配置之前，可以使用系统属性 org.apache.logging.log4j.simplelog.StatusLogger.level 控制状态记录器级别。</p>
</li>
<li>
<p>找到配置后，可以在配置文件中使用“status”属性控制状态记录器级别，例如：<code>&lt;Configuration status=&quot;trace&quot;&gt;.</code></p>
</li>
</ol>
<p>正如希望能够诊断应用程序中的问题一样，经常需要能够诊断日志配置或已配置组件中的问题。</p>
<p>由于尚未配置日志记录，因此在初始化期间无法使用“正常”日志记录。</p>
<p>此外，appender 中的正常日志记录可能会创建无限递归，Log4j 将检测到该递归并导致递归事件被忽略。</p>
<p>为了满足这种需求，Log4j 2 API 包含一个 StatusLogger。</p>
<pre><code class="language-java">protected final static Logger logger = StatusLogger.getLogger();
</code></pre>
<p>由于 StatusLogger 实现了 Log4j 2 API 的 Logger 接口，因此可以使用所有正常的 Logger 方法。</p>
<p>在配置 Log4j 时，有时需要查看生成的状态事件。</p>
<p>这可以通过将 status 属性添加到配置元素来完成，或者可以通过设置“Log4jDefaultStatusLevel”系统属性来提供默认值。 </p>
<p>status 属性的有效值为“trace”、“debug”、“info”、“warn”、“error”和“fatal”。</p>
<h1 id="testing-in-maven"><a class="header" href="#testing-in-maven">Testing in Maven</a></h1>
<p>Maven 可以在构建周期中运行单元和功能测试。</p>
<p>默认情况下，放置在 src/test/resources 中的任何文件都会自动复制到 target/test-classes 并在执行任何测试期间包含在类路径中。</p>
<p>因此，将 log4j2-test.xml 放入此目录将导致使用它而不是可能存在的 log4j2.xml 或 log4j2.json。</p>
<p>因此，在测试期间可以使用不同于生产中使用的日志配置。 </p>
<p>Log4j 2 广泛使用的第二种方法是在 junit 测试类中用 @BeforeClass 注释的方法中设置 log4j.configurationFile 属性。</p>
<p>这将允许在测试期间使用任意命名的文件。 </p>
<p>Log4j 2 也广泛使用的第三种方法是使用 LoggerContextRule JUnit 测试规则，它为测试提供了额外的便利方法。</p>
<p>这需要将 log4j-core test-jar 依赖项添加到您的测试范围依赖项中。</p>
<pre><code class="language-java">public class AwesomeTest {
    @Rule
    public LoggerContextRule init = new LoggerContextRule(&quot;MyTestConfig.xml&quot;);
 
    @Test
    public void testSomeAwesomeFeature() {
        final LoggerContext ctx = init.getLoggerContext();
        final Logger logger = init.getLogger(&quot;org.apache.logging.log4j.my.awesome.test.logger&quot;);
        final Configuration cfg = init.getConfiguration();
        final ListAppender app = init.getListAppender(&quot;List&quot;);
        logger.warn(&quot;Test message&quot;);
        final List&lt;LogEvent&gt; events = app.getEvents();
        // etc.
    }
}
</code></pre>
<h1 id="system-properties"><a class="header" href="#system-properties">System Properties</a></h1>
<p>Log4j 文档引用了许多系统属性，可用于控制 Log4j 2 行为的各个方面。</p>
<p>下表列出了这些属性以及它们的默认值和它们控制的内容的描述。</p>
<p>属性名称中存在的任何空格都用于视觉流，应删除。</p>
<p>请注意，从 Log4j 2.10 开始，所有系统属性名称都已规范化以遵循一致的命名方案。</p>
<p>虽然仍支持旧的属性名称以实现向后兼容性，但建议更新配置以使用新样式。</p>
<p>该系统是可扩展的，并通过 PropertySource 接口启用。</p>
<p>可以通过 Java SE 中的标准 ServiceLoader 机制添加其他属性源类。</p>
<p>属性可以被优先级较低的源覆盖（例如，-100 在 100 之前）。</p>
<p>默认情况下，以下来源都是可用的：</p>
<table><thead><tr><th style="text-align: left">Source</th><th style="text-align: left">Priority</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Environment Variables</td><td style="text-align: left">-100</td><td style="text-align: left">环境变量都以LOG4J_为前缀，全部大写，单词之间用下划线分隔。只有这个命名方案支持环境变量，因为没有旧的命名方案来保持兼容性。</td></tr>
<tr><td style="text-align: left">log4j2.component.properties file</td><td style="text-align: left">0</td><td style="text-align: left">在类路径中包含此文件可用作提供属性作为系统属性的替代方法。这优先于系统属性，但它们可以被如上所述的环境变量覆盖。</td></tr>
<tr><td style="text-align: left">System Properties</td><td style="text-align: left">100</td><td style="text-align: left">所有属性都可以使用正常的系统属性模式设置。<br/><br/>它们具有最低优先级，可以被包含的属性文件或环境变量覆盖。</td></tr>
</tbody></table>
<p>以下是可用全局配置属性的列表。</p>
<p>请注意，与配置文件中可用的配置设置不同，这些只能为每个 JVM 进程设置一次。</p>
<p>属性名称列包含在属性文件和系统属性中使用的名称； </p>
<p>Environemt Variable 为等效的环境变量；</p>
<p>和 2.10 之前的名称的旧属性名称。</p>
<table><thead><tr><th style="text-align: left">Property Name (Legacy Property Name)</th><th style="text-align: left">Environment Variable</th><th style="text-align: left">Default Value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">log4j2.configurationFile (log4j.configurationFile)</td><td style="text-align: left">LOG4J_CONFIGURATION_FILE</td><td style="text-align: left">Log4j 2 配置文件的路径。<br/>还可能包含逗号分隔的配置文件名列表。可能包含一个 URL。<br/><br/>当指定为 URL 时，“覆盖”查询参数可用于指定其他配置文件位置。</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">log4j2.debug (log4j2.debug)</td><td style="text-align: left">LOG4J_DEBUG</td><td style="text-align: left"></td><td style="text-align: left">Log4j2 will print all internal logging to the console if system property log4j2.debug is defined (with any or no value).</td></tr>
<tr><td style="text-align: left">log4j2.mergeStrategy (log4j.mergeStrategy)</td><td style="text-align: left">LOG4J_MERGE_STRATEGY</td><td style="text-align: left"></td><td style="text-align: left">The name of the class that implements the MergeStrategy interface. If not specified DefaultMergeStrategy will be used when creating a CompositeConfiguration..</td></tr>
<tr><td style="text-align: left">log4j2.contextSelector (Log4jContextSelector)</td><td style="text-align: left">LOG4J_CONTEXT_SELECTOR</td><td style="text-align: left">ClassLoaderContextSelector</td><td style="text-align: left">Creates the LoggerContexts. An application can have one or more active LoggerContexts depending on the circumstances. See <a href="https://logging.apache.org/log4j/2.x/manual/logsep.html">Log Separation</a> for more details. Available context selector implementation classes: org.apache.logging.log4j.core.async .AsyncLoggerContextSelector - makes <a href="https://logging.apache.org/log4j/2.x/manual/async.html">all loggers asynchronous</a>. org.apache.logging.log4j.core.selector .BasicContextSelector - creates a single shared LoggerContext. org.apache.logging.log4j.core.selector .ClassLoaderContextSelector - separate LoggerContexts for each web application. org.apache.logging.log4j.core.selector .JndiContextSelector - use JNDI to locate each web application's LoggerContext. org.apache.logging.log4j.core.osgi .BundleContextSelector - separate LoggerContexts for each OSGi bundle.</td></tr>
<tr><td style="text-align: left">log4j2.logEventFactory (Log4jLogEventFactory)</td><td style="text-align: left">LOG4J_LOG_EVENT_FACTORY</td><td style="text-align: left">org.apache.logging.log4j.core.impl .DefaultLogEventFactory</td><td style="text-align: left">Factory class used by LoggerConfig to create LogEvent instances. (Ignored when the AsyncLoggerContextSelector is used.)</td></tr>
<tr><td style="text-align: left">log4j2.loggerContextFactory (log4j2.loggerContextFactory)</td><td style="text-align: left">LOG4J_LOGGER_CONTEXT_FACTORY</td><td style="text-align: left">org.apache.logging.log4j.simple .SimpleLoggerContextFactory</td><td style="text-align: left">Factory class used by LogManager to bootstrap the logging implementation. The core jar provides org.apache.logging.log4j.core .impl.Log4jContextFactory.</td></tr>
<tr><td style="text-align: left">log4j2.configurationFactory (log4j.configurationFactory)</td><td style="text-align: left">LOG4J_CONFIGURATION_FACTORY</td><td style="text-align: left"></td><td style="text-align: left">Fully specified class name of a class extending org.apache.logging.log4j.core .config.ConfigurationFactory. If specified, an instance of this class is added to the list of configuration factories.</td></tr>
<tr><td style="text-align: left">log4j2.shutdownHookEnabled (log4j.shutdownHookEnabled)</td><td style="text-align: left">LOG4J_SHUTDOWN_<br />HOOK_ENABLED</td><td style="text-align: left">true</td><td style="text-align: left">Overrides the global flag for whether or not a shutdown hook should be used to stop a LoggerContext. By default, this is enabled and can be disabled on a per-configuration basis. When running with the log4j-web module, this is automatically disabled.</td></tr>
<tr><td style="text-align: left">log4j2.shutdownCallbackRegistry (log4j.shutdownCallbackRegistry)</td><td style="text-align: left">LOG4J_SHUTDOWN_<br />CALLBACK_REGISTRY</td><td style="text-align: left">org.apache.logging.log4j.core.util .DefaultShutdownCallbackRegistry</td><td style="text-align: left">Fully specified class name of a class implementing <a href="https://logging.apache.org/log4j/2.x/log4j-core/apidocs/org/apache/logging/log4j/core/util/ShutdownCallbackRegistry.html">ShutdownCallbackRegistry</a>. If specified, an instance of this class is used instead of DefaultShutdownCallbackRegistry. The specified class must have a default constructor.</td></tr>
<tr><td style="text-align: left">log4j2.clock (log4j.Clock)</td><td style="text-align: left">LOG4J_CLOCK</td><td style="text-align: left">SystemClock</td><td style="text-align: left">Implementation of the org.apache.logging.log4j .core.util.Clock interface that is used for timestamping the log events. By default, System.currentTimeMillis is called on every log event. You can also specify a fully qualified class name of a custom class that implements the Clock interface.</td></tr>
<tr><td style="text-align: left">log4j2.level (org.apache.logging.log4j.level)</td><td style="text-align: left">LOG4J_LEVEL</td><td style="text-align: left">ERROR</td><td style="text-align: left">Log level of the default configuration. The default configuration is used if the ConfigurationFactory could not successfully create a configuration (e.g. no log4j2.xml file was found).</td></tr>
<tr><td style="text-align: left">log4j2.disableThreadContext (disableThreadContext)</td><td style="text-align: left">LOG4J_DISABLE_<br />THREAD_CONTEXT</td><td style="text-align: left">false</td><td style="text-align: left">If true, the ThreadContext stack and map are disabled. (May be ignored if a custom ThreadContext map is specified.)</td></tr>
<tr><td style="text-align: left">log4j2.disableThreadContextStack (disableThreadContextStack)</td><td style="text-align: left">LOG4J_DISABLE_THREAD_<br />CONTEXT_STACK</td><td style="text-align: left">false</td><td style="text-align: left">If true, the ThreadContext stack is disabled.</td></tr>
<tr><td style="text-align: left">log4j2.disableThreadContextMap (disableThreadContextMap)</td><td style="text-align: left">LOG4J_DISABLE_THREAD_<br />CONTEXT_MAP</td><td style="text-align: left">false</td><td style="text-align: left">If true, the ThreadContext map is disabled. (May be ignored if a custom ThreadContext map is specified.)</td></tr>
<tr><td style="text-align: left">log4j2.threadContextMap (log4j2.threadContextMap)</td><td style="text-align: left">LOG4J_THREAD_CONTEXT_MAP</td><td style="text-align: left"></td><td style="text-align: left">Fully specified class name of a custom ThreadContextMap implementation class.</td></tr>
<tr><td style="text-align: left">log4j2.isThreadContextMapInheritable (isThreadContextMapInheritable)</td><td style="text-align: left">LOG4J_IS_THREAD_CONTEXT<br />_MAP_INHERITABLE</td><td style="text-align: left">false</td><td style="text-align: left">If true use a InheritableThreadLocal to implement the ThreadContext map. Otherwise, use a plain ThreadLocal. (May be ignored if a custom ThreadContext map is specified.)</td></tr>
<tr><td style="text-align: left">log4j2.contextDataInjector (log4j2.ContextDataInjector)</td><td style="text-align: left">LOG4J_CONTEXT_DATA_INJECTOR</td><td style="text-align: left"></td><td style="text-align: left">Fully specified class name of a custom ContextDataInjector implementation class.</td></tr>
<tr><td style="text-align: left">log4j2.garbagefreeThreadContextMap (log4j2.garbagefree.threadContextMap)</td><td style="text-align: left">LOG4J_GARBAGEFREE_<br />THREAD_CONTEXT_MAP</td><td style="text-align: left">false</td><td style="text-align: left">Specify &quot;true&quot; to make the ThreadContext map garbage-free.</td></tr>
<tr><td style="text-align: left">log4j2.disableJmx (log4j2.disable.jmx)</td><td style="text-align: left">LOG4J_DISABLE_JMX</td><td style="text-align: left">false</td><td style="text-align: left">If true, Log4j configuration objects like LoggerContexts, Appenders, Loggers, etc. will not be instrumented with MBeans and cannot be remotely monitored and managed.</td></tr>
<tr><td style="text-align: left">log4j2.jmxNotifyAsync (log4j2.jmx.notify.async)</td><td style="text-align: left">LOG4J_JMX_NOTIFY_ASYNC</td><td style="text-align: left">false for web apps, true otherwise</td><td style="text-align: left">If true, log4j's JMX notifications are sent from a separate background thread, otherwise they are sent from the caller thread. If system property log4j2.is.webapp is true or the javax.servlet.Servlet class is on the classpath, the default behaviour is to use the caller thread to send JMX notifications.</td></tr>
<tr><td style="text-align: left">log4j2.skipJansi (log4j.skipJansi)</td><td style="text-align: left">LOG4J_SKIP_JANSI</td><td style="text-align: left">true</td><td style="text-align: left">If true, the ConsoleAppender will not try to use the Jansi output stream on Windows.</td></tr>
<tr><td style="text-align: left">log4j2.ignoreTCL (log4j.ignoreTCL)</td><td style="text-align: left">LOG4J_IGNORE_TCL</td><td style="text-align: left">false</td><td style="text-align: left">If true, classes are only loaded with the default class loader. Otherwise, an attempt is made to load classes with the current thread's context class loader before falling back to the default class loader.</td></tr>
<tr><td style="text-align: left">log4j2.uuidSequence (org.apache.logging.log4j.uuidSequence)</td><td style="text-align: left">LOG4J_UUID_SEQUENCE</td><td style="text-align: left">0</td><td style="text-align: left">System property that may be used to seed the UUID generation with an integer value.</td></tr>
<tr><td style="text-align: left">log4j2.simplelogShowContextMap (org.apache.logging.log4j .simplelog.showContextMap)</td><td style="text-align: left">LOG4J_SIMPLELOG_SHOW<br />_CONTEXT_MAP</td><td style="text-align: left">false</td><td style="text-align: left">If true, the full ThreadContext map is included in each SimpleLogger log message.</td></tr>
<tr><td style="text-align: left">log4j2.simplelogShowlogname (org.apache.logging.log4j .simplelog.showlogname)</td><td style="text-align: left">LOG4J_SIMPLELOG_SHOWLOGNAME</td><td style="text-align: left">false</td><td style="text-align: left">If true, the logger name is included in each SimpleLogger log message.</td></tr>
<tr><td style="text-align: left">log4j2.simplelogShowShortLogname (org.apache.logging.log4j .simplelog.showShortLogname)</td><td style="text-align: left">LOG4J_SIMPLELOG_SHOW_<br />SHORT_LOGNAME</td><td style="text-align: left">true</td><td style="text-align: left">If true, only the last component of a logger name is included in SimpleLogger log messages. (E.g., if the logger name is &quot;mycompany.myproject.mycomponent&quot;, only &quot;mycomponent&quot; is logged.</td></tr>
<tr><td style="text-align: left">log4j2.simplelogShowdatetime (org.apache.logging.log4j .simplelog.showdatetime)</td><td style="text-align: left">LOG4J_SIMPLELOG_SHOWDATETIME</td><td style="text-align: left">false</td><td style="text-align: left">If true, SimpleLogger log messages contain timestamp information.</td></tr>
<tr><td style="text-align: left">log4j2.simplelogDateTimeFormat (org.apache.logging.log4j .simplelog.dateTimeFormat)</td><td style="text-align: left">LOG4J_SIMPLELOG_<br />DATE_TIME_FORMAT</td><td style="text-align: left">&quot;yyyy/MM/dd HH:mm:ss:SSS zzz&quot;</td><td style="text-align: left">Date-time format to use. Ignored if org.apache.logging.log4j .simplelog.showdatetime is false.</td></tr>
<tr><td style="text-align: left">log4j2.simplelogLogFile (org.apache.logging.log4j .simplelog.logFile)</td><td style="text-align: left">LOG4J_SIMPLELOG_LOG_FILE</td><td style="text-align: left">system.err</td><td style="text-align: left">&quot;system.err&quot; (case-insensitive) logs to System.err, &quot;system.out&quot; (case-insensitive) logs to System.out, any other value is interpreted as a file name to save SimpleLogger messages to.</td></tr>
<tr><td style="text-align: left">log4j2.simplelogLevel (org.apache.logging.log4j .simplelog.level)</td><td style="text-align: left">LOG4J_SIMPLELOG_LEVEL</td><td style="text-align: left">ERROR</td><td style="text-align: left">Default level for new SimpleLogger instances.</td></tr>
<tr><td style="text-align: left">log4j2.simplelog.<loggerName>.level (org.apache.logging.log4j .simplelog.<loggerName>.level)</td><td style="text-align: left">LOG4J_SIMPLELOG_&lt;LOGGER_NAME&gt;_LEVEL</td><td style="text-align: left">SimpleLogger default log level</td><td style="text-align: left">Log level for a the SimpleLogger instance with the specified name.</td></tr>
<tr><td style="text-align: left">log4j2.simplelogStatusLoggerLevel (org.apache.logging.log4j.simplelog .StatusLogger.level)</td><td style="text-align: left">LOG4J_SIMPLELOG_STATUS<br />_LOGGER_LEVEL</td><td style="text-align: left">ERROR</td><td style="text-align: left">This property is used to control the initial StatusLogger level, and can be overridden in code by calling StatusLogger.getLogger() .setLevel(someLevel). Note that the StatusLogger level is only used to determine the status log output level until a listener is registered. In practice, a listener is registered when a configuration is found, and from that point onwards, status messages are only sent to the listeners (depending on their statusLevel).</td></tr>
<tr><td style="text-align: left">log4j2.defaultStatusLevel (Log4jDefaultStatusLevel)</td><td style="text-align: left">LOG4J_DEFAULT_STATUS_LEVEL</td><td style="text-align: left">ERROR</td><td style="text-align: left">The StatusLogger logs events that occur in the logging system to the console. During configuration, AbstractConfiguration registers a StatusConsoleListener with the StatusLogger that may redirect status log events from the default console output to a file. The listener also supports fine-grained filtering. This system property specifies the default status log level for the listener to use if the configuration does not specify a status level.Note: this property is used by the log4j-core implementation only after a configuration file has been found.</td></tr>
<tr><td style="text-align: left">log4j2.statusLoggerLevel (log4j2.StatusLogger.level)</td><td style="text-align: left">LOG4J_STATUS_LOGGER_LEVEL</td><td style="text-align: left">WARN</td><td style="text-align: left">The initial &quot;listenersLevel&quot; of the StatusLogger. If StatusLogger listeners are added, the &quot;listenerLevel&quot; is changed to that of the most verbose listener. If any listeners are registered, the listenerLevel is used to quickly determine if an interested listener exists.By default, StatusLogger listeners are added when a configuration is found and by the JMX StatusLoggerAdmin MBean. For example, if a configuration contains <Configuration status="trace">, a listener with statusLevel TRACE is registered and the StatusLogger listenerLevel is set to TRACE, resulting in verbose status messages displayed on the console.If no listeners are registered, the listenersLevel is not used, and the StatusLogger output level is determined by StatusLogger.getLogger().getLevel() (see property org.apache.logging.log4j.simplelog .StatusLogger.level).</td></tr>
<tr><td style="text-align: left">log4j2.statusEntries (log4j2.status.entries)</td><td style="text-align: left">LOG4J_STATUS_ENTRIES</td><td style="text-align: left">200</td><td style="text-align: left">Number of StatusLogger events that are kept in a buffer and can be retrieved with StatusLogger.getStatusData().</td></tr>
<tr><td style="text-align: left">log4j2.statusLoggerDateformat (log4j2.StatusLogger.DateFormat)</td><td style="text-align: left">LOG4J_STATUS_LOGGER<br />_DATEFORMAT</td><td style="text-align: left"></td><td style="text-align: left">Date-time format string to use as the format for timestamps in the status logger output. See java.text.SimpleDateFormat for supported formats.</td></tr>
<tr><td style="text-align: left">log4j2.asyncLoggerExceptionHandler (AsyncLogger.ExceptionHandler)</td><td style="text-align: left">LOG4J_ASYNC_LOGGER<br />_EXCEPTION_HANDLER</td><td style="text-align: left">default handler</td><td style="text-align: left">See <a href="https://logging.apache.org/log4j/2.x/manual/async.html#SysPropsAllAsync">Async Logger System Properties</a> for details.</td></tr>
<tr><td style="text-align: left">log4j2.asyncLoggerRingBufferSize (AsyncLogger.RingBufferSize)</td><td style="text-align: left">LOG4J_ASYNC_LOGGER<br />_RING_BUFFER_SIZE</td><td style="text-align: left">256 * 1024 or 4 * 1024 in garbage-free mode</td><td style="text-align: left">See <a href="https://logging.apache.org/log4j/2.x/manual/async.html#SysPropsAllAsync">Async Logger System Properties</a> for details.</td></tr>
<tr><td style="text-align: left">log4j2.asyncLoggerWaitStrategy (AsyncLogger.WaitStrategy)</td><td style="text-align: left">LOG4J_ASYNC_LOGGER<br />_WAIT_STRATEGY</td><td style="text-align: left">Timeout</td><td style="text-align: left">See <a href="https://logging.apache.org/log4j/2.x/manual/async.html#SysPropsAllAsync">Async Logger System Properties</a> for details.</td></tr>
<tr><td style="text-align: left">log4j2.asyncLoggerTimeout (AsyncLogger.Timeout)</td><td style="text-align: left">LOG4J_ASYNC_LOGGER_TIMEOUT</td><td style="text-align: left">10</td><td style="text-align: left">See <a href="https://logging.apache.org/log4j/2.x/manual/async.html#SysPropsAllAsync">Async Logger System Properties</a> for details.</td></tr>
<tr><td style="text-align: left">log4j2.asyncLoggerSleepTimeNs (AsyncLogger.SleepTimeNs)</td><td style="text-align: left">LOG4J_ASYNC_LOGGER_SLEEP_TIME_NS</td><td style="text-align: left">100</td><td style="text-align: left">See <a href="https://logging.apache.org/log4j/2.x/manual/async.html#SysPropsAllAsync">Async Logger System Properties</a> for details.</td></tr>
<tr><td style="text-align: left">log4j2.asyncLoggerRetries (AsyncLogger.Retries)</td><td style="text-align: left">LOG4J_ASYNC_LOGGER_SLEEP_TIME_NS</td><td style="text-align: left">200</td><td style="text-align: left">See <a href="https://logging.apache.org/log4j/2.x/manual/async.html#SysPropsAllAsync">Async Logger System Properties</a> for details.</td></tr>
<tr><td style="text-align: left">AsyncLogger.SynchronizeEnqueueWhenQueueFull</td><td style="text-align: left">ASYNC_LOGGER_SYNCHRONIZE_<br />ENQUEUE_WHEN_QUEUE_FULL</td><td style="text-align: left">true</td><td style="text-align: left">See <a href="https://logging.apache.org/log4j/2.x/manual/async.html#SysPropsAllAsync">Async Logger System Properties</a> for details.</td></tr>
<tr><td style="text-align: left">log4j2.asyncLoggerThreadNameStrategy (AsyncLogger.ThreadNameStrategy)</td><td style="text-align: left">LOG4J_ASYNC_LOGGER_THREAD_<br />NAME_STRATEGY</td><td style="text-align: left">CACHED</td><td style="text-align: left">See <a href="https://logging.apache.org/log4j/2.x/manual/async.html#SysPropsAllAsync">Async Logger System Properties</a> for details.</td></tr>
<tr><td style="text-align: left">log4j2.asyncLoggerConfigExceptionHandler (AsyncLoggerConfig.ExceptionHandler)</td><td style="text-align: left">LOG4J_ASYNC_LOGGER_CONFIG_<br />EXCEPTION_HANDLER</td><td style="text-align: left">default handler</td><td style="text-align: left">See <a href="https://logging.apache.org/log4j/2.x/manual/async.html#SysPropsMixedSync-Async">Mixed Async/Synchronous Logger System Properties</a> for details.</td></tr>
<tr><td style="text-align: left">log4j2.asyncLoggerConfigRingBufferSize (AsyncLoggerConfig.RingBufferSize)</td><td style="text-align: left">LOG4J_ASYNC_LOGGER_CONFIG_<br />RING_BUFFER_SIZE</td><td style="text-align: left">256 * 1024 or 4 * 1024 in garbage-free mode</td><td style="text-align: left">See <a href="https://logging.apache.org/log4j/2.x/manual/async.html#SysPropsMixedSync-Async">Mixed Async/Synchronous Logger System Properties</a> for details.</td></tr>
<tr><td style="text-align: left">log4j2.asyncLoggerConfigWaitStrategy (AsyncLoggerConfig.WaitStrategy)</td><td style="text-align: left">LOG4J_ASYNC_LOGGER_CONFIG_<br />WAIT_STRATEGY</td><td style="text-align: left">Timeout</td><td style="text-align: left">See <a href="https://logging.apache.org/log4j/2.x/manual/async.html#SysPropsMixedSync-Async">Mixed Async/Synchronous Logger System Properties</a> for details.</td></tr>
<tr><td style="text-align: left">AsyncLoggerConfig.SynchronizeEnqueueWhenQueueFull</td><td style="text-align: left">ASYNC_LOGGER_CONFIG_SYNCHRONIZE<br />_ENQUEUE_WHEN_QUEUE_FULL</td><td style="text-align: left">true</td><td style="text-align: left">See <a href="https://logging.apache.org/log4j/2.x/manual/async.html#SysPropsMixedSync-Async">Mixed Async/Synchronous Logger System Properties</a> for details.</td></tr>
<tr><td style="text-align: left">log4j2.julLoggerAdapter (log4j.jul.LoggerAdapter)</td><td style="text-align: left">LOG4J_JUL_LOGGER_ADAPTER</td><td style="text-align: left">org.apache.logging.log4j .jul.ApiLoggerAdapter</td><td style="text-align: left">Default LoggerAdapter to use in the JUL adapter. By default, if log4j-core is available, then the class org.apache.logging.log4j.jul .CoreLoggerAdapter will be used. Otherwise, the ApiLogggerAdapter will be used. Custom implementations must provide a public default constructor.</td></tr>
<tr><td style="text-align: left">log4j2.formatMsgAsync (log4j.format.msg.async)</td><td style="text-align: left">LOG4J_FORMAT_MSG_ASYNC</td><td style="text-align: left">false</td><td style="text-align: left">If false (the default), Log4j will make sure the message is formatted in the caller thread, to ensure the value at the time of the call to the logger is the value that is logged.</td></tr>
<tr><td style="text-align: left">log4j2.asyncQueueFullPolicy (log4j2.AsyncQueueFullPolicy)</td><td style="text-align: left">LOG4J_ASYNC_QUEUE_FULL_POLICY</td><td style="text-align: left"></td><td style="text-align: left">Used by Async Loggers and the AsyncAppender to maintain application throughput even when the underlying appender cannot keep up with the logging rate and the queue is filling up.If no value is specified (the default) events are never discarded. If the queue is full, the logger call blocks until the event can be added to the queue.Specify Discard to drop events whose level is equal or less than the threshold level (INFO by default) when the queue is full.</td></tr>
<tr><td style="text-align: left">log4j2.discardThreshold (log4j2.DiscardThreshold)</td><td style="text-align: left">LOG4J_DISCARD_THRESHOLD</td><td style="text-align: left">INFO</td><td style="text-align: left">Used by the DiscardingAsyncQueueFullPolicy to determine which events to drop when the queue becomes full. By default, INFO, DEBUG and TRACE level events are discarded when the queue is full. This property only has effect if Discard is specified as the log4j2.AsyncQueueFullPolicy.</td></tr>
<tr><td style="text-align: left">log4j2.messageFactory (log4j2.messageFactory)</td><td style="text-align: left">LOG4J_MESSAGE_FACTORY</td><td style="text-align: left">org.apache.logging.log4j.message. ParameterizedMessageFactory or org.apache.logging.log4j.message. ReusableMessageFactory in garbage-free mode</td><td style="text-align: left">Default message factory used by Loggers if no factory was specified.</td></tr>
<tr><td style="text-align: left">log4j2.flowMessageFactory (log4j2.flowMessageFactory)</td><td style="text-align: left">LOG4J_FLOW_MESSAGE_FACTORY</td><td style="text-align: left">org.apache.logging.log4j.message. DefaultFlowMessageFactory</td><td style="text-align: left">Default flow message factory used by Loggers.</td></tr>
<tr><td style="text-align: left">log4j2.isWebapp (log4j2.is.webapp)</td><td style="text-align: left">LOG4J_IS_WEBAPP</td><td style="text-align: left">true if Servlet class on class path</td><td style="text-align: left">This system property can be used to force Log4j 2 to behave as if it is part of a web application (when true) or as if it is not part of a web application (when false).</td></tr>
<tr><td style="text-align: left">log4j2.enableThreadlocals (log4j2.enable.threadlocals)</td><td style="text-align: left">LOG4J_ENABLE_THREADLOCALS</td><td style="text-align: left">true</td><td style="text-align: left">This system property can be used to switch off the use of threadlocals, which will partly disable Log4j's garbage-free behaviour: to be fully garbage-free, Log4j stores objects in ThreadLocal fields to reuse them, otherwise new objects are created for each log event. Note that this property is not effective when Log4j detects it is running in a web application.</td></tr>
<tr><td style="text-align: left">log4j2.enableDirectEncoders (log4j2.enable.direct.encoders)</td><td style="text-align: left">LOG4J_ENABLE_DIRECT_ENCODERS</td><td style="text-align: left">true</td><td style="text-align: left">This property can be used to force garbage-aware Layouts and Appenders to revert to the pre-2.6 behaviour where converting log events to text generates temporary objects like Strings and char[] arrays, and converting this text to bytes generates temporary byte[] arrays. By default, this property is true and garbage-aware Layouts and Appenders that convert log events to text will convert this text to bytes without creating temporary objects.</td></tr>
<tr><td style="text-align: left">log4j2.initialReusableMsgSize (log4j.initialReusableMsgSize)</td><td style="text-align: left">LOG4J_INITIAL_REUSABLE_MSG_SIZE</td><td style="text-align: left">128</td><td style="text-align: left">In GC-free mode, this property determines the initial size of the reusable StringBuilders where the message text is formatted and potentially passed to background threads.</td></tr>
<tr><td style="text-align: left">log4j2.maxReusableMsgSize (log4j.maxReusableMsgSize)</td><td style="text-align: left">LOG4J_MAX_REUSABLE_MSG_SIZE</td><td style="text-align: left">518</td><td style="text-align: left">In GC-free mode, this property determines the maximum size of the reusable StringBuilders where the message text is formatted and potentially passed to background threads.</td></tr>
<tr><td style="text-align: left">log4j2.layoutStringBuilderMaxSize (log4j.layoutStringBuilder.maxSize)</td><td style="text-align: left">LOG4J_LAYOUT_STRING<br />_BUILDER_MAX_SIZE</td><td style="text-align: left">2048</td><td style="text-align: left">This property determines the maximum size of the thread-local reusable StringBuilders used to format the log event to text by Layouts that extend AbstractStringLayout.</td></tr>
<tr><td style="text-align: left">log4j2.unboxRingbufferSize (log4j.unbox.ringbuffer.size)</td><td style="text-align: left">LOG4J_UNBOX_RINGBUFFER_SIZE</td><td style="text-align: left">32</td><td style="text-align: left">The org.apache.logging.log4j.util.Unbox utility manages a small thread-local ring buffer of StringBuilders. Each time one of the box() methods is called, the next slot in the ring buffer is used, until the ring buffer is full and the first slot is reused. By default the Unbox ring buffer has 32 slots, so user code can have up to 32 boxed primitives in a single logger call.If more slots are required, set system property log4j.unbox.ringbuffer.size to the desired ring buffer size. Note that the specified number will be rounded up to the nearest power of 2.</td></tr>
<tr><td style="text-align: left">log4j2.loggerContextStacktraceOnStart (log4j.LoggerContext.stacktrace.on.start)</td><td style="text-align: left">LOG4J_LOGGER_CONTEXT<br />_STACKTRACE_ON_START</td><td style="text-align: left">false</td><td style="text-align: left">Prints a stacktrace to the <a href="https://logging.apache.org/log4j/2.x/manual/configuration.html#StatusMessages">status logger</a> at DEBUG level when the LoggerContext is started. For debug purposes.</td></tr>
<tr><td style="text-align: left">log4j2.formatMsgNoLookups (log4j2.formatMsgNoLookups)</td><td style="text-align: left">FORMAT_MESSAGES_<br />PATTERN_DISABLE_LOOKUPS</td><td style="text-align: left">false</td><td style="text-align: left">Disables message pattern lookups globally when set to true. This is equivalent to defining all message patterns using %m{nolookups}.</td></tr>
<tr><td style="text-align: left">log4j2.trustStoreLocation</td><td style="text-align: left">LOG4J_TRUST_STORE_LOCATION</td><td style="text-align: left"></td><td style="text-align: left">The location of the trust store. If not provided the default trust store will be used.</td></tr>
<tr><td style="text-align: left">log4j2.trustStorePassword</td><td style="text-align: left">LOG4J_TRUST_STORE_PASSWORD</td><td style="text-align: left"></td><td style="text-align: left">Password needed to access the trust store.</td></tr>
<tr><td style="text-align: left">log4j2.trustStorePasswordFile</td><td style="text-align: left">LOG4J_TRUST_STORE_PASSWORD_FILE</td><td style="text-align: left"></td><td style="text-align: left">The location of a file that contains the password for the trust store.</td></tr>
<tr><td style="text-align: left">log4j2.trustStorePasswordEnvironmentVariable</td><td style="text-align: left">LOG4J_TRUST_STORE_PASSWORD_<br />ENVIRONMENT_VARIABLE</td><td style="text-align: left"></td><td style="text-align: left">The name of the environment variable that contains the trust store password.</td></tr>
<tr><td style="text-align: left">log4j2.trustStoreType</td><td style="text-align: left">LOG4J_TRUST_STORE_TYPE</td><td style="text-align: left"></td><td style="text-align: left">The type of key store used for the trust store.</td></tr>
<tr><td style="text-align: left">log4j2.trustStoreKeyManagerFactoryAlgorithm</td><td style="text-align: left">LOG4J_TRUST_STORE_KEY_<br />MANAGER_FACTORY_ALGORITHM</td><td style="text-align: left"></td><td style="text-align: left">Java cryptographic algorithm.</td></tr>
<tr><td style="text-align: left">log4j2.keyStoreLocation</td><td style="text-align: left">LOG4J_KEY_STORE_LOCATION</td><td style="text-align: left"></td><td style="text-align: left">The location of the key store. If not provided the default key store will be used.</td></tr>
<tr><td style="text-align: left">log4j2.keyStorePassword</td><td style="text-align: left">LOG4J_KEY_STORE_PASSWORD</td><td style="text-align: left"></td><td style="text-align: left">Password needed to access the key store.</td></tr>
<tr><td style="text-align: left">log4j2.keyStorePasswordFile</td><td style="text-align: left">LOG4J_KEY_STORE_PASSWORD_FILE</td><td style="text-align: left"></td><td style="text-align: left">The location of a file that contains the password for the key store.</td></tr>
<tr><td style="text-align: left">log4j2.keyStorePasswordEnvironmentVariable</td><td style="text-align: left">LOG4J_KEY_STORE_PASSWORD_<br />ENVIRONMENT_VARIABLE</td><td style="text-align: left"></td><td style="text-align: left">The name of the environment variable that contains the key store password.</td></tr>
<tr><td style="text-align: left">log4j2.keyStoreType</td><td style="text-align: left">LOG4J_KEY_STORE_TYPE</td><td style="text-align: left"></td><td style="text-align: left">The type of key store.</td></tr>
<tr><td style="text-align: left">log4j2.keyStoreKeyManagerFactoryAlgorithm</td><td style="text-align: left">LOG4J_KEY_STORE_KEY_MANAGER_<br />FACTORY_ALGORITHM</td><td style="text-align: left"></td><td style="text-align: left">Java cryptographic algorithm.</td></tr>
<tr><td style="text-align: left">log4j2.sslVerifyHostName</td><td style="text-align: left"></td><td style="text-align: left">false</td><td style="text-align: left">true or false if the host name should be verified</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipeline-设计模式"><a class="header" href="#pipeline-设计模式">Pipeline 设计模式</a></h1>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<p><strong>解释</strong></p>
<p>Pipeline 翻译过来就是水管的意思，Pipeline 设计模式其实很简单，就像是我们常用的 CI/CD 的 Pipeline 一样，一个环节做一件事情，最终串联成一个完整的 Pipeline。</p>
<p><strong>概念</strong></p>
<p>Pipeline 设计模式有三个概念：Pipeline、Valve、Context。它们的关系大概是这样：</p>
<p><img src="https://i.loli.net/2020/10/17/HUp52SCEkmXcaZy.png" alt="20201017160821" /></p>
<p><strong>对象定义</strong></p>
<pre><code class="language-java">public interface Pipeline {
    void init(PipelineConfig config);
    void start();
    Context getContext();
}

public class Context {

}

public interface Valve {
    void invoke(Context context);
    void invokeNext(Context context);
    String getValveName();
}
</code></pre>
<p><strong>Tomcat 也广泛使用了 Pipeline 设计模式</strong></p>
<p><img src="https://i.loli.net/2020/10/17/7TUKzpjCcgBLQ2M.png" alt="20201017161509" /></p>
<p><strong>value配置</strong></p>
<pre><code class="language-json">{
    &quot;scene_a&quot;: {
        &quot;valves&quot;: [
            &quot;checkOrder&quot;,
            &quot;checkPayment&quot;,
            &quot;checkDiscount&quot;,
            &quot;computeMount&quot;,
            &quot;payment&quot;,
            &quot;DeductInventory&quot;
        ],
        &quot;config&quot;: {
            &quot;sendEmail&quot;: true,
            &quot;supportAlipay&quot;: true
        }
    }
}
</code></pre>
<h2 id="pipeline变种与演化"><a class="header" href="#pipeline变种与演化">Pipeline变种与演化</a></h2>
<blockquote>
<p>Pipeline不是一成不变的，根据你的需要，它可以有很多变种和演化。</p>
</blockquote>
<h3 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h3>
<blockquote>
<p>Pipeline其实是使用了责任链模式的思想。但它也可以和其它设计模式很好地结合起来。</p>
</blockquote>
<p><strong>策略模式</strong></p>
<p>可以在配置里面写上当前这个业务线要发送的渠道,然后在Valve里面通过策略模式去决定使用什么渠道发送</p>
<p><strong>模板方法模式</strong></p>
<p>这个时候就可以使用模板方法模式，定义一个抽象的Valve，把公共逻辑抽取出来，把每个Valve差异的逻辑做成抽象方法，由Valve自己去实现。</p>
<p><strong>工厂方法模式</strong></p>
<pre><code class="language-java">Pipeline pipeline = PipelineFactory.create(pipelineConfig);
pipeline.start();
</code></pre>
<p><strong>组合</strong></p>
<p>虽然我们说一个Valve只做一件简单的事。但这是相对于整个流程来说的。有时候太过细化也不好，不方便管理。正确的做法应该是做好抽象和分组。比如我们会有一个“校验”阶段，就不用把具体每个字段的校验都单独抽成Valve放进主流程。我们可以就在主流程放一个“校验”的Valve，然后在这个“校验”的Valve里面专门生成一条“校验Pipeline”。这样主流程也比较清晰明了，每个Valve的职责也比较清晰。</p>
<blockquote>
<p>注意，子Pipeline应该有它单独的Context，但是它同时也应该具有主Pipeline的Context，是不是应该通过继承来实现?</p>
</blockquote>
<h2 id="树与图"><a class="header" href="#树与图"><strong>树与图</strong></a></h2>
<p>上面我们介绍的Pipeline，本质上是一个链。但如果往更通用（同时也更复杂）的方向去设计，它还可以做成一个图或者树。</p>
<p>假设我们在某个环节有一个条件分支，通过当时的context里面的数据状态，来判断下一步要走哪个Valve，形成一个树。最后可能又归拢到一个Valve，那就形成了一个图。</p>
<h2 id="并行执行"><a class="header" href="#并行执行"><strong>并行执行</strong></a></h2>
<p>我们在前面看到Valve都是链式一个一个执行的。但有时候可能多个Valve彼此之间并不依赖，可以同时并行地去跑。比如发消息，可能多个Valve并行地去发</p>
<p>这个时候我们可以把Pipeline改造一下，就像Jenkins设计Pipeline那样，把一个完整的Pipeline分成Phase、Stage、Step等，我们可以对某个Phase或者某个Step设置成可以并行执行的。这需要另外写一个并行执行的Pipeline，用CountDownLatch等工具来等待所有Valve执行完，往下走。</p>
<h2 id="日志和可视化"><a class="header" href="#日志和可视化"><strong>日志和可视化</strong></a></h2>
<p>日志和可视化是有必要的。对于一条Pipeline来说，推荐在Context里面生成一个traceId，然后用AOP等技术打印日志或者落库，最后通过可视化的方式在界面展现每次调用经过了哪些Valve，时间，在每个Valve执行前和执行后的Context等等信息。</p>
<p>异常也很重要。如果使用Pipeline设计模式，推荐专门定义一套异常，可以区分为“可中断Pipeline异常”和“不可中断Pipeline”异常。这个根据实际的业务需求，来决定是否需要中断Pipeline。以我们前面的例子来说，我们在校验阶段如果不通过，就应该抛出一个可以中断Pipeline的异常，让它不往下走。但如果在发送邮件的时候发生了异常，只需要catch住异常，打印一下warn日志，继续往下走。中不中断Pipeline，是业务来决定的。</p>
<h2 id="使用threadlocal"><a class="header" href="#使用threadlocal"><strong>使用ThreadLocal</strong></a></h2>
<p>不要把零散的一个个属性放进ThreadLocal，因为同一种类型，一个线程只能在一个ThreadLocal里面放一个值。而我们的上下文可能会有多个String、boolean等值。如果使用ThreadLocal，可以把所有属性都包成一个Context类，放进ThreadLocal。</p>
<h2 id="pipe的缺点"><a class="header" href="#pipe的缺点"><strong>Pipe的缺点</strong></a></h2>
<ul>
<li>
<p>第一个缺点是可读性不强。因为它是可配置化的，且配置经常在外部（比如数据库里的一个JSON）。所以可读性不好。尤其是我们在读Valve代码的时候，<strong>如果不对照配置，其实是不知道它的前后调用关系的</strong>。</p>
</li>
<li>
<p>第二个缺点是Pipeline之间传递数据是通过Context，而不是简单的函数调用。所以一条Pipeline是有状态的，而且<strong>方法调用内部修改Context</strong>，而不是通过返回值，是有副作用的。</p>
</li>
</ul>
<p><a href="https://www.toutiao.com/i6872495007941526020/"><strong>参考链接</strong></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-11"><a class="header" href="#概述-11">概述</a></h1>
<p>本Maven教程的目的是使您了解Maven的工作方式。因此，本教程重点介绍Maven的核心概念。</p>
<p>实际上，Maven开发人员声称Maven不仅仅是一个构建工具。参见 <a href="http://maven.apache.org/background/philosophy-of-maven.html">Philosophy of Maven</a></p>
<p><strong>Maven Version</strong></p>
<p>该Maven教程的第一个版本基于Maven 3.6.3。</p>
<p><strong>Maven Website</strong></p>
<p>[<a href="http://maven.apache.org/">http://maven.apache.org</a>]</p>
<h2 id="what-is-a-build-tool"><a class="header" href="#what-is-a-build-tool">What is a Build Tool?</a></h2>
<p>A build tool is a tool that automates everything related to building the software project. </p>
<p>构建工具是一种工具，它可以自动完成与构建软件项目相关的所有操作，构建软件工程一半需要以下几个步骤</p>
<ul>
<li>产生源代码</li>
<li>产生文档</li>
<li>编译源代码</li>
<li>打包编译后的源代码</li>
<li>部署源代码</li>
</ul>
<p>任何给定的软件项目可能具有比完成最终软件所需的更多活动。通常可以将此类活动插入构建工具中，因此也可以将这些活动自动化。</p>
<h2 id="安装maven"><a class="header" href="#安装maven">安装Maven</a></h2>
<ol>
<li>Set the <code>JAVA_HOME</code> environment variable to point to a valid Java SDK (e.g. Java 8).</li>
<li>Set the <code>M2_HOME</code> environment variable to point to the directory you unzipped Maven to.</li>
<li>Set the <code>M2</code> environment variable to point to <code>M2_HOME/bin</code> (<code>%M2_HOME%\bin</code> on Windows, <code>$M2_HOME/bin</code> on unix).</li>
<li>Add <code>M2</code> to the <code>PATH</code> environment variable (<code>%M2%</code> on Windows, <code>$M2</code> on unix).</li>
<li>验证 <em>mvn</em> 命令</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="需求分析"><a class="header" href="#需求分析">需求分析</a></h2>
<p>在一个应用中，我们总是会遇到一些参数，例如：</p>
<ul>
<li>数据库服务器IP地址、端口、用户名；</li>
<li>用来保存上传资料的目录。</li>
<li>一些参数，诸如是否打开cache、加密所用的密钥名称等等。</li>
</ul>
<p>这些参数有一个共性，那就是：<em>它们和应用的逻辑无关，只和当前环境、当前系统用户相关</em>。以下场景很常见：</p>
<ul>
<li>在开发、测试、发布阶段，使用不同的数据库服务器；</li>
<li>在开发阶段，使用Windows的A开发者将用户上传的文件存放在<code>d:\my_upload</code>目录中，而使用Linux的B开发者将同样的文件存放在<code>/home/myname/my_upload</code>目录中。</li>
<li>在开发阶段设置<code>cache=off</code>，在生产环境中设置<code>cache=on</code>。</li>
</ul>
<p>很明显，<em>这些参数不适合被“硬编码”在配置文件或代码中</em>。因为每一个从源码库中取得它们的人，都有可能需要修改它们，使之与自己的环境相匹配。</p>
<h2 id="解决方案"><a class="header" href="#解决方案">解决方案</a></h2>
<h3 id="运行时替换的placeholders"><a class="header" href="#运行时替换的placeholders">运行时替换的placeholders</a></h3>
<p>很多框架支持在运行时刻替换配置文件中的placeholder占位符。例如， Webx/Spring就有这个功能。</p>
<pre><code class="language-xml">&lt;services:property-placeholder /&gt;

&lt;services:webx-configuration&gt;
    &lt;services:productionMode&gt;${productionMode:true}&lt;/services:productionMode&gt;
&lt;/services:webx-configuration&gt;
</code></pre>
<p>在上面这个例子中，你可以在启动应用时，加上JVM参数：“<code>-DproductionMode=false|true</code>”来告诉系统用哪一种模式来工作。如果不指定，则取默认值“<code>true</code>”。</p>
<p>运行时替换placeholder是一种非常实用的技术，它有如下优缺点：</p>
<table><thead><tr><th style="text-align: left">优点</th><th style="text-align: left">缺点</th></tr></thead><tbody>
<tr><td style="text-align: left">配置文件是静态的、不变的。即使采用不同的参数值，你也不需要更改配置文件本身。你可以随时改变参数的值，只需要启动时指定不同的JVM参数、或指定不同的properties文件即可。这种配置对于应用程序各组件是透明的 —— 应用程序不需要做特别的编程，即可使用placeholders。</td><td style="text-align: left">并非所有框架都支持这种技术。<br />支持该技术的框架各有不同的用法。例如：Spring和Log4j都支持placeholder替换，然则它们的做法是完全不同的。Spring通过<code>PropertyPlaceholderConfigurer</code>类来配置，而Log4j则需要在<code>DomConfigurator</code>中把参数传进去。</td></tr>
</tbody></table>
<h3 id="中心配置服务器config-server"><a class="header" href="#中心配置服务器config-server">中心配置服务器（Config Server）</a></h3>
<p>这也是一种运行时技术。它可以在运行时刻，将应用所需的参数推送到应用中。</p>
<p><strong>中心配置服务器的优缺点</strong></p>
<table><thead><tr><th style="text-align: left">优点</th><th style="text-align: left">缺点</th></tr></thead><tbody>
<tr><td style="text-align: left">它可以集中管理所有应用的配置，避免可能的错误；它可以在运行时改变参数的值，并推送到所有应用中。参数的更改可立即生效。</td><td style="text-align: left">需要一套独立的服务器系统。性能、可用性（availability）都是必须考虑的问题。对应用不是透明的，有一定的侵入性。应用程序必须主动来配合该技术。因此，该技术不可能适用于所有情况，特别对于第三方提供的代码，很难使用该技术。为了连接到中心配置服务器，你仍然需要配置适当的IP、端口等参数。你需要用其它技术来处理这些参数（例如placeholders）。</td></tr>
</tbody></table>
<h2 id="maven-filtering机制"><a class="header" href="#maven-filtering机制">Maven Filtering机制</a></h2>
<p>Maven提供了一种过滤机制，可以在资源文件被复制到目标目录的同时，替换其中的placeholders。</p>
<pre><code>web-project
 │  pom.xml
 │
 └─src
     └─main
         ├─java
         ├─resources
         └─webapp
             └─WEB-INF
                     web.xml
</code></pre>
<p>在<code>pom.xml</code>中这样写：</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;filters&gt;
        &lt;filter&gt;${user.home}/antx.properties&lt;/filter&gt; 
    &lt;/filters&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt; 
            &lt;includes&gt;
                &lt;include&gt;**.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;excludes&gt;
                &lt;exclude&gt;**.xml&lt;/exclude&gt;
            &lt;/excludes&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;webResources&gt;
                    &lt;resource&gt;
                        &lt;directory&gt;src/main/webapp&lt;/directory&gt; 
                        &lt;includes&gt;
                            &lt;include&gt;WEB-INF/**.xml&lt;/include&gt;
                        &lt;/includes&gt;
                        &lt;filtering&gt;true&lt;/filtering&gt;
                    &lt;/resource&gt;
                    &lt;resource&gt;
                        &lt;directory&gt;src/main/webapp&lt;/directory&gt;
                        &lt;excludes&gt;
                            &lt;include&gt;WEB-INF/**.xml&lt;/include&gt;
                        &lt;/excludes&gt;
                    &lt;/resource&gt;
                &lt;/webResources&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>这段pom定义告诉maven：</p>
<ol>
<li>用指定的properties文件（<code>${user.home}/antx.properties</code>）中的值，替换文件中的placeholders</li>
<li>过滤<code>src/main/resources/</code>目录中的所有xml文件，替换其中的placeholders。</li>
<li>过滤<code>src/webapp/WEB-INF/</code>目录中的所有xml文件，替换其中的placeholders。</li>
</ol>
<p>如果上述xml文件中，包含“<code>${xxx.yyy.zzz}</code>”这样的placeholders，将被替换成properties文件中的相应值。</p>
<p>和运行时替换placeholders方案相比，Maven Filtering是一个build时进行的过程。它的优缺点是：</p>
<p><strong>Maven Filtering机制的优缺点</strong></p>
<table><thead><tr><th style="text-align: left">优点</th><th style="text-align: left">缺点</th></tr></thead><tbody>
<tr><td style="text-align: left">Maven filtering机制和应用所采用的技术、框架完全无关，对应用完全透明，通用性好。</td><td style="text-align: left">Maven filtering机制在build时刻永久性改变被过滤的配置文件的内容，build结束以后无法更改。这将导致一个问题：如果要改变配置文件的参数，必须获取源码并重新build。缺少验证机制。当某个placeholder拼写错误；当properties中的值写错；当某配置文件中新增了一个placeholder，而你的properties文件中没有对应的值时，maven不会提醒你。而这些错误往往被拖延到应用程序运行时才会被报告出来。</td></tr>
</tbody></table>
<h2 id="autoconfig机制"><a class="header" href="#autoconfig机制">AutoConfig机制</a></h2>
<p>AutoConfig是一种类似于Maven Filtering的<em>build时刻的工具</em>。</p>
<p>这意味着该机制与应用所采用的技术、框架完全无关，对应用完全透明，具有良好的通用性。</p>
<p>同时，AutoConfig与运行时的配置技术并不冲突。</p>
<p>它可以和运行时替换的placeholders以及中心配置服务器完美并存，互为补充。</p>
<p>AutoConfig书写placeholder的方法和Maven Filtering机制完全相同。</p>
<p>换言之，Maven Filtering的配置文件模板（前例中的<code>/WEB-INF/**.xml</code>）可以不加修改地用在AutoConfig中。</p>
<p>然而，autoconfig成功克服了Maven Filtering的主要问题。</p>
<p><strong>Maven Filtering和AutoConfig的比较</strong></p>
<table><thead><tr><th style="text-align: left">问题</th><th style="text-align: left">Maven Filtering</th><th style="text-align: left">AutoConfig</th></tr></thead><tbody>
<tr><td style="text-align: left">如何修改配置文件的参数？</td><td style="text-align: left">Maven Filtering必须获得源码并重新build；</td><td style="text-align: left">而AutoConfig不需要提取源码，也不需要重新build，即可改变<em>目标文件</em>中所有配置文件中placeholders的值。</td></tr>
<tr><td style="text-align: left">如何确保placeholder替换的正确性？</td><td style="text-align: left">Maven Filtering不能验证placeholder值的缺失和错误；</td><td style="text-align: left">但AutoConfig可以对placeholder及其值进行检查。</td></tr>
</tbody></table>
<h2 id="autoconfig的设计"><a class="header" href="#autoconfig的设计">AutoConfig的设计</a></h2>
<p>为了把事情说清楚，我们必须要定义两种角色：<em>开发者（Developer）<em>和</em>部署者（Deployer）</em>。</p>
<h3 id="角色和职责"><a class="header" href="#角色和职责"><strong>角色和职责</strong></a></h3>
<table><thead><tr><th style="text-align: left">角色名称</th><th style="text-align: left">职责</th></tr></thead><tbody>
<tr><td style="text-align: left">开发者</td><td style="text-align: left">定义应用所需要的properties，及其限定条件；提供包含placeholders的配置文件模板。</td></tr>
<tr><td style="text-align: left">部署者</td><td style="text-align: left">根据所定义的properties，提供符合限定条件的属性值。调用AutoConfig来生成目标配置文件。</td></tr>
</tbody></table>
<p>例如，一个宠物店（petstore）的WEB应用中需要指定一个用来上传文件的目录。于是，</p>
<h3 id="petstore应用中的角色和职责"><a class="header" href="#petstore应用中的角色和职责"><strong>Petstore应用中的角色和职责</strong></a></h3>
<table><thead><tr><th style="text-align: left">开发者</th><th style="text-align: left">部署者</th></tr></thead><tbody>
<tr><td style="text-align: left">开发者定义了一个property：<code>petstore.upload_dir</code>，限定条件为：“合法的文件系统的目录名”。</td><td style="text-align: left">部署者取得petstore的二进制发布包，通过AutoConfig了解到，应用需要一个名为<code>petstore.upload_dir</code>目录名。部署者便指定一个目录给petstore，该目录名的具体值可能因不同的系统而异。AutoConfig会检验该值是否符合限定条件（是否为合法目录名），如果检验通过，就生成配置文件，并将其中的<code>${petstore.upload_dir}</code>替换成该目录名。</td></tr>
</tbody></table>
<p>需要注意的是，一个“物理人”所对应的“角色”不是一成不变的。例如：某“开发者”需要试运行应用，此时，他就变成“部署者”。</p>
<h3 id="分享二进制目标文件"><a class="header" href="#分享二进制目标文件">分享二进制目标文件</a></h3>
<p>假设现在有两个team要互相合作，team A的开发者创建了project A，而team B的开发者创建了project B。假定project B依赖于project A。如果我们利用maven这样的build工具，那么最显而易见的合作方案是这样的：</p>
<ul>
<li>Team A发布一个project A的版本到maven repository中。</li>
<li>Team B从maven repository中取得project A的二进制目标文件。</li>
</ul>
<p>这种方案有很多好处，</p>
<ul>
<li>每个team都可以独立控制自己发布版本的节奏；</li>
<li>Team之间的关系较松散，唯一的关系纽带就是maven repository。</li>
<li>Team之间不需要共享源码。</li>
</ul>
<p>然而，假如project A中有一些配置文件中的placeholders需要被替换，如果使用Maven Filtering机制，就会出现问题。因为Maven Filtering只能在project A被build时替换其中的placeholders，一旦project A被发布到repository中，team B的人将无法修改任何project A中的配置参数。除非team B的人取得project A的源码，并重新build。这将带来很大的负担。</p>
<p>然而，假如project A中有一些配置文件中的placeholders需要被替换，如果使用Maven Filtering机制，就会出现问题。因为Maven Filtering只能在project A被build时替换其中的placeholders，一旦project A被发布到repository中，team B的人将无法修改任何project A中的配置参数。除非team B的人取得project A的源码，并重新build。这将带来很大的负担。</p>
<p>AutoConfig解决了这个问题。因为当team B的人从maven repository中取得project A的二进制包时，仍然有机会修改其配置文件里的placeholders。Team B的人甚至不需要了解project A里配置文件的任何细节，AutoConfig会自动发现所有的properties定义，并提示编辑。</p>
<h3 id="部署二进制目标文件"><a class="header" href="#部署二进制目标文件">部署二进制目标文件</a></h3>
<p>部署应用的人（即部署者、deployer）也从中受益。因为deployer不再需要亲手去build源代码，而是从maven repository中取得二进制目标文件即可。</p>
<p>从这个意义上讲，AutoConfig不应当被看成是一个build时的简单配置工具</p>
<p>，而是一个“<em>软件安装工具</em>”。如同我们安装一个Windows软件 —— 我们当然不需要从源码开始build它们，而是执行其安装程序，设定一些参数诸如安装目录、文档目录、可选项等。安装程序就会自动把软件设置好，确保软件可正确运行于当前的Windows环境中。</p>
<h3 id="autoconfig特性列表"><a class="header" href="#autoconfig特性列表">AutoConfig特性列表</a></h3>
<table><thead><tr><th style="text-align: left">名称</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">两种用法</td><td style="text-align: left">既可独立使用（支持Windows和Unix-like平台）。也可以作为maven插件来使用。</td></tr>
<tr><td style="text-align: left">对目标文件而不是源文件进行配置</td><td style="text-align: left">可对同一个目标文件反复配置。配置时不依赖于项目源文件。支持嵌套包文件，例如：ear包含war，war又包含jar。高性能，特别对于嵌套的包文件。</td></tr>
<tr><td style="text-align: left">验证和编辑properties</td><td style="text-align: left">自动发现保存于war包、jar包、ear包中的properties定义。验证properties的正确性。交互式编辑properties。当配置文件中出现未定义的placeholders时，提示报错。</td></tr>
</tbody></table>
<h2 id="autoconfig的使用--开发者指南"><a class="header" href="#autoconfig的使用--开发者指南">AutoConfig的使用 —— 开发者指南</a></h2>
<h3 id="建立autoconfig目录结构"><a class="header" href="#建立autoconfig目录结构">建立AutoConfig目录结构</a></h3>
<p>和Maven Filtering不同的是，AutoConfig是针对目标文件的配置工具</p>
<p>因此AutoConfig关心的目录结构是<em>目标文件的目录结构</em></p>
<p>不同的build工具，创建同一目标目录结构所需要的源文件的目录结构会各有不同。</p>
<p>本文仅以maven标准目录结构为例，来说明源文件的目录结构编排。</p>
<h4 id="war包的目录结构"><a class="header" href="#war包的目录结构">WAR包的目录结构</a></h4>
<p>这里所说的war包，可以是一个以zip方式打包的文件，也可以是一个展开的目录。下面以maven标准目录为例，说明项目源文件和目标文件的目录结构的对比：</p>
<pre><code>war-project（源目录结构）               -&gt; war-project.war（目标目录结构）
 │  pom.xml
 │
 └─src
     └─main
         ├─java
         ├─resources                    -&gt; /WEB-INF/classes
         │      file1.xml                      file1.xml
         │      file2.xml                      file2.xml
         │
         └─webapp                       -&gt; /
             ├─META-INF                 -&gt; /META-INF
             │  └─autoconf              -&gt; /META-INF/autoconf 
             │        auto-config.xml          auto-config.xml 
             │
             └─WEB-INF                  -&gt; /WEB-INF
                   web.xml                     web.xml
                   file3.xml                   file3.xml
</code></pre>
<ol>
<li><em>/META-INF/autoconf</em>目录用来存放AutoConfig的描述文件，以及可选的模板文件。</li>
<li><code>auto-config.xml</code>是用来指导AutoConfig行为的关键描述文件。</li>
</ol>
<p>创建war包的AutoConfig机制，关键在于创建war目标文件中的<code>/META-INF/autoconf/auto-config.xml</code>描述文件。该描述文件对应的maven项目源文件为：<code>/src/main/webapp/META-INF/autoconf/auto-config.xml</code>。</p>
<h4 id="jar包的目录结构"><a class="header" href="#jar包的目录结构">JAR包的目录结构</a></h4>
<p>这里所说的jar包，可以是一个以zip方式打包的文件，也可以是一个展开的目录。下面以maven标准目录为例，说明项目源文件和目标文件的目录结构的对比：</p>
<p><strong>JAR包的源文件和目标文件目录结构</strong></p>
<pre><code>jar-project（源目录结构）               -&gt; jar-project.jar（目标目录结构）
 │  pom.xml
 │
 └─src
     └─main
         ├─java
         └─resources                    -&gt; /
             │  file1.xml                      file1.xml
             │  file2.xml                      file2.xml
             │
             └─META-INF                 -&gt; /META-INF
                 └─autoconf             -&gt; /META-INF/autoconf 
                       auto-config.xml         auto-config.xml 
</code></pre>
<ol>
<li>/META-INF/autoconf目录用来存放AutoConfig的描述文件，以及可选的模板文件。</li>
<li>创建jar包的AutoConfig机制，关键在于创建jar目标文件中的<code>/META-INF/autoconf/auto-config.xml</code>描述文件。该描述文件对应的maven项目源文件为：<code>/src/main/resources/META-INF/autoconf/auto-config.xml</code>。</li>
</ol>
<h4 id="普通目录"><a class="header" href="#普通目录">普通目录</a></h4>
<p>AutoConfig也支持对普通文件目录进行配置。</p>
<pre><code>directory
 │  file1.xml
 │  file2.xml
 │
 └─conf 
       auto-config.xml 
</code></pre>
<ol>
<li>默认情况下，AutoConfig在/conf目录中寻找AutoConfig的描述文件，以及可选的模板文件。</li>
</ol>
<h3 id="建立auto-configxml描述文件"><a class="header" href="#建立auto-configxml描述文件">建立auto-config.xml描述文件</a></h3>
<p>AutoConfig系统的核心就是<code>auto-config.xml</code>描述文件。该描述文件中包含两部分内容：</p>
<ol>
<li>定义properties：properties的名称、描述、默认值、约束条件等信息；</li>
<li>指定包含placeholders的模板文件。</li>
</ol>
<p>下面是<code>auto-config.xml</code>文件的样子：（以petstore应用为例）</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;config&gt;
    &lt;group&gt;

        &lt;property name=&quot;petstore.work&quot;
                    description=&quot;应用程序的工作目录&quot; /&gt; 

        &lt;property name=&quot;petstore.loggingRoot&quot; 
                    defaultValue=&quot;${petstore.work}/logs&quot;
                    description=&quot;日志文件目录&quot; /&gt; 

        &lt;property name=&quot;petstore.upload&quot;
                    defaultValue=&quot;${petstore.work}/upload&quot;
                    description=&quot;上传文件的目录&quot; /&gt; 

        &lt;property name=&quot;petstore.loggingLevel&quot;
                    defaultValue=&quot;warn&quot;
                    description=&quot;日志文件级别&quot;&gt; 

            &lt;validator name=&quot;choice&quot;
                         choice=&quot;trace, debug, info, warn, error&quot; /&gt; 
        &lt;/property&gt;

    &lt;/group&gt;
    &lt;script&gt;
        &lt;generate template=&quot;WEB-INF/web.xml&quot; /&gt; 
        &lt;generate template=&quot;WEB-INF/common/resources.xml&quot; /&gt;
    &lt;/script&gt;
&lt;/config&gt;
</code></pre>
<h4 id="定义properties"><a class="header" href="#定义properties">定义properties</a></h4>
<pre><code class="language-xml">&lt;property
    name=&quot;...&quot;
    [defaultValue=&quot;...&quot;]
    [description=&quot;...&quot;]
    [required=&quot;true|false&quot;]
&gt;
    &lt;validator name=&quot;...&quot; /&gt;
    &lt;validator name=&quot;...&quot; /&gt;
    ...
&lt;/property&gt;
</code></pre>
<p><strong>定义property时可用的参数</strong></p>
<table><thead><tr><th style="text-align: left">参数名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>name</code></td><td style="text-align: left">Property名称。</td></tr>
<tr><td style="text-align: left"><code>defaultValue</code>（可选）</td><td style="text-align: left">默认值。默认值中可包含对其它property的引用，如<code>${petstore.work}/logs</code>。</td></tr>
<tr><td style="text-align: left"><code>description</code>（可选）</td><td style="text-align: left">对字段的描述，这个描述会显示给deployer，这对他理解该property非常重要。</td></tr>
<tr><td style="text-align: left"><code>required</code>（可选）</td><td style="text-align: left">是否“必填”，默认为<code>true</code>。如果deployer未提供必填项的值，就会报错。</td></tr>
</tbody></table>
<p><strong>定义property的验证规则</strong></p>
<p><strong>可用的property验证规则</strong></p>
<table><thead><tr><th style="text-align: left">验证规则</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>&lt;validator name=&quot;boolean&quot; /&gt;</code></td><td style="text-align: left">Property值必须为<code>true</code>或<code>false</code>。</td></tr>
<tr><td style="text-align: left"><code>&lt;validator name=&quot;choice&quot;           choice=&quot;trace, debug, info, warn, error&quot; /&gt;</code></td><td style="text-align: left">Property值必须为choice所定义的值之一。</td></tr>
<tr><td style="text-align: left"><code>&lt;validator** name=&quot;email&quot; /&gt;</code></td><td style="text-align: left">Property值必须为合法的email格式。</td></tr>
<tr><td style="text-align: left"><code>&lt;validator name=&quot;fileExist&quot;           [file=&quot;WEB-INF/web.xml&quot;] /&gt;</code></td><td style="text-align: left">Property值必须为某个存在的文件或目录。如果指定了file，那就意味着property值所指的目录下，必须存在file所指的文件或子目录。</td></tr>
<tr><td style="text-align: left"><code>&lt;validator name=&quot;hostExist&quot; /&gt;</code></td><td style="text-align: left">Property值必须为合法的IP地址，或者可以解析得到的域名。</td></tr>
<tr><td style="text-align: left"><code>&lt;validator name=&quot;keyword&quot; /&gt;</code></td><td style="text-align: left">Property值必须为字母、数字、下划线的组合。</td></tr>
<tr><td style="text-align: left"><code>&lt;validator name=&quot;number&quot; /&gt;</code></td><td style="text-align: left">Property值必须为数字的组合。</td></tr>
<tr><td style="text-align: left">`&lt;validator name=&quot;regexp&quot;           regexp=&quot;...&quot;           [mode=&quot;exact</td><td style="text-align: left">prefix</td></tr>
<tr><td style="text-align: left"><code>&lt;validator name=&quot;url&quot;           [checkHostExist=&quot;false&quot;]           [protocols=&quot;http, https&quot;]           [endsWithSlash=&quot;true&quot;] /&gt;</code></td><td style="text-align: left">Property值必须是合法URL。假如指定了<code>checkHostExist=true</code>，那么还会检查域名或IP的正确性；假如指定了protocols，那么URL的协议必须为其中之一；假如指定了<code>endsWithSlash=true</code>，那么URL必须以/结尾。</td></tr>
</tbody></table>
<h4 id="生成配置文件的指令"><a class="header" href="#生成配置文件的指令">生成配置文件的指令</a></h4>
<p>描述文件中，每个<code>&lt;generate&gt;</code>标签指定了一个包含<em>placeholders</em>的配置文件模板，具体格式为：</p>
<pre><code>&lt;generate
    template=&quot;...&quot;
    [destfile=&quot;...&quot;]
    [charset=&quot;...&quot;]
    [outputCharset=&quot;...&quot;]
&gt;
</code></pre>
<p><strong>生成配置文件的指令参数</strong></p>
<table><thead><tr><th style="text-align: left">参数名</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>template</code></td><td style="text-align: left">需要配置的模板名。模板名为相对路径，相对于当前jar/war/ear包的根目录。</td></tr>
<tr><td style="text-align: left"><code>destfile</code>（可选）</td><td style="text-align: left">目标文件。如不指定，表示目标文件和模板文件相同。</td></tr>
<tr><td style="text-align: left"><code>charset</code>（可选）</td><td style="text-align: left">模板的字符集编码。XML文件不需要指定<code>charset</code>，因为AutoConfig可以自动取得XML文件的字符集编码；对其它文件必须指定charset。</td></tr>
<tr><td style="text-align: left"><code>outputCharset</code>（可选）</td><td style="text-align: left">目标文件的输出字符集编码。如不指定，表示和模板charset相同。</td></tr>
</tbody></table>
<h3 id="建立模板文件"><a class="header" href="#建立模板文件">建立模板文件</a></h3>
<h4 id="模板文件的位置"><a class="header" href="#模板文件的位置">模板文件的位置</a></h4>
<p>定义完<code>auto-config.xml</code>描述文件以后，就可以创建模板了。模板放在哪里呢？举例说明。</p>
<p>假设在一个典型的WEB应用中，你的<code>auto-config.xml</code>中包含指定了如下模板：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;config&gt;
    &lt;group&gt;
        ...
    &lt;/group&gt;
    &lt;script&gt;
        &lt;generate template=&quot;WEB-INF/classes/file1.xml&quot; /&gt;
        &lt;generate template=&quot;WEB-INF/classes/file2.xml&quot; /&gt;
        &lt;generate template=&quot;WEB-INF/file3.xml&quot; /&gt;
    &lt;/script&gt;
&lt;/config&gt;
</code></pre>
<p>那么，你可以把<code>file1.xml</code>、<code>file2.xml</code>、<code>file3.xml</code>放在下面的位置：</p>
<pre><code>war-project（源目录结构）               -&gt; war-project.war（目标目录结构）
 │  pom.xml
 │
 └─src
     └─main
         ├─java
         ├─resources                    -&gt; /WEB-INF/classes
         │     file1.xml                       file1.xml - 建议放在这里
         │     file2.xml                       file2.xml - 建议放在这里
         │
         └─webapp
             ├─META-INF
             │  └─autoconf
             │      │  auto-config.xml
             │      │
             │      └─WEB-INF           -&gt; /WEB-INF
             │          │ file3.xml            file3.xml - 也可以放在这里
             │          │
             │          └─classes       -&gt; /WEB-INF/classes
             │                file1.xml        file1.xml - 也可以放在这里
             │                file2.xml        file2.xml - 也可以放在这里
             │
             └─WEB-INF                  -&gt; /WEB-INF
                   file3.xml                   file3.xml - 建议放在这里
</code></pre>
<p>AutoConfig的寻找模板的逻辑是：</p>
<ul>
<li>如果在<code>auto-config.xml</code>所在的目录下发现模板文件，就使用它；</li>
<li>否则在包的根目录中查找模板文件；如果两处均未找到，则报错。</li>
</ul>
<h4 id="模板的写法"><a class="header" href="#模板的写法">模板的写法</a></h4>
<p>书写模板是很简单的事，你只要：</p>
<ul>
<li>把需要配置的点替换成placeholder：“<code>${property.name}</code>”。当然，你得确保property.name被定义在<code>auto-config.xml</code>中。</li>
<li>假如模板中包含<em>不希望被替换的</em>运行时的placeholder“<em><code>$</code></em><code>{...}</code>”，需要更改成“<em><code>${D}</code></em><code>{...}</code>” 。</li>
</ul>
<pre><code class="language-xml">...
&lt;context-param&gt;
    &lt;param-name&gt;loggingRoot&lt;/param-name&gt;
    &lt;param-value&gt;${petstore.loggingRoot}&lt;/param-value&gt;
&lt;/context-param&gt;
&lt;context-param&gt;
    &lt;param-name&gt;loggingLevel&lt;/param-name&gt;
    &lt;param-value&gt;${petstore.loggingLevel}&lt;/param-value&gt;
&lt;/context-param&gt;
...
${D}{runtime.placeholder}
</code></pre>
<p>此外，AutoConfig模板其实是由Velocity模板引擎来渲染的。因此，所有的placeholder必须能够通过velocity的语法。</p>
<p><strong>使用不符合velocity语法的placeholders</strong></p>
<p>例如，下面的placeholder被velocity看作非法：</p>
<pre><code>${my.property.2}
</code></pre>
<p>解决的办法是，改写成如下样式：</p>
<pre><code>${my_property_2}
</code></pre>
<h2 id="autoconfig的使用--部署者指南"><a class="header" href="#autoconfig的使用--部署者指南">AutoConfig的使用 —— 部署者指南</a></h2>
<p>部署者有两种方法可以使用AutoConfig：</p>
<ul>
<li>在命令行上直接运行。</li>
<li>在maven中调用AutoConfig plugin。</li>
</ul>
<h3 id="在命令行中使用autoconfig"><a class="header" href="#在命令行中使用autoconfig">在命令行中使用AutoConfig</a></h3>
<h4 id="取得可执行文件"><a class="header" href="#取得可执行文件">取得可执行文件</a></h4>
<p>AutoConfig提供了Windows以及Unix-like（Linux、Mac OS等）等平台上均可使用的native可执行程序。可执行程序文件被发布在Maven repository中。</p>
<p>如果你已经配置好了maven，那么可以让maven来帮你下载目标文件。</p>
<p><strong>例 13.12. 让maven帮忙下载AutoConfig可执行文件</strong></p>
<p>请创建一个临时文件：<code>pom.xml</code>。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.alibaba.citrus.tool&lt;/groupId&gt;
        &lt;artifactId&gt;antx-parent&lt;/artifactId&gt;
        &lt;version&gt;1.2&lt;/version&gt; 
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;artifactId&gt;temp&lt;/artifactId&gt;
&lt;/project&gt;
</code></pre>
<p>文件中的parent pom的版本号（1.2）决定了你要取得的AutoConfig的版本号。</p>
<p>然后在命令行上执行如下命令：</p>
<pre><code>mvn dependency:copy
</code></pre>
<p>这样就取得了两个文件：</p>
<ul>
<li><code>autoconfig-1.2.tgz</code></li>
<li><code>autoexpand-1.2.tgz</code> - AutoExpand是另一个小工具。它是用来展开war、jar、ear包的。关于AutoExpand的详情，请见<a href="https://jjm2473.github.io/citrus-doc/autoexpand.html">第 14 章 <em>AutoExpand工具使用指南</em></a>。</li>
</ul>
<p>你也可以直接去maven repository中手工下载以上两个包：</p>
<ul>
<li>http://repo1.maven.org/maven2/com/alibaba/citrus/tool/antx-autoconfig/1.2/antx-autoconfig-1.2.tgz</li>
<li>http://repo1.maven.org/maven2/com/alibaba/citrus/tool/antx-autoexpand/1.2/antx-autoexpand-1.2.tgz</li>
</ul>
<p>取得压缩包以后，可以用下面的命令来展开并安装工具。</p>
<p><strong>展开并安装工具</strong></p>
<table><thead><tr><th style="text-align: left">Unix-like系统</th><th style="text-align: left">Windows系统</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>tar zxvf autoconfig-1.2.tgz tar zxvf autoexpand-1.2.tgz cp autoconfig /usr/local/bin cp autoexpand /usr/local/bin</code></td><td style="text-align: left"><code>tar zxvf autoconfig-1.2.tgz tar zxvf autoexpand-1.2.tgz copy autoconfig.exe c:\windows\system32 copy autoexpand.exe c:\windows\system32</code></td></tr>
</tbody></table>
<h4 id="执行autoconfig命令"><a class="header" href="#执行autoconfig命令">执行AutoConfig命令</a></h4>
<p>取得可执行文件以后，就可以试用一下：在命令行上输入<strong>autoconfig</strong>。不带参数的<strong>autoconfig</strong>命令会显示出如下帮助信息。</p>
<p><strong>例 13.13. AutoConfig的帮助信息</strong></p>
<pre><code>$ autoconfig
Detected system charset encoding: UTF-8
If your can't read the following text, specify correct one like this: 
  autoconfig -c mycharset

使用方法：autoconfig [可选参数] [目录名|包文件名]
                
可选参数：
 -c,--charset                输入/输出编码字符集
 -d,--include-descriptors
                             包含哪些配置描述文件，例如：conf/auto-config.xml，可使用*、**、?通配符，如有多项，用逗号分隔
 -D,--exclude-descriptors    排除哪些配置描述文件，可使用*、**、?通配符，如有多项，用逗号分隔
 -g,--gui                    图形用户界面（交互模式）
 -h,--help                   显示帮助信息
 -i,--interactive            交互模式：auto|on|off，默认为auto，无参数表示on
 -I,--non-interactive        非交互模式，相当于--interactive=off
 -n,--shared-props-name      共享的属性文件的名称
 -o,--output                 输出文件名或目录名
 -P,--exclude-packages       排除哪些打包文件，可使用*、**、?通配符，如有多项，用逗号分隔
 -p,--include-packages
                             包含哪些打包文件，例如：target/*.war，可使用*、**、?通配符，如有多项，用逗号分隔
 -s,--shared-props           共享的属性文件URL列表，以逗号分隔
 -T,--type                   文件类型，例如：war, jar, ear等
 -t,--text                   文本用户界面（交互模式）
 -u,--userprop               用户属性文件
 -v,--verbose                显示更多信息

总耗费时间：546毫秒
</code></pre>
<p><strong>最简单的AutoConfig命令</strong></p>
<pre><code>autoconfig petstore.war
</code></pre>
<p>无论<code>petstore.war</code>是一个zip包还是目录，AutoConfig都会正确地生成其中的配置文件。</p>
<h3 id="在maven中使用autoconfig"><a class="header" href="#在maven中使用autoconfig">在maven中使用AutoConfig</a></h3>
<p>AutoConfig也可以通过maven plugin来执行。</p>
<p>这种方式使用方式，方便了开发者试运行并测试应用程序。开发者可以在build项目的同时，把AutoConfig也配置好。然而对于非开发的应用测试人员、发布应用的系统管理员来说，最好的方法是使用独立可执行的AutoConfig来配置应用的二进制目标文件。</p>
<p>为了使用maven插件，你需要修改项目的<code>pom.xml</code>来设定它。请注意，一般来说，不要在parent <code>pom.xml</code>中设定AutoConfig，因为这个设置会作用在每个子项目上，导致不必要的AutoConfig执行。只在生成最终目标文件的子项目<code>pom.xml</code>中设定AutoConfig就可以了。例如，对于一个web项目，你可以在生成war包的子项目上设置AutoConfig plugin。</p>
<p><strong>在pom.xml中设定AutoConfig plugin</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;
    ...
    &lt;properties&gt;
        ...
        &lt;!-- 定义autoconfig的版本，建议将此行写在parent pom.xml中。 --&gt;
        &lt;autoconfig-plugin-version&gt;1.2&lt;/autoconfig-plugin-version&gt;
    &lt;/properties&gt;
    ...
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;com.alibaba.citrus.tool&lt;/groupId&gt;
                &lt;artifactId&gt;autoconfig-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;${autoconfig-plugin-version}&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;!-- 要进行AutoConfig的目标文件，默认为${project.artifact.file}。 
                    &lt;dest&gt;${project.artifact.file}&lt;/dest&gt;
                    --&gt;
                    &lt;!-- 配置后，是否展开目标文件，默认为false，不展开。 
                    &lt;exploding&gt;true&lt;/exploding&gt;
                    --&gt;
                    &lt;!-- 展开到指定目录，默认为${project.build.directory}/${project.build.finalName}。 
                    &lt;explodedDirectory&gt;
                        ${project.build.directory}/${project.build.finalName}
                    &lt;/explodedDirectory&gt;
                    --&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;autoconfig&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<p>这样，每次执行<code>mvn package</code>或者<code>mvn install</code>时，都会激活AutoConfig，对package目标文件进行配置。</p>
<p>想要避免AutoConfig，只需要一个额外的命令行参数：</p>
<p><strong>避免执行AutoConfig</strong></p>
<pre><code>mvn install –Dautoconfig.skip
</code></pre>
<h3 id="运行并观察autoconfig的结果"><a class="header" href="#运行并观察autoconfig的结果">运行并观察AutoConfig的结果</a></h3>
<p>第一次执行AutoConfig，无论通过何种方式（独立命令行或maven插件），</p>
<p>AutoConfig都会提示你修改user properties文件，以提供所需要的properties值。</p>
<p>AutoConfig提供了一套基于文本的交互式界面来编辑这些properties。</p>
<p><strong>交互式编辑properties</strong></p>
<pre><code>╭───────────────────────┈┈┈┈
│
│ 您的配置文件需要被更新：
│
│ file:/.../antx.properties
│
│ 这个文件包括了您个人的特殊设置，
│ 包括服务器端口、您的邮件地址等内容。
│
└───────┈┈┈┈┈┈┈┈┈┈┈

 如果不更新此文件，可能会导致配置文件的内容不完整。
 您需要现在更新此文件吗? [Yes][No] y
</code></pre>
<p>当你通过交互式界面填写了所有properties的值，并通过了AutoConfig的验证以后，AutoConfig就开始生成配置文件：</p>
<pre><code>即将保存到文件&quot;file:/.../antx.properties&quot;中, 确定? [Yes][No] y

╭───────────────────────┈┈┈┈
│ 保存文件 file:/.../antx.properties...
│┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
│petstore.loggingLevel  = warn
│petstore.loggingRoot   = ${petstore.work}/logs
│petstore.upload        = ${petstore.work}/upload
│petstore.work          = /tmp
└───────┈┈┈┈┈┈┈┈┈┈┈
 已保存至文件: file:/.../antx.properties
Loading file:/.../antx.properties
&lt;jar:file:/.../Work/my/apps/petstore-webx3/target/petstore.war!/&gt;
    Generating WEB-INF/web.xml [UTF-8] =&gt; WEB-INF/web.xml [UTF-8]

&lt;jar:file:/.../Work/my/apps/petstore-webx3/target/petstore.war!/&gt;
    Generating WEB-INF/common/resources.xml [UTF-8] =&gt; WEB-INF/common/resources.xml [UTF-8]

&lt;jar:file:/.../Work/my/apps/petstore-webx3/target/petstore.war!/&gt;
    Generating log file: META-INF/autoconf/auto-config.xml.log

Expanding: /.../Work/my/apps/petstore-webx3/target/petstore.war
       To: /.../Work/my/apps/petstore-webx3/target/petstore
done.
</code></pre>
<p>假如发现模板中某个placeholder，并未在<code>auto-config.xml</code>中定义，就会出现以下错误：</p>
<pre><code>ERROR - Undefined placeholders found in template:
- Template:   META-INF/autoconf/WEB-INF/web.xml
- Descriptor: META-INF/autoconf/auto-config.xml
- Base URL:   file:/.../Work/my/apps/petstore-webx3/target/petstore/
---------------------------------------------------------------
-&gt; petstore.loggingRoot
---------------------------------------------------------------
</code></pre>
<p>出现错误以后，Maven会报错，并停止build过程。假如你不希望maven停止，可以用下面的命令来执行maven：</p>
<p><strong>避免maven因为placeholder未定义而停止</strong></p>
<pre><code>mvn ... –Dautoconfig.strict=false
</code></pre>
<p>AutoConfig会生成一个日志文件，就在<code>auto-config.xml</code>所在的目录下，名字为：<code>auto-config.xml.log</code>。</p>
<p><strong>AutoConfig所生成的日志文件</strong></p>
<pre><code>Last Configured at: Fri Jun 18 13:54:22 CST 2010

Base URL: file:/.../Work/my/apps/petstore-webx3/target/petstore/
Descriptor: META-INF/autoconf/auto-config.xml

Generating META-INF/autoconf/WEB-INF/web.xml [UTF-8] =&gt; WEB-INF/web.xml [UTF-8]
Generating META-INF/autoconf/WEB-INF/common/resources.xml [UTF-8] =&gt; WEB-INF/common/resources.xml [UTF-8]
</code></pre>
<p>最后，让我们查看一下AutoConfig所生成的文件，其中所有的placeholders应当被替换成你所提供的值了。</p>
<p><strong>AutoConfig生成的结果</strong></p>
<pre><code>...
&lt;context-param&gt;
    &lt;param-name&gt;loggingRoot&lt;/param-name&gt;
    &lt;param-value&gt;/tmp/logs&lt;/param-value&gt;
&lt;/context-param&gt;
&lt;context-param&gt;
    &lt;param-name&gt;loggingLevel&lt;/param-name&gt;
    &lt;param-value&gt;warn&lt;/param-value&gt;
&lt;/context-param&gt;
...
${runtime.placeholder}
</code></pre>
<h3 id="共享properties文件"><a class="header" href="#共享properties文件">共享properties文件</a></h3>
<p>当需要配置的内容越来越多时，即使使用AutoConfig这样的机制，也会变得不胜其烦。</p>
<p>假如你的项目包含了好几个模块，而你只负责其中的一个模块。</p>
<p>一般来说，你对其它模块的配置是什么并不清楚，事实上你也懒得去关心。</p>
<p>但是你为了运行这个项目，你不得不去配置这些模块。</p>
<p>假如模块A就是一个你不想关心的模块，但为了运行它，你需要告诉模块A一些参数：数据库连接的参数、域名、端口、文件目录、搜索引擎……可你并不清楚这些参数应该取什么值。</p>
<p>好在AutoConfig提供了一个共享properties文件的方法。</p>
<p><strong>共享的properties文件</strong></p>
<p>你可以创建一系列文件：<code>module-a-db.properites</code>，<code>module-a-searchengine.properties</code>等等。每个文件中都包含了某个运行环境中的关于module A模块的配置参数。</p>
<p>现在，你可以不关心module A了！你只要使用下面的命令：</p>
<p><code>-s</code>参数代表“共享的properties文件”。</p>
<pre><code>autoconfig -s module-a-db.properties,module-a-searchengine.properties ……
</code></pre>
<p>同时，你的<code>antx.properties</code>也被简化了，因为这里只会保存你定义的配置项，而不会包含共享的配置项。</p>
<h3 id="共享整个目录"><a class="header" href="#共享整个目录">共享整个目录</a></h3>
<p>假如共享的文件很多的话，AutoConfig还有一个贴心的功能，你可以把这些文件按目录来组织：</p>
<pre><code>shared-properties/
 ├─test/                                 // 测试环境的共享配置
 │    module-a-db.properties
 │    module-a-searchengine.properties
 │    module-b.properties
 └─prod/                                 // 生产环境的共享配置
       module-a-db.properties
       module-a-searchengine.properties
       module-b.properties
</code></pre>
<p>然后，你可以直接在AutoConfig中引用目录：</p>
<pre><code>autoconfig -s shared-propertes/test/ ……
</code></pre>
<p>AutoConfig就会为你装载这个目录下的所有共享配置文件。（注意，<em>目录必须以斜杠“/”结尾</em>）</p>
<h4 id="将共享目录放在httphttps或ssh服务器上"><a class="header" href="#将共享目录放在httphttps或ssh服务器上">将共享目录放在http、https或ssh服务器上</a></h4>
<p>AutoConfig还支持从http、https或ssh服务器上取得共享配置文件，只需要将前面例子中的文件名改成http或ssh的URI就可以了：</p>
<pre><code>autoconfig -s http://share.alibaba.com/shared-propertes/test/ ……
autoconfig -s http://myname@share.alibaba.com/shared-propertes/test/ ……
autoconfig -s https://share.alibaba.com/shared-propertes/test/ ……
autoconfig -s https://myname@share.alibaba.com/shared-propertes/test/ ……
autoconfig -s ssh://myname@share.alibaba.com/shared-propertes/test/ ……
</code></pre>
<p>由于Subversion、Git服务器是支持HTTP/HTTPS协议的，因此将properties文件存放在Subversion或Git服务器上，也是一个极好的办法。由于采用了Subversion或Git，properties文件的版本管理问题也被一举解决了。</p>
<p>需要注意的是，访问http和ssh有可能需要验证用户和密码。当需要验证时，AutoConfig会提示你输入用户名和密码。输入以后，密码将被保存在*<code>$HOME/passwd.autoconfig</code>*文件中，以后就不需要重复提问了。</p>
<h4 id="在多种配置项中切换"><a class="header" href="#在多种配置项中切换">在多种配置项中切换</a></h4>
<p>当你使用前文所述的<code>autoconfig –s</code>命令来生成<code>antx.properties</code>文件时，你会发现<code>antx.properties</code>中增加了几行特别的内容：</p>
<p><strong>包含共享文件、目录信息的<code>antx.properties</code>文件</strong></p>
<pre><code>antx.properties.default  = http://share.alibaba.com/shared-propertes/test/
</code></pre>
<p>如果你在<code>-s</code>参数中指定了多项共享properties文件或目录，那么<code>antx.properties</code>中将会这样：</p>
<pre><code>antx.properties.default.1  = http://share.alibaba.com/shared-propertes/test/
antx.properties.default.2  = file:/shared-properties/test/my-1.properites
antx.properties.default.3  = file:/shared-properties/test/my-2.properites
</code></pre>
<p>事实上，AutoConfig还支持多组共享配置，请试用下面的命令：</p>
<p><strong>使用多组共享配置</strong></p>
<pre><code>autoconfig -s http://share.alibaba.com/shared-propertes/test/ -n test ……
</code></pre>
<p>为当前共享配置定义一个名字，以后可以用这个名字来简化命令。</p>
<p>antx.properties就会是这个样子：</p>
<pre><code>antx.properties = test
antx.properties.test = http://share.alibaba.com/shared-propertes/test/
</code></pre>
<pre><code>autoconfig -s http://share.alibaba.com/shared-propertes/prod/ -n prod ……
</code></pre>
<p>antx.properties就会变成这个样子：</p>
<pre><code>antx.properties = prod
antx.properties.test = http://share.alibaba.com/shared-propertes/test/
antx.properties.prod = http://share.alibaba.com/shared-propertes/prod/
</code></pre>
<p>以后再执行，就不需要再指定<code>-s</code>参数了，只需用<code>-n</code>参数选择一组共享properties文件即可。例如：</p>
<pre><code>autoconfig -n prod ……                      // 使用prod生产环境的参数
autoconfig -n test ……                      // 使用test测试环境的参数
autoconfig  ……                             // 不指定，则使用最近一次所选择的共享文件
</code></pre>
<h3 id="autoconfig常用命令"><a class="header" href="#autoconfig常用命令">AutoConfig常用命令</a></h3>
<p>下面罗列了AutoConfig的常用的命令及参数：</p>
<h4 id="指定交互式界面的charset"><a class="header" href="#指定交互式界面的charset">指定交互式界面的charset</a></h4>
<p>一般不需要特别指定charset，除非AutoConfig自动识别系统编码出错，导致显示乱码。</p>
<pre><code>运行AutoConfig独立可执行程序	
autoconfig ... -c GBK
运行AutoConfig maven插件	
mvn ... -Dautoconfig.charset=GBK


</code></pre>
<h4 id="指定交互模式"><a class="header" href="#指定交互模式">指定交互模式</a></h4>
<p>默认情况下，交互模式为自动（auto）。仅当user properties中的值不满足auto-config.xml中的定义时，才会交互式地引导用户提供properties值。</p>
<p>但你可以强制打开交互模式：</p>
<pre><code>运行AutoConfig独立可执行程序	
autoconfig ... –i
autoconfig ... –i on
</code></pre>
<pre><code>运行AutoConfig maven插件	
mvn ... -Dautoconfig.interactive
mvn ...  -Dautoconfig.interactive=true
</code></pre>
<p>或强制关闭交互模式：</p>
<pre><code>运行AutoConfig独立可执行程序	
autoconfig ... –I
autoconfig ... –i off
运行AutoConfig maven插件	
mvn ...  -Dautoconfig.interactive=false
</code></pre>
<h4 id="指定user-properties"><a class="header" href="#指定user-properties">指定user properties</a></h4>
<p>默认情况下，AutoConfig会按下列顺序查找user properties：</p>
<ol>
<li><code>当前目录/antx.properties</code></li>
<li><code>当前用户HOME目录/antx.properties</code></li>
</ol>
<p>但你可以指定一个自己的properties文件，用下面的命令：</p>
<pre><code>运行AutoConfig独立可执行程序	
autoconfig ... –u my.props
运行AutoConfig maven插件	
mvn ... -Dautoconfig.userProperties=my.props
</code></pre>
<h4 id="指定输出文件"><a class="header" href="#指定输出文件">指定输出文件</a></h4>
<p>默认情况下，AutoConfig所生成的配置文件以及日志信息会直接输出到当前包文件或目录中。例如以下命令会改变<code>petstore.war</code>的内容：</p>
<pre><code>autoconfig petstore.war
</code></pre>
<p>但你可以指定另一个输出文件或目录，这样，原来的文件或目录就不会被修改：</p>
<pre><code>运行AutoConfig独立可执行程序	
autoconfig petstore.war –o petstore-configured.war
运行AutoConfig maven插件	不适用
</code></pre>
<h4 id="避免执行autoconfig"><a class="header" href="#避免执行autoconfig">避免执行AutoConfig</a></h4>
<p>将AutoConfig和maven package phase绑定以后，每次build都会激活AutoConfig。假如你想跳过这一步，只需要下面的命令：</p>
<pre><code>mvn ... -Dautoconfig.skip
</code></pre>
<h4 id="避免中断maven-build"><a class="header" href="#避免中断maven-build">避免中断maven build</a></h4>
<pre><code>mvn ... -Dautoconfig.strict=false
</code></pre>
<p>AutoConfig是一个简单而有用的小工具，弥补了Maven Filtering及类似机制的不足。但它还有不少改进的余地。</p>
<ul>
<li>界面不够直观。如果能够通过GUI或WEB界面来配置，就更好了。</li>
<li>Properties validator目前不易扩展。</li>
<li>缺少集成环境的支持。</li>
</ul>
<p><a href="https://jjm2473.github.io/citrus-doc/autoconfig.html">COPY LINK</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="introduction-to-archetypes"><a class="header" href="#introduction-to-archetypes">Introduction to Archetypes</a></h2>
<h3 id="what-is-archetype"><a class="header" href="#what-is-archetype">What is Archetype?</a></h3>
<p>简而言之，原型是一个Maven项目模板工具包</p>
<p>原型被定义为<em>原始模式或模型，从中可以制造所有其他相同类型的东西</em>。</p>
<p>这个名字很合适，因为我们试图提供一种机制，这种机制提供一种生成Maven项目的一致方法。</p>
<p>原型将帮助作者为用户创建 Maven 项目模板，并为用户提供生成这些项目模板的参数化版本的方法。</p>
<p>使用原型提供了一种很好的方法，可以以与项目或组织采用的最佳实践一致的方式快速支持开发人员。</p>
<p>在 Maven 项目中，我们使用<em>archetypes</em> ，通过提供一个演示 Maven 许多功能的示例项目，同时向新用户介绍 Maven 采用的最佳实践，尝试让用户尽快启动和运行。</p>
<p>在几秒钟内，新用户可以有一个正在工作的Maven项目，用作调查Maven中更多功能的跳板。</p>
<p>We have also tried to make the Archetype mechanism additive, and by that we mean allowing portions of a project to be captured in an archetype so that pieces or aspects of a project can be added to existing projects.</p>
<p>一个很好的例子是 Maven site archetype。</p>
<p>您已使用快速入门原型生成工作项目，然后可以使用该现有项目中的站点原型快速为该项目创建站点</p>
<p>你可以用原型做任何类似的事情。</p>
<p>您可能希望在组织内标准化 J2EE 开发，因此您可能希望为 EJB、WAR 或 Web 服务提供原型</p>
<p>.在组织的存储库中创建并部署这些原型后，组织内的所有开发人员都可以使用它们。</p>
<h3 id="using-an-archetype"><a class="header" href="#using-an-archetype">Using an Archetype</a></h3>
<p>To create a new project based on an Archetype, you need to call <code>mvn archetype:generate</code> goal, like the following:</p>
<pre><code class="language-xml">mvn archetype:generate
</code></pre>
<p>Please refer to <a href="https://maven.apache.org/archetype/maven-archetype-plugin/usage.html">Archetype Plugin page</a>.</p>
<h3 id="provided-archetypes"><a class="header" href="#provided-archetypes">Provided Archetypes</a></h3>
<p>Maven provides several Archetype artifacts:</p>
<table><thead><tr><th style="text-align: left">Archetype ArtifactIds</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">maven-archetype-archetype</td><td style="text-align: left">An archetype to generate a sample archetype project.</td></tr>
<tr><td style="text-align: left">maven-archetype-j2ee-simple</td><td style="text-align: left">An archetype to generate a simplifed sample J2EE application.</td></tr>
<tr><td style="text-align: left">maven-archetype-mojo</td><td style="text-align: left">An archetype to generate a sample a sample Maven plugin.</td></tr>
<tr><td style="text-align: left">maven-archetype-plugin</td><td style="text-align: left">An archetype to generate a sample Maven plugin.</td></tr>
<tr><td style="text-align: left">maven-archetype-plugin-site</td><td style="text-align: left">An archetype to generate a sample Maven plugin site.</td></tr>
<tr><td style="text-align: left">maven-archetype-portlet</td><td style="text-align: left">An archetype to generate a sample JSR-268 Portlet.</td></tr>
<tr><td style="text-align: left">maven-archetype-quickstart</td><td style="text-align: left">An archetype to generate a sample Maven project.</td></tr>
<tr><td style="text-align: left">maven-archetype-simple</td><td style="text-align: left">An archetype to generate a simple Maven project.</td></tr>
<tr><td style="text-align: left">maven-archetype-site</td><td style="text-align: left">An archetype to generate a sample Maven site which demonstrates some of the supported document types like APT, XDoc, and FML and demonstrates how to i18n your site.</td></tr>
<tr><td style="text-align: left">maven-archetype-site-simple</td><td style="text-align: left">An archetype to generate a sample Maven site.</td></tr>
<tr><td style="text-align: left">maven-archetype-webapp</td><td style="text-align: left">An archetype to generate a sample Maven Webapp project.</td></tr>
</tbody></table>
<p>For more information on these archetypes, please refer to the <a href="https://maven.apache.org/archetypes/index.html">Maven Archetype Bundles page</a>.</p>
<h3 id="what-makes-up-an-archetype"><a class="header" href="#what-makes-up-an-archetype">What makes up an Archetype?</a></h3>
<p>Archetypes are packaged up in a JAR and they consist of the archetype metadata which describes the contents of archetype, and a set of <a href="http://velocity.apache.org/">Velocity</a> templates which make up the prototype project. If you would like to know how to make your own archetypes, please refer to our <a href="https://maven.apache.org/guides/mini/guide-creating-archetypes.html">Guide to creating archetypes</a>.</p>
<p>原型被打包在JAR中，</p>
<ul>
<li>它们由描述原型内容的原型元数据和构成原型项目的一组<a href="http://velocity.apache.org/">Velocity</a>模板组成。</li>
</ul>
<p>如果您想知道如何制作自己的原型，请参阅我们的 <a href="https://maven.apache.org/guides/mini/guide-creating-archetypes.html">Guide to creating archetypes</a>.</p>
<h2 id="guide-to-creating-archetypes"><a class="header" href="#guide-to-creating-archetypes">Guide to Creating Archetypes</a></h2>
<p>创建原型是一个非常直接的过程。原型是一个非常简单的工件，其中包含要创建的项目原型。原型由以下部分组成：</p>
<ul>
<li>an <a href="https://maven.apache.org/archetype/archetype-models/archetype-descriptor/archetype-descriptor.html">archetype descriptor</a> (<code>archetype-metadata.xml</code> in directory: <code>src/main/resources/META-INF/maven/</code>). 它列出了将包含在原型中的所有文件，并对它们进行分类，以便原型生成机制可以正确处理它们。</li>
<li>the prototype files that are copied by the archetype plugin (directory: <code>src/main/resources/archetype-resources/</code>)</li>
<li>the prototype pom (<code>pom.xml</code> in: <code>src/main/resources/archetype-resources</code>)</li>
<li>a pom for the archetype (<code>pom.xml</code> in the archetype's root directory).</li>
</ul>
<p>To create an archetype follow these steps:</p>
<h3 id="create-a-new-project-and-pomxml-for-the-archetype-artifact"><a class="header" href="#create-a-new-project-and-pomxml-for-the-archetype-artifact">Create a new project and pom.xml for the archetype artifact</a></h3>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
  &lt;groupId&gt;my.groupId&lt;/groupId&gt;
  &lt;artifactId&gt;my-archetype-id&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;maven-archetype&lt;/packaging&gt;
 
  &lt;build&gt;
    &lt;extensions&gt;
      &lt;extension&gt;
        &lt;groupId&gt;org.apache.maven.archetype&lt;/groupId&gt;
        &lt;artifactId&gt;archetype-packaging&lt;/artifactId&gt;
        &lt;version&gt;3.1.1&lt;/version&gt;
      &lt;/extension&gt;
    &lt;/extensions&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<p>All you need to specify is a <code>groupId</code>, <code>artifactId</code> and <code>version</code>.</p>
<p>These three parameters will be needed later for invoking the archetype via <code>archetype:generate</code> from the commandline.</p>
<h3 id="create-the-archetype-descriptor"><a class="header" href="#create-the-archetype-descriptor">Create the archetype descriptor</a></h3>
<p>The <a href="https://maven.apache.org/archetype/archetype-models/archetype-descriptor/archetype-descriptor.html">archetype descriptor</a> is a file called <code>archetype-metadata.xml</code> which must be located in the <code>src/main/resources/META-INF/maven/</code> directory. An example of an archetype descriptor can be found in the quickstart archetype:</p>
<pre><code class="language-xml">&lt;archetype-descriptor
        xmlns=&quot;http://maven.apache.org/plugins/maven-archetype-plugin/archetype-descriptor/1.1.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://maven.apache.org/plugins/maven-archetype-plugin/archetype-descriptor/1.1.0 https://maven.apache.org/xsd/archetype-descriptor-1.1.0.xsd&quot;
        name=&quot;quickstart&quot;&gt;
    &lt;fileSets&gt;
        &lt;fileSet filtered=&quot;true&quot; packaged=&quot;true&quot;&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
        &lt;/fileSet&gt;
        &lt;fileSet&gt;
            &lt;directory&gt;src/test/java&lt;/directory&gt;
        &lt;/fileSet&gt;
    &lt;/fileSets&gt;
&lt;/archetype-descriptor&gt;
</code></pre>
<ol>
<li>
<p>The attribute <code>name</code> tag should be the same as the <code>artifactId</code> in the archetype <code>pom.xml</code>.</p>
</li>
<li>
<p>The boolean attribute <code>partial</code> show if this archetype is representing a full Maven project or only parts.</p>
</li>
</ol>
<p>The <code>requiredProperties</code>, <code>fileSets</code> and <code>modules</code> tags represent the differents parts of the project:</p>
<ul>
<li><code>&lt;requiredProperties&gt;</code> : List of required properties to generate a project from this archetype</li>
<li><code>&lt;fileSets&gt;</code> : File sets definition</li>
<li><code>&lt;modules&gt;</code> : Modules definition</li>
</ul>
<p>At this point one can only specify individual files to be created but not empty directories.</p>
<p>Thus the quickstart archetype shown above defines the following directory structure:</p>
<pre><code>archetype
|-- pom.xml
`-- src
    `-- main
        `-- resources
            |-- META-INF
            |   `-- maven
            |       `--archetype-metadata.xml
            `-- archetype-resources
                |-- pom.xml
                `-- src
                    |-- main
                    |   `-- java
                    |       `-- App.java
                    `-- test
                        `-- java
                            `-- AppTest.java
</code></pre>
<h3 id="create-the-prototype-files-and-the-prototype-pomxml"><a class="header" href="#create-the-prototype-files-and-the-prototype-pomxml">Create the prototype files and the prototype pom.xml</a></h3>
<p>The next component of the archetype to be created is the prototype <code>pom.xml</code>. Any <code>pom.xml</code> will do, just don't forget to the set <code>artifactId</code> and <code>groupId</code> as variables ( <code>${artifactId}</code> / <code>${groupId}</code> ). </p>
<p>Both variables will be initialized from the commandline when calling <code>archetype:generate</code>.</p>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
    &lt;groupId&gt;${groupId}&lt;/groupId&gt;
    &lt;artifactId&gt;${artifactId}&lt;/artifactId&gt;
    &lt;version&gt;${version}&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
 
    &lt;name&gt;${artifactId}&lt;/name&gt;
    &lt;url&gt;http://www.myorganization.org&lt;/url&gt;
 
    &lt;dependencies&gt;
        &lt;dependency&gt;
                &lt;groupId&gt;junit&lt;/groupId&gt;
                &lt;artifactId&gt;junit&lt;/artifactId&gt;
                 &lt;version&gt;4.12&lt;/version&gt;
                &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h3 id="install-the-archetype-and-run-the-archetype-plugin"><a class="header" href="#install-the-archetype-and-run-the-archetype-plugin">Install the archetype and run the archetype plugin</a></h3>
<pre><code>mvn install
</code></pre>
<p>现在，您已经创建了一个原型，可以使用以下命令在本地系统上尝试它。</p>
<p>在此命令中，您需要指定有关要使用的原型的完整信息（其 groupId、其 artifactId、其version）以及有关要创建的新项目的信息（artifactId 和 groupId）。不要忘记包含原型的版本（if you don't include the version，you archetype creation may fail with a message that version:RELEASE was not found）</p>
<pre><code>mvn archetype:generate                                  \
  -DarchetypeGroupId=&lt;archetype-groupId&gt;                \
  -DarchetypeArtifactId=&lt;archetype-artifactId&gt;          \
  -DarchetypeVersion=&lt;archetype-version&gt;                \
  -DgroupId=&lt;my.groupid&gt;                                \
  -DartifactId=&lt;my-artifactId&gt;
</code></pre>
<h3 id="alternative-way-to-start-creating-your-archetype"><a class="header" href="#alternative-way-to-start-creating-your-archetype">Alternative way to start creating your Archetype</a></h3>
<pre><code class="language-shell">mvn archetype:generate
  -DgroupId=[your project's group id]
  -DartifactId=[your project's artifact id]
  -DarchetypeGroupId=org.apache.maven.archetypes
  -DarchetypeArtifactId=maven-archetype-archetype
</code></pre>
<pre><code class="language-shell">mvn archetype:generate  -DgroupId=&quot;com.alibaba.cola.demo.service&quot; -DartifactId=demo-service -Dversion=&quot;1.0.0-SNAPSHOT&quot; -Dpackage&quot;=com.alibaba.demo&quot; -DarchetypeArtifactId=&quot;cola-framework-archetype-servic&quot;e -DarchetypeGroupId=&quot;com.alibaba.cola&quot; -DarchetypeVersion=&quot;4.0.1&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maven功能"><a class="header" href="#maven功能">maven功能</a></h1>
<p>构建项目</p>
<p>文档生成</p>
<p>报告</p>
<p>依赖</p>
<p>SCMS</p>
<p>发布</p>
<p>分发</p>
<p>邮件列表</p>
<h1 id="约定配置"><a class="header" href="#约定配置">约定配置</a></h1>
<table><thead><tr><th style="text-align: left">目录</th><th style="text-align: left">目的</th></tr></thead><tbody>
<tr><td style="text-align: left">${basedir}</td><td style="text-align: left">存放pom.xml和所有的子目录</td></tr>
<tr><td style="text-align: left">${basedir}/src/main/java</td><td style="text-align: left">项目的java源代码</td></tr>
<tr><td style="text-align: left">${basedir}/src/main/resources</td><td style="text-align: left">项目的资源，比如说property文件，springmvc.xml</td></tr>
<tr><td style="text-align: left">${basedir}/src/test/java</td><td style="text-align: left">项目的测试类，比如说Junit代码</td></tr>
<tr><td style="text-align: left">${basedir}/src/test/resources</td><td style="text-align: left">测试用的资源</td></tr>
<tr><td style="text-align: left">${basedir}/src/main/webapp/WEB-INF</td><td style="text-align: left">web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面</td></tr>
<tr><td style="text-align: left">${basedir}/target</td><td style="text-align: left">打包输出目录</td></tr>
<tr><td style="text-align: left">${basedir}/target/classes</td><td style="text-align: left">编译输出目录</td></tr>
<tr><td style="text-align: left">${basedir}/target/test-classes</td><td style="text-align: left">测试编译输出目录</td></tr>
<tr><td style="text-align: left">Test.java</td><td style="text-align: left">Maven只会自动运行符合该命名规则的测试类</td></tr>
<tr><td style="text-align: left">~/.m2/repository</td><td style="text-align: left">Maven默认的本地仓库目录位置</td></tr>
</tbody></table>
<h1 id="pom文件"><a class="header" href="#pom文件">POM文件</a></h1>
<h2 id="可以指定的配置类型"><a class="header" href="#可以指定的配置类型">可以指定的配置类型</a></h2>
<p>项目自身信息</p>
<ul>
<li>modelVersion</li>
<li>groupId,artifactId,version</li>
</ul>
<p>项目依赖</p>
<p>插件</p>
<p>执行目标</p>
<p>项目构建profile</p>
<p>项目版本</p>
<p>项目开发者列表</p>
<p>邮件列表信息</p>
<h2 id="父pom"><a class="header" href="#父pom">父POM</a></h2>
<p>父（Super）POM是 Maven 默认的 POM,所有的 POM 都继承自一个父 POM</p>
<p>包含了一些可以被继承的默认设置</p>
<h2 id="effectivepom"><a class="header" href="#effectivepom">EffectivePOM</a></h2>
<pre><code>mvn help:effective-pom
</code></pre>
<p>经过继承、插值,变量替换之后的有效配置</p>
<h1 id="pom标签大全"><a class="header" href="#pom标签大全">POM标签大全</a></h1>
<h2 id="父pom-1"><a class="header" href="#父pom-1">父POM</a></h2>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;!--被继承的父项目的构件标识符 --&gt;
    &lt;artifactId /&gt;
    &lt;!--被继承的父项目的全球唯一标识符 --&gt;
    &lt;groupId /&gt;
    &lt;!--被继承的父项目的版本 --&gt;
    &lt;version /&gt;
    &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 
        目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;
    &lt;relativePath /&gt;
&lt;/parent&gt;
</code></pre>
<h2 id="项目标识"><a class="header" href="#项目标识">项目标识</a></h2>
<pre><code class="language-xml">&lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;
&lt;groupId&gt;asia.banseon&lt;/groupId&gt;
&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 
    特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt;
&lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt;
&lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;
&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
</code></pre>
<h2 id="项目构建信息"><a class="header" href="#项目构建信息">项目构建信息</a></h2>
<pre><code class="language-xml">&lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;
&lt;packaging&gt;jar&lt;/packaging&gt;
</code></pre>
<h2 id="项目文档描述"><a class="header" href="#项目文档描述">项目文档描述</a></h2>
<pre><code class="language-xml">&lt;!--项目的名称, Maven产生的文档用 --&gt;
&lt;name&gt;banseon-maven&lt;/name&gt;
&lt;!--项目主页的URL, Maven产生的文档用 --&gt;
&lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;
&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 
    签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;
&lt;description&gt;A maven project to study maven.&lt;/description&gt;
</code></pre>
<h2 id="配置项目的问题管理系统"><a class="header" href="#配置项目的问题管理系统">配置项目的问题管理系统</a></h2>
<pre><code class="language-xml">&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;
    &lt;issueManagement&gt;
        &lt;!--问题管理系统（例如jira）的名字， --&gt;
        &lt;system&gt;jira&lt;/system&gt;
        &lt;!--该项目使用的问题管理系统的URL --&gt;
        &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt;
    &lt;/issueManagement&gt;
</code></pre>
<h2 id="项目持续集成信息"><a class="header" href="#项目持续集成信息">项目持续集成信息</a></h2>
<pre><code>&lt;!--项目持续集成信息 --&gt;
    &lt;ciManagement&gt;
        &lt;!--持续集成系统的名字，例如continuum --&gt;
        &lt;system /&gt;
        &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;
        &lt;url /&gt;
        &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;
        &lt;notifiers&gt;
            &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;
            &lt;notifier&gt;
                &lt;!--传送通知的途径 --&gt;
                &lt;type /&gt;
                &lt;!--发生错误时是否通知 --&gt;
                &lt;sendOnError /&gt;
                &lt;!--构建失败时是否通知 --&gt;
                &lt;sendOnFailure /&gt;
                &lt;!--构建成功时是否通知 --&gt;
                &lt;sendOnSuccess /&gt;
                &lt;!--发生警告时是否通知 --&gt;
                &lt;sendOnWarning /&gt;
                &lt;!--不赞成使用。通知发送到哪里 --&gt;
                &lt;address /&gt;
                &lt;!--扩展配置项 --&gt;
                &lt;configuration /&gt;
            &lt;/notifier&gt;
        &lt;/notifiers&gt;
    &lt;/ciManagement&gt;
</code></pre>
<h2 id="项目创建年份"><a class="header" href="#项目创建年份">项目创建年份</a></h2>
<pre><code>&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;
&lt;inceptionYear /&gt;
</code></pre>
<h2 id="项目相关邮件列表信息"><a class="header" href="#项目相关邮件列表信息">项目相关邮件列表信息</a></h2>
<pre><code>&lt;mailingLists&gt;
        &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;
        &lt;mailingList&gt;
            &lt;!--邮件的名称 --&gt;
            &lt;name&gt;Demo&lt;/name&gt;
            &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;
            &lt;post&gt;banseon@126.com&lt;/post&gt;
            &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;
            &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt;
            &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;
            &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt;
            &lt;!--你可以浏览邮件信息的URL --&gt;
            &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt;
        &lt;/mailingList&gt;
    &lt;/mailingLists&gt;
</code></pre>
<h2 id="项目开发者列表"><a class="header" href="#项目开发者列表">项目开发者列表</a></h2>
<pre><code class="language-xml">&lt;!--项目开发者列表 --&gt;
    &lt;developers&gt;
        &lt;!--某个项目开发者的信息 --&gt;
        &lt;developer&gt;
            &lt;!--SCM里项目开发者的唯一标识符 --&gt;
            &lt;id&gt;HELLO WORLD&lt;/id&gt;
            &lt;!--项目开发者的全名 --&gt;
            &lt;name&gt;banseon&lt;/name&gt;
            &lt;!--项目开发者的email --&gt;
            &lt;email&gt;banseon@126.com&lt;/email&gt;
            &lt;!--项目开发者的主页的URL --&gt;
            &lt;url /&gt;
            &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;
            &lt;roles&gt;
                &lt;role&gt;Project Manager&lt;/role&gt;
                &lt;role&gt;Architect&lt;/role&gt;
            &lt;/roles&gt;
            &lt;!--项目开发者所属组织 --&gt;
            &lt;organization&gt;demo&lt;/organization&gt;
            &lt;!--项目开发者所属组织的URL --&gt;
            &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt;
            &lt;!--项目开发者属性，如即时消息如何处理等 --&gt;
            &lt;properties&gt;
                &lt;dept&gt;No&lt;/dept&gt;
            &lt;/properties&gt;
            &lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;
            &lt;timezone&gt;-5&lt;/timezone&gt;
        &lt;/developer&gt;
    &lt;/developers&gt;
</code></pre>
<h2 id="项目的其他贡献者列表"><a class="header" href="#项目的其他贡献者列表">项目的其他贡献者列表</a></h2>
<pre><code class="language-xml">&lt;contributors&gt;
    &lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;
    &lt;contributor&gt;
        &lt;name /&gt;
        &lt;email /&gt;
        &lt;url /&gt;
        &lt;organization /&gt;
        &lt;organizationUrl /&gt;
        &lt;roles /&gt;
        &lt;timezone /&gt;
        &lt;properties /&gt;
    &lt;/contributor&gt;
&lt;/contributors&gt;
</code></pre>
<pre><code class="language-xml"> &lt;licenses&gt;
        &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;
        &lt;license&gt;
            &lt;!--license用于法律上的名称 --&gt;
            &lt;name&gt;Apache 2&lt;/name&gt;
            &lt;!--官方的license正文页面的URL --&gt;
            &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt;
            &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;
            &lt;distribution&gt;repo&lt;/distribution&gt;
            &lt;!--关于license的补充信息 --&gt;
            &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt;
        &lt;/license&gt;
    &lt;/licenses&gt;
</code></pre>
<h2 id="scm配置你的代码库"><a class="header" href="#scm配置你的代码库">SCM配置你的代码库</a></h2>
<pre><code>&lt;scm&gt;
        &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;
        &lt;connection&gt;
            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)
        &lt;/connection&gt;
        &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;
        &lt;developerConnection&gt;
            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk
        &lt;/developerConnection&gt;
        &lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;
        &lt;tag /&gt;
        &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;
        &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt;
    &lt;/scm&gt;
</code></pre>
<h2 id="项目所属组织"><a class="header" href="#项目所属组织">项目所属组织</a></h2>
<pre><code class="language-xml">&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;
&lt;organization&gt;
    &lt;!--组织的全名 --&gt;
    &lt;name&gt;demo&lt;/name&gt;
    &lt;!--组织主页的URL --&gt;
    &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;
&lt;/organization&gt;
</code></pre>
<h2 id="构建项目所需要的信息"><a class="header" href="#构建项目所需要的信息">构建项目所需要的信息</a></h2>
<pre><code class="language-xml">&lt;build&gt;
        &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;
        &lt;sourceDirectory /&gt;
        &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;
        &lt;scriptSourceDirectory /&gt;
        &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;
        &lt;testSourceDirectory /&gt;
        &lt;!--被编译过的应用程序class文件存放的目录。 --&gt;
        &lt;outputDirectory /&gt;
        &lt;!--被编译过的测试class文件存放的目录。 --&gt;
        &lt;testOutputDirectory /&gt;
        &lt;!--使用来自该项目的一系列构建扩展 --&gt;
        &lt;extensions&gt;
            &lt;!--描述使用到的构建扩展。 --&gt;
            &lt;extension&gt;
                &lt;!--构建扩展的groupId --&gt;
                &lt;groupId /&gt;
                &lt;!--构建扩展的artifactId --&gt;
                &lt;artifactId /&gt;
                &lt;!--构建扩展的版本 --&gt;
                &lt;version /&gt;
            &lt;/extension&gt;
        &lt;/extensions&gt;
        &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;
        &lt;defaultGoal /&gt;
        &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;
        &lt;resources&gt;
            &lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;
            &lt;resource&gt;
                &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例 
                    子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;
                &lt;targetPath /&gt;
                &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;
                &lt;filtering /&gt;
                &lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;
                &lt;directory /&gt;
                &lt;!--包含的模式列表，例如**/*.xml. --&gt;
                &lt;includes /&gt;
                &lt;!--排除的模式列表，例如**/*.xml --&gt;
                &lt;excludes /&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
        &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;
        &lt;testResources&gt;
            &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;
            &lt;testResource&gt;
                &lt;targetPath /&gt;
                &lt;filtering /&gt;
                &lt;directory /&gt;
                &lt;includes /&gt;
                &lt;excludes /&gt;
            &lt;/testResource&gt;
        &lt;/testResources&gt;
        &lt;!--构建产生的所有文件存放的目录 --&gt;
        &lt;directory /&gt;
        &lt;!--产生的构件的文件名，默认值是${artifactId}-${version}。 --&gt;
        &lt;finalName /&gt;
        &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;
        &lt;filters /&gt;
        &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;
        &lt;pluginManagement&gt;
            &lt;!--使用的插件列表 。 --&gt;
            &lt;plugins&gt;
                &lt;!--plugin元素包含描述插件所需要的信息。 --&gt;
                &lt;plugin&gt;
                    &lt;!--插件在仓库里的group ID --&gt;
                    &lt;groupId /&gt;
                    &lt;!--插件在仓库里的artifact ID --&gt;
                    &lt;artifactId /&gt;
                    &lt;!--被使用的插件的版本（或版本范围） --&gt;
                    &lt;version /&gt;
                    &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;
                    &lt;extensions /&gt;
                    &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;
                    &lt;executions&gt;
                        &lt;!--execution元素包含了插件执行需要的信息 --&gt;
                        &lt;execution&gt;
                            &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;
                            &lt;id /&gt;
                            &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;
                            &lt;phase /&gt;
                            &lt;!--配置的执行目标 --&gt;
                            &lt;goals /&gt;
                            &lt;!--配置是否被传播到子POM --&gt;
                            &lt;inherited /&gt;
                            &lt;!--作为DOM对象的配置 --&gt;
                            &lt;configuration /&gt;
                        &lt;/execution&gt;
                    &lt;/executions&gt;
                    &lt;!--项目引入插件所需要的额外依赖 --&gt;
                    &lt;dependencies&gt;
                        &lt;!--参见dependencies/dependency元素 --&gt;
                        &lt;dependency&gt;
                            ......
                        &lt;/dependency&gt;
                    &lt;/dependencies&gt;
                    &lt;!--任何配置是否被传播到子项目 --&gt;
                    &lt;inherited /&gt;
                    &lt;!--作为DOM对象的配置 --&gt;
                    &lt;configuration /&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/pluginManagement&gt;
        &lt;!--使用的插件列表 --&gt;
        &lt;plugins&gt;
            &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;
            &lt;plugin&gt;
                &lt;groupId /&gt;
                &lt;artifactId /&gt;
                &lt;version /&gt;
                &lt;extensions /&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id /&gt;
                        &lt;phase /&gt;
                        &lt;goals /&gt;
                        &lt;inherited /&gt;
                        &lt;configuration /&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
                &lt;dependencies&gt;
                    &lt;!--参见dependencies/dependency元素 --&gt;
                    &lt;dependency&gt;
                        ......
                    &lt;/dependency&gt;
                &lt;/dependencies&gt;
                &lt;goals /&gt;
                &lt;inherited /&gt;
                &lt;configuration /&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</code></pre>
<h2 id="项目构建profile"><a class="header" href="#项目构建profile">项目构建profile</a></h2>
<pre><code class="language-xml">&lt;profiles&gt;
        &lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;
        &lt;profile&gt;
            &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;
            &lt;id /&gt;
            &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;
            &lt;activation&gt;
                &lt;!--profile默认是否激活的标志 --&gt;
                &lt;activeByDefault /&gt;
                &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;
                &lt;jdk /&gt;
                &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;
                &lt;os&gt;
                    &lt;!--激活profile的操作系统的名字 --&gt;
                    &lt;name&gt;Windows XP&lt;/name&gt;
                    &lt;!--激活profile的操作系统所属家族(如 'windows') --&gt;
                    &lt;family&gt;Windows&lt;/family&gt;
                    &lt;!--激活profile的操作系统体系结构 --&gt;
                    &lt;arch&gt;x86&lt;/arch&gt;
                    &lt;!--激活profile的操作系统版本 --&gt;
                    &lt;version&gt;5.1.2600&lt;/version&gt;
                &lt;/os&gt;
                &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;
                &lt;property&gt;
                    &lt;!--激活profile的属性的名称 --&gt;
                    &lt;name&gt;mavenVersion&lt;/name&gt;
                    &lt;!--激活profile的属性的值 --&gt;
                    &lt;value&gt;2.0.3&lt;/value&gt;
                &lt;/property&gt;
                &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;
                &lt;file&gt;
                    &lt;!--如果指定的文件存在，则激活profile。 --&gt;
                    &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/
                    &lt;/exists&gt;
                    &lt;!--如果指定的文件不存在，则激活profile。 --&gt;
                    &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/
                    &lt;/missing&gt;
                &lt;/file&gt;
            &lt;/activation&gt;
            &lt;!--构建项目所需要的信息。参见build元素 --&gt;
            &lt;build&gt;
                &lt;defaultGoal /&gt;
                &lt;resources&gt;
                    &lt;resource&gt;
                        &lt;targetPath /&gt;
                        &lt;filtering /&gt;
                        &lt;directory /&gt;
                        &lt;includes /&gt;
                        &lt;excludes /&gt;
                    &lt;/resource&gt;
                &lt;/resources&gt;
                &lt;testResources&gt;
                    &lt;testResource&gt;
                        &lt;targetPath /&gt;
                        &lt;filtering /&gt;
                        &lt;directory /&gt;
                        &lt;includes /&gt;
                        &lt;excludes /&gt;
                    &lt;/testResource&gt;
                &lt;/testResources&gt;
                &lt;directory /&gt;
                &lt;finalName /&gt;
                &lt;filters /&gt;
                &lt;pluginManagement&gt;
                    &lt;plugins&gt;
                        &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;
                        &lt;plugin&gt;
                            &lt;groupId /&gt;
                            &lt;artifactId /&gt;
                            &lt;version /&gt;
                            &lt;extensions /&gt;
                            &lt;executions&gt;
                                &lt;execution&gt;
                                    &lt;id /&gt;
                                    &lt;phase /&gt;
                                    &lt;goals /&gt;
                                    &lt;inherited /&gt;
                                    &lt;configuration /&gt;
                                &lt;/execution&gt;
                            &lt;/executions&gt;
                            &lt;dependencies&gt;
                                &lt;!--参见dependencies/dependency元素 --&gt;
                                &lt;dependency&gt;
                                    ......
                                &lt;/dependency&gt;
                            &lt;/dependencies&gt;
                            &lt;goals /&gt;
                            &lt;inherited /&gt;
                            &lt;configuration /&gt;
                        &lt;/plugin&gt;
                    &lt;/plugins&gt;
                &lt;/pluginManagement&gt;
                &lt;plugins&gt;
                    &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;
                    &lt;plugin&gt;
                        &lt;groupId /&gt;
                        &lt;artifactId /&gt;
                        &lt;version /&gt;
                        &lt;extensions /&gt;
                        &lt;executions&gt;
                            &lt;execution&gt;
                                &lt;id /&gt;
                                &lt;phase /&gt;
                                &lt;goals /&gt;
                                &lt;inherited /&gt;
                                &lt;configuration /&gt;
                            &lt;/execution&gt;
                        &lt;/executions&gt;
                        &lt;dependencies&gt;
                            &lt;!--参见dependencies/dependency元素 --&gt;
                            &lt;dependency&gt;
                                ......
                            &lt;/dependency&gt;
                        &lt;/dependencies&gt;
                        &lt;goals /&gt;
                        &lt;inherited /&gt;
                        &lt;configuration /&gt;
                    &lt;/plugin&gt;
                &lt;/plugins&gt;
            &lt;/build&gt;
            &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;
            &lt;modules /&gt;
            &lt;!--发现依赖和扩展的远程仓库列表。 --&gt;
            &lt;repositories&gt;
                &lt;!--参见repositories/repository元素 --&gt;
                &lt;repository&gt;
                    &lt;releases&gt;
                        &lt;enabled /&gt;
                        &lt;updatePolicy /&gt;
                        &lt;checksumPolicy /&gt;
                    &lt;/releases&gt;
                    &lt;snapshots&gt;
                        &lt;enabled /&gt;
                        &lt;updatePolicy /&gt;
                        &lt;checksumPolicy /&gt;
                    &lt;/snapshots&gt;
                    &lt;id /&gt;
                    &lt;name /&gt;
                    &lt;url /&gt;
                    &lt;layout /&gt;
                &lt;/repository&gt;
            &lt;/repositories&gt;
            &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;
            &lt;pluginRepositories&gt;
                &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;
                &lt;pluginRepository&gt;
                    &lt;releases&gt;
                        &lt;enabled /&gt;
                        &lt;updatePolicy /&gt;
                        &lt;checksumPolicy /&gt;
                    &lt;/releases&gt;
                    &lt;snapshots&gt;
                        &lt;enabled /&gt;
                        &lt;updatePolicy /&gt;
                        &lt;checksumPolicy /&gt;
                    &lt;/snapshots&gt;
                    &lt;id /&gt;
                    &lt;name /&gt;
                    &lt;url /&gt;
                    &lt;layout /&gt;
                &lt;/pluginRepository&gt;
            &lt;/pluginRepositories&gt;
            &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;
            &lt;dependencies&gt;
                &lt;!--参见dependencies/dependency元素 --&gt;
                &lt;dependency&gt;
                    ......
                &lt;/dependency&gt;
            &lt;/dependencies&gt;
            &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;
            &lt;reports /&gt;
            &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行&quot;mvn site&quot;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;
            &lt;reporting&gt;
                ......
            &lt;/reporting&gt;
            &lt;!--参见dependencyManagement元素 --&gt;
            &lt;dependencyManagement&gt;
                &lt;dependencies&gt;
                    &lt;!--参见dependencies/dependency元素 --&gt;
                    &lt;dependency&gt;
                        ......
                    &lt;/dependency&gt;
                &lt;/dependencies&gt;
            &lt;/dependencyManagement&gt;
            &lt;!--参见distributionManagement元素 --&gt;
            &lt;distributionManagement&gt;
                ......
            &lt;/distributionManagement&gt;
            &lt;!--参见properties元素 --&gt;
            &lt;properties /&gt;
        &lt;/profile&gt;
    &lt;/profiles&gt;
</code></pre>
<h2 id="模块依赖配置"><a class="header" href="#模块依赖配置">模块依赖配置</a></h2>
<pre><code> &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;
    &lt;modules /&gt;
</code></pre>
<h2 id="项目依赖的远程仓库"><a class="header" href="#项目依赖的远程仓库">项目依赖的远程仓库</a></h2>
<pre><code class="language-xml"> &lt;repositories&gt;
        &lt;!--包含需要连接到远程仓库的信息 --&gt;
        &lt;repository&gt;
            &lt;!--如何处理远程仓库里发布版本的下载 --&gt;
            &lt;releases&gt;
                &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;
                &lt;enabled /&gt;
                &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;
                &lt;updatePolicy /&gt;
                &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;
                &lt;checksumPolicy /&gt;
            &lt;/releases&gt;
            &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 
                策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;
            &lt;snapshots&gt;
                &lt;enabled /&gt;
                &lt;updatePolicy /&gt;
                &lt;checksumPolicy /&gt;
            &lt;/snapshots&gt;
            &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;
            &lt;id&gt;banseon-repository-proxy&lt;/id&gt;
            &lt;!--远程仓库名称 --&gt;
            &lt;name&gt;banseon-repository-proxy&lt;/name&gt;
            &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;
            &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt;
            &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 
                而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;
            &lt;layout&gt;default&lt;/layout&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
</code></pre>
<h2 id="插件的远程仓库"><a class="header" href="#插件的远程仓库">插件的远程仓库</a></h2>
<pre><code class="language-xml">&lt;pluginRepositories&gt;
        &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;
        &lt;pluginRepository&gt;
            ......
        &lt;/pluginRepository&gt;
    &lt;/pluginRepositories&gt;
</code></pre>
<h2 id="项目相关的所有依赖"><a class="header" href="#项目相关的所有依赖">项目相关的所有依赖</a></h2>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;!--依赖的group ID --&gt;
            &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
            &lt;!--依赖的artifact ID --&gt;
            &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt;
            &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;
            &lt;version&gt;3.8.1&lt;/version&gt;
            &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 
                尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;
            &lt;type&gt;jar&lt;/type&gt;
            &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 
                JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;
            &lt;classifier&gt;&lt;/classifier&gt;
            &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath 
                - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 
                - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 --&gt;
            &lt;systemPath&gt;&lt;/systemPath&gt;
            &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
            &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h2 id="使用报表插件产生报表的规范"><a class="header" href="#使用报表插件产生报表的规范">使用报表插件产生报表的规范</a></h2>
<pre><code class="language-xml">&lt;reporting&gt;
        &lt;!--true，则，网站不包括默认的报表。这包括&quot;项目信息&quot;菜单中的报表。 --&gt;
        &lt;excludeDefaults /&gt;
        &lt;!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。 --&gt;
        &lt;outputDirectory /&gt;
        &lt;!--使用的报表插件和他们的配置。 --&gt;
        &lt;plugins&gt;
            &lt;!--plugin元素包含描述报表插件需要的信息 --&gt;
            &lt;plugin&gt;
                &lt;!--报表插件在仓库里的group ID --&gt;
                &lt;groupId /&gt;
                &lt;!--报表插件在仓库里的artifact ID --&gt;
                &lt;artifactId /&gt;
                &lt;!--被使用的报表插件的版本（或版本范围） --&gt;
                &lt;version /&gt;
                &lt;!--任何配置是否被传播到子项目 --&gt;
                &lt;inherited /&gt;
                &lt;!--报表插件的配置 --&gt;
                &lt;configuration /&gt;
                &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;
                &lt;reportSets&gt;
                    &lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;
                    &lt;reportSet&gt;
                        &lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;
                        &lt;id /&gt;
                        &lt;!--产生报表集合时，被使用的报表的配置 --&gt;
                        &lt;configuration /&gt;
                        &lt;!--配置是否被继承到子POMs --&gt;
                        &lt;inherited /&gt;
                        &lt;!--这个集合里使用到哪些报表 --&gt;
                        &lt;reports /&gt;
                    &lt;/reportSet&gt;
                &lt;/reportSets&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/reporting&gt;
</code></pre>
<h2 id="继承自该项目的所有子项目的默认依赖信息"><a class="header" href="#继承自该项目的所有子项目的默认依赖信息">继承自该项目的所有子项目的默认依赖信息</a></h2>
<pre><code class="language-xml">这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息)
如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息
&lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!--参见dependencies/dependency元素 --&gt;
            &lt;dependency&gt;
                ......
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
</code></pre>
<h2 id="项目分发信息"><a class="header" href="#项目分发信息">项目分发信息</a></h2>
<pre><code class="language-xml">&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;
    &lt;distributionManagement&gt;
        &lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;
        &lt;repository&gt;
            &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;
            &lt;uniqueVersion /&gt;
            &lt;id&gt;banseon-maven2&lt;/id&gt;
            &lt;name&gt;banseon maven2&lt;/name&gt;
            &lt;url&gt;file://${basedir}/target/deploy&lt;/url&gt;
            &lt;layout /&gt;
        &lt;/repository&gt;
        &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;
        &lt;snapshotRepository&gt;
            &lt;uniqueVersion /&gt;
            &lt;id&gt;banseon-maven2&lt;/id&gt;
            &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt;
            &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt;
            &lt;layout /&gt;
        &lt;/snapshotRepository&gt;
        &lt;!--部署项目的网站需要的信息 --&gt;
        &lt;site&gt;
            &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;
            &lt;id&gt;banseon-site&lt;/id&gt;
            &lt;!--部署位置的名称 --&gt;
            &lt;name&gt;business api website&lt;/name&gt;
            &lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;
            &lt;url&gt;
                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web
            &lt;/url&gt;
        &lt;/site&gt;
        &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;
        &lt;downloadUrl /&gt;
        &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;
        &lt;relocation&gt;
            &lt;!--构件新的group ID --&gt;
            &lt;groupId /&gt;
            &lt;!--构件新的artifact ID --&gt;
            &lt;artifactId /&gt;
            &lt;!--构件新的版本号 --&gt;
            &lt;version /&gt;
            &lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;
            &lt;message /&gt;
        &lt;/relocation&gt;
        &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 
            Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt;
        &lt;status /&gt;
    &lt;/distributionManagement&gt;
</code></pre>
<pre><code class="language-xml">&lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;
&lt;properties /&gt;
</code></pre>
<h1 id="maven-构建生命周期"><a class="header" href="#maven-构建生命周期">Maven 构建生命周期</a></h1>
<h2 id="典型的项目周期"><a class="header" href="#典型的项目周期">典型的项目周期</a></h2>
<p>一个典型的 Maven 构建（build）生命周期是由以下几个阶段的序列组成的</p>
<table><thead><tr><th style="text-align: left">阶段</th><th style="text-align: left">处理</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">验证 validate</td><td style="text-align: left">验证项目</td><td style="text-align: left">验证项目是否正确且所有必须信息是可用的</td></tr>
<tr><td style="text-align: left">编译 compile</td><td style="text-align: left">执行编译</td><td style="text-align: left">源代码编译在此阶段完成</td></tr>
<tr><td style="text-align: left">测试 Test</td><td style="text-align: left">测试</td><td style="text-align: left">使用适当的单元测试框架（例如JUnit）运行测试。</td></tr>
<tr><td style="text-align: left">包装 package</td><td style="text-align: left">打包</td><td style="text-align: left">创建JAR/WAR包如在 pom.xml 中定义提及的包</td></tr>
<tr><td style="text-align: left">检查 verify</td><td style="text-align: left">检查</td><td style="text-align: left">对集成测试的结果进行检查，以保证质量达标</td></tr>
<tr><td style="text-align: left">安装 install</td><td style="text-align: left">安装</td><td style="text-align: left">安装打包的项目到本地仓库，以供其他项目使用</td></tr>
<tr><td style="text-align: left">部署 deploy</td><td style="text-align: left">部署</td><td style="text-align: left">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td></tr>
</tbody></table>
<h2 id="三个标准的生命周期"><a class="header" href="#三个标准的生命周期">三个标准的生命周期</a></h2>
<ul>
<li><strong>clean</strong>：项目清理的处理</li>
<li><strong>default(或 build)</strong>：项目部署的处理</li>
<li><strong>site</strong>：项目站点文档创建的处理</li>
</ul>
<h2 id="构建阶段由插件目标构成"><a class="header" href="#构建阶段由插件目标构成">构建阶段由插件目标构成</a></h2>
<ol>
<li>
<p>一个插件目标代表一个特定的任务（比构建阶段更为精细）</p>
</li>
<li>
<p>这些目标可能被绑定到多个阶段或者无绑定</p>
</li>
<li>
<p>不绑定到任何构建阶段的目标可以在构建生命周期之外通过直接调用执行</p>
</li>
<li>
<p>这些目标的执行顺序取决于调用目标和构建阶段的顺序</p>
</li>
</ol>
<pre><code>clean 和 pakage 是构建阶段，dependency:copy-dependencies 是目标

mvn clean dependency:copy-dependencies package
</code></pre>
<h2 id="clean-生命周期"><a class="header" href="#clean-生命周期">Clean 生命周期</a></h2>
<ul>
<li>pre-clean：执行一些需要在clean之前完成的工作</li>
<li>clean：移除所有上一次构建生成的文件</li>
<li>post-clean：执行一些需要在clean之后立刻完成的工作</li>
</ul>
<p>在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，如果执行 mvn clean 将运行以下两个生命周期阶段：</p>
<pre><code class="language-xml">当我们执行 mvn post-clean 命令时，Maven 调用 clean 生命周期
pre-clean, clean

如果我们运行 mvn post-clean ，则运行以下三个生命周期阶段：
pre-clean, clean, post-clean
</code></pre>
<ul>
<li>example</li>
</ul>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
   http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;com.companyname.projectgroup&lt;/groupId&gt;
&lt;artifactId&gt;project&lt;/artifactId&gt;
&lt;version&gt;1.0&lt;/version&gt;
&lt;build&gt;
&lt;plugins&gt;
   &lt;plugin&gt;
   &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
   &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
   &lt;version&gt;1.1&lt;/version&gt;
   &lt;executions&gt;
      &lt;execution&gt;
         &lt;id&gt;id.pre-clean&lt;/id&gt;
         &lt;phase&gt;pre-clean&lt;/phase&gt;
         &lt;goals&gt;
            &lt;goal&gt;run&lt;/goal&gt;
         &lt;/goals&gt;
         &lt;configuration&gt;
            &lt;tasks&gt;
               &lt;echo&gt;pre-clean phase&lt;/echo&gt;
            &lt;/tasks&gt;
         &lt;/configuration&gt;
      &lt;/execution&gt;
      &lt;execution&gt;
         &lt;id&gt;id.clean&lt;/id&gt;
         &lt;phase&gt;clean&lt;/phase&gt;
         &lt;goals&gt;
          &lt;goal&gt;run&lt;/goal&gt;
         &lt;/goals&gt;
         &lt;configuration&gt;
            &lt;tasks&gt;
               &lt;echo&gt;clean phase&lt;/echo&gt;
            &lt;/tasks&gt;
         &lt;/configuration&gt;
      &lt;/execution&gt;
      &lt;execution&gt;
         &lt;id&gt;id.post-clean&lt;/id&gt;
         &lt;phase&gt;post-clean&lt;/phase&gt;
         &lt;goals&gt;
            &lt;goal&gt;run&lt;/goal&gt;
         &lt;/goals&gt;
         &lt;configuration&gt;
            &lt;tasks&gt;
               &lt;echo&gt;post-clean phase&lt;/echo&gt;
            &lt;/tasks&gt;
         &lt;/configuration&gt;
      &lt;/execution&gt;
   &lt;/executions&gt;
   &lt;/plugin&gt;
&lt;/plugins&gt;
&lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h2 id="default-build-生命周期"><a class="header" href="#default-build-生命周期">Default (Build) 生命周期</a></h2>
<table><thead><tr><th style="text-align: left">生命周期阶段</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">validate（校验）</td><td style="text-align: left">校验项目是否正确并且所有必要的信息可以完成项目的构建过程。</td></tr>
<tr><td style="text-align: left">initialize（初始化）</td><td style="text-align: left">初始化构建状态，比如设置属性值。</td></tr>
<tr><td style="text-align: left">generate-sources（生成源代码）</td><td style="text-align: left">生成包含在编译阶段中的任何源代码。</td></tr>
<tr><td style="text-align: left">process-sources（处理源代码）</td><td style="text-align: left">处理源代码，比如说，过滤任意值。</td></tr>
<tr><td style="text-align: left">generate-resources（生成资源文件）</td><td style="text-align: left">生成将会包含在项目包中的资源文件。</td></tr>
<tr><td style="text-align: left">process-resources （处理资源文件）</td><td style="text-align: left">复制和处理资源到目标目录，为打包阶段最好准备。</td></tr>
<tr><td style="text-align: left">compile（编译）</td><td style="text-align: left">编译项目的源代码。</td></tr>
<tr><td style="text-align: left">process-classes（处理类文件）</td><td style="text-align: left">处理编译生成的文件，比如说对Java class文件做字节码改善优化。</td></tr>
<tr><td style="text-align: left">generate-test-sources（生成测试源代码）</td><td style="text-align: left">生成包含在编译阶段中的任何测试源代码。</td></tr>
<tr><td style="text-align: left">process-test-sources（处理测试源代码）</td><td style="text-align: left">处理测试源代码，比如说，过滤任意值。</td></tr>
<tr><td style="text-align: left">generate-test-resources（生成测试资源文件）</td><td style="text-align: left">为测试创建资源文件。</td></tr>
<tr><td style="text-align: left">process-test-resources（处理测试资源文件）</td><td style="text-align: left">复制和处理测试资源到目标目录。</td></tr>
<tr><td style="text-align: left">test-compile（编译测试源码）</td><td style="text-align: left">编译测试源代码到测试目标目录.</td></tr>
<tr><td style="text-align: left">process-test-classes（处理测试类文件）</td><td style="text-align: left">处理测试源码编译生成的文件。</td></tr>
<tr><td style="text-align: left">test（测试）</td><td style="text-align: left">使用合适的单元测试框架运行测试（Juint是其中之一）。</td></tr>
<tr><td style="text-align: left">prepare-package（准备打包）</td><td style="text-align: left">在实际打包之前，执行任何的必要的操作为打包做准备。</td></tr>
<tr><td style="text-align: left">package（打包）</td><td style="text-align: left">将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者EAR文件。</td></tr>
<tr><td style="text-align: left">pre-integration-test（集成测试前）</td><td style="text-align: left">在执行集成测试前进行必要的动作。比如说，搭建需要的环境。</td></tr>
<tr><td style="text-align: left">integration-test（集成测试）</td><td style="text-align: left">处理和部署项目到可以运行集成测试环境中。</td></tr>
<tr><td style="text-align: left">post-integration-test（集成测试后）</td><td style="text-align: left">在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境。</td></tr>
<tr><td style="text-align: left">verify （验证）</td><td style="text-align: left">运行任意的检查来验证项目包有效且达到质量标准。</td></tr>
<tr><td style="text-align: left">install（安装）</td><td style="text-align: left">安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖。</td></tr>
<tr><td style="text-align: left">deploy（部署）</td><td style="text-align: left">将最终的项目包复制到远程仓库中与其他开发者和项目共享。</td></tr>
</tbody></table>
<pre><code>mvn clean deploy可以用来干净的构建项目
</code></pre>
<h2 id="site-生命周期"><a class="header" href="#site-生命周期">Site 生命周期</a></h2>
<ul>
<li>pre-site：执行一些需要在生成站点文档之前完成的工作</li>
<li>site：生成项目的站点文档</li>
<li>post-site： 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li>
<li>site-deploy：将生成的站点文档部署到特定的服务器上</li>
</ul>
<h1 id="maven设置多环境"><a class="header" href="#maven设置多环境">maven设置多环境</a></h1>
<p><a href="22.Maven/maven-profile.html">多环境设置</a></p>
<h1 id="maven-仓库"><a class="header" href="#maven-仓库">Maven 仓库</a></h1>
<h2 id="三种类型maven-仓库"><a class="header" href="#三种类型maven-仓库">三种类型Maven 仓库</a></h2>
<ul>
<li>本地（local）</li>
<li>中央（central）</li>
<li>远程（remote）</li>
</ul>
<h2 id="本地仓库"><a class="header" href="#本地仓库">本地仓库</a></h2>
<ul>
<li>
<p>每个用户在自己的用户目录下都有一个路径名为 .m2/respository/ 的仓库目录。</p>
</li>
<li>
<p>要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。</p>
</li>
<li>
<p><code>&lt;localRepository&gt;C:/MyLocalRepository&lt;/localRepository&gt;</code></p>
</li>
</ul>
<h2 id="中央仓库"><a class="header" href="#中央仓库">中央仓库</a></h2>
<ul>
<li>这个仓库由 Maven 社区管理。</li>
<li>不需要配置。</li>
<li>需要通过网络才能访问。</li>
</ul>
<h2 id="远程仓库"><a class="header" href="#远程仓库">远程仓库</a></h2>
<pre><code class="language-xml">   &lt;repositories&gt;
      &lt;repository&gt;
         &lt;id&gt;companyname.lib1&lt;/id&gt;
         &lt;url&gt;http://download.companyname.org/maven2/lib1&lt;/url&gt;
      &lt;/repository&gt;
      &lt;repository&gt;
         &lt;id&gt;companyname.lib2&lt;/id&gt;
         &lt;url&gt;http://download.companyname.org/maven2/lib2&lt;/url&gt;
      &lt;/repository&gt;
   &lt;/repositories&gt;
</code></pre>
<h2 id="maven-依赖搜索顺序"><a class="header" href="#maven-依赖搜索顺序">Maven 依赖搜索顺序</a></h2>
<ul>
<li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li>
<li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li>
<li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li>
<li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li>
</ul>
<pre><code class="language-xml">&lt;repositories&gt;  
        &lt;repository&gt;  
            &lt;id&gt;alimaven&lt;/id&gt;  
            &lt;name&gt;aliyun maven&lt;/name&gt;  
            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  
            &lt;releases&gt;  
                &lt;enabled&gt;true&lt;/enabled&gt;  
            &lt;/releases&gt;  
            &lt;snapshots&gt;  
                &lt;enabled&gt;false&lt;/enabled&gt;  
            &lt;/snapshots&gt;  
        &lt;/repository&gt;  
&lt;/repositories&gt;
</code></pre>
<h1 id="maven-插件"><a class="header" href="#maven-插件">Maven 插件</a></h1>
<p>Maven 生命周期的每一个阶段的具体实现都是由 Maven 插件实现的。</p>
<p>Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven 插件通常被用来：</p>
<ul>
<li>创建 jar 文件</li>
<li>创建 war 文件</li>
<li>编译代码文件</li>
<li>代码单元测试</li>
<li>创建工程文档</li>
<li>创建工程报告</li>
</ul>
<h2 id="插件执行命令"><a class="header" href="#插件执行命令">插件执行命令</a></h2>
<pre><code>mvn [plugin-name]:[goal-name]

mvn compiler:compile
</code></pre>
<h2 id="插件类型"><a class="header" href="#插件类型">插件类型</a></h2>
<table><thead><tr><th style="text-align: left">类型</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">Build plugins</td><td style="text-align: left">在构建时执行，并在 pom.xml 的 元素中配置。</td></tr>
<tr><td style="text-align: left">Reporting plugins</td><td style="text-align: left">在网站生成过程中执行，并在 pom.xml 的 元素中配置。</td></tr>
</tbody></table>
<h2 id="常用插件列表"><a class="header" href="#常用插件列表">常用插件列表</a></h2>
<table><thead><tr><th style="text-align: left">插件</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">clean</td><td style="text-align: left">构建之后清理目标文件。删除目标目录。</td></tr>
<tr><td style="text-align: left">compiler</td><td style="text-align: left">编译 Java 源文件。</td></tr>
<tr><td style="text-align: left">surefile</td><td style="text-align: left">运行 JUnit 单元测试。创建测试报告。</td></tr>
<tr><td style="text-align: left">jar</td><td style="text-align: left">从当前工程中构建 JAR 文件。</td></tr>
<tr><td style="text-align: left">war</td><td style="text-align: left">从当前工程中构建 WAR 文件。</td></tr>
<tr><td style="text-align: left">javadoc</td><td style="text-align: left">为工程生成 Javadoc。</td></tr>
<tr><td style="text-align: left">antrun</td><td style="text-align: left">从构建过程的任意一个阶段中运行一个 ant 任务的集合。</td></tr>
</tbody></table>
<h2 id="插件使用example"><a class="header" href="#插件使用example">插件使用example</a></h2>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
    http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;com.companyname.projectgroup&lt;/groupId&gt;
&lt;artifactId&gt;project&lt;/artifactId&gt;
&lt;version&gt;1.0&lt;/version&gt;
&lt;build&gt;
&lt;plugins&gt;
   &lt;plugin&gt;
   &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
   &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
   &lt;version&gt;1.1&lt;/version&gt;
   &lt;executions&gt;
      &lt;execution&gt;
         &lt;id&gt;id.clean&lt;/id&gt;
         &lt;phase&gt;clean&lt;/phase&gt;
         &lt;goals&gt;
            &lt;goal&gt;run&lt;/goal&gt;
         &lt;/goals&gt;
         &lt;configuration&gt;
            &lt;tasks&gt;
               &lt;echo&gt;clean phase&lt;/echo&gt;
            &lt;/tasks&gt;
         &lt;/configuration&gt;
      &lt;/execution&gt;     
   &lt;/executions&gt;
   &lt;/plugin&gt;
&lt;/plugins&gt;
&lt;/build&gt;
&lt;/project&gt;

</code></pre>
<h1 id="maven-项目模板"><a class="header" href="#maven-项目模板">Maven 项目模板</a></h1>
<p>Maven 使用 archetype(原型) 来创建自定义的项目结构，形成 Maven 项目模板</p>
<pre><code>mvn archetype:generate
按下 Enter 选择默认选项 (6:maven-archetype-quickstart:1.1)

mvn archetype:generate -DgroupId=com.companyname.bank -DartifactId=consumerBanking -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
</code></pre>
<h1 id="maven文档生成"><a class="header" href="#maven文档生成">Maven文档生成</a></h1>
<pre><code class="language-xml"> &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.3&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.7&lt;/version&gt;
&lt;/plugin&gt;
</code></pre>
<p><strong>mvn site</strong> <em>命令时出现</em> <strong>java.lang.NoClassDefFoundError: org/apache/maven/doxia/siterenderer/DocumentContent</strong> <em>的问题， 这是由于 maven-site-plugin 版本过低，升级到 3.3+ 即可。</em></p>
<p>Maven 使用一个名为 <a href="http://maven.apache.org/doxia/index.html">Doxia</a>的文档处理引擎来创建文档，它能将多种格式的源码读取成一种通用的文档模型。要为你的项目撰写文档，你可以将内容写成下面几种常用的，可被 Doxia 转化的格式。</p>
<table><thead><tr><th style="text-align: left">格式名</th><th style="text-align: left">描述</th><th style="text-align: left">参考</th></tr></thead><tbody>
<tr><td style="text-align: left">Apt</td><td style="text-align: left">纯文本文档格式</td><td style="text-align: left">http://maven.apache.org/doxia/references/apt-format.html</td></tr>
<tr><td style="text-align: left">Xdoc</td><td style="text-align: left">Maven 1.x 的一种文档格式</td><td style="text-align: left">http://jakarta.apache.org/site/jakarta-site2.html</td></tr>
<tr><td style="text-align: left">FML</td><td style="text-align: left">FAQ 文档适用</td><td style="text-align: left">http://maven.apache.org/doxia/references/fml-format.html</td></tr>
<tr><td style="text-align: left">XHTML</td><td style="text-align: left">可扩展的 HTML 文档</td><td style="text-align: left">http://en.wikipedia.org/wiki/XHTML</td></tr>
</tbody></table>
<h1 id="maven-快照snapshot"><a class="header" href="#maven-快照snapshot">Maven 快照(SNAPSHOT)</a></h1>
<p>快照是一种特殊的版本，指定了某个当前的开发进度的副本</p>
<p>不同于常规的版本，Maven 每次构建都会在远程仓库中检查新的快照</p>
<p>每次发布更新代码的快照到仓库中，比如说 data-service:1.0-SNAPSHOT 来替代旧的快照 jar 包</p>
<h1 id="自动化构建"><a class="header" href="#自动化构建">自动化构建?</a></h1>
<h1 id="maven自动化部署"><a class="header" href="#maven自动化部署">maven自动化部署</a></h1>
<h2 id="部署的过程包含需如下步骤"><a class="header" href="#部署的过程包含需如下步骤">部署的过程包含需如下步骤：</a></h2>
<ul>
<li>将所的项目代码提交到 SVN 或者代码库中并打上标签。</li>
<li>从 SVN 上下载完整的源代码。</li>
<li>构建应用。</li>
<li>存储构建输出的 WAR 或者 EAR 文件到一个常用的网络位置下。</li>
<li>从网络上获取文件并且部署文件到生产站点上。</li>
<li>更新文档并且更新应用的版本号。</li>
</ul>
<h2 id="解决方案-1"><a class="header" href="#解决方案-1">解决方案</a></h2>
<ul>
<li>使用 Maven 构建和发布项目</li>
<li>使用 SubVersion， 源码仓库来管理源代码</li>
<li>使用远程仓库管理软件（Jfrog或者Nexus） 来管理项目二进制文件。</li>
</ul>
<h2 id="配置案例"><a class="header" href="#配置案例">配置案例</a></h2>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; 
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 
   http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
   &lt;groupId&gt;bus-core-api&lt;/groupId&gt;
   &lt;artifactId&gt;bus-core-api&lt;/artifactId&gt;
   &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
   &lt;packaging&gt;jar&lt;/packaging&gt; 
   &lt;scm&gt;
      &lt;url&gt;http://www.svn.com&lt;/url&gt;
      &lt;connection&gt;scm:svn:http://localhost:8080/svn/jrepo/trunk/
      Framework&lt;/connection&gt;
      &lt;developerConnection&gt;scm:svn:${username}/${password}@localhost:8080:
      common_core_api:1101:code&lt;/developerConnection&gt;
   &lt;/scm&gt;
   &lt;distributionManagement&gt;
      &lt;repository&gt;
         &lt;id&gt;Core-API-Java-Release&lt;/id&gt;
         &lt;name&gt;Release repository&lt;/name&gt;
         &lt;url&gt;http://localhost:8081/nexus/content/repositories/
         Core-Api-Release&lt;/url&gt;
      &lt;/repository&gt;
   &lt;/distributionManagement&gt;
   &lt;build&gt;
      &lt;plugins&gt;
         &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.0-beta-9&lt;/version&gt;
            &lt;configuration&gt;
               &lt;useReleaseProfile&gt;false&lt;/useReleaseProfile&gt;
               &lt;goals&gt;deploy&lt;/goals&gt;
               &lt;scmCommentPrefix&gt;[bus-core-api-release-checkin]-&lt;
               /scmCommentPrefix&gt;
            &lt;/configuration&gt;
         &lt;/plugin&gt;
      &lt;/plugins&gt;
   &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<table><thead><tr><th style="text-align: left">元素节点</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">SCM</td><td style="text-align: left">配置 SVN 的路径，Maven 将从该路径下将代码取下来。</td></tr>
<tr><td style="text-align: left">repository</td><td style="text-align: left">构建的 WAR 或 EAR 或JAR 文件的位置，或者其他源码构建成功后生成的构件的存储位置。</td></tr>
<tr><td style="text-align: left">Plugin</td><td style="text-align: left">配置 maven-release-plugin 插件来实现自动部署过程。</td></tr>
</tbody></table>
<h2 id="maven-release-插件"><a class="header" href="#maven-release-插件">Maven Release 插件</a></h2>
<pre><code>mvn release:clean
mvn release:rollback
</code></pre>
<p>mvn release:prepare 执行多种操作：</p>
<ul>
<li>检查本地是否存在还未提交的修改</li>
<li>确保没有快照的依赖</li>
<li>改变应用程序的版本信息用以发布</li>
<li>更新 POM 文件到 SVN</li>
<li>运行测试用例</li>
<li>提交修改后的 POM 文件</li>
<li>为代码在 SVN 上做标记</li>
<li>增加版本号和附加快照以备将来发布</li>
<li>提交修改后的 POM 文件到 SVN</li>
</ul>
<pre><code>mvn release:perform
将代码切换到之前做标记的地方，运行 Maven 部署目标来部署 WAR 文件或者构建相应的结构到仓库里。

</code></pre>
<h1 id="maven使用案例"><a class="header" href="#maven使用案例">maven使用案例</a></h1>
<h2 id="maven配置-mybatis--逆向工程"><a class="header" href="#maven配置-mybatis--逆向工程"><em>maven</em>配置 <em>mybatis</em>  逆向工程</a></h2>
<pre><code>&lt;finalName&gt;ase&lt;/finalName&gt;
&lt;plugin&gt;
                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.3.2&lt;/version&gt;
                   &lt;configuration&gt;
                    &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt;
                    &lt;verbose&gt;true&lt;/verbose&gt;
                    &lt;overwrite&gt;true&lt;/overwrite&gt;
                &lt;/configuration&gt;

                &lt;dependencies&gt;
                    &lt;dependency&gt;
                        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
                        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;
                        &lt;version&gt;1.3.2&lt;/version&gt;
                    &lt;/dependency&gt;
                    &lt;dependency&gt;
                        &lt;groupId&gt;mysql&lt;/groupId&gt;
                        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                        &lt;version&gt;${mysql-connector-java.version}&lt;/version&gt;&lt;!--$NO-MVN-MAN-VER$--&gt;
                    &lt;/dependency&gt;
                &lt;/dependencies&gt;
&lt;/plugin&gt;
</code></pre>
<p>不要压制所有注释</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;


&lt;generatorConfiguration&gt;
    &lt;context id=&quot;default&quot; targetRuntime=&quot;MyBatis3&quot;&gt;

        &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;/&gt;
        &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot; /&gt;
        &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt;
        &lt;commentGenerator&gt;
            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;
            &lt;!-- &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;--&gt;
            &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;
            &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot;/&gt;
        &lt;/commentGenerator&gt;

        &lt;!--jdbc的数据库连接，直接写死也可以 --&gt;
        &lt;jdbcConnection
                userId=&quot;root&quot;
                connectionURL=&quot;jdbc:mysql://localhost:3306/myapp?characterEncoding=utf-8&amp;amp;serverTimezone=UTC&amp;amp;useSSL=false&quot;
                driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;
                password=&quot;root&quot;
        &gt;
        &lt;/jdbcConnection&gt;

        &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt;
        &lt;javaTypeResolver&gt;
            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;useJSR310Types&quot; value=&quot;true&quot;/&gt;
        &lt;/javaTypeResolver&gt;


        &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类
            targetPackage     指定生成的model生成所在的包名
            targetProject     指定在该项目下所在的路径
        --&gt;
        &lt;javaModelGenerator targetPackage=&quot;com.weisanju.web.orm.entity&quot; targetProject=&quot;src/main/java&quot;&gt;
            &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;
            &lt;!-- 是否对model添加 构造函数 --&gt;
            &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;
            &lt;!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 --&gt;
            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;
            &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;
            &lt;property name=&quot;trimStrings&quot; value=&quot;false&quot;/&gt;
        &lt;/javaModelGenerator&gt;

        &lt;!--mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;xml&quot; targetProject=&quot;src/main/resources&quot;&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;
        &lt;/sqlMapGenerator&gt;

        &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码
                type=&quot;ANNOTATEDMAPPER&quot;,生成Java Model 和基于注解的Mapper对象
                type=&quot;MIXEDMAPPER&quot;,生成基于注解的Java Model 和相应的Mapper对象
                type=&quot;XMLMAPPER&quot;,生成SQLMap XML文件和独立的Mapper接口
        --&gt;

        &lt;!-- targetPackage：mapper接口dao生成的位置 --&gt;
        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.weisanju.web.orm.mapper&quot; targetProject=&quot;src/main/java&quot;&gt;
            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;
        &lt;/javaClientGenerator&gt;


        &lt;table  tableName=&quot;h3c_schedule_data&quot;
                domainObjectName=&quot;H3cScheduleData&quot;
                enableCountByExample=&quot;true&quot;
                enableUpdateByExample=&quot;true&quot;
                enableDeleteByExample=&quot;true&quot;
                enableSelectByExample=&quot;true&quot;
                selectByExampleQueryId=&quot;true&quot;&gt;
            &lt;!-- 上面的属性都可以使用子标签形式表示 --&gt;
            &lt;!-- 是否使用真实字段名，设置为false将自动驼峰转换 --&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot; /&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
            &lt;!-- 还可以对表中的字段进行类型转换 --&gt;
            &lt;!-- 这里转换的原因是会自动将个位的int值自动转化为Boolean，所以指定为Integer --&gt;
            &lt;!--   &lt;columnOverride column=&quot;sex&quot; javaType=&quot;Integer&quot;/&gt;--&gt;
        &lt;/table&gt;
        &lt;!--
                &lt;table tableName=&quot;tb_item&quot; domainObjectName=&quot;Item&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;
                &lt;table tableName=&quot;tb_order&quot; domainObjectName=&quot;Order&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;
                &lt;table tableName=&quot;tb_orderdetail&quot; domainObjectName=&quot;OrderDetail&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;

        --&gt;

        &lt;!-- geelynote mybatis插件的搭建 --&gt;
    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<h2 id="maven多模块配置"><a class="header" href="#maven多模块配置">maven多模块配置</a></h2>
<pre><code>父模块指定子模块
	&lt;modules&gt;
		&lt;module&gt;xxl-job-core&lt;/module&gt;
		&lt;module&gt;xxl-job-admin&lt;/module&gt;
		&lt;module&gt;xxl-job-executor-samples&lt;/module&gt;
    &lt;/modules&gt;
子模块指定父模块
	&lt;parent&gt;
		&lt;groupId&gt;com.xuxueli&lt;/groupId&gt;
		&lt;artifactId&gt;xxl-job&lt;/artifactId&gt;
		&lt;version&gt;2.2.1-SNAPSHOT&lt;/version&gt;
	&lt;/parent&gt;
</code></pre>
<h2 id="maven中的dependencymanagement"><a class="header" href="#maven中的dependencymanagement">Maven中的dependencyManagement</a></h2>
<pre><code>//只是对版本进行管理，不会实际引入jar  
&lt;dependencyManagement&gt;  
      &lt;dependencies&gt;  
            &lt;dependency&gt;  
                &lt;groupId&gt;org.springframework&lt;/groupId&gt;  
                &lt;artifactId&gt;spring-core&lt;/artifactId&gt;  
                &lt;version&gt;3.2.7&lt;/version&gt;  
            &lt;/dependency&gt;  
    &lt;/dependencies&gt;  
&lt;/dependencyManagement&gt;  
  
//会实际下载jar包  
&lt;dependencies&gt;  
       &lt;dependency&gt;  
                &lt;groupId&gt;org.springframework&lt;/groupId&gt;  
                &lt;artifactId&gt;spring-core&lt;/artifactId&gt;  
       &lt;/dependency&gt;  
&lt;/dependencies&gt;  
</code></pre>
<h2 id="maven编译-java源码等级"><a class="header" href="#maven编译-java源码等级">maven编译 java源码等级</a></h2>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.3&lt;/version&gt;
            &lt;configuration&gt;
                &lt;source&gt;1.8&lt;/source&gt;
                &lt;target&gt;1.8&lt;/target&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<h2 id="maven运行本地模板"><a class="header" href="#maven运行本地模板">maven运行本地模板</a></h2>
<p>运行 MVN 命令的时候加上 <strong>-DarchetypeCatalog=local</strong> 这个参数。在 IDEA 中：</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-10"><a class="header" href="#简介-10">简介</a></h1>
<ul>
<li>
<p>Maven Resources Plugin是帮助处理项目资源文件 copy到 输出目录的插件</p>
</li>
<li>
<p>有两种不同的资源: JavaCode相关联的资源,TestCode相关联的资源 </p>
</li>
<li>
<p>从 2.3开始,使用 the <a href="http://maven.apache.org/shared/maven-filtering/">Maven Filtering</a> shared component for filtering resources.</p>
</li>
</ul>
<h1 id="总览"><a class="header" href="#总览">总览</a></h1>
<p>有三种处理资源的方式</p>
<ul>
<li><a href="http://maven.apache.org/plugins/maven-resources-plugin/resources-mojo.html">resources:resources</a>
<ul>
<li>JavaMainCode资源 copy到主输出路径</li>
<li>会自动执行,因为绑定到了默认 process-resources (资源处理)生命周期阶段</li>
<li>通常使用 project.build.resources 指定资源</li>
<li>project.build.outputDirectory 作为输出路径</li>
</ul>
</li>
<li><a href="http://maven.apache.org/plugins/maven-resources-plugin/testResources-mojo.html">resources:testResources</a> 
<ul>
<li>拷贝test资源 到test输出路径</li>
<li>默认会加载因为 绑定到了 process-test-resources 生命周期处理 阶段</li>
<li>使用 project.build.testResources  指定资源</li>
<li>project.build.testOutputDirectory 指定输出目录</li>
</ul>
</li>
<li><a href="http://maven.apache.org/plugins/maven-resources-plugin/copy-resources-mojo.html">resources:copy-resources</a> 
<ul>
<li>copy任意目标 到任意目录</li>
<li>需要指定资源 和目标目录</li>
</ul>
</li>
</ul>
<h1 id="使用实例"><a class="header" href="#使用实例">使用实例</a></h1>
<h2 id="specifying-a-character-encoding-scheme"><a class="header" href="#specifying-a-character-encoding-scheme">Specifying a character encoding scheme</a></h2>
<p>统一指定为读写资源文件 指定字符编码格式</p>
<pre><code class="language-xml">&lt;properties&gt;
   &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
   ...
 &lt;/properties&gt;
</code></pre>
<p>特定任务指定</p>
<pre><code class="language-xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.1.0&lt;/version&gt;
        &lt;configuration&gt;
          ...
          &lt;encoding&gt;UTF-8&lt;/encoding&gt;
          ...
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
    ...
  &lt;/build&gt;
  ...
&lt;/project&gt;
</code></pre>
<h2 id="specifying-resource-directories"><a class="header" href="#specifying-resource-directories">Specifying resource directories</a></h2>
<p>指定资源路径</p>
<pre><code class="language-xml">&lt;project&gt;
 ...
 &lt;build&gt;
   ...
   &lt;resources&gt;
     &lt;resource&gt;
       &lt;directory&gt;[your folder here]&lt;/directory&gt;
     &lt;/resource&gt;
   &lt;/resources&gt;
   ...
 &lt;/build&gt;
 ...
&lt;/project&gt;


---

   &lt;resources&gt;
     &lt;resource&gt;
       &lt;directory&gt;src/my-resources&lt;/directory&gt;
     &lt;/resource&gt;
   &lt;/resources&gt;


 ...指定目录
   &lt;resources&gt;
     &lt;resource&gt;
       &lt;directory&gt;resource1&lt;/directory&gt;
     &lt;/resource&gt;
     &lt;resource&gt;
       &lt;directory&gt;resource2&lt;/directory&gt;
     &lt;/resource&gt;
     &lt;resource&gt;
       &lt;directory&gt;resource3&lt;/directory&gt;
     &lt;/resource&gt;
   &lt;/resources&gt;
   ...
</code></pre>
<h2 id="filtering"><a class="header" href="#filtering">Filtering</a></h2>
<ul>
<li>
<p>针对maven有的变量 对 资源文件的占位符替换</p>
</li>
<li>
<p>或者使用环境变量</p>
</li>
</ul>
<pre><code>Hello ${name}
mvn resources:resources
mvn resources:resources -Dname=&quot;world&quot;
</code></pre>
<ul>
<li>
<p>指定 可替换的资源文件</p>
<pre><code class="language-xml">&lt;project&gt;
  ...
  &lt;name&gt;My Resources Plugin Practice Project&lt;/name&gt;
  ...
  &lt;build&gt;
    ...
    &lt;filters&gt;
      &lt;filter&gt;[a filter property]&lt;/filter&gt;
    &lt;/filters&gt;
    ...
  &lt;/build&gt;
  ...
&lt;/project&gt;

   ...
    &lt;filters&gt;
      &lt;filter&gt;my-filter-values.properties&lt;/filter&gt;
    &lt;/filters&gt;
    ...

 &lt;build&gt;
    ...
    &lt;resources&gt;
      &lt;resource&gt;
        &lt;directory&gt;src/main/resources-filtered&lt;/directory&gt;
        &lt;filtering&gt;true&lt;/filtering&gt;
      &lt;/resource&gt;
      ...
    &lt;/resources&gt;
    ...
  &lt;/build&gt;
</code></pre>
</li>
</ul>
<p>配置解析转义符</p>
<pre><code class="language-xml"> &lt;configuration&gt;
          ...
          &lt;escapeString&gt;\&lt;/escapeString&gt;
          ...
        &lt;/configuration&gt;
</code></pre>
<h2 id="包含和排除"><a class="header" href="#包含和排除">包含和排除</a></h2>
<p>包含</p>
<pre><code class="language-xml">&lt;build&gt;
    ...
    &lt;resources&gt;
      &lt;resource&gt;
        &lt;directory&gt;[your directory]&lt;/directory&gt;
        &lt;includes&gt;
          &lt;include&gt;[resource file #1]&lt;/include&gt;
          &lt;include&gt;[resource file #2]&lt;/include&gt;
          &lt;include&gt;[resource file #3]&lt;/include&gt;
          ...
          &lt;include&gt;[resource file #n]&lt;/include&gt;
        &lt;/includes&gt;
      &lt;/resource&gt;
      ...
    &lt;/resources&gt;
    ...
  &lt;/build&gt;
</code></pre>
<p>排除</p>
<pre><code class="language-xml">&lt;build&gt;
    ...
    &lt;resources&gt;
      &lt;resource&gt;
        &lt;directory&gt;[your directory]&lt;/directory&gt;
        &lt;excludes&gt;
          &lt;exclude&gt;[non-resource file #1]&lt;/exclude&gt;
          &lt;exclude&gt;[non-resource file #2]&lt;/exclude&gt;
          &lt;exclude&gt;[non-resource file #3]&lt;/exclude&gt;
          ...
          &lt;exclude&gt;[non-resource file #n]&lt;/exclude&gt;
        &lt;/excludes&gt;
      &lt;/resource&gt;
      ...
    &lt;/resources&gt;
    ...
  &lt;/build&gt;
</code></pre>
<p>排除该目录下的所有文件</p>
<pre><code class="language-xml">&lt;project&gt;
  ...
  &lt;name&gt;My Resources Plugin Practice Project&lt;/name&gt;
  ...
  &lt;build&gt;
    ...
    &lt;resources&gt;
      &lt;resource&gt;
        &lt;directory&gt;src/my-resources&lt;/directory&gt;
        &lt;excludes&gt;
          &lt;exclude&gt;**/*.bmp&lt;/exclude&gt;
          &lt;exclude&gt;**/*.jpg&lt;/exclude&gt;
          &lt;exclude&gt;**/*.jpeg&lt;/exclude&gt;
          &lt;exclude&gt;**/*.gif&lt;/exclude&gt;
        &lt;/excludes&gt;
      &lt;/resource&gt;
      ...
    &lt;/resources&gt;
    ...
  &lt;/build&gt;
  ...
&lt;/project&gt;
</code></pre>
<h2 id="copy-resources"><a class="header" href="#copy-resources">Copy Resources</a></h2>
<pre><code class="language-xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.1.0&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;copy-resources&lt;/id&gt;
            &lt;!-- here the phase you need --&gt;
            &lt;phase&gt;validate&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;copy-resources&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;outputDirectory&gt;${basedir}/target/extra-resources&lt;/outputDirectory&gt;
              &lt;resources&gt;          
                &lt;resource&gt;
                  &lt;directory&gt;src/non-packaged-resources&lt;/directory&gt;
                  &lt;filtering&gt;true&lt;/filtering&gt;
                &lt;/resource&gt;
              &lt;/resources&gt;              
            &lt;/configuration&gt;            
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
    ...
  &lt;/build&gt;
  ...
&lt;/project&gt;
</code></pre>
<h2 id="binary-filtering"><a class="header" href="#binary-filtering">Binary filtering</a></h2>
<pre><code class="language-xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.1.0&lt;/version&gt;
        &lt;configuration&gt;
          ...
          &lt;nonFilteredFileExtensions&gt;
            &lt;nonFilteredFileExtension&gt;pdf&lt;/nonFilteredFileExtension&gt;
            &lt;nonFilteredFileExtension&gt;swf&lt;/nonFilteredFileExtension&gt;
          &lt;/nonFilteredFileExtensions&gt;
          ...
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
    ...
  &lt;/build&gt;
  ...
&lt;/project&gt;
</code></pre>
<h2 id="自定义解析过滤器"><a class="header" href="#自定义解析过滤器">自定义解析过滤器</a></h2>
<pre><code class="language-xml">实现该类
public class ItFilter
    implements MavenResourcesFiltering
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apache-maven-archiver"><a class="header" href="#apache-maven-archiver">Apache Maven Archiver</a></h1>
<p>Maven Archiver主要由插件使用以处理打包。</p>
<p><a href="http://maven.apache.org/shared/maven-archiver/index.html">详见</a></p>
<h2 id="archive示例配置"><a class="header" href="#archive示例配置">archive示例配置</a></h2>
<pre><code class="language-xml">&lt;archive&gt;
  &lt;addMavenDescriptor/&gt;
  &lt;compress/&gt;
  &lt;forced/&gt;
  &lt;index/&gt;
  &lt;pomPropertiesFile/&gt;
 
  &lt;manifestFile/&gt;
  &lt;manifest&gt;
    &lt;addClasspath/&gt;
    &lt;addDefaultEntries/&gt;
    &lt;addDefaultImplementationEntries/&gt;
    &lt;addDefaultSpecificationEntries/&gt;
    &lt;addBuildEnvironmentEntries/&gt;
    &lt;addExtensions/&gt;
    &lt;classpathLayoutType/&gt;
    &lt;classpathPrefix/&gt;
    &lt;customClasspathLayout/&gt;
    &lt;mainClass/&gt;
    &lt;packageName/&gt;
    &lt;useUniqueVersions/&gt;
  &lt;/manifest&gt;
  &lt;manifestEntries&gt;
    &lt;key&gt;value&lt;/key&gt;
  &lt;/manifestEntries&gt;
  &lt;manifestSections&gt;
    &lt;manifestSection&gt;
      &lt;name/&gt;
      &lt;manifestEntries&gt;
        &lt;key&gt;value&lt;/key&gt;
      &lt;/manifestEntries&gt;
    &lt;manifestSection/&gt;
  &lt;/manifestSections&gt;
&lt;/archive&gt;
</code></pre>
<h2 id="archive元素"><a class="header" href="#archive元素">archive元素</a></h2>
<blockquote>
<p>since的版本 是 Maven Archiver component 的版本，而不是plugin的版本</p>
</blockquote>
<table><thead><tr><th style="text-align: left">Element</th><th style="text-align: left">Description</th><th style="text-align: left">Type</th><th>默认值</th><th style="text-align: left">Since</th></tr></thead><tbody>
<tr><td style="text-align: left">addMavenDescriptor</td><td style="text-align: left">是否包含两个文件: <code>META-INF/maven/${groupId}/${artifactId}/pom.xml</code> <a href="http://maven.apache.org/shared/maven-archiver/index.html#pom-properties-content">pom.properties</a> file, located in the archive in <code>META-INF/maven/${groupId}/${artifactId}/pom.properties</code></td><td style="text-align: left">boolean</td><td><em>true</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">compress</td><td style="text-align: left">是由启用压缩</td><td style="text-align: left">boolean</td><td><em>true</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">forced</td><td style="text-align: left">是否强制重新创建存档（默认），<em>false</em>意味着应将包含文件的时间戳与目标存档文件的存档时间戳进行比较，只有时间戳更新过了才会更新存档. 特别是，不会检测到源文件的删除.</td><td style="text-align: left">boolean</td><td><em>true</em></td><td style="text-align: left">2.2</td></tr>
<tr><td style="text-align: left">index</td><td style="text-align: left">创建的档案是否将包含一个“ INDEX.LIST”文件。</td><td style="text-align: left">boolean</td><td><em>false</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">pomPropertiesFile</td><td style="text-align: left">使用这个文件覆盖自动生成的 <a href="http://maven.apache.org/shared/maven-archiver/index.html#pom-properties-content">pom.properties</a> file (only if <code>addMavenDescriptor</code> is set to <code>true</code>)</td><td style="text-align: left">File</td><td></td><td style="text-align: left">2.3</td></tr>
<tr><td style="text-align: left">manifestFile</td><td style="text-align: left">自定义 manifest文件</td><td style="text-align: left">File</td><td></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><a href="http://maven.apache.org/shared/maven-archiver/index.html#class_manifest">manifest</a></td><td style="text-align: left"></td><td style="text-align: left"></td><td></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">manifestEntries</td><td style="text-align: left">A list of key/value pairs to add to the manifest.</td><td style="text-align: left">Map</td><td></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><a href="http://maven.apache.org/shared/maven-archiver/index.html#class_manifestSection">manifestSections</a></td><td style="text-align: left"></td><td style="text-align: left"></td><td></td><td style="text-align: left"></td></tr>
</tbody></table>
<h2 id="pomproperties-content"><a class="header" href="#pomproperties-content">pom.properties content</a></h2>
<p>自动创建的<code>pom.properties</code>文件将包含以下内容</p>
<pre><code>artifactId=${project.artifactId}
groupId=${project.groupId}
version=${project.version}
</code></pre>
<h2 id="manifest"><a class="header" href="#manifest">manifest</a></h2>
<table><thead><tr><th style="text-align: left">Element</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th><th>默认值</th><th style="text-align: left">Since</th></tr></thead><tbody>
<tr><td style="text-align: left">addClasspath</td><td style="text-align: left">boolean</td><td style="text-align: left">是否创建 <code>Class-Path</code></td><td>true</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">addDefaultEntries</td><td style="text-align: left">boolean</td><td style="text-align: left">默认设置的 entries,<br />Created-By: Maven Archiver ${maven-archiver.version}<br />Build-Jdk-Spec: ${java.specification.version}</td><td>true</td><td style="text-align: left">3.4.0</td></tr>
<tr><td style="text-align: left">addDefaultImplementationEntries</td><td style="text-align: left">boolean</td><td style="text-align: left">是否添加以下<em>entries</em><br />Implementation-Title: ${project.name}<br />Implementation-Version: ${project.version}<br />Implementation-Vendor: ${project.organization.name}</td><td>false</td><td style="text-align: left">2.1 and 2.6</td></tr>
<tr><td style="text-align: left">addDefaultSpecificationEntries</td><td style="text-align: left">boolean</td><td style="text-align: left">是否添加以下<em>entries</em>:<br />Specification-Title: ${project.name}<br />Specification-Version: ${project.artifact.selectedVersion.majorVersion}.​${project.artifact.selectedVersion.minorVersion}<br />Specification-Vendor: ${project.organization.name}</td><td>false</td><td style="text-align: left">2.1</td></tr>
<tr><td style="text-align: left">addBuildEnvironmentEntries</td><td style="text-align: left">boolean</td><td style="text-align: left">是否添加以下<em>entries</em>:<br />Build-Tool: ${maven.build.version}<br />Build-Jdk: ${java.version} (​${java.vendor})<br />Build-Os:  ​${os.name} (​${os.version}; (${os.arch})</td><td>false</td><td style="text-align: left">3.4.0</td></tr>
<tr><td style="text-align: left">addExtensions</td><td style="text-align: left">boolean</td><td style="text-align: left">是否添加以下<em>entries</em><br /><code>Extension-List</code> manifest entry</td><td>false</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">classpathLayoutType</td><td style="text-align: left">String</td><td style="text-align: left">生成 <code>Class-Path</code>的 <em>layoutType</em> 可选: <br /><code>simple</code>, <br /><code>repository</code> (the same as a Maven classpath layout) and <br /><code>custom</code>. If you specify a type of <code>custom</code> you <strong>must</strong> also set <code>customClasspathLayout</code>.</td><td><code>simple</code></td><td style="text-align: left">2.4</td></tr>
<tr><td style="text-align: left">classpathPrefix</td><td style="text-align: left">String</td><td style="text-align: left">A text that will be prefixed to all your <code>Class-Path</code> entries. The default value is <code>&quot;&quot;</code>.</td><td></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">customClasspathLayout</td><td style="text-align: left">String</td><td style="text-align: left">使用<code>custom</code> 的时候指定的表达式，<br />将根据以下与类路径相关的对象的有序列表对表达式进行求值<br />The current Artifact instance, if one exists.<br />The current ArtifactHandler instance from the artifact above</td><td></td><td style="text-align: left">2.4</td></tr>
<tr><td style="text-align: left">mainClass</td><td style="text-align: left">String</td><td style="text-align: left">The <code>Main-Class</code> manifest entry.</td><td></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">packageName</td><td style="text-align: left">String</td><td style="text-align: left">Package manifest entry.</td><td></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">useUniqueVersions</td><td style="text-align: left"></td><td style="text-align: left">是否使用唯一的时间戳快照版本而不是-SNAPSHOT版本。</td><td>true</td><td style="text-align: left"></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maven-assembly-plugin"><a class="header" href="#maven-assembly-plugin">Maven Assembly Plugin</a></h1>
<h2 id="简介-11"><a class="header" href="#简介-11">简介</a></h2>
<p><a href="http://maven.apache.org/plugins/maven-assembly-plugin/index.html">首页</a></p>
<p>Maven的Assembly Plugin使开发人员能够将项目输出组合到一个可分发的存档中，该存档还包含依赖项，模块，站点文档和其他文件。</p>
<p>可以 使用 预制的 装配描述符 轻松构建 装配体</p>
<p>这些描述符处理许多常见的操作，这些描述符处理许多常见的操作，例如将项目的工件和生成的文档打包到[单个zip归档文件，另外，您的项目可以提供自己的descriptor，并可以对依赖项，模块，文件集和单个文件打包在程序集中。</p>
<p>目前，它可以创建以下格式的发行版：-</p>
<ul>
<li>zip</li>
<li>tar</li>
<li>tar.gz (or tgz)</li>
<li>tar.bz2 (or tbz2)</li>
<li>tar.snappy</li>
<li>tar.xz (or txz)</li>
<li>jar</li>
<li>dir</li>
<li>war</li>
<li>以及已为ArchiveManager配置的任何其他格式</li>
</ul>
<p>如果您的项目想要将工件打包在uber-jar中，则Assembly插件仅提供基本支持。
要进行更多控制，请使用[Maven Shade插件]（http://maven.apache.org/plugins/maven-shade-plugin/）。</p>
<p>要在Maven中使用Assembly Plugin，您只需要：</p>
<ul>
<li>选择或编写要使用的 组装描述符文件</li>
<li>在项目的<code>pom.xml</code>中配置程序集插件，然后-</li>
<li><code>mvn assembly:single</code></li>
</ul>
<p>要编写自己的自定义程序集，您需要参考<a href="http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html">程序集描述符格式</a>参考。</p>
<h2 id="what-is-an-assembly"><a class="header" href="#what-is-an-assembly">What is an Assembly?</a></h2>
<p>An &quot;assembly&quot;  是一组文件，目录和依赖项，它们被组合成存档格式并进行分发，例如，假设一个Maven项目定义了一个同时包含控制台应用程序和Swing应用程序的JAR工件。这样的项目可以定义两个“程序集”，将应用程序与一组不同的支持脚本和依赖项集捆绑在一起。
一个程序集将是控制台应用程序的程序集，另一个程序集将是一个捆绑有稍微不同的依赖项的Swing应用程序。</p>
<p>The Assembly Plugin 插件提供了一种描述符格式,该格式允许您定义项目中文件和目录的任意程序集。</p>
<p>如果您的Maven项目包含目录“ src / main / bin”，则可以指示程序集插件将该目录的内容复制到程序集的“ bin”目录中，并更改目录中文件的权限。 
“ bin”目录进入UNIX模式755。用于配置此行为的参数通过<a href="http://maven.apache.org/plugins/maven-assembly-plugin/assembly">程序集描述符</a>提供给程序集插件</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>The main goal in the assembly plugin is the <a href="http://maven.apache.org/plugins/maven-assembly-plugin/single-mojo.html">single</a> goal. It is used to create all assemblies.</p>
<p>For more information about the goals that are available in the Assembly Plugin, see <a href="http://maven.apache.org/plugins/maven-assembly-plugin/plugin-info.html">the plugin documentation page</a>.</p>
<p>assembly plugin 主要目标是<a href="http://maven.apache.org/plugins/maven-assembly-plugin/single-mojo.html">single</a>目标。它用于创建所有程序集。
有关Assembly Plugin中可用目标的更多信息，请参见<a href="http://maven.apache.org/plugins/maven-assembly-plugin/plugin-info.html">插件文档页面</a>。</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h3>
<p>使用预定义的装配体描述符之一，请配置要与<code>&lt;descriptorRefs&gt;</code>
如果要使用自定义程序集描述符，则可以使用  <code>&lt;descriptors&gt; &lt;descriptor&gt;</code> 参数来配置描述符的路径。</p>
<p>请注意，对程序集插件的一次调用 实际上可以从多个描述符生成程序集，从而使您能够最大程度地自定义项目所生成的二进制文件套件。
创建程序集后，使用 project 名称 + assemblyId 名称</p>
<p><strong>jar example</strong></p>
<pre><code class="language-xml">&lt;project&gt;
  [...]
  &lt;build&gt;
    [...]
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;!-- NOTE: We don't need a groupId specification because the group is
             org.apache.maven.plugins ...which is assumed by default.
         --&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.3.0&lt;/version&gt;
        &lt;configuration&gt;
          &lt;descriptorRefs&gt;
            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
          &lt;/descriptorRefs&gt;
        &lt;/configuration&gt;
        [...]
&lt;/project&gt;
</code></pre>
<p>Assembly Plugin允许您一次指定多个描述符引用，以在一次调用中生成多种类型的程序集。
另外，我们在src / assembly目录中创建了一个名为src.xml的自定义程序集描述符</p>
<p><strong>使用文件</strong></p>
<pre><code class="language-xml">&lt;project&gt;
  [...]
  &lt;build&gt;
    [...]
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.3.0&lt;/version&gt;
        &lt;configuration&gt;
          &lt;descriptors&gt;
            &lt;descriptor&gt;src/assembly/src.xml&lt;/descriptor&gt;
          &lt;/descriptors&gt;
        &lt;/configuration&gt;
        [...]
&lt;/project&gt;
</code></pre>
<p><strong>绑定到 构建阶段</strong></p>
<pre><code class="language-xml">&lt;project&gt;
  [...]
  &lt;build&gt;
    [...]
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.3.0&lt;/version&gt;
        &lt;configuration&gt;
          &lt;descriptorRefs&gt;
            &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
          &lt;/descriptorRefs&gt;
        &lt;/configuration&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;make-assembly&lt;/id&gt; &lt;!-- this is used for inheritance merges --&gt;
            &lt;phase&gt;package&lt;/phase&gt; &lt;!-- bind to the packaging phase --&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
      [...]
&lt;/project&gt;
</code></pre>
<h3 id="advanced-configuration"><a class="header" href="#advanced-configuration">Advanced Configuration</a></h3>
<blockquote>
<p>仅jar和war汇编格式支持配置 archiver 元素。</p>
</blockquote>
<p><strong>创建可执行jar</strong></p>
<p>Assembly插件支持配置 <em>archiver</em> 元素，该元素由maven-archiver处理</p>
<pre><code class="language-xml">&lt;project&gt;
  [...]
  &lt;build&gt;
    [...]
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.3.0&lt;/version&gt;
        &lt;configuration&gt;
          [...]
          &lt;archive&gt;
            &lt;manifest&gt;
              &lt;mainClass&gt;org.sample.App&lt;/mainClass&gt;
            &lt;/manifest&gt;
          &lt;/archive&gt;
        &lt;/configuration&gt;
        [...]
      &lt;/plugin&gt;
      [...]
&lt;/project&gt;
</code></pre>
<h3 id="示例配置"><a class="header" href="#示例配置">示例配置</a></h3>
<pre><code class="language-xml">            &lt;plugin&gt;
                //配置插件 artifactId
                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
                //配置执行阶段
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;makeAssembly&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;assembly&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
                //插件配置
                &lt;configuration&gt;
                    &lt;archive&gt;
                        &lt;manifest&gt;
                            &lt;mainClass&gt;MainDemo01&lt;/mainClass&gt;
                        &lt;/manifest&gt;
                    &lt;/archive&gt;
                    //配置描述符文件
                    &lt;descriptors&gt;
                        &lt;descriptor&gt;src/main/resources/assembly.xml&lt;/descriptor&gt;
                        &lt;descriptor&gt;src/main/resources/assembly-copy.xml&lt;/descriptor&gt;
                    &lt;/descriptors&gt;
                    //配置变量替换源文件
                    &lt;filters&gt;
                        &lt;filter&gt;src/main/resources/subsititute.properties&lt;/filter&gt;
                    &lt;/filters&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
</code></pre>
<p><em>archive</em> 标签 详见 </p>
<h2 id="asembly-xml文件"><a class="header" href="#asembly-xml文件">asembly xml文件</a></h2>
<pre><code class="language-xml">&lt;assembly xmlns=&quot;http://maven.apache.org/ASSEMBLY/2.1.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/ASSEMBLY/2.1.0 http://maven.apache.org/xsd/assembly-2.1.0.xsd&quot;&gt;
  &lt;id/&gt;
  &lt;formats/&gt;
  &lt;includeBaseDirectory/&gt;
  &lt;baseDirectory/&gt;
  &lt;includeSiteDirectory/&gt;
  &lt;containerDescriptorHandlers&gt;
    &lt;containerDescriptorHandler&gt;
      &lt;handlerName/&gt;
      &lt;configuration/&gt;
    &lt;/containerDescriptorHandler&gt;
  &lt;/containerDescriptorHandlers&gt;
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;useAllReactorProjects/&gt;
      &lt;includeSubModules/&gt;
      &lt;includes/&gt;
      &lt;excludes/&gt;
      &lt;sources&gt;
        &lt;useDefaultExcludes/&gt;
        &lt;outputDirectory/&gt;
        &lt;includes/&gt;
        &lt;excludes/&gt;
        &lt;fileMode/&gt;
        &lt;directoryMode/&gt;
        &lt;fileSets&gt;
          &lt;fileSet&gt;
            &lt;useDefaultExcludes/&gt;
            &lt;outputDirectory/&gt;
            &lt;includes/&gt;
            &lt;excludes/&gt;
            &lt;fileMode/&gt;
            &lt;directoryMode/&gt;
            &lt;directory/&gt;
            &lt;lineEnding/&gt;
            &lt;filtered/&gt;
            &lt;nonFilteredFileExtensions/&gt;
          &lt;/fileSet&gt;
        &lt;/fileSets&gt;
        &lt;includeModuleDirectory/&gt;
        &lt;excludeSubModuleDirectories/&gt;
        &lt;outputDirectoryMapping/&gt;
      &lt;/sources&gt;
      &lt;binaries&gt;
        &lt;outputDirectory/&gt;
        &lt;includes/&gt;
        &lt;excludes/&gt;
        &lt;fileMode/&gt;
        &lt;directoryMode/&gt;
        &lt;attachmentClassifier/&gt;
        &lt;includeDependencies/&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet&gt;
            &lt;outputDirectory/&gt;
            &lt;includes/&gt;
            &lt;excludes/&gt;
            &lt;fileMode/&gt;
            &lt;directoryMode/&gt;
            &lt;useStrictFiltering/&gt;
            &lt;outputFileNameMapping/&gt;
            &lt;unpack/&gt;
            &lt;unpackOptions&gt;
              &lt;includes/&gt;
              &lt;excludes/&gt;
              &lt;filtered/&gt;
              &lt;nonFilteredFileExtensions/&gt;
              &lt;lineEnding/&gt;
              &lt;useDefaultExcludes/&gt;
              &lt;encoding/&gt;
            &lt;/unpackOptions&gt;
            &lt;scope/&gt;
            &lt;useProjectArtifact/&gt;
            &lt;useProjectAttachments/&gt;
            &lt;useTransitiveDependencies/&gt;
            &lt;useTransitiveFiltering/&gt;
          &lt;/dependencySet&gt;
        &lt;/dependencySets&gt;
        &lt;unpack/&gt;
        &lt;unpackOptions&gt;
          &lt;includes/&gt;
          &lt;excludes/&gt;
          &lt;filtered/&gt;
          &lt;nonFilteredFileExtensions/&gt;
          &lt;lineEnding/&gt;
          &lt;useDefaultExcludes/&gt;
          &lt;encoding/&gt;
        &lt;/unpackOptions&gt;
        &lt;outputFileNameMapping/&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;useDefaultExcludes/&gt;
      &lt;outputDirectory/&gt;
      &lt;includes/&gt;
      &lt;excludes/&gt;
      &lt;fileMode/&gt;
      &lt;directoryMode/&gt;
      &lt;directory/&gt;
      &lt;lineEnding/&gt;
      &lt;filtered/&gt;
      &lt;nonFilteredFileExtensions/&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
  &lt;files&gt;
    &lt;file&gt;
      &lt;source/&gt;
      &lt;sources/&gt;
      &lt;outputDirectory/&gt;
      &lt;destName/&gt;
      &lt;fileMode/&gt;
      &lt;lineEnding/&gt;
      &lt;filtered/&gt;
    &lt;/file&gt;
  &lt;/files&gt;
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory/&gt;
      &lt;includes/&gt;
      &lt;excludes/&gt;
      &lt;fileMode/&gt;
      &lt;directoryMode/&gt;
      &lt;useStrictFiltering/&gt;
      &lt;outputFileNameMapping/&gt;
      &lt;unpack/&gt;
      &lt;unpackOptions&gt;
        &lt;includes/&gt;
        &lt;excludes/&gt;
        &lt;filtered/&gt;
        &lt;nonFilteredFileExtensions/&gt;
        &lt;lineEnding/&gt;
        &lt;useDefaultExcludes/&gt;
        &lt;encoding/&gt;
      &lt;/unpackOptions&gt;
      &lt;scope/&gt;
      &lt;useProjectArtifact/&gt;
      &lt;useProjectAttachments/&gt;
      &lt;useTransitiveDependencies/&gt;
      &lt;useTransitiveFiltering/&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;outputDirectory/&gt;
      &lt;includes/&gt;
      &lt;excludes/&gt;
      &lt;fileMode/&gt;
      &lt;directoryMode/&gt;
      &lt;includeMetadata/&gt;
      &lt;groupVersionAlignments&gt;
        &lt;groupVersionAlignment&gt;
          &lt;id/&gt;
          &lt;version/&gt;
          &lt;excludes/&gt;
        &lt;/groupVersionAlignment&gt;
      &lt;/groupVersionAlignments&gt;
      &lt;scope/&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;
  &lt;componentDescriptors/&gt;
&lt;/assembly&gt;
</code></pre>
<h3 id="通用元素"><a class="header" href="#通用元素">通用元素</a></h3>
<table><thead><tr><th style="text-align: left">Element</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>id</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">用作 产生工件时的文件名后缀</td></tr>
<tr><td style="text-align: left"><code>formats/format*</code></td><td style="text-align: left"><code>List&lt;String&gt;</code></td><td style="text-align: left">支持输出的格式</td></tr>
<tr><td style="text-align: left"><code>includeBaseDirectory</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left">是否包含基目录，true的话默认为  构件的名称作为目录 即 ${project.build.finalName}</td></tr>
<tr><td style="text-align: left"><code>baseDirectory</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">true的话默认为${project.build.finalName}</td></tr>
<tr><td style="text-align: left"><code>includeSiteDirectory</code></td><td style="text-align: left"><code>boolean</code></td><td style="text-align: left">是否构建 siteDirectory <br/><strong>Default</strong>: <code>false</code></td></tr>
<tr><td style="text-align: left"><code>containerDescriptorHandlers/containerDescriptorHandler*</code></td><td style="text-align: left">`List<ContainerDescriptorHandlerConfig></td><td style="text-align: left">一组组件，可从常规存档流中过滤掉各种容器描述符，以便可以对其进行汇总然后添加。</td></tr>
<tr><td style="text-align: left"><code>moduleSets/moduleSet*</code></td><td style="text-align: left"><code>List&lt;ModuleSet&gt;</code></td><td style="text-align: left">模块</td></tr>
<tr><td style="text-align: left"><code>fileSets/fileSet*</code></td><td style="text-align: left"><code>List&lt;FileSet&gt;</code></td><td style="text-align: left">文件集</td></tr>
<tr><td style="text-align: left"><code>files/file*</code></td><td style="text-align: left"><code>List&lt;FileItem&gt;</code></td><td style="text-align: left">包含文件</td></tr>
<tr><td style="text-align: left"><code>dependencySets/dependencySet*</code></td><td style="text-align: left"><code>List&lt;DependencySet&gt;</code></td><td style="text-align: left">依赖</td></tr>
<tr><td style="text-align: left"><code>repositories/repository*</code></td><td style="text-align: left"><code>List&lt;Repository&gt;</code></td><td style="text-align: left">装载依赖使用的仓库</td></tr>
<tr><td style="text-align: left"><code>componentDescriptors/componentDescriptor*</code></td><td style="text-align: left"><code>List&lt;String&gt;</code></td><td style="text-align: left">descriptor xml 可以基于 descriptorRef,也可以指定相对路径</td></tr>
</tbody></table>
<p><a href="http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html">详见</a></p>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<h3 id="添加编译后的输出文件"><a class="header" href="#添加编译后的输出文件">添加编译后的输出文件</a></h3>
<pre><code class="language-xml">    &lt;fileSets&gt;
        &lt;fileSet&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
            &lt;/includes&gt;
            &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
            &lt;filtered&gt;true&lt;/filtered&gt;
        &lt;/fileSet&gt;
        &lt;fileSet&gt;
            &lt;directory&gt;${project.build.outputDirectory}&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.class&lt;/include&gt;
            &lt;/includes&gt;
            &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
        &lt;/fileSet&gt;
    &lt;/fileSets&gt;
</code></pre>
<h3 id="添加资源文件"><a class="header" href="#添加资源文件">添加资源文件</a></h3>
<pre><code class="language-xml">&lt;assembly&gt;

    &lt;id&gt;file-copy&lt;/id&gt;&lt;!-- 配置文件的标识，同时生成的jar包名字会把这个文本包含进去 --&gt;
    &lt;formats&gt;
        &lt;format&gt;jar&lt;/format&gt;&lt;!-- 打包类型，此处为jar --&gt;
    &lt;/formats&gt;


    &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
    &lt;files&gt;
        &lt;file&gt;
            &lt;source&gt;src/main/resources/README.txt&lt;/source&gt;
            &lt;outputDirectory&gt;&lt;/outputDirectory&gt;
            &lt;filtered&gt;true&lt;/filtered&gt;
        &lt;/file&gt;
    &lt;/files&gt;
&lt;/assembly&gt;
</code></pre>
<h3 id="添加项目依赖"><a class="header" href="#添加项目依赖">添加项目依赖</a></h3>
<pre><code class="language-xml">&lt;assembly&gt;

    &lt;id&gt;with-dependence-unpack&lt;/id&gt;&lt;!-- 配置文件的标识，同时生成的jar包名字会把这个文本包含进去 --&gt;
    &lt;formats&gt;
        &lt;format&gt;jar&lt;/format&gt;&lt;!-- 打包类型，此处为jar --&gt;
    &lt;/formats&gt;
    &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
    &lt;dependencySets&gt;
        &lt;dependencySet&gt;
            &lt;unpack&gt;false&lt;/unpack&gt;&lt;!-- 是否解压 --&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;outputDirectory&gt;lib/&lt;/outputDirectory&gt;
        &lt;/dependencySet&gt;
    &lt;/dependencySets&gt;
    &lt;fileSets&gt;
        &lt;fileSet&gt;
            &lt;directory&gt;${project.build.outputDirectory}&lt;/directory&gt;
            &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
        &lt;/fileSet&gt;
    &lt;/fileSets&gt;
&lt;/assembly&gt;
</code></pre>
<h3 id="添加manifest"><a class="header" href="#添加manifest">添加ManiFest</a></h3>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;makeAssembly&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
        &lt;archive&gt;
            &lt;manifest&gt;
                &lt;addClasspath&gt;true&lt;/addClasspath&gt;
                &lt;classpathPrefix&gt;lib&lt;/classpathPrefix&gt;
                &lt;mainClass&gt;MainDemo01&lt;/mainClass&gt;
                &lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt;
            &lt;/manifest&gt;
        &lt;/archive&gt;
        &lt;descriptors&gt;
            &lt;descriptor&gt;src/main/resources/assembly-copy.xml&lt;/descriptor&gt;
        &lt;/descriptors&gt;
        &lt;filters&gt;
            &lt;filter&gt;src/main/resources/subsititute.properties&lt;/filter&gt;
        &lt;/filters&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是bom"><a class="header" href="#什么是bom">什么是BOM</a></h1>
<p><strong>BOM</strong>（Bill of Materials）是由Maven提供的功能,它通过定义一<strong>整套相互兼容</strong>的jar包版本集合，</p>
<p>使用时只需要依赖该BOM文件，即可放心的使用需要的依赖jar包，且<strong>无需再指定版本号</strong>。</p>
<p>BOM的<strong>维护方负责版本升级</strong>，并保证BOM中定义的jar包版本之间的兼容性。</p>
<h1 id="bom作用"><a class="header" href="#bom作用">BOM作用</a></h1>
<p>使用BOM除了可以方便使用者在声明依赖的客户端时<strong>不需要指定版本号</strong>外</p>
<p>最主要的原因是可以<strong>解决依赖冲突</strong>，如考虑以下的依赖场景：</p>
<pre><code>项目A依赖项目B 2.1和  项目C 1.2版本：

项目B 2.1依赖项目 D 1.1版本；

项目C 1.2依赖项目 D 1.3版本；
</code></pre>
<p>在该例中，项目A对于项目D的依赖就会出现冲突，按照maven dependency mediation的规则，最后生效的可能是:项目A中会依赖到项目D1.1版本（就近原则，取决于路径和依赖的先后,和Maven版本有关系）。</p>
<p>在这种情况下，由于项目C依赖1.3版本的项目D，但是在运行时生效的确是1.1版本，</p>
<p>所以在运行时很容易产生问题，如 <strong>NoSuchMethodError</strong>, <strong>ClassNotFoundException</strong>等，</p>
<p>有些jar包冲突定位还是比较难的，这种方式可以节省很多定位此类问题的时间。</p>
<p><strong>Spring、SpringBoot、SpringCloud</strong>自身都采用了此机制来解决第三方包的冲突，</p>
<h1 id="常见官方提供的bom"><a class="header" href="#常见官方提供的bom">常见官方提供的BOM：</a></h1>
<h2 id="resteasy-maven-bom-dependency"><a class="header" href="#resteasy-maven-bom-dependency"><strong>RESTEasy Maven BOM dependency</strong></a></h2>
<pre><code class="language-xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
            &lt;artifactId&gt;resteasy-bom&lt;/artifactId&gt;
            &lt;version&gt;3.0.6.Final&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<h2 id="jboss-maven-bom-dependency"><a class="header" href="#jboss-maven-bom-dependency"><strong>JBOSS Maven BOM dependency</strong></a></h2>
<pre><code class="language-xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.jboss.bom&lt;/groupId&gt;
            &lt;artifactId&gt;jboss-javaee-6.0-with-tools&lt;/artifactId&gt;
            &lt;version&gt;${some.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt; 
</code></pre>
<h2 id="spring-maven-bom-dependency"><a class="header" href="#spring-maven-bom-dependency"><strong>Spring Maven BOM dependency</strong></a></h2>
<pre><code class="language-xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;
            &lt;version&gt;4.0.1.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<h2 id="jersey-maven-bom-dependency"><a class="header" href="#jersey-maven-bom-dependency"><strong>Jersey Maven BOM dependency</strong></a></h2>
<pre><code class="language-xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.glassfish.jersey&lt;/groupId&gt;
            &lt;artifactId&gt;jersey-bom&lt;/artifactId&gt;
            &lt;version&gt;${jersey.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<h2 id="springcloud-springboot-maven-bom-dependency"><a class="header" href="#springcloud-springboot-maven-bom-dependency"><strong>SpringCloud SpringBoot Maven BOM dependency</strong></a></h2>
<pre><code class="language-xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
            &lt;version&gt;2.4.4&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;2020.0.2&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<h1 id="bom是如何解决依赖冲突的"><a class="header" href="#bom是如何解决依赖冲突的">BOM是如何解决依赖冲突的</a></h1>
<h2 id="定义bom"><a class="header" href="#定义bom">定义BOM</a></h2>
<p>BOM本质上是一个普通的POM文件，区别是对于<strong>使用方</strong>而言，生效的只有 <dependencyManagement>这一个部分。</p>
<p>只需要在<code>&lt;dependencyManagement&gt;</code>定义对外发布的客户端版本即可，</p>
<p>比如需要在项目中<strong>统一</strong>所有SpringBoot和SpringCloud的<strong>版本</strong></p>
<p>第一步需要在POM文件中增加两个的官方BOM，</p>
<p>以目前最新稳定的SpringBoot版本为例，使用官方推荐的版本组合比较稳定，一般不会有什么大的问题</p>
<pre><code class="language-xml">&lt;groupId&gt;com.niu.not&lt;/groupId&gt;
&lt;artifactId&gt;niu-dependency&lt;/artifactId&gt;
&lt;version&gt;1.1.1&lt;/version&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;packaging&gt;pom&lt;/packaging&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
            &lt;version&gt;2.4.6&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;2020.0.3&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;
        &lt;artifactId&gt;gson&lt;/artifactId&gt;
        &lt;version&gt;2.8.6&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p><strong>下面的Gson是除了SpringBoot和SpingCloud外需要统一版本的jar</strong></p>
<h2 id="其他工程使用方法"><a class="header" href="#其他工程使用方法">其他工程使用方法</a></h2>
<p>在项目主pom.xml文件中<code>&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;</code>节点下加入BOM的GAV信息如下：</p>
<pre><code class="language-xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.niu.not&lt;/groupId&gt;
            &lt;artifactId&gt;niu-dependency&lt;/artifactId&gt;
            &lt;version&gt;1.1.1&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<p>在需要使用相关JAR包的pom.xml文件中<dependencies></dependencies>节点下引入如下：</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;!--此时用到Spring和Gson都不需要加版本号,会自动引用BOM中提供的版本--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;
        &lt;artifactId&gt;gson&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p><strong>这种设置后，如果项目要求升级Spring版本，只需要在提供方升级验证兼容性，然后修改BOM依赖即可</strong></p>
<p>如果需要使用不同于当前bom中所维护的jar包版本，则加上<version>覆盖即可，如：</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;!--此时用到Spring和Gson都不需要加版本号,会自动引用BOM中提供的版本--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;
        &lt;artifactId&gt;gson&lt;/artifactId&gt;
        &lt;!--会覆盖掉BOM中声明的版本2.8.6，使用自定义版本2.8.2--&gt;
        &lt;version&gt;2.8.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="profile多环境配置"><a class="header" href="#profile多环境配置">profile多环境配置</a></h1>
<h2 id="通过属性激活配置"><a class="header" href="#通过属性激活配置">通过属性激活配置</a></h2>
<pre><code>&lt;profiles&gt;
    &lt;profile&gt;
        &lt;!--本地开发环境--&gt;
        &lt;id&gt;dev&lt;/id&gt;
        &lt;properties&gt;
            &lt;package.environment&gt;dev&lt;/package.environment&gt;
        &lt;/properties&gt;
        &lt;activation&gt;
            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
        &lt;/activation&gt;
    &lt;/profile&gt;
    &lt;profile&gt;
        &lt;!--tb环境--&gt;
        &lt;id&gt;tb&lt;/id&gt;
        &lt;properties&gt;
            &lt;package.environment&gt;tb&lt;/package.environment&gt;
        &lt;/properties&gt;
    &lt;/profile&gt;
&lt;/profiles&gt;
</code></pre>
<h2 id="多数据文件"><a class="header" href="#多数据文件">多数据文件</a></h2>
<pre><code class="language-xml">    &lt;profile&gt;
          &lt;id&gt;test&lt;/id&gt;
          &lt;build&gt;
              &lt;plugins&gt;
                 &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                    &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
                    &lt;version&gt;1.8&lt;/version&gt;
                    &lt;executions&gt;
                       &lt;execution&gt;
                          &lt;phase&gt;test&lt;/phase&gt;
                          &lt;goals&gt;
                             &lt;goal&gt;run&lt;/goal&gt;
                          &lt;/goals&gt;
                          &lt;configuration&gt;
                          &lt;tasks&gt;
                             &lt;echo&gt;Using env.test.properties&lt;/echo&gt;
                             &lt;copy file=&quot;src/main/resources/env.test.properties&quot; tofile=&quot;${project.build.outputDirectory}/env.properties&quot; overwrite=&quot;true&quot;/&gt;
                          &lt;/tasks&gt;
                          &lt;/configuration&gt;
                       &lt;/execution&gt;
                    &lt;/executions&gt;
                 &lt;/plugin&gt;
              &lt;/plugins&gt;
          &lt;/build&gt;
      &lt;/profile&gt;
</code></pre>
<h2 id="通过mvn命令行激活"><a class="header" href="#通过mvn命令行激活">通过mvn命令行激活</a></h2>
<pre><code>mvn test -Ptest
</code></pre>
<h2 id="通过maven设置激活配置文件"><a class="header" href="#通过maven设置激活配置文件">通过Maven设置激活配置文件</a></h2>
<p>配置 setting.xml 文件，增加 <code>&lt;activeProfiles&gt;属性：</code></p>
<pre><code class="language-xml">&lt;settings xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
   http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;
   ...
   &lt;activeProfiles&gt;
      &lt;activeProfile&gt;test&lt;/activeProfile&gt;
   &lt;/activeProfiles&gt;
&lt;/settings&gt;
</code></pre>
<h2 id="通过环境变量激活配置文件"><a class="header" href="#通过环境变量激活配置文件">通过环境变量激活配置文件</a></h2>
<pre><code class="language-xml">mvn test -Denv=test
</code></pre>
<h2 id="通过操作系统激活配置文件"><a class="header" href="#通过操作系统激活配置文件">通过操作系统激活配置文件</a></h2>
<pre><code class="language-xml">&lt;profile&gt;
   &lt;id&gt;test&lt;/id&gt;
   &lt;activation&gt;
      &lt;os&gt;
         &lt;name&gt;Windows XP&lt;/name&gt;
         &lt;family&gt;Windows&lt;/family&gt;
         &lt;arch&gt;x86&lt;/arch&gt;
         &lt;version&gt;5.1.2600&lt;/version&gt;
      &lt;/os&gt;
   &lt;/activation&gt;
&lt;/profile&gt;
</code></pre>
<h2 id="通过文件的存在或者缺失激活配置文件"><a class="header" href="#通过文件的存在或者缺失激活配置文件">通过文件的存在或者缺失激活配置文件</a></h2>
<pre><code>&lt;profile&gt;
   &lt;id&gt;test&lt;/id&gt;
   &lt;activation&gt;
      &lt;file&gt;
         &lt;missing&gt;target/generated-sources/axistools/wsdl2java/
         com/companyname/group&lt;/missing&gt;
      &lt;/file&gt;
   &lt;/activation&gt;
&lt;/profile&gt;
</code></pre>
<h1 id="配置示例"><a class="header" href="#配置示例">配置示例</a></h1>
<h2 id="动态切换配置"><a class="header" href="#动态切换配置">动态切换配置</a></h2>
<pre><code class="language-xml">&lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;repackage&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
                &lt;configuration&gt;
                    &lt;executable&gt;true&lt;/executable&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;

        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources/&lt;/directory&gt;
                &lt;!--打包时先排除掉三个文件夹--&gt;
                &lt;excludes&gt;
                    &lt;exclude&gt;dev/*&lt;/exclude&gt;
                    &lt;exclude&gt;prod/*&lt;/exclude&gt;
                    &lt;exclude&gt;test/*&lt;/exclude&gt;
                &lt;/excludes&gt;
                &lt;includes&gt;
                    &lt;!--如果有其他定义通用文件，需要包含进来--&gt;
                    &lt;!--&lt;include&gt;messages/*&lt;/include&gt;--&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
            &lt;resource&gt;
                &lt;!--这里是关键！ 根据不同的环境，把对应文件夹里的配置文件打包--&gt;
                &lt;directory&gt;src/main/resources/${profiles.active}&lt;/directory&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;

    &lt;profiles&gt;
        &lt;profile&gt;
            &lt;!--不同环境Profile的唯一id--&gt;
            &lt;id&gt;dev&lt;/id&gt;
            &lt;properties&gt;
                &lt;!--profiles.active是自定义的字段，自定义字段可以有多个--&gt;
                &lt;profiles.active&gt;dev&lt;/profiles.active&gt;
            &lt;/properties&gt;
        &lt;/profile&gt;
        &lt;profile&gt;
            &lt;id&gt;prod&lt;/id&gt;
            &lt;properties&gt;
                &lt;profiles.active&gt;prod&lt;/profiles.active&gt;
            &lt;/properties&gt;
            &lt;!--activation用来指定激活方式，可以根据jdk环境，环境变量，文件的存在或缺失--&gt;
            &lt;activation&gt;
                &lt;!--这个字段表示默认激活--&gt;
                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
            &lt;/activation&gt;
        &lt;/profile&gt;
        &lt;profile&gt;
            &lt;id&gt;test&lt;/id&gt;
            &lt;properties&gt;
                &lt;profiles.active&gt;test&lt;/profiles.active&gt;
            &lt;/properties&gt;
        &lt;/profile&gt;
    &lt;/profiles&gt;

</code></pre>
<h2 id="动态切换配置并将配置与包分离"><a class="header" href="#动态切换配置并将配置与包分离">动态切换配置,并将配置与包分离</a></h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.3.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.weisanju&lt;/groupId&gt;
    &lt;artifactId&gt;javaconfig&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;javaconfig&lt;/name&gt;
    &lt;description&gt;javaconfig学习&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;profiles&gt;
        &lt;profile&gt;
            &lt;id&gt;dev&lt;/id&gt;
            &lt;properties&gt;
                &lt;environment&gt;dev&lt;/environment&gt;
            &lt;/properties&gt;
            &lt;activation&gt;
                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
            &lt;/activation&gt;
        &lt;/profile&gt;
        &lt;profile&gt;
            &lt;id&gt;prod&lt;/id&gt;
            &lt;properties&gt;
                &lt;environment&gt;prod&lt;/environment&gt;
            &lt;/properties&gt;
        &lt;/profile&gt;
    &lt;/profiles&gt;
    &lt;build&gt;

        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;excludes&gt;
                    &lt;exclude&gt;**/*&lt;/exclude&gt;
                &lt;/excludes&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;


            &lt;plugin&gt;
                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;copy-resources&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;copy-resources&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;resources&gt;
                                &lt;resource&gt;
                                    &lt;directory&gt;src/main/resources/${environment}&lt;/directory&gt;
                                    &lt;!--&lt;directory&gt;../config&lt;/directory&gt;--&gt;
                                    &lt;filtering&gt;true&lt;/filtering&gt;
                                &lt;/resource&gt;
                            &lt;/resources&gt;
                            &lt;outputDirectory&gt;${project.build.directory}/config&lt;/outputDirectory&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;

    &lt;/build&gt;

&lt;/project&gt;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maven-依赖管理"><a class="header" href="#maven-依赖管理">Maven 依赖管理</a></h1>
<h2 id="可传递性依赖发现"><a class="header" href="#可传递性依赖发现">可传递性依赖发现</a></h2>
<table><thead><tr><th style="text-align: left">功能</th><th style="text-align: left">功能描述</th></tr></thead><tbody>
<tr><td style="text-align: left">依赖调节</td><td style="text-align: left">决定当多个手动创建的版本同时出现时，哪个依赖版本将会被使用。 如果两个依赖版本在依赖树里的深度是一样的时候，第一个被声明的依赖将会被使用。</td></tr>
<tr><td style="text-align: left">依赖管理</td><td style="text-align: left">直接的指定手动创建的某个版本被使用。例如当一个工程 C 在自己的依赖管理模块包含工程 B，即 B 依赖于 A， 那么 A 即可指定在 B 被引用时所使用的版本。</td></tr>
<tr><td style="text-align: left">依赖范围</td><td style="text-align: left">包含在构建过程每个阶段的依赖。scope</td></tr>
<tr><td style="text-align: left">依赖排除</td><td style="text-align: left">任何可传递的依赖都可以通过 &quot;exclusion&quot; 元素被排除在外。举例说明，A 依赖 B， B 依赖 C，因此 A 可以标记 C 为 &quot;被排除的&quot;。</td></tr>
<tr><td style="text-align: left">依赖可选</td><td style="text-align: left">任何可传递的依赖可以被标记为可选的，通过使用 &quot;optional&quot; 元素。例如：A 依赖 B， B 依赖 C。因此，B 可以标记 C 为可选的， 这样 A 就可以不再使用 C。</td></tr>
</tbody></table>
<h2 id="依赖范围"><a class="header" href="#依赖范围">依赖范围</a></h2>
<p>传递依赖发现可以通过使用如下的依赖范围来得到限制：</p>
<table><thead><tr><th style="text-align: left">范围</th><th>标识</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">编译阶段</td><td><em>compiler</em></td><td style="text-align: left">该范围表明相关依赖是只在项目的类路径下有效。默认取值。</td></tr>
<tr><td style="text-align: left">供应阶段</td><td><em>provided</em></td><td style="text-align: left">该范围表明相关依赖是由运行时的 JDK 或者 网络服务器提供的。(运行时由其他提供，例如从网络加载或者被别人依赖时由别人提供<br />在编译测试阶段由自己提供)</td></tr>
<tr><td style="text-align: left">运行阶段</td><td><em>runtime</em></td><td style="text-align: left">该范围表明相关依赖在编译阶段不是必须的，但是在执行阶段是必须的。</td></tr>
<tr><td style="text-align: left">测试阶段</td><td><em>test</em></td><td style="text-align: left">该范围表明相关依赖只在测试编译阶段和执行阶段。</td></tr>
<tr><td style="text-align: left">系统阶段</td><td><em>system</em></td><td style="text-align: left">该范围表明你需要提供一个系统路径的jar包</td></tr>
<tr><td style="text-align: left">导入阶段</td><td><em>import</em></td><td style="text-align: left">该范围只在依赖是一个 pom 里定义的依赖时使用。同时，当前项目的POM 文件的 部分定义的依赖关系可以取代某特定的 POM。</td></tr>
</tbody></table>
<h2 id="依赖范围对于-classpath的影响"><a class="header" href="#依赖范围对于-classpath的影响">依赖范围对于 classpath的影响</a></h2>
<table><thead><tr><th>依赖范围（scope）</th><th>对于编译classpath有效</th><th>对于测试classpath有效</th><th>对于运行时classpath有效</th><th>例子</th></tr></thead><tbody>
<tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td><td>spring-core</td></tr>
<tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>JUnit</td></tr>
<tr><td>provided</td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr>
<tr><td>runtime</td><td>-</td><td>Y</td><td>Y</td><td>JDBC驱动实现</td></tr>
<tr><td>system</td><td>Y</td><td>Y</td><td>-</td><td>本地的，Maven仓库之外的类库文件</td></tr>
</tbody></table>
<h2 id="依赖传递"><a class="header" href="#依赖传递">依赖传递</a></h2>
<table><thead><tr><th>第一依赖范围\第二依赖范围</th><th>compile</th><th>test</th><th>provided</th><th>runtime</th></tr></thead><tbody>
<tr><td>compile</td><td>compile</td><td>N</td><td></td><td></td></tr>
<tr><td>test</td><td></td><td></td><td></td><td></td></tr>
<tr><td>provider</td><td></td><td></td><td></td><td></td></tr>
<tr><td>runtime</td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<h2 id="使用父依赖"><a class="header" href="#使用父依赖">使用父依赖</a></h2>
<p>App-UI-WAR依赖App-core-lib,App-data-lib</p>
<p><strong>app-ui-war的pom文件</strong></p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
   http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
      &lt;groupId&gt;com.companyname.groupname&lt;/groupId&gt;
      &lt;artifactId&gt;App-UI-WAR&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;packaging&gt;war&lt;/packaging&gt;
      &lt;dependencies&gt;
         &lt;dependency&gt;
            &lt;groupId&gt;com.companyname.groupname&lt;/groupId&gt;
            &lt;artifactId&gt;App-Core-lib&lt;/artifactId&gt;
            &lt;version&gt;1.0&lt;/version&gt;
         &lt;/dependency&gt;
      &lt;/dependencies&gt;  
      &lt;dependencies&gt;
         &lt;dependency&gt;
            &lt;groupId&gt;com.companyname.groupname&lt;/groupId&gt;
            &lt;artifactId&gt;App-Data-lib&lt;/artifactId&gt;
            &lt;version&gt;1.0&lt;/version&gt;
         &lt;/dependency&gt;
      &lt;/dependencies&gt;  
&lt;/project&gt;
</code></pre>
<p><strong>App-Core-lib 的 pom.xml</strong> </p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
   http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
      &lt;parent&gt;
         &lt;artifactId&gt;Root&lt;/artifactId&gt;
         &lt;groupId&gt;com.companyname.groupname&lt;/groupId&gt;
         &lt;version&gt;1.0&lt;/version&gt;
      &lt;/parent&gt;
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
      &lt;groupId&gt;com.companyname.groupname&lt;/groupId&gt;
      &lt;artifactId&gt;App-Core-lib&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt; 
      &lt;packaging&gt;jar&lt;/packaging&gt;
&lt;/project&gt;
</code></pre>
<p><strong>App-Data-lib 的 pom.xml</strong> </p>
<pre><code class="language-xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
   http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
      &lt;parent&gt;
         &lt;artifactId&gt;Root&lt;/artifactId&gt;
         &lt;groupId&gt;com.companyname.groupname&lt;/groupId&gt;
         &lt;version&gt;1.0&lt;/version&gt;
      &lt;/parent&gt;
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
      &lt;groupId&gt;com.companyname.groupname&lt;/groupId&gt;
      &lt;artifactId&gt;App-Data-lib&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;   
      &lt;packaging&gt;jar&lt;/packaging&gt;
&lt;/project&gt;
</code></pre>
<p><strong>Root 的 pom.xml 文件代码</strong></p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
   http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
      &lt;groupId&gt;com.companyname.groupname&lt;/groupId&gt;
      &lt;artifactId&gt;Root&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;packaging&gt;pom&lt;/packaging&gt;
      &lt;dependencies&gt;
         &lt;dependency&gt;
            &lt;groupId&gt;com.companyname.groupname1&lt;/groupId&gt;
            &lt;artifactId&gt;Lib1&lt;/artifactId&gt;
            &lt;version&gt;1.0&lt;/version&gt;
         &lt;/dependency&gt;
      &lt;/dependencies&gt;  
      &lt;dependencies&gt;
         &lt;dependency&gt;
            &lt;groupId&gt;com.companyname.groupname2&lt;/groupId&gt;
            &lt;artifactId&gt;Lib2&lt;/artifactId&gt;
            &lt;version&gt;2.1&lt;/version&gt;
         &lt;/dependency&gt;
      &lt;/dependencies&gt;  
      &lt;dependencies&gt;
         &lt;dependency&gt;
            &lt;groupId&gt;com.companyname.groupname3&lt;/groupId&gt;
            &lt;artifactId&gt;Lib3&lt;/artifactId&gt;
            &lt;version&gt;1.1&lt;/version&gt;
         &lt;/dependency&gt;
      &lt;/dependencies&gt;  
&lt;/project&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apache-maven-source-plugin"><a class="header" href="#apache-maven-source-plugin">Apache Maven Source Plugin</a></h1>
<p>source plugin 创建当前项目源文件的 jar 存档</p>
<h1 id="goals-overview"><a class="header" href="#goals-overview">Goals Overview</a></h1>
<p>The Source Plugin has five goals:</p>
<p><strong>source:aggregate</strong>: 在聚合项目的所有模块 中 聚合所有源代码
<strong>source:jar</strong>: 用于将项目的主要来源捆绑到一个jar中
<strong>source:test-jar</strong> :将项目的测试源捆绑到 jar 存档中
<strong>source:jar-no-fork</strong> ：类似于 jar 但不分叉构建生命周期.
<strong>source:test-jar-no-fork</strong> ：类似于 test-jar，但不分叉构建生命周期。.</p>
<h1 id="模板配置"><a class="header" href="#模板配置">模板配置</a></h1>
<pre><code class="language-xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.2.0&lt;/version&gt;
        &lt;configuration&gt;
          &lt;outputDirectory&gt;/absolute/path/to/the/output/directory&lt;/outputDirectory&gt;
          &lt;finalName&gt;filename-of-generated-jar-file&lt;/finalName&gt;
          &lt;attach&gt;false&lt;/attach&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  ...
&lt;/project&gt;
</code></pre>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
    &lt;version&gt;3.2.0&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;attach-sources&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;jar-no-fork&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<p>生成的 jar 文件，如果是主源，会以 finalName 的值加上“-sources”来命名。否则，如果它是测试源，它将是 finalName 加上“-test-sources”。它将在指定的 outputDirectory 中生成。 attach 参数指定 java 源是否将附加到项目的工件列表中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期lifecycle"><a class="header" href="#生命周期lifecycle">生命周期（lifecycle）</a></h1>
<p>Maven的生命周期就是对所有的 <strong>构建过程</strong> 进行抽象和统一。包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有的构建步骤。</p>
<p>Maven 内置的三套生命周期：</p>
<ul>
<li>clean 清理项目</li>
<li>default 构建、发布项目</li>
<li>site 生成项目站点</li>
</ul>
<h1 id="阶段phase"><a class="header" href="#阶段phase">阶段（phase）</a></h1>
<ul>
<li>
<p>阶段是生命周期的组成部分。</p>
</li>
<li>
<p>特点：各个阶段之间 在生命周期内具有顺序性</p>
</li>
<li>
<p>执行生命周期的某个阶段会将该阶段之前的所有 其他阶段执行</p>
</li>
</ul>
<p><strong>clean周期共有3个阶段</strong></p>
<ol>
<li>pre-clean</li>
<li>clean</li>
<li>post-clean</li>
</ol>
<h1 id="插件目标plugingoal"><a class="header" href="#插件目标plugingoal">插件:目标（plugin:goal）</a></h1>
<ul>
<li>
<p><strong>插件与 目标 构成 阶段</strong></p>
</li>
<li>
<p><strong>插件与目标可以单独执行</strong></p>
</li>
<li>
<p>插件可以 绑定到 某个阶段上</p>
</li>
</ul>
<h2 id="clean阶段"><a class="header" href="#clean阶段"><strong>clean阶段</strong></a></h2>
<table><thead><tr><th>顺序</th><th>阶段</th><th>插件:目标</th></tr></thead><tbody>
<tr><td>1</td><td>pre-clean</td><td></td></tr>
<tr><td>2</td><td>clean</td><td>clean:clean</td></tr>
<tr><td>3</td><td>post-clean</td><td></td></tr>
</tbody></table>
<h2 id="default阶段"><a class="header" href="#default阶段"><strong>default阶段</strong></a></h2>
<table><thead><tr><th>顺序</th><th>阶段</th><th>插件:目标</th></tr></thead><tbody>
<tr><td>1</td><td>validate（校验）</td><td></td></tr>
<tr><td>2</td><td>initialize（初始化）</td><td></td></tr>
<tr><td>3</td><td>generate-sources</td><td></td></tr>
<tr><td>4</td><td>process-sources</td><td></td></tr>
<tr><td>5</td><td>generate-resources</td><td></td></tr>
<tr><td>6</td><td>process-resources</td><td>resources:resources</td></tr>
<tr><td>7</td><td>compile</td><td>compiler:compile</td></tr>
<tr><td>8</td><td>process-classes</td><td></td></tr>
<tr><td>9</td><td>generate-test-sources</td><td></td></tr>
<tr><td>10</td><td>process-test-sources</td><td></td></tr>
<tr><td>11</td><td>generate-test-resources</td><td></td></tr>
<tr><td>12</td><td>process-test-resources</td><td>resources:testResources</td></tr>
<tr><td>13</td><td>test-compile</td><td>compiler:testCompile</td></tr>
<tr><td>14</td><td>process-test-classes</td><td></td></tr>
<tr><td>15</td><td>test surefire:test</td><td></td></tr>
<tr><td>16</td><td>prepare-package</td><td></td></tr>
<tr><td>17</td><td>package</td><td></td></tr>
<tr><td>18</td><td>pre-integration-test</td><td></td></tr>
<tr><td>19</td><td>integration-test</td><td></td></tr>
<tr><td>20</td><td>post-integration-test</td><td></td></tr>
<tr><td>21</td><td>verify</td><td></td></tr>
<tr><td>22</td><td>install</td><td>install:install</td></tr>
<tr><td>23</td><td>deploy deploy:deploy</td><td>deploy:deploy</td></tr>
</tbody></table>
<p>生命周期site(4个阶段)</p>
<table><thead><tr><th>顺序</th><th>阶段</th><th>插件:目标</th></tr></thead><tbody>
<tr><td>1</td><td>pre-site</td><td></td></tr>
<tr><td>2</td><td>site</td><td>site:site</td></tr>
<tr><td>3</td><td>post-site</td><td></td></tr>
<tr><td>4</td><td>site-deploy</td><td>site:deploy</td></tr>
</tbody></table>
<h1 id="示例-7"><a class="header" href="#示例-7">示例</a></h1>
<ul>
<li>该插件有两个目标，一个是 flattern,一个是 clean</li>
<li>第一个目标 绑定到  <em>process-resources</em> 阶段上</li>
<li>第二个目标绑定到 <em>clean</em> 阶段上</li>
</ul>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;!-- https://mvnrepository.com/artifact/org.codehaus.mojo/flatten-maven-plugin --&gt;
    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
    &lt;artifactId&gt;flatten-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.2.5&lt;/version&gt;

    &lt;configuration&gt;
        &lt;!--是否更新pom文件，此处还有更高级的用法--&gt;
        &lt;updatePomFile&gt;true&lt;/updatePomFile&gt;
        &lt;flattenMode&gt;resolveCiFriendliesOnly&lt;/flattenMode&gt;
    &lt;/configuration&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;flatten&lt;/id&gt;
            &lt;phase&gt;process-resources&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;flatten&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
        &lt;execution&gt;
            &lt;id&gt;flatten.clean&lt;/id&gt;
            &lt;phase&gt;clean&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;clean&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jar"><a class="header" href="#jar">Jar</a></h1>
<p>打jar包方式这里有两种：</p>
<p>1、将第三方依赖包打成class类放置到jar包。</p>
<p>2、将第三方依赖包打成jar包另外放置。</p>
<h2 id="打成class类放置到jar包"><a class="header" href="#打成class类放置到jar包">打成class类放置到jar包</a></h2>
<pre><code class="language-xml">&lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.4&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;
                    &lt;finalName&gt;searchIndex&lt;/finalName&gt;
                    &lt;descriptorRefs&gt;
&lt;!-- 将依赖的jar包中的class文件打进生成的jar包--&gt;
                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
                    &lt;/descriptorRefs&gt;
                    &lt;archive&gt;
                        &lt;manifest&gt;
                            &lt;addClasspath&gt;true&lt;/addClasspath&gt;
&lt;!-- 有Main函数的类：为了生成的jar包使用命令执行时的入口函数，可灵活增加活删除--&gt;
                            &lt;mainClass&gt;com.yourcompany.yourproject.MainClass&lt;/mainClass&gt;
                        &lt;/manifest&gt;
                    &lt;/archive&gt;
                &lt;/configuration&gt;
    //绑定到生命周期的 package阶段
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;make-assembly&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
&lt;!-- &lt;goal&gt;single&lt;/goal&gt;--&gt;
                            &lt;goal&gt;single&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
</code></pre>
<h2 id="lib依赖-配置-与包分离包另外放置"><a class="header" href="#lib依赖-配置-与包分离包另外放置">lib依赖 配置 与包分离包另外放置</a></h2>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;dispatch&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;!--打包jar--&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;!--不打包资源文件--&gt;
                    &lt;excludes&gt;
                        &lt;exclude&gt;*.**&lt;/exclude&gt;
                        &lt;exclude&gt;*/*.xml&lt;/exclude&gt;
                    &lt;/excludes&gt;
                    &lt;archive&gt;
                        &lt;manifest&gt;
                            &lt;addClasspath&gt;true&lt;/addClasspath&gt;
                            &lt;!--MANIFEST.MF 中 Class-Path 加入前缀--&gt;
                            &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;
                            &lt;!--jar包不包含唯一版本标识--&gt;
                            &lt;useUniqueVersions&gt;false&lt;/useUniqueVersions&gt;
                            &lt;!--指定入口类--&gt;
                            &lt;mainClass&gt;Demo&lt;/mainClass&gt;
                        &lt;/manifest&gt;
                        &lt;manifestEntries&gt;
                            &lt;!--MANIFEST.MF 中 Class-Path 加入资源文件目录--&gt;
                            &lt;Class-Path&gt;./resources/&lt;/Class-Path&gt;
                        &lt;/manifestEntries&gt;
                    &lt;/archive&gt;
                    &lt;outputDirectory&gt;${project.build.directory}&lt;/outputDirectory&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;

            &lt;!--拷贝依赖 copy-dependencies--&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;copy-dependencies&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;copy-dependencies&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;outputDirectory&gt;
                                ${project.build.directory}/lib/
                            &lt;/outputDirectory&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;

            &lt;!--拷贝资源文件 copy-resources--&gt;
            &lt;plugin&gt;
                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;copy-resources&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;copy-resources&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;resources&gt;
                                &lt;resource&gt;
                                    &lt;!--&lt;directory&gt;src/main/resources&lt;/directory&gt;--&gt;
                                    &lt;directory&gt;config&lt;/directory&gt;
                                &lt;/resource&gt;
                            &lt;/resources&gt;
                            &lt;outputDirectory&gt;${project.build.directory}/config&lt;/outputDirectory&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;



            &lt;!--spring boot repackage，依赖 maven-jar-plugin 打包的jar包 重新打包成 spring boot 的jar包--&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;!--重写包含依赖，包含不存在的依赖，jar里没有pom里的依赖--&gt;
                    &lt;includes&gt;
                        &lt;include&gt;
                            &lt;groupId&gt;null&lt;/groupId&gt;
                            &lt;artifactId&gt;null&lt;/artifactId&gt;
                        &lt;/include&gt;
                    &lt;/includes&gt;
                    &lt;layout&gt;ZIP&lt;/layout&gt;
                    &lt;!--使用外部配置文件，jar包里没有资源文件--&gt;
                    &lt;addResources&gt;true&lt;/addResources&gt;
                    &lt;outputDirectory&gt;${project.build.directory}&lt;/outputDirectory&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;repackage&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;!--配置jar包特殊标识 配置后，保留原文件，生成新文件 *-run.jar --&gt;
                            &lt;!--配置jar包特殊标识 不配置，原文件命名为 *.jar.original，生成新文件 *.jar --&gt;
                            &lt;!--&lt;classifier&gt;run&lt;/classifier&gt;--&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maven-ci-friendly-versions"><a class="header" href="#maven-ci-friendly-versions">Maven CI Friendly Versions</a></h1>
<h2 id="介绍-12"><a class="header" href="#介绍-12">介绍</a></h2>
<p>从Maven 3.5.0-beta-1版本开始，可以使用<code>${revision}</code>, <code>${sha1}</code> 和 <code>${changelist}</code>作为占位符来替换pom文件了。</p>
<h2 id="单模块项目配置"><a class="header" href="#单模块项目配置">单模块项目配置</a></h2>
<pre><code class="language-xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.apache&lt;/groupId&gt;
    &lt;artifactId&gt;apache&lt;/artifactId&gt;
    &lt;version&gt;18&lt;/version&gt;
  &lt;/parent&gt;
  &lt;groupId&gt;org.apache.maven.ci&lt;/groupId&gt;
  &lt;artifactId&gt;ci-parent&lt;/artifactId&gt;
  &lt;name&gt;First CI Friendly&lt;/name&gt;
  &lt;version&gt;${revision}&lt;/version&gt;
  ...
&lt;/project&gt;
</code></pre>
<p><strong>使用命令指定版本号</strong></p>
<pre><code class="language-shell">mvn -Drevision=1.0.0-SNAPSHOT clean package
</code></pre>
<p><strong>使用properties</strong></p>
<pre><code class="language-xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.apache&lt;/groupId&gt;
    &lt;artifactId&gt;apache&lt;/artifactId&gt;
    &lt;version&gt;18&lt;/version&gt;
  &lt;/parent&gt;
  &lt;groupId&gt;org.apache.maven.ci&lt;/groupId&gt;
  &lt;artifactId&gt;ci-parent&lt;/artifactId&gt;
  &lt;name&gt;First CI Friendly&lt;/name&gt;
  &lt;version&gt;${revision}&lt;/version&gt;
  ...
  &lt;properties&gt;
    &lt;revision&gt;1.0.0-SNAPSHOT&lt;/revision&gt;
  &lt;/properties&gt;
&lt;/project&gt;
</code></pre>
<p><strong>在配置文件中指定</strong></p>
<pre><code>.mvn/maven.config
</code></pre>
<p><strong>可以组合properties</strong></p>
<pre><code class="language-xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.apache&lt;/groupId&gt;
    &lt;artifactId&gt;apache&lt;/artifactId&gt;
    &lt;version&gt;18&lt;/version&gt;
  &lt;/parent&gt;
  &lt;groupId&gt;org.apache.maven.ci&lt;/groupId&gt;
  &lt;artifactId&gt;ci-parent&lt;/artifactId&gt;
  &lt;name&gt;First CI Friendly&lt;/name&gt;
  &lt;version&gt;${revision}${sha1}${changelist}&lt;/version&gt;
  ...
  &lt;properties&gt;
    &lt;revision&gt;1.3.1&lt;/revision&gt;
    &lt;changelist&gt;-SNAPSHOT&lt;/changelist&gt;
    &lt;sha1/&gt;
  &lt;/properties&gt;
&lt;/project&gt;
</code></pre>
<h2 id="多模块"><a class="header" href="#多模块">多模块</a></h2>
<p><strong>父项目配置</strong></p>
<pre><code class="language-xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.apache&lt;/groupId&gt;
    &lt;artifactId&gt;apache&lt;/artifactId&gt;
    &lt;version&gt;18&lt;/version&gt;
  &lt;/parent&gt;
  &lt;groupId&gt;org.apache.maven.ci&lt;/groupId&gt;
  &lt;artifactId&gt;ci-parent&lt;/artifactId&gt;
  &lt;name&gt;First CI Friendly&lt;/name&gt;
  &lt;version&gt;${revision}&lt;/version&gt;
  ...
  &lt;properties&gt;
    &lt;revision&gt;1.0.0-SNAPSHOT&lt;/revision&gt;
  &lt;/properties&gt;
  &lt;modules&gt;
    &lt;module&gt;child1&lt;/module&gt;
    ..
  &lt;/modules&gt;
&lt;/project&gt;
</code></pre>
<p><strong>子项目配置</strong></p>
<pre><code class="language-xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.apache.maven.ci&lt;/groupId&gt;
    &lt;artifactId&gt;ci-parent&lt;/artifactId&gt;
    &lt;version&gt;${revision}&lt;/version&gt;
  &lt;/parent&gt;
  &lt;groupId&gt;org.apache.maven.ci&lt;/groupId&gt;
  &lt;artifactId&gt;ci-child&lt;/artifactId&gt;
   ...
&lt;/project&gt;
</code></pre>
<p><strong>多项目中的依赖管理</strong></p>
<p>多模块工程结构下，会有很多模块依赖的情况，应该使用${project.version}来定义依赖（同父工程下的依赖）的版本或者使用 <em>dependencyManagement</em> 管理子模块依赖</p>
<p><strong>父项目</strong></p>
<pre><code class="language-java">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.apache&lt;/groupId&gt;
    &lt;artifactId&gt;apache&lt;/artifactId&gt;
    &lt;version&gt;18&lt;/version&gt;
  &lt;/parent&gt;
  &lt;groupId&gt;org.apache.maven.ci&lt;/groupId&gt;
  &lt;artifactId&gt;ci-parent&lt;/artifactId&gt;
  &lt;name&gt;First CI Friendly&lt;/name&gt;
  &lt;version&gt;${revision}&lt;/version&gt;
  ...
  &lt;properties&gt;
    &lt;revision&gt;1.0.0-SNAPSHOT&lt;/revision&gt;
  &lt;/properties&gt;
  &lt;modules&gt;
    &lt;module&gt;child1&lt;/module&gt;
    ..
  &lt;/modules&gt;
&lt;/project&gt;
</code></pre>
<p><strong>子项目依赖另一个子项目</strong></p>
<pre><code class="language-java">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.apache.maven.ci&lt;/groupId&gt;
    &lt;artifactId&gt;ci-parent&lt;/artifactId&gt;
    &lt;version&gt;${revision}&lt;/version&gt;
  &lt;/parent&gt;
  &lt;groupId&gt;org.apache.maven.ci&lt;/groupId&gt;
  &lt;artifactId&gt;ci-child&lt;/artifactId&gt;
   ...
  &lt;dependencies&gt;
		&lt;dependency&gt;
      &lt;groupId&gt;org.apache.maven.ci&lt;/groupId&gt;
      &lt;artifactId&gt;child2&lt;/artifactId&gt;
      &lt;version&gt;${project.version}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p><strong>部署到本地仓库、远程仓库</strong></p>
<pre><code class="language-xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.apache&lt;/groupId&gt;
    &lt;artifactId&gt;apache&lt;/artifactId&gt;
    &lt;version&gt;18&lt;/version&gt;
  &lt;/parent&gt;
  &lt;groupId&gt;org.apache.maven.ci&lt;/groupId&gt;
  &lt;artifactId&gt;ci-parent&lt;/artifactId&gt;
  &lt;name&gt;First CI Friendly&lt;/name&gt;
  &lt;version&gt;${revision}&lt;/version&gt;
  ...
  &lt;properties&gt;
    &lt;revision&gt;1.0.0-SNAPSHOT&lt;/revision&gt;
  &lt;/properties&gt;
 
 &lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
      &lt;artifactId&gt;flatten-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.2.5&lt;/version&gt;
      &lt;configuration&gt;
        &lt;updatePomFile&gt;true&lt;/updatePomFile&gt;
        &lt;flattenMode&gt;resolveCiFriendliesOnly&lt;/flattenMode&gt;
      &lt;/configuration&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;id&gt;flatten&lt;/id&gt;
          &lt;phase&gt;process-resources&lt;/phase&gt;
          &lt;goals&gt;
            &lt;goal&gt;flatten&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
        &lt;execution&gt;
          &lt;id&gt;flatten.clean&lt;/id&gt;
          &lt;phase&gt;clean&lt;/phase&gt;
          &lt;goals&gt;
            &lt;goal&gt;clean&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
  &lt;/build&gt;
  &lt;modules&gt;
    &lt;module&gt;child1&lt;/module&gt;
    ..
  &lt;/modules&gt;
&lt;/project&gt;
</code></pre>
<h1 id="deploy-发布到私服"><a class="header" href="#deploy-发布到私服">deploy 发布到私服</a></h1>
<h2 id="配置发布仓库"><a class="header" href="#配置发布仓库">配置发布仓库</a></h2>
<pre><code class="language-xml">    &lt;!-- 部署module的jar到私有仓库 --&gt;
    &lt;distributionManagement&gt;
        &lt;repository&gt;
            &lt;id&gt;public&lt;/id&gt;
            &lt;name&gt;releases&lt;/name&gt;
            &lt;url&gt;http://ip:port/repository/maven-releases/&lt;/url&gt;
        &lt;/repository&gt;
        &lt;snapshotRepository&gt;
            &lt;id&gt;snapshot&lt;/id&gt;
            &lt;name&gt;snapshot&lt;/name&gt;
            &lt;url&gt;http://ip:port/repository/maven-snapshots/&lt;/url&gt;
        &lt;/snapshotRepository&gt;
    &lt;/distributionManagement&gt;
</code></pre>
<h2 id="配置仓库认证信息"><a class="header" href="#配置仓库认证信息"><strong>配置仓库认证信息</strong></a></h2>
<p>**注意：**次id必须与上述配置的仓库id保持 一致</p>
<pre><code class="language-xml">&lt;server&gt;
    &lt;id&gt;public&lt;/id&gt;
    &lt;username&gt;111&lt;/username&gt;
    &lt;password&gt;111&lt;/password&gt;
&lt;/server&gt;

&lt;server&gt;
    &lt;id&gt;snapshot&lt;/id&gt;
    &lt;username&gt;111&lt;/username&gt;
    &lt;password&gt;111&lt;/password&gt;
&lt;/server&gt;
</code></pre>
<h2 id="统一版本号"><a class="header" href="#统一版本号"><strong>统一版本号</strong></a></h2>
<ul>
<li>
<p>使用 <em>revision</em> 变量统一 各个子模块的版本</p>
</li>
<li>
<p>使用 dependence Manager 在父工程统一管理依赖</p>
</li>
</ul>
<p><strong>定义版本号</strong></p>
<pre><code class="language-xml">&lt;properties&gt;
        &lt;revision&gt;1.0.1-SNAPSHOT&lt;/revision&gt;
&lt;properties&gt;
</code></pre>
<p><strong>定义父POM的版本号</strong></p>
<pre><code class="language-xml">&lt;groupId&gt;com.aiseeding.ase&lt;/groupId&gt;
&lt;artifactId&gt;ase-parent&lt;/artifactId&gt;
&lt;packaging&gt;pom&lt;/packaging&gt;
&lt;version&gt;${revision}&lt;/version&gt;
</code></pre>
<p><strong>定义子POM的版本</strong></p>
<pre><code class="language-xml"> &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.aiseeding.ase&lt;/groupId&gt;
                &lt;artifactId&gt;ase-workflow&lt;/artifactId&gt;
                &lt;version&gt;${revision}&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;com.aiseeding.ase&lt;/groupId&gt;
                &lt;artifactId&gt;ase-message&lt;/artifactId&gt;
                &lt;version&gt;${revision}&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;com.aiseeding.ase&lt;/groupId&gt;
                &lt;artifactId&gt;ase-user-docking&lt;/artifactId&gt;
                &lt;version&gt;${revision}&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
</code></pre>
<h2 id="发布到本地仓库与私服"><a class="header" href="#发布到本地仓库与私服">发布到本地仓库与私服</a></h2>
<p>配置<em>flatMap</em>更新打包方式</p>
<pre><code class="language-java">            &lt;plugin&gt;
                &lt;!-- https://mvnrepository.com/artifact/org.codehaus.mojo/flatten-maven-plugin --&gt;
                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
                &lt;artifactId&gt;flatten-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.2.5&lt;/version&gt;

                &lt;configuration&gt;
                    &lt;!--是否更新pom文件，此处还有更高级的用法--&gt;
                    &lt;updatePomFile&gt;true&lt;/updatePomFile&gt;
                    &lt;flattenMode&gt;resolveCiFriendliesOnly&lt;/flattenMode&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;flatten&lt;/id&gt;
                        &lt;phase&gt;process-resources&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;flatten&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                    &lt;execution&gt;
                        &lt;id&gt;flatten.clean&lt;/id&gt;
                        &lt;phase&gt;clean&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;clean&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
</code></pre>
<p><strong>跳过不需要发布的包</strong></p>
<pre><code class="language-java">    &lt;properties&gt;
        &lt;maven.deploy.skip&gt;true&lt;/maven.deploy.skip&gt;
    &lt;/properties&gt;
</code></pre>
<p><strong>指定发布的包</strong></p>
<p><em>deploy</em> 右键 -&gt; <em>modify run configuration</em> -&gt; 修改命令</p>
<pre><code>deploy -pl ase-message -am -f pom.xml
</code></pre>
<h1 id="snapshot-与-release"><a class="header" href="#snapshot-与-release"><em>SNAPSHOT</em> 与 RELEASE</a></h1>
<ul>
<li>
<p>在Nexus仓库中，一个仓库一般分为public(Release)仓和SNAPSHOT仓，前者存放正式版本，后者存放快照版本。</p>
</li>
<li>
<p>如果在项目配置文件中（无论是build.gradle还是pom.xml）指定的版本号带有’-SNAPSHOT’后缀，比如版本号为’Junit-4.10-SNAPSHOT’，那么打出的包就是一个快照版本。</p>
</li>
<li>
<p>快照版本和正式版本的主要区别在于，<strong>本地获取这些依赖的机制有所不同</strong>。</p>
<p><strong>example</strong></p>
</li>
</ul>
<pre><code>假设你依赖一个库的正式版本，构建的时候构建工具会先在本次仓库中查找是否已经有了这个依赖库，如果没有的话才会去远程仓库中去拉取。

所以假设你发布了Junit-4.10.jar到了远程仓库，有一个项目依赖了这个库，它第一次构建的时候会把该库从远程仓库中下载到本地仓库缓存，以后再次构建都不会去访问远程仓库了。

所以如果你修改了代码，向远程仓库中发布了新的软件包，但仍然叫Junit-4.10.jar，那么依赖这个库的项目就无法得到最新更新。

你只有在重新发布的时候升级版本，比如叫做Junit-4.11.jar，然后通知依赖该库的项目组也修改依赖版本为Junit-4.11,这样才能使用到你最新添加的功能。
</code></pre>
<ul>
<li>弊处</li>
</ul>
<p>这种方式在团队内部开发的时候会变的特别蛋痛。假设有两个小组负责维护两个组件，example-service和example-ui,其中example-ui项目依赖于example-service。而这两个项目每天都会构建多次，如果每次构建你都要升级example-service的版本，那么你会疯掉。这个时候SNAPSHOT版本就派上用场了。每天日常构建时你可以构建example-service的快照版本，比如example-service-1.0-SNAPSHOT.jar，而example-ui依赖该快照版本。每次example-ui构建时，会优先去远程仓库中查看是否有最新的example-service-1.0-SNAPSHOT.jar，如果有则下载下来使用。即使本地仓库中已经有了example-service-1.0-SNAPSHOT.jar，它也会尝试去远程仓库中查看同名的jar是否是最新的。有的人可能会问，这样不就不能充分利用本地仓库的缓存机制了吗？别着急，Maven比我们想象中的要聪明。在配置Maven的Repository的时候中有个配置项，可以配置对于SNAPSHOT版本<strong>向远程仓库中查找的频率</strong>。频率共有四种，分别是<strong>always、daily、interval、never</strong>。当本地仓库中存在需要的依赖项目时，always是每次都去远程仓库查看是否有更新，daily是只在第一次的时候查看是否有更新，当天的其它时候则不会查看；interval允许设置一个分钟为单位的间隔时间，在这个间隔时间内只会去远程仓库中查找一次，never是不会去远程仓库中查找（这种就和正式版本的行为一样了）。</p>
<pre><code class="language-xml">&lt;repository&gt;
    &lt;id&gt;myRepository&lt;/id&gt;
    &lt;url&gt;...&lt;/url&gt;
    &lt;snapshots&gt;
        &lt;enabled&gt;true&lt;/enabled&gt;
        &lt;updatePolicy&gt;XXX&lt;/updatePolicy&gt;
    &lt;/snapshots&gt;
&lt;/repository&gt;
</code></pre>
<h1 id="参考链接-1"><a class="header" href="#参考链接-1">参考链接</a></h1>
<p><a href="https://maven.apache.org/maven-ci-friendly.html">maven-ci-friendly</a></p>
<p>https://www.mojohaus.org/flatten-maven-plugin/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nio"><a class="header" href="#nio">NIO</a></h1>
<ol>
<li>JavaNIO（NewIO，或者Non-Block IO）是从 java1.4版本引入的 新的IOAPI 可以替代标准JavaIOAPI的</li>
<li>NIO 与原来的IO有同样的作用和目的，但是使用方式完全不同</li>
<li>NIO 是 面向缓冲区、基于Channel 的IO操作</li>
<li>NIO 以更高效的方式进行 流的读写操作</li>
</ol>
<h1 id="核心对象"><a class="header" href="#核心对象">核心对象</a></h1>
<h2 id="buffer-1"><a class="header" href="#buffer-1">Buffer</a></h2>
<p>缓冲区，用于数据读写</p>
<h2 id="channel"><a class="header" href="#channel">Channel</a></h2>
<p>用于缓冲区数据的传递</p>
<h2 id="selector"><a class="header" href="#selector">Selector</a></h2>
<p>用于 单线程管理 多个 <strong>Channel</strong> 连接</p>
<h1 id="各种io模型"><a class="header" href="#各种io模型">各种IO模型</a></h1>
<table><thead><tr><th>BIO</th><th>NIO</th><th>AIO</th></tr></thead><tbody>
<tr><td>Socket</td><td>SocketChannel</td><td>AsynchronousSocketChannel</td></tr>
<tr><td>ServerSocket</td><td>ServerSocketChannel</td><td>AsynchronousServerSocketChannel</td></tr>
</tbody></table>
<h1 id="javaaionio20"><a class="header" href="#javaaionio20">JavaAIO(NIO2.0)</a></h1>
<ol>
<li>
<p>真正的 异步非阻塞</p>
</li>
<li>
<p>服务器实现模式为一个有效请求一个线程</p>
</li>
<li>
<p>客户端的IO请求 都是由 os完成 在通知服务器应用 去启动先线程 处理</p>
</li>
</ol>
<p>java.nio.channels 包下增加了 下面四个异步通道</p>
<pre><code>AsynchronousSocketChannel
AsynchronousSerrverSocketChannel
AsynchronousFileChannel
AsynchronousDatagramChannel
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buffer-2"><a class="header" href="#buffer-2">Buffer</a></h1>
<p>缓冲区，用于数据读写</p>
<h2 id="buffer的基本实现类"><a class="header" href="#buffer的基本实现类">buffer的基本实现类</a></h2>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
<li>MappedByteBuffer</li>
</ul>
<h1 id="三大核心属性"><a class="header" href="#三大核心属性">三大核心属性</a></h1>
<p><strong>capacity</strong>: 容量，缓冲区最大存储数据的容量。一旦声明不能改变</p>
<p><strong>limit</strong>:  界限，缓冲区 可以 操作数据的 大小</p>
<p><strong>postion</strong>: 位置，表示缓冲区 正在 操作数据 的位置</p>
<p><strong>mark</strong>：标记上次的位置</p>
<p><strong>mark&lt;=position</strong> &lt;= <strong>limit</strong> &lt;=  <strong>capacity</strong></p>
<h2 id="基本操作"><a class="header" href="#基本操作">基本操作</a></h2>
<p><strong>put</strong>：存入数据到缓冲区中</p>
<p><strong>get</strong>：读取缓存区的数据</p>
<p><strong>flip</strong>：缓冲区读写翻转</p>
<p><strong>rewind</strong>:  <strong>将position设回0,limit保持不变</strong></p>
<p><strong>clear</strong>: position将被设回0，limit被设置成 capacity的值</p>
<p><strong>compact</strong>:将所有未读的数据拷贝到Buffer起始处然后,将position设到最后一个未读元素正后面</p>
<p><strong>mark/reset</strong>:标记一个position ，恢复 position</p>
<p><strong>equals</strong>:buffer的类型相同，个数相同，每个byte相同</p>
<h1 id="基本操作解析"><a class="header" href="#基本操作解析">基本操作解析</a></h1>
<h2 id="当进行读写混合操作之后-position指针时如何-运转的"><a class="header" href="#当进行读写混合操作之后-position指针时如何-运转的">当进行读写混合操作之后 position指针时如何 运转的</a></h2>
<p><strong>问题描述</strong></p>
<p><em>capacity</em> 是10 put 5个字符串、get 1个字符串、put1个字符串 切换到读模式 此时的 <em>position</em> 与limit是多少</p>
<p><strong>猜想</strong></p>
<p>读写模式切换时 </p>
<p><strong>position = limit+1</strong></p>
<p><strong>limit =  position</strong></p>
<p><strong>结论</strong></p>
<p><strong>读写翻转时：默认只继承上次模式可用的数据，并不会识别缓冲区本身的所有大小</strong></p>
<p>例如：10个字节的缓冲区：写了5个字节，切读模式，那么只有5个字节可用，</p>
<p>这五个字节 在切换到 写模式时，由于未读0个：则没有写入空间</p>
<h2 id="缓冲区满了或空了之后发生什么情况"><a class="header" href="#缓冲区满了或空了之后发生什么情况">缓冲区满了或空了之后发生什么情况</a></h2>
<h2 id="现象"><a class="header" href="#现象">现象</a></h2>
<p><strong>从满的缓冲区PUT</strong></p>
<p>会报 <strong>BufferOverflowException</strong></p>
<p><strong>从空的缓冲区GET</strong></p>
<p>指针往前</p>
<p><strong>从满的缓存区GET</strong></p>
<p>会报 <strong>BufferOverflowException</strong></p>
<h2 id="结论"><a class="header" href="#结论">结论</a></h2>
<ol>
<li>Buffer内部 不会 特定 区分读写模式</li>
<li>只要 指针越过 <em>Limit</em> 就会 报 <strong>BufferOverflowException</strong></li>
<li>而 <em>GET</em> <em>PUT</em> 都会 把 指针往前移</li>
</ol>
<h2 id="buffer-flip"><a class="header" href="#buffer-flip">Buffer Flip</a></h2>
<blockquote>
<p>将 position设置成 0，limit设置成 <em>position</em></p>
</blockquote>
<ol>
<li><em>flip</em> 没有任何 涉及到读写相关的逻辑</li>
<li>我们可以把 position ~ limit设置成 当前 工作窗口</li>
<li>0~position的位置就是 当前操作的 产出段，翻转的就是 当前操作的产出</li>
<li>而对于 写入 读取操作：写入的产出就是 一个个数据、读取的产出就是 为写入腾空间</li>
</ol>
<pre><code class="language-java">public final Buffer flip() {
    limit = position;
    position = 0;
    mark = -1;
    return this;
}
</code></pre>
<h2 id="rewind"><a class="header" href="#rewind">Rewind</a></h2>
<blockquote>
<p>将<em>position</em> 设置成 0 ，mark重置</p>
</blockquote>
<p>将当前操作的产出 重置为0</p>
<pre><code class="language-java">public final Buffer rewind() {
    position = 0;
    mark = -1;
    return this;
}
</code></pre>
<h2 id="remaining"><a class="header" href="#remaining">remaining</a></h2>
<blockquote>
<p>剩余多少可供消费的空间  limit - position</p>
</blockquote>
<h2 id="clear-1"><a class="header" href="#clear-1">clear</a></h2>
<blockquote>
<p>清空产出，</p>
</blockquote>
<pre><code>    public final Buffer clear() {
        position = 0;
        limit = capacity;
        mark = -1;
        return this;
    }
</code></pre>
<h2 id="markreset"><a class="header" href="#markreset">mark/reset</a></h2>
<pre><code class="language-java">public final Buffer mark() {
        mark = position;
        return this;
}
public final Buffer reset() {
    int m = mark;
    if (m &lt; 0)
        throw new InvalidMarkException();
    position = m;
    return this;
}
</code></pre>
<h2 id="positionint-newposition"><a class="header" href="#positionint-newposition">position(int newPosition)</a></h2>
<blockquote>
<p>修改新的position</p>
</blockquote>
<p>新的position不能大于  工作窗口</p>
<pre><code class="language-java">public final Buffer position(int newPosition) {
    if ((newPosition &gt; limit) || (newPosition &lt; 0))
        throw new IllegalArgumentException();
    position = newPosition;
    if (mark &gt; position) mark = -1;
    return this;
}
</code></pre>
<h1 id="直接缓冲区与非直接缓冲区"><a class="header" href="#直接缓冲区与非直接缓冲区">直接缓冲区与非直接缓冲区</a></h1>
<h2 id="解释"><a class="header" href="#解释">解释</a></h2>
<p>非直接缓冲区：<em>allocate</em> 分配缓冲区，将缓冲建立在JVM内存中</p>
<p>直接缓冲区：及那个 缓冲区建立在 操作系统的物理内存中</p>
<h2 id="为什么出现直接缓冲区的需求"><a class="header" href="#为什么出现直接缓冲区的需求">为什么出现直接缓冲区的需求</a></h2>
<p><strong>传统方式 读取文件</strong> </p>
<p>需要经历  <strong>物理磁盘 -&gt; 内核缓存 -&gt; JVM缓存 -&gt; 应用程序空间</strong></p>
<p><strong>直接缓冲区</strong></p>
<p>需要经历  <strong>物理磁盘 -&gt; 直接缓冲区 -&gt; 应用程序空间</strong></p>
<h2 id="建立直接缓冲区的办法"><a class="header" href="#建立直接缓冲区的办法">建立直接缓冲区的办法</a></h2>
<ol>
<li><strong>allocateDirect</strong></li>
<li><strong>FileChannel.map()</strong></li>
</ol>
<h2 id="example-7"><a class="header" href="#example-7">example</a></h2>
<pre><code class="language-java">//20.002、16.028、16.879、 一次系统调用
@Test
public void main() throws IOException {
    long l = System.currentTimeMillis();

    FileChannel file = FileChannel.open(Paths.get(&quot;D:\\&quot;, &quot;myimage.tar&quot;), StandardOpenOption.READ);
    //直接映射的缓冲区
    MappedByteBuffer map = file.map(FileChannel.MapMode.READ_ONLY, 0, file.size());

    //copy到C:
    FileChannel open = FileChannel.open(Paths.get(&quot;Z:\\&quot;, &quot;myimage.tar&quot;), StandardOpenOption.WRITE,StandardOpenOption.CREATE);
    open.write(map);
    System.out.println((System.currentTimeMillis() - l)/1000D);
}
// 482s、18.717
@Test
public void testNormal() throws IOException {
    long l = System.currentTimeMillis();
    FileChannel file = FileChannel.open(Paths.get(&quot;D:\\&quot;, &quot;myimage.tar&quot;), StandardOpenOption.READ);
    FileChannel open = FileChannel.open(Paths.get(&quot;Z:\\&quot;, &quot;myimage.tar&quot;), StandardOpenOption.WRITE,StandardOpenOption.CREATE);
    ByteBuffer allocate = ByteBuffer.allocate((int) file.size());
    while (file.read(allocate)&gt;0) {
        allocate.flip();
        open.write(allocate);
        allocate.clear();
    }

    System.out.println((System.currentTimeMillis() - l)/1000D);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-8"><a class="header" href="#前言-8">前言</a></h1>
<p>用于 源节点 与目标节点 的连接</p>
<p>在JAVA NIO 中负责 缓冲区 中数据的传输</p>
<p>Channel本身不存储数据、需要配合缓冲区进行传输</p>
<h1 id="channel实现类"><a class="header" href="#channel实现类">Channel实现类</a></h1>
<p>Channel的实现：覆盖了TCP，UDP，文件IO</p>
<ul>
<li>文件通道：FileChannel</li>
<li>数据包通道：DatagramChannel</li>
<li>客户端socket：SocketChannel</li>
<li>服务端socket：ServerSocketChannel</li>
</ul>
<h1 id="获取通道"><a class="header" href="#获取通道">获取通道</a></h1>
<h2 id="针对通道的类提供了-getchannel-方法"><a class="header" href="#针对通道的类提供了-getchannel-方法">针对通道的类提供了 <em>getChannel()</em> 方法</a></h2>
<h3 id="本地io"><a class="header" href="#本地io">本地IO</a></h3>
<p><strong>FileInputSream/FileOutputStream</strong>/<strong>RandomAccessFile</strong></p>
<h2 id="网络-io"><a class="header" href="#网络-io">网络 IO</a></h2>
<p><strong>Socket/ServerSocket/DatagramSocket</strong></p>
<h2 id="jdk17-nio2的改进"><a class="header" href="#jdk17-nio2的改进">jdk1.7 NIO2的改进</a></h2>
<ol>
<li>针对各个通道提供了 静态 <em>open</em> 方法</li>
<li>Files工具类 有一个 <strong>newByteChannel()</strong></li>
</ol>
<h1 id="通道之间的数据传输"><a class="header" href="#通道之间的数据传输">通道之间的数据传输</a></h1>
<h2 id="transferto"><a class="header" href="#transferto">transferTo</a></h2>
<blockquote>
<p>将此通道在中的数据 传输到 目标通道 中</p>
</blockquote>
<pre><code class="language-java">public abstract long transferTo(long position, long count,
                                WritableByteChannel target)
</code></pre>
<blockquote>
<p>将目标通道的数据 写入到此通道中</p>
</blockquote>
<pre><code class="language-java">public abstract long transferFrom(ReadableByteChannel src,
                                  long position, long count)
</code></pre>
<h1 id="分散scatter与聚集gather"><a class="header" href="#分散scatter与聚集gather">分散（Scatter）与聚集（Gather）</a></h1>
<h2 id="分散读取"><a class="header" href="#分散读取">分散读取</a></h2>
<p>分散读取（Scattering Reads）是指将缓冲区的数据 按顺序读取 到各个 缓冲区去</p>
<h2 id="聚集写入"><a class="header" href="#聚集写入">聚集写入</a></h2>
<p><strong>gathering writer</strong>  是指将各个 缓冲区的数据  按顺序写入到 Chaanel中</p>
<div style="break-before: page; page-break-before: always;"></div><p>在互联网中提起网络，我们都会避免不了讨论高并发、百万连接。而此处的百万连接的实现，脱离不了网络 IO 的选择，因此本文作为一篇个人学习的笔记，特此进行记录一下整个网络 IO 的发展演变过程。以及目前广泛使用的网络模型。</p>
<h3 id="1网络-io-的发展"><a class="header" href="#1网络-io-的发展"><strong>1.网络 IO 的发展</strong></a></h3>
<p>在本节内容中，我们将一步一步介绍网络 IO 的演变发展过程。介绍完发展过程后，再对网络 IO 中几组容易混淆的概念进行对比、分析。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauhvQxpibL7I3CeEZPcaA1HETu42nzJ6nvmrltaxMIlZJdXr2TaY9pPbZoSMASuG5NhCh4sQzIXPDA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<h4 id="11-网络-io-的各个发展阶段"><a class="header" href="#11-网络-io-的各个发展阶段">1.1 网络 IO 的各个发展阶段</a></h4>
<p>通常，我们在此讨论的网络 IO 一般都是针对 linux 操作系统而言。网络 IO 的发展过程是随着 linux 的内核演变而变化，因此网络 IO 大致可以分为如下几个阶段：</p>
<p><strong>1. 阻塞 IO(BIO)</strong>
<strong>2. 非阻塞 IO(NIO)</strong>
<strong>3. IO 多路复用第一版(select/poll)</strong>
<strong>4. IO 多路复用第二版(epoll)</strong>
<strong>5. 异步 IO(AIO)</strong></p>
<p>而每一个阶段，都是因为当前的网络有一些缺陷，因此又在不断改进该缺陷。这是<strong>网络 IO 一直演变过程中的本质</strong>。下面将对上述几个阶段进行介绍，并对每个阶段的网络 IO 解决了哪些问题、优点、缺点进行剖析。</p>
<p><strong>1.2 网络的两个阶段</strong></p>
<p>在网络中，我们通常可以将其广义上划分为以下两个阶段：</p>
<p><strong>第一阶段：硬件接口到内核态</strong>
<strong>第二阶段：内核态到用户态</strong></p>
<p>本人理解：我们通常上网，大部分数据都是通过网线传递的。因此对于两台计算机而言，要进行网络通信，其数据都是先从应用程序传递到传输层(TCP/UDP)到达内核态，然后再到网络层、数据链路层、物理层，接着数据传递到硬件网卡，最后通过网络传输介质传递到对端机器的网卡，然后再一步一步数据从网卡传递到内核态，最后再拷贝到用户态。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauhvQxpibL7I3CeEZPcaA1HEZDwwibVibDL8RCj0Vhia4xMMbO5FqvRcdIEicjYyjQSpBe4kanbfFbRrRg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<h4 id="13-阻塞-io-和非阻塞-io-的区别"><a class="header" href="#13-阻塞-io-和非阻塞-io-的区别">1.3 阻塞 IO 和非阻塞 IO 的区别</a></h4>
<p>根据 1.2 节的内容，我们可以知道，网络中的数据传输从网络传输介质到达目的机器，需要如上两个阶段。此处我们把从<strong>硬件到内核态</strong>这一阶段，是否发生阻塞等待，可以将网络分为<strong>阻塞 IO</strong>和<strong>非阻塞 IO</strong>。如果用户发起了读写请求，但内核态数据还未准备就绪，该阶段不会阻塞用户操作，内核立马返回，则称为非阻塞 IO。如果该阶段一直阻塞用户操作。直到内核态数据准备就绪，才返回。这种方式称为阻塞 IO。</p>
<p>因此，区分阻塞 IO 和非阻塞 IO 主要看第一阶段是否阻塞用户操作。</p>
<h4 id="14-同步-io-和异步-io-的区别"><a class="header" href="#14-同步-io-和异步-io-的区别">1.4 同步 IO 和异步 IO 的区别</a></h4>
<p>从前面我们知道了，数据的传递需要两个阶段，在此处只要任何一个阶段会阻塞用户请求，都将其称为同步 IO，两个阶段都不阻塞，则称为异步 IO。</p>
<p>在目前所有的操作系统中，linux 中的 epoll、mac 的 kqueue 都属于同步 IO，因为其在第二阶段(数据从内核态到用户态)都会发生拷贝阻塞。而只有 windows 中的 IOCP 才真正属于异步 IO，即 AIO。</p>
<h3 id="2阻塞-io"><a class="header" href="#2阻塞-io"><strong>2.阻塞 IO</strong></a></h3>
<p>在本节，我们将介绍最初的阻塞 IO，阻塞 IO 英文为 blocking IO，又称为 BIO。根据前面的介绍，阻塞 IO 主要指的是第一阶段(硬件网卡到内核态)。</p>
<h4 id="21-阻塞-io-的概念"><a class="header" href="#21-阻塞-io-的概念">2.1 阻塞 IO 的概念</a></h4>
<p>阻塞 IO，顾名思义当用户发生了系统调用后，如果数据未从网卡到达内核态，内核态数据未准备好，此时会一直阻塞。直到数据就绪，然后从内核态拷贝到用户态再返回。具体过程可以参考 2.2 的图示。</p>
<h4 id="22-阻塞-io-的过程"><a class="header" href="#22-阻塞-io-的过程">2.2 阻塞 IO 的过程</a></h4>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauhvQxpibL7I3CeEZPcaA1HEGibuyiacHXVXK7gdQ95jEUAwSuy3s6G5v61Tms5R368FXesWOhiajiaq4A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<h4 id="23-阻塞-io-的缺点"><a class="header" href="#23-阻塞-io-的缺点">2.3 阻塞 IO 的缺点</a></h4>
<p>在一般使用阻塞 IO 时，都需要配置多线程来使用，最常见的模型是<strong>阻塞 IO+多线程</strong>，每个连接一个单独的线程进行处理。</p>
<p><strong>我们知道，一般一个程序可以开辟的线程是有限的，而且开辟线程的开销也是比较大的。也正是这种方式，会导致一个应用程序可以处理的客户端请求受限。面对百万连接的情况，是无法处理。</strong></p>
<p>既然发现了问题，分析了问题，那就得解决问题。既然阻塞 IO 有问题，本质是由于其阻塞导致的，因此自然而然引出了下面即将介绍的主角：<strong>非阻塞 IO</strong></p>
<h3 id="3非阻塞-io"><a class="header" href="#3非阻塞-io"><strong>3.非阻塞 IO</strong></a></h3>
<p>非阻塞 IO 是为了解决前面提到的阻塞 IO 的缺陷而引出的，下面我们将介绍非阻塞 IO 的过程。</p>
<h4 id="31-非阻塞-io-的概念"><a class="header" href="#31-非阻塞-io-的概念">3.1 非阻塞 IO 的概念</a></h4>
<p>非阻塞 IO：见名知意，就是在第一阶段(网卡-内核态)数据未到达时不等待，然后直接返回。因此非阻塞 IO 需要不断的用户发起请求，询问内核数据好了没，好了没。</p>
<h4 id="32-非阻塞-io-的过程"><a class="header" href="#32-非阻塞-io-的过程">3.2 非阻塞 IO 的过程</a></h4>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauhvQxpibL7I3CeEZPcaA1HESdhj8nSKbRFuZ6U6GuoT5gnyttj1uic3YcC0LQy2kHC45s3jSC82aXA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>非阻塞 IO 是需要系统内核支持的，在创建了连接后，可以调用 setsockop 设置 noblocking</p>
<h4 id="33-非阻塞-io-的优点"><a class="header" href="#33-非阻塞-io-的优点">3.3 非阻塞 IO 的优点</a></h4>
<p>正如前面提到的，非阻塞 IO 解决了阻塞 IO<strong>每个连接一个线程处理的问题</strong>，所以其最大的优点就是 <strong>一个线程可以处理多个连接</strong>，这也是其非阻塞决定的。</p>
<h4 id="34-非阻塞-io-的缺点"><a class="header" href="#34-非阻塞-io-的缺点">3.4 非阻塞 IO 的缺点</a></h4>
<p>但这种模式，也有一个问题，就是需要用户多次发起系统调用。<strong>频繁的系统调用</strong>是比较消耗系统资源的。</p>
<p>因此，既然存在这样的问题，那么自然而然我们就需要解决该问题：<strong>保留非阻塞 IO 的优点的前提下，减少系统调用</strong></p>
<h3 id="4io-多路复用第一版"><a class="header" href="#4io-多路复用第一版"><strong>4.IO 多路复用第一版</strong></a></h3>
<p>为了解决非阻塞 IO 存在的频繁的系统调用这个问题，随着内核的发展，出现了 IO 多路复用模型。那么我们就需要搞懂几个问题：</p>
<ol>
<li>IO 多路复用到底复用什么？</li>
<li>IO 多路复用如何复用？</li>
</ol>
<p><strong>IO 多路复用：</strong> 很多人都说，IO 多路复用是用一个线程来管理多个网络连接，但本人不太认可，因为在非阻塞 IO 时，就已经可以实现一个线程处理多个网络连接了，这个是由于其非阻塞而决定的。</p>
<p><strong>在此处，个人观点，多路复用主要复用的是通过有限次的系统调用来实现管理多个网络连接。最简单来说，我目前有 10 个连接，我可以通过一次系统调用将这 10 个连接都丢给内核，让内核告诉我，哪些连接上面数据准备好了，然后我再去读取每个就绪的连接上的数据。因此，IO 多路复用，复用的是系统调用。通过有限次系统调用判断海量连接是否数据准备好了</strong></p>
<p><strong>无论下面的 select、poll、epoll，其都是这种思想实现的，不过在实现上，select/poll 可以看做是第一版，而 epoll 是第二版</strong></p>
<h4 id="41io-多路复用第一版的概念"><a class="header" href="#41io-多路复用第一版的概念">4.1IO 多路复用第一版的概念</a></h4>
<p><strong>IO 多路复用第一版，这个概念是本人想出来的，主要是方便将 select/poll 和 epoll 进行区分</strong></p>
<p>所以此处 IO 多路复用第一版，主要特指 select 和 poll 这两个。</p>
<p>select 的 api</p>
<pre><code>// readfds:关心读的fd集合；writefds：关心写的fd集合；excepttfds：异常的fd集合
int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
</code></pre>
<blockquote>
<p>select 函数监视的文件描述符分 3 类，分别是 writefds、readfds、和 exceptfds。调用后 select 函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有 except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可），函数返回。当 select 函数返回后，可以 通过遍历 fdset，来找到就绪的描述符。</p>
</blockquote>
<blockquote>
<p>select 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select 的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>
</blockquote>
<p>poll 的 api</p>
<pre><code>int poll (struct pollfd *fds, unsigned int nfds, int timeout);

struct pollfd {
    int fd; /* file descriptor */
    short events; /* requested events to watch */
    short revents; /* returned events witnessed */
};
</code></pre>
<blockquote>
<p>pollfd 结构包含了要监视的 event 和发生的 event，不再使用 select“参数-值”传递的方式。同时，pollfd 并没有最大数量限制（但是数量过大后性能也是会下降）。和 select 函数一样，poll 返回后，需要轮询 pollfd 来获取就绪的描述符。</p>
</blockquote>
<blockquote>
<p>从上面看，select 和 poll 都需要在返回后，通过遍历文件描述符来获取已经就绪的 socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
</blockquote>
<p><strong>从本质来说：IO 多路复用中，select()/poll()/epoll_wait()这几个函数对应第一阶段；read()/recvfrom()对应第二阶段</strong></p>
<h4 id="42io-多路复用第一版的过程"><a class="header" href="#42io-多路复用第一版的过程">4.2IO 多路复用第一版的过程</a></h4>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauhvQxpibL7I3CeEZPcaA1HEbPaUbbrbibQsCw9xPib0FfZXfOKQ6OdekEicBSyr5micL6iaUAIQqRrDqAA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<h4 id="43io-多路复用第一版的优点"><a class="header" href="#43io-多路复用第一版的优点">4.3IO 多路复用第一版的优点</a></h4>
<p><strong>IO 多路复用，主要在于复用，通过 select()或者 poll()将多个 socket fds 批量通过系统调用传递给内核，由内核进行循环遍历判断哪些 fd 上数据就绪了，然后将就绪的 readyfds 返回给用户。再由用户进行挨个遍历就绪好的 fd，读取或者写入数据。</strong></p>
<p><strong>所以通过 IO 多路复用+非阻塞 IO，一方面降低了系统调用次数，另一方面可以用极少的线程来处理多个网络连接。</strong></p>
<h4 id="44io-多路复用第一版的缺点"><a class="header" href="#44io-多路复用第一版的缺点">4.4IO 多路复用第一版的缺点</a></h4>
<p>虽然第一版 IO 多路复用解决了之前提到的频繁的系统调用次数，但同时引入了新的问题：<strong>用户需要每次将海量的 socket fds 集合从用户态传递到内核态，让内核态去检测哪些网络连接数据就绪了</strong></p>
<p><strong>但这个地方会出现频繁的将海量 fd 集合从用户态传递到内核态，再从内核态拷贝到用户态。所以，这个地方开销也挺大。</strong></p>
<p>既然还有这个问题，那我们继续开始解决这个问题，因此就引出了第二版的 IO 多路复用。</p>
<p><strong>其实思路也挺简单，既然需要拷贝，那就想办法，不拷贝。既然不拷贝，那就在内核开辟一段区域咯</strong></p>
<h4 id="45io-多路复用第一版的区别"><a class="header" href="#45io-多路复用第一版的区别">4.5IO 多路复用第一版的区别</a></h4>
<p><strong>select 和 poll 的区别</strong></p>
<ol>
<li>select 能处理的最大连接，默认是 1024 个，可以通过修改配置来改变，但终究是有限个；而 poll 理论上可以支持无限个</li>
<li>select 和 poll 在管理海量的连接时，会频繁的从用户态拷贝到内核态，比较消耗资源。</li>
</ol>
<h3 id="5io-多路复用第二版"><a class="header" href="#5io-多路复用第二版"><strong>5.IO 多路复用第二版</strong></a></h3>
<p>IO 多路复用第二版主要指 epoll，epoll 的出现也是随着内核版本迭代才诞生的，在网上到处看到，epoll 是内核 2.6 以后开始支持的</p>
<p><strong>epoll 的出现是为了解决前面提到的 IO 多路复用第一版的问题</strong></p>
<h4 id="51io-多路复用第二版的概念"><a class="header" href="#51io-多路复用第二版的概念">5.1IO 多路复用第二版的概念</a></h4>
<p>epoll 提供的 api</p>
<pre><code>//创建epollFd，底层是在内核态分配一段区域，底层数据结构红黑树+双向链表
int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大

//往红黑树中增加、删除、更新管理的socket fd
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；

//这个api是用来在第一阶段阻塞，等待就绪的fd。
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
1. int epoll_create(int size);
创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。
当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。

2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
函数是对指定描述符fd执行op操作。
- epfd：是epoll_create()的返回值。
- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。
- fd：是需要监听的fd（文件描述符）
- epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：

struct epoll_event {
  __uint32_t events;  /* Epoll events */
  epoll_data_t data;  /* User data variable */
};

//events可以是以下几个宏的集合：
EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
EPOLLOUT：表示对应的文件描述符可以写；
EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
EPOLLERR：表示对应的文件描述符发生错误；
EPOLLHUP：表示对应的文件描述符被挂断；
EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。
EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里

3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
等待epfd上的io事件，最多返回maxevents个事件。
参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。
</code></pre>
<p>二 工作模式</p>
<p>epoll 对文件描述符的操作有两种模式：LT（level trigger）和 ET（edge trigger）。LT 模式是默认模式，LT 模式与 ET 模式的区别如下：　　 LT 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。　　 ET 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。</p>
<ol>
<li>LT 模式</li>
</ol>
<p>LT(level triggered)是缺省的工作方式，并且同时支持 block 和 no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<ol>
<li>ET 模式</li>
</ol>
<p>ET(edge-triggered)是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个 EWOULDBLOCK 错误）。但是请注意，如果一直不对这个 fd 作 IO 操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h4 id="52io-多路复用第二版的过程"><a class="header" href="#52io-多路复用第二版的过程">5.2IO 多路复用第二版的过程</a></h4>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauhvQxpibL7I3CeEZPcaA1HEbPaUbbrbibQsCw9xPib0FfZXfOKQ6OdekEicBSyr5micL6iaUAIQqRrDqAA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>当 epoll_wait()调用后会阻塞，然后完了当返回时，会返回了哪些 fd 的数据就绪了，用户只需要遍历就绪的 fd 进行读写即可。</p>
<h4 id="53io-多路复用第二版的优点"><a class="header" href="#53io-多路复用第二版的优点">5.3IO 多路复用第二版的优点</a></h4>
<p><strong>IO 多路复用第二版 epoll 的优点在于：</strong></p>
<p>一开始就在内核态分配了一段空间，来存放管理的 fd,所以在每次连接建立后，交给 epoll 管理时，需要将其添加到原先分配的空间中，后面再管理时就不需要频繁的从用户态拷贝管理的 fd 集合。通通过这种方式大大的提升了性能。</p>
<p>所以现在的 IO 多路复用主要指 epoll</p>
<h4 id="54io-多路复用第二版的缺点"><a class="header" href="#54io-多路复用第二版的缺点">5.4IO 多路复用第二版的缺点</a></h4>
<p><strong>个人猜想：</strong> 如何降低占用的空间</p>
<h3 id="6异步-io"><a class="header" href="#6异步-io"><strong>6.异步 IO</strong></a></h3>
<h4 id="61-异步-io-的过程"><a class="header" href="#61-异步-io-的过程">6.1 异步 IO 的过程</a></h4>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauhvQxpibL7I3CeEZPcaA1HEXGYke8ibPkbXEkaQ861CSg8YvQ3qFdvGcXicAicyrD9Vaicx77liakCLBnA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<p>前面介绍的所有网络 IO 都是同步 IO，因为当数据在内核态就绪时，在内核态拷贝用用户态的过程中，仍然会有短暂时间的阻塞等待。而异步 IO 指：<strong>内核态拷贝数据到用户态这种方式也是交给系统线程来实现，不由用户线程完成</strong>，目前只有 windows 系统的 IOCP 是属于异步 IO。</p>
<h3 id="7网络-io-各种模型"><a class="header" href="#7网络-io-各种模型"><strong>7.网络 IO 各种模型</strong></a></h3>
<h4 id="71-reactor-模型"><a class="header" href="#71-reactor-模型">7.1 reactor 模型</a></h4>
<p>目前 reactor 模型有以下几种实现方案：</p>
<p><strong>1. 单 reactor 单线程模型</strong>
<strong>2. 单 reactor 多线程模型</strong>
<strong>3. multi-reactor 多进程模型</strong></p>
<blockquote>
<p>下文网络模型的图，均摘自<a href="https://zhuanlan.zhihu.com/p/95662364">这篇文章</a></p>
</blockquote>
<h5 id="711-单-reactor-单线程模型"><a class="header" href="#711-单-reactor-单线程模型"><strong>7.1.1 单 reactor 单线程模型</strong></a></h5>
<p>此种模型，通常是只有一个 epoll 对象，所有的<strong>接收客户端连接</strong>、<strong>客户端读取</strong>、<strong>客户端写入</strong>操作都包含在一个线程内。该种模型也有一些中间件在用，比如 redis</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauhvQxpibL7I3CeEZPcaA1HEibnlbqiclVmzSkNpIym8ibYaXOAAnn2cZSibDr7fiaHXGjypWk0iacO7kkdA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<blockquote>
<p>但在目前的单线程 Reactor 模式中，不仅 I/O 操作在该 Reactor 线程上，连非 I/O 的业务操作也在该线程上进行处理了，这可能会大大延迟 I/O 请求的响应。所以我们应该将非 I/O 的业务逻辑操作从 Reactor 线程上卸载，以此来加速 Reactor 线程对 I/O 请求的响应。</p>
</blockquote>
<h5 id="712-单-reactor-多线程模型"><a class="header" href="#712-单-reactor-多线程模型"><strong>7.1.2 单 reactor 多线程模型</strong></a></h5>
<p>该模型主要是通过将，前面的模型进行改造，将读写的业务逻辑交给具体的线程池来实现，这样可以显示 reactor 线程对 IO 的响应，以此提升系统性能<img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauhvQxpibL7I3CeEZPcaA1HEvzbIZnWXH0HUWLgUZTRzHGzNsRK0F2JC0bxHmia6XG02wocUUvianoIQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<blockquote>
<p>在工作者线程池模式中，虽然非 I/O 操作交给了线程池来处理，但是所有的 I/O 操作依然由 Reactor 单线程执行，在高负载、高并发或大数据量的应用场景，依然较容易成为瓶颈。所以，对于 Reactor 的优化，又产生出下面的多线程模式。</p>
</blockquote>
<h5 id="713-multi-reactor-多线程模型"><a class="header" href="#713-multi-reactor-多线程模型"><strong>7.1.3 multi-reactor 多线程模型</strong></a></h5>
<p>在这种模型中，主要分为两个部分：mainReactor、subReactors。mainReactor 主要负责接收客户端的连接，然后将建立的客户端连接通过负载均衡的方式分发给 subReactors，</p>
<p>subReactors 来负责具体的每个连接的读写</p>
<p>对于非 IO 的操作，依然交给工作线程池去做，对逻辑进行解耦</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauhvQxpibL7I3CeEZPcaA1HEJ1BVQvZoIJB0xqBLxNvCOcOWkTknoMP4t1XkUgHfsoN7J2jzClJuaw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<blockquote>
<p>mainReactor 对应 Netty 中配置的 BossGroup 线程组，主要负责接受客户端连接的建立。一般只暴露一个服务端口，BossGroup 线程组一般一个线程工作即可 subReactor 对应 Netty 中配置的 WorkerGroup 线程组，BossGroup 线程组接受并建立完客户端的连接后，将网络 socket 转交给 WorkerGroup 线程组，然后在 WorkerGroup 线程组内选择一个线程，进行 I/O 的处理。WorkerGroup 线程组主要处理 I/O，一般设置 2*CPU 核数个线程</p>
</blockquote>
<h4 id="72-proactor-模型"><a class="header" href="#72-proactor-模型">7.2 proactor 模型</a></h4>
<p>proactor 主要是通过对异步 IO 的封装的一种模型，它需要底层操作系统的支持，目前只有 windows 的 IOCP 支持的比较好。详细的介绍可以参考<a href="https://zhuanlan.zhihu.com/p/95662364">这篇文章</a></p>
<h4 id="73-主流的中间件所采用的网络模型"><a class="header" href="#73-主流的中间件所采用的网络模型">7.3 主流的中间件所采用的网络模型</a></h4>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvauhvQxpibL7I3CeEZPcaA1HEiaTnSvliaMcYCEDmUiaDlbRQTlURhaKHY8N0qwsgLuXZpkOgeJ3UtXMlQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>
<h4 id="74-主流网络框架"><a class="header" href="#74-主流网络框架">7.4 主流网络框架</a></h4>
<ul>
<li>netty</li>
<li>gnet</li>
<li>libevent</li>
<li>evio(golang)</li>
<li>ACE(c++)</li>
<li>boost::asio(c++)</li>
<li>muduo （linux only)</li>
</ul>
<p>关于c++和c的上述几个库对比，感兴趣的话大家可以自行搜索资料或者阅读<a href="https://www.cnblogs.com/leijiangtao/p/5197566.html">这篇文章</a>。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;mid=2649756681&amp;idx=1&amp;sn=b9ce565bedca42cd824d3414bc01d98e">原文</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selector选择器介绍"><a class="header" href="#selector选择器介绍">Selector（选择器）介绍</a></h1>
<p><strong>Selector</strong> 一般称 为<strong>选择器</strong> ，当然你也可以翻译为 <strong>多路复用器</strong> 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。</p>
<p><strong>使用Selector的好处在于：</strong> 使用更少的线程来就可以来处理通道了， 相比使用多个线程，避免了线程上下文切换带来的开销。</p>
<h1 id="selector选择器的使用方法介绍"><a class="header" href="#selector选择器的使用方法介绍">Selector（选择器）的使用方法介绍</a></h1>
<h2 id="通过调用selectoropen方法创建一个selector对象"><a class="header" href="#通过调用selectoropen方法创建一个selector对象">通过调用Selector.open()方法创建一个Selector对象</a></h2>
<p>如下：</p>
<pre><code class="language-java">Selector selector = Selector.open();
</code></pre>
<h2 id="注册channel到selector"><a class="header" href="#注册channel到selector">注册Channel到Selector</a></h2>
<p><strong>Channel必须是非阻塞的</strong>。</p>
<p>所以FileChannel不适用Selector，因为FileChannel不能切换为非阻塞模式，更准确的来说是因为FileChannel没有继承SelectableChannel。Socket channel可以正常使用。</p>
<p><strong>SelectableChannel抽象类</strong> 有一个 <strong>configureBlocking（）</strong> 方法用于使通道处于阻塞模式或非阻塞模式。</p>
<pre><code class="language-java">channel.configureBlocking(false);
SelectionKey key = channel.register(selector, Selectionkey.OP_READ);
</code></pre>
<h1 id="对io事件分类"><a class="header" href="#对io事件分类">对IO事件分类</a></h1>
<p><strong>register()</strong> 方法的第二个参数。这是一个“ <strong>interest集合</strong> ”，意思是在<strong>通过Selector监听Channel时对什么事件感兴趣</strong>。可以监听四种不同类型的事件：</p>
<ul>
<li><strong>Connect</strong></li>
<li><strong>Accept</strong></li>
<li><strong>Read</strong></li>
<li><strong>Write</strong></li>
</ul>
<p>通道触发了一个事件意思是该事件已经就绪。比如某个Channel成功连接到另一个服务器称为“ <strong>连接就绪</strong> ”。一个Server Socket Channel准备好接收新进入的连接称为“ <strong>接收就绪</strong> ”。一个有数据可读的通道可以说是“ <strong>读就绪</strong> ”。等待写数据的通道可以说是“ <strong>写就绪</strong> ”。</p>
<p>这四种事件用SelectionKey的四个常量来表示：</p>
<pre><code class="language-java">SelectionKey.OP_CONNECT
SelectionKey.OP_ACCEPT
SelectionKey.OP_READ
SelectionKey.OP_WRITE
</code></pre>
<p>如果你对不止一种事件感兴趣，使用或运算符即可，如下：</p>
<pre><code class="language-java">int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
</code></pre>
<h1 id="selectionkey介绍"><a class="header" href="#selectionkey介绍">SelectionKey介绍</a></h1>
<p>一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。</p>
<pre><code class="language-java">key.attachment(); //返回SelectionKey的attachment，attachment可以在注册channel的时候指定。
key.channel(); // 返回该SelectionKey对应的channel。
key.selector(); // 返回该SelectionKey对应的Selector。
key.interestOps(); //返回代表需要Selector监控的IO操作的bit mask
key.readyOps(); // 返回一个bit mask，代表在相应channel上可以进行的IO操作。
</code></pre>
<p><strong>key.interestOps():</strong></p>
<p>我们可以通过以下方法来判断Selector是否对Channel的某种事件感兴趣</p>
<pre><code class="language-java">int interestSet = selectionKey.interestOps(); 
boolean isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；
boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;
boolean isInterestedInRead = interestSet &amp; SelectionKey.OP_READ;
boolean isInterestedInWrite = interestSet &amp; SelectionKey.OP_WRITE;
</code></pre>
<p><strong>key.readyOps()</strong></p>
<p>ready 集合是通道已经准备就绪的操作的集合。JAVA中定义以下几个方法用来检查这些操作是否就绪.</p>
<pre><code class="language-java">//创建ready集合的方法
int readySet = selectionKey.readyOps();
//检查这些操作是否就绪的方法
key.isAcceptable();//是否可读，是返回 true
boolean isWritable()：//是否可写，是返回 true
boolean isConnectable()：//是否可连接，是返回 true
boolean isAcceptable()：//是否可接收，是返回 true
</code></pre>
<pre><code>Channel channel = key.channel();
Selector selector = key.selector();
key.attachment();
</code></pre>
<p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p>
<pre><code>SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);

</code></pre>
<h1 id="从selector中选择channelselecting-channels-via-a-selector"><a class="header" href="#从selector中选择channelselecting-channels-via-a-selector">从Selector中选择channel(Selecting Channels via a Selector)</a></h1>
<p><strong>Selector维护的三种类型SelectionKey集合：</strong></p>
<ul>
<li>
<p><strong>已注册的键的集合(Registered key set)</strong></p>
<p>所有与选择器关联的通道所生成的键的集合称为已经注册的键的集合。并不是所有注册过的键都仍然有效。这个集合通过 <strong>keys()</strong> 方法返回，并且可能是空的。这个已注册的键的集合不是可以直接修改的；试图这么做的话将引发java.lang.UnsupportedOperationException。</p>
</li>
<li>
<p><strong>已选择的键的集合(Selected key set)</strong></p>
<p>所有与选择器关联的通道所生成的键的集合称为已经注册的键的集合。并不是所有注册过的键都仍然有效。这个集合通过 <strong>keys()</strong> 方法返回，并且可能是空的。这个已注册的键的集合不是可以直接修改的；试图这么做的话将引发java.lang.UnsupportedOperationException。</p>
</li>
<li>
<p><strong>已取消的键的集合(Cancelled key set)</strong></p>
<p>已注册的键的集合的子集，这个集合包含了 <strong>cancel()</strong> 方法被调用过的键(这个键已经被无效化)，但它们还没有被注销。这个集合是选择器对象的私有成员，因而无法直接访问。</p>
<p><strong>注意：</strong></p>
<ol>
<li>
<p>当键被取消（ 可以通过<strong>isValid( )</strong> 方法来判断）时，它将被放在相关的选择器的已取消的键的集合里。</p>
</li>
<li>
<p>注册不会立即被取消，但键会立即失效。</p>
</li>
<li>
<p>当再次调用 <strong>select( )</strong> 方法时（或者一个正在进行的select()调用结束时），已取消的键的集合中的被取消的键将被清理掉，并且相应的注销也将完成。通道会被注销，而新的SelectionKey将被返回。</p>
</li>
<li>
<p>当通道关闭时，所有相关的键会自动取消（记住，一个通道可以被注册到多个选择器上）。</p>
</li>
<li>
<p>当选择器关闭时，所有被注册到该选择器的通道都将被注销，并且相关的键将立即被无效化（取消）。一旦键被无效化，调用它的与选择相关的方法就将抛出CancelledKeyException。</p>
</li>
</ol>
</li>
</ul>
<h1 id="select方法介绍"><a class="header" href="#select方法介绍"><strong>select()方法介绍：</strong></a></h1>
<p>在刚初始化的Selector对象中，这三个集合都是空的。 <strong>通过Selector的select（）方法可以选择已经准备就绪的通道</strong> （这些通道包含你感兴趣的的事件）。比如你对读就绪的通道感兴趣，那么select（）方法就会返回读事件已经就绪的那些通道。下面是Selector几个重载的select()方法：</p>
<ul>
<li>int select()：阻塞到至少有一个通道在你注册的事件上就绪了。</li>
<li>int select(long timeout)：和select()一样，但最长阻塞时间为timeout毫秒。</li>
<li>int selectNow()：非阻塞，只要有通道就绪就立刻返回。</li>
</ul>
<h2 id="返回值解析"><a class="header" href="#返回值解析">返回值解析</a></h2>
<p><strong>select()方法返回的int值表示有多少通道已经就绪,</strong></p>
<ol>
<li>
<p>是自上次调用select()方法后有多少通道变成就绪状态</p>
</li>
<li>
<p>之前在select（）调用时进入就绪的通道不会在本次调用中被记入，</p>
</li>
<li>
<p>而在前一次select（）调用进入就绪但现在已经不再处于就绪的通道也不会被记入</p>
</li>
</ol>
<p><strong>example</strong></p>
<p>例如：首次调用select()方法，如果有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p>
<p><strong>一旦调用select()方法，并且返回值不为0时，则 可以通过调用Selector的selectedKeys()方法来访问已选择键集合</strong> 。如下：</p>
<pre><code class="language-java">Set selectedKeys = selector.selectedKeys();
Iterator keyIterator = selectedKeys.iterator();
while(keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.
    } else if (key.isConnectable()) {
        // a connection was established with a remote server.
    } else if (key.isReadable()) {
        // a channel is ready for reading
    } else if (key.isWritable()) {
        // a channel is ready for writing
    }
    keyIterator.remove();
}
</code></pre>
<h1 id="停止选择的方法"><a class="header" href="#停止选择的方法">停止选择的方法</a></h1>
<p>选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能会造成调用线程进入阻塞状态,那么我们有以下三种方式可以唤醒在select</p>
<ul>
<li><strong>wakeup()方法</strong> ：通过调用Selector对象的wakeup（）方法让处在阻塞状态的select()方法立刻返回
该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中的选择操作，那么下一次对select()方法的一次调用将立即返回。</li>
<li><strong>close()方法</strong> ：通过close（）方法关闭Selector，
该方法使得任何一个在选择操作中阻塞的线程都被唤醒（类似wakeup（）），同时使得注册到该Selector的所有Channel被注销，所有的键将被取消，但是Channel本身并不会关闭。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="阻塞io有什么弊端"><a class="header" href="#阻塞io有什么弊端">阻塞IO有什么弊端</a></h1>
<ol>
<li>建立连接与 读取连接输入 这两个过程 需要时间</li>
<li>在单线程情况下：连接需要一个个处理，效率低下</li>
<li>在多线程情况 下：如果海量连接 来到 会严重消耗 服务器线程</li>
<li>在多线程情况下，海量连接，中只有一小部分是活跃连接，大部分是无效连接，为每个连接维护一个 线程浪费服务器性能</li>
</ol>
<h1 id="非阻塞io如何改变上述情况的"><a class="header" href="#非阻塞io如何改变上述情况的">非阻塞IO如何改变上述情况的？</a></h1>
<p><strong>实现思路</strong></p>
<ol>
<li>首先所有的读写都是异步的</li>
<li>然后 把所有连接统一管理，并轮询操作系统内核 某一个 连接 是否可读可写</li>
</ol>
<p><strong>好处</strong></p>
<ol>
<li>使用单一线程 就能管理 海量 连接</li>
<li>还可针对指定连接 指定读或写事件</li>
</ol>
<p><strong>不足之处</strong></p>
<ol>
<li>
<p>当连接数过多时 在用户态 轮询 会造成 过多的系统调用而 响应延时提高</p>
<p>解决办法：让系统自己轮询：然后通知 上层用户。这就是 Selector模式 在Linux 中 <code>select poll</code></p>
</li>
<li>
<p>每次传送海量 连接FD给 内核  数据复制 也会造成延时</p>
<p>解决办法：在内核中开辟一段空间，使得所有连接FD存放至此 ：省去了 COPY FD的时间</p>
</li>
<li>
<p>每次连接可读之后：仍 需要把 数据从 网卡 到 内核内存，到用户内存 ，copy仍需要时间</p>
</li>
</ol>
<h1 id="客户端"><a class="header" href="#客户端">客户端</a></h1>
<pre><code class="language-java">package com.weisanju.ioStudy;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class SelfNioTimeClient {
    public static void main(String[] args) throws IOException {
        SocketChannel open = SocketChannel.open();
        open.connect(new InetSocketAddress(8080));
        ByteBuffer allocate = ByteBuffer.allocate(1024);

        while (true) {
            Scanner scanner = new Scanner(System.in);
            String yourName = scanner.next();
            if (&quot;quit&quot;.equals(yourName)) {
                open.close();
                System.out.println(&quot;client exit&quot;);
                return;
            }
            open.write(ByteBuffer.wrap(yourName.getBytes(StandardCharsets.UTF_8)));
            int read = open.read(allocate);
            allocate.flip();
            System.out.println(StandardCharsets.UTF_8.decode(allocate));
            allocate.clear();
        }
    }
}
</code></pre>
<h1 id="普通io复用实现思路"><a class="header" href="#普通io复用实现思路">普通IO复用实现思路</a></h1>
<pre><code class="language-java">package com.weisanju.ioStudy;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class SelfNioTimeServer {
    public static void main(String[] args) throws IOException, InterruptedException {
        List&lt;SocketChannel&gt; objects = new LinkedList&lt;&gt;();
        ByteBuffer allocate = ByteBuffer.allocate(1024);

        ServerSocketChannel open = ServerSocketChannel.open();

        open.bind(new InetSocketAddress(8080));
        open.configureBlocking(false);


        //设置为阻塞
        while (true) {
            SocketChannel accept = open.accept();

            System.out.println(String.format(&quot;currentConnections:%d&quot;,objects.size()));

            if (accept!=null) {
                accept.configureBlocking(false);
                objects.add(accept);
            }else{
                Thread.sleep(2000);
            }

            for (SocketChannel object : objects) {
                if (object.isConnected()) {
                    int read = 0;
                    try {
                        read = object.read(allocate);
                    } catch (IOException e) {
                        System.out.println(&quot;client exception exits&quot;);
                        objects.remove(object);
                    }
                    System.out.println(&quot;already read：&quot;+read);
                    if (read&gt;0) {
                        allocate.flip();
                        String name = Charset.defaultCharset().decode(allocate).toString();
                        String format = String.format(&quot;hello:%s,now time is  %s&quot;, name, LocalDateTime.now());
                        object.write(StandardCharsets.UTF_8.encode(format));
                        allocate.clear();
                    }else if(read &lt; 0){
                        System.out.println(&quot;client normal exits&quot;);
                        objects.remove(object);
                    }
                }else{
                    System.out.println(&quot;client normal exits&quot;);
                    objects.remove(object);
                }
            }
        }

    }
}
</code></pre>
<h1 id="nioselector实现思路"><a class="header" href="#nioselector实现思路">NIOSelector实现思路</a></h1>
<pre><code class="language-java">package com.weisanju.ioStudy;


import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

public class NioTimeServer {
    public static void main(String[] args) throws IOException, InterruptedException {
        ByteBuffer allocate = ByteBuffer.allocate(1024);
        Selector selector = Selector.open();
        ServerSocketChannel open = ServerSocketChannel.open();
        open.bind(new InetSocketAddress(8080));
        open.configureBlocking(false);

        open.register(selector, SelectionKey.OP_ACCEPT);
        //设置为阻塞
        while (selector.select() &gt;= 0) {
            System.out.println(String.format(&quot;currentConnections:%d&quot;, selector.keys().size() - 1));
            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
            for (SelectionKey selectedKey : selectionKeys) {
                if (selectedKey.isAcceptable()) {
                    SocketChannel accept = ((ServerSocketChannel)selectedKey.channel()).accept();
                    accept.configureBlocking(false);
                    accept.register(selector, SelectionKey.OP_READ);
                } else {
                    SocketChannel channel = (SocketChannel) selectedKey.channel();
                    int read = 0;
                    try {
                        read = channel.read(allocate);
                    } catch (IOException e) {
                        System.out.println(&quot;client exception exits&quot;);
                        read = -1;
                        selectedKey.cancel();
                    }
                    System.out.println(&quot;already read：&quot; + read);
                    if (read &gt; 0) {
                        allocate.flip();
                        String name = Charset.defaultCharset().decode(allocate).toString();
                        String format = String.format(&quot;hello:%s,now time is  %s&quot;, name, LocalDateTime.now());
                        channel.write(StandardCharsets.UTF_8.encode(format));
                        allocate.clear();
                    } else if (read &lt; 0) {
                        System.out.println(&quot;client normal exits&quot;);
                        selectedKey.cancel();
                    }
                }
            }
            selectionKeys.clear();
        }

    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-9"><a class="header" href="#前言-9">前言</a></h1>
<p>编码 -&gt; 将 字符串转换 成 字节数组</p>
<p>解码 -&gt; 将字节数组转换成 字符串</p>
<h1 id="获取所有支持的字符集"><a class="header" href="#获取所有支持的字符集">获取所有支持的字符集</a></h1>
<pre><code>Charset.availableCharsets();
</code></pre>
<h1 id="编码与解码"><a class="header" href="#编码与解码">编码与解码</a></h1>
<blockquote>
<p>编码与解码：可以手动获取一个 Decoder</p>
</blockquote>
<pre><code class="language-java">ByteBuffer sdfsfdds士大夫但是 = StandardCharsets.UTF_8.encode(&quot;sdfsfdds士大夫但是&quot;);

CharBuffer decode = StandardCharsets.UTF_8.decode(sdfsfdds士大夫但是);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-12"><a class="header" href="#简介-12">简介</a></h1>
<p>Java I/O 支持包含在 java.io 和 java.nio 包中。</p>
<p>这些软件包包括以下功能：</p>
<ul>
<li>Input and output through data streams, serialization and the file system.</li>
<li>Charsets, decoders, and encoders, for translating between bytes and Unicode characters.</li>
<li>Access to file, file attributes and file systems.</li>
<li>APIs for building scalable servers using asynchronous or multiplexed, non-blocking I/O.</li>
</ul>
<h1 id="fileio-nio20-feature"><a class="header" href="#fileio-nio20-feature">FileI/O NIO2.0 feature</a></h1>
<p><strong>前言</strong></p>
<p>java.nio.file 包及其相关包 java.nio.file.attribute 为文件 I/O 和访问默认文件系统提供全面支持。</p>
<p>尽管 API 有很多类，但您只需关注几个入口点。</p>
<p><strong>Path</strong></p>
<p>本教程首先询问  <a href="https://docs.oracle.com/javase/tutorial/essential/io/path.html">what is a path?</a>  然后，</p>
<p>引入了 java.nio.file 包中的主要入口点 Path 类。</p>
<p>Path 类中与句法操作相关的方法。</p>
<p><strong>Files</strong></p>
<p>然后，本教程转到包中的另一个主要类 Files 类，其中包含处理文件操作的方法。</p>
<p>首先，介绍了许多文件操作共有的一些概念,本教程随后介绍了<a href="https://docs.oracle.com/javase/tutorial/essential/io/check.html">checking</a>, <a href="https://docs.oracle.com/javase/tutorial/essential/io/delete.html">deleting</a>, <a href="https://docs.oracle.com/javase/tutorial/essential/io/copy.html">copying</a>, and <a href="https://docs.oracle.com/javase/tutorial/essential/io/move.html">moving</a> files.</p>
<p><strong>元数据管理</strong></p>
<p>本教程展示了如何管理<a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html">元数据</a>，然后再介绍<a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html">文件 I/O</a> 和<a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html">目录 I/O</a>。</p>
<p>解释了<a href="https://docs.oracle.com/javase/tutorial/essential/io/rafs.html">随机访问文件</a>，issues specific to <a href="https://docs.oracle.com/javase/tutorial/essential/io/links.html">symbolic and hard links</a> are examined.</p>
<p><strong>遍历目录树</strong></p>
<p>接下来，将介绍一些非常强大但更高级的主题。</p>
<p>首先，演示了<a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html">递归遍历文件树</a>的能力，然后是有关如何使用<a href="https://docs.oracle.com/javase/tutorial/essential/io/find.html">通配符搜索文件</a>的信息。</p>
<p>接下来，将解释和<a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html">演示如何观察目录的变化</a>。</p>
<h1 id="总结-18"><a class="header" href="#总结-18">总结</a></h1>
<p><code>java.io</code> 包包含许多类，您的程序可以使用这些类来读取和写入数据。</p>
<p>大多数类实现顺序访问流，顺序访问流可以分为两组 <strong>读写字节的</strong>和<strong>读写 Unicode 字符的</strong></p>
<p>每个顺序访问流都有其特殊性，例如读取或写入文件、在读取或写入数据时过滤数据或序列化对象。</p>
<p><code>java.nio.file</code> 包为文件和文件系统 I/O 提供了广泛的支持。</p>
<p>这是一个非常全面的API，但关键的入口点如下：</p>
<ul>
<li><code>Path</code> 类具有操作路径的方法.</li>
<li><code>Files</code> 类具有文件操作的方法，例如移动、复制、删除，以及检索和设置文件属性的方法。.</li>
<li><code>FileSystem</code> 类有多种获取文件系统信息的方法.</li>
</ul>
<p>更多关于 NIO.2 的信息可以在 <a href="http://openjdk.java.net/projects/nio/">OpenJDK: NIO</a> 项目网站上找到。</p>
<p>该站点包含 NIO.2 提供的特性的资源，这些特性超出了本教程的范围，例如多播、异步 I/O 和创建您自己的文件系统实现。</p>
<h1 id="参考链接-2"><a class="header" href="#参考链接-2">参考链接</a></h1>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/io/index.html">Oracle官方教程</a></p>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/io/enhancements.html#pre">Enhancements in Java I/O</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="links-symbolic-or-otherwise"><a class="header" href="#links-symbolic-or-otherwise">Links, Symbolic or Otherwise</a></h1>
<p>如前所述，<code>java.nio.file</code> 包，特别是 <code>Path</code> 类，是“链接感知的”。</p>
<p>每个“Path”方法要么检测遇到符号链接时要做什么，要么提供一个选项，使您可以配置遇到符号链接时的行为。</p>
<p>到目前为止的讨论是关于 <a href="https://docs.oracle.com/javase/tutorial/essential/io/path.html#symlink">符号或 <em>软</em> 链接</a>，但一些文件系统也支持硬链接。 </p>
<p><em>硬链接</em>比符号链接更具限制性，如下所示：-</p>
<ul>
<li>
<p>链接的目标必须存在。 </p>
</li>
<li>
<p>目录上通常不允许使用硬链接。.</p>
</li>
<li>
<p>硬链接不允许跨分区或卷。因此，它们不能跨文件系统存在。</p>
</li>
<li>
<p>硬链接的外观和行为都与普通文件相似，因此很难找到它们。</p>
</li>
<li>
<p>就所有意图和目的而言，硬链接是与原始文件相同的实体。它们具有相同的文件权限、时间戳等。</p>
<p>所有属性都相同。</p>
</li>
</ul>
<p>由于这些限制，硬链接不像符号链接那样经常使用，但是<code>Path</code> 方法可以与硬链接无缝协作。</p>
<p>几种方法专门处理链接，并在以下部分中介绍：:</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/links.html#symLink">Creating a Symbolic Link</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/links.html#hardLink">Creating a Hard Link</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/links.html#detect">Detecting a Symbolic Link</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/links.html#read">Finding the Target of a Link</a></li>
</ul>
<h1 id="creating-a-symbolic-link"><a class="header" href="#creating-a-symbolic-link">Creating a Symbolic Link</a></h1>
<p>如果您的文件系统支持它，您可以使用 [<code>createSymbolicLink(Path, Path, FileAttribute)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio /file/Files.html#createSymbolicLink-java.nio.file.Path-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-) 方法。</p>
<p>第二个“Path”参数代表目标文件或目录，可能存在也可能不存在。</p>
<p>以下代码片段创建了一个具有默认权限的符号链接</p>
<pre><code>Path newLink = ...;
Path target = ...;
try {
    Files.createSymbolicLink(newLink, target);
} catch (IOException x) {
    System.err.println(x);
} catch (UnsupportedOperationException x) {
    // Some file systems do not support symbolic links.
    System.err.println(x);
}
</code></pre>
<p><code>FileAttributes</code> 可变参数使您能够指定在创建链接时自动设置的初始文件属性。</p>
<p>但是，此参数旨在供将来使用，目前尚未实现。 </p>
<h1 id="creating-a-hard-link"><a class="header" href="#creating-a-hard-link">Creating a Hard Link</a></h1>
<p>您可以使用 [<code>createLink(Path, Path)</code>](https://docs.oracle.com/javase/8/docs/api/java/ nio/file/Files.html#createLink-java.nio.file.Path-java.nio.file.Path-) 方法。</p>
<p>第二个 <code>Path</code> 参数定位现有文件，它必须存在，否则会抛出 <code>NoSuchFileException</code>。</p>
<p>以下代码片段显示了如何创建链接：</p>
<pre><code class="language-java">Path newLink = ...;
Path existingFile = ...;
try {
    Files.createLink(newLink, existingFile);
} catch (IOException x) {
    System.err.println(x);
} catch (UnsupportedOperationException x) {
    // Some file systems do not
    // support adding an existing
    // file to a directory.
    System.err.println(x);
}
</code></pre>
<h1 id="detecting-a-symbolic-link"><a class="header" href="#detecting-a-symbolic-link">Detecting a Symbolic Link</a></h1>
<p>要确定一个 <code>Path</code> 实例是否是符号链接，可以使用 [<code>isSymbolicLink(Path)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/ Files.html#isSymbolicLink-java.nio.file.Path-) 方法。</p>
<p>以下代码片段显示了如何：</p>
<pre><code>Path file = ...;
boolean isSymbolicLink =
    Files.isSymbolicLink(file);
</code></pre>
<p>For more information, see <a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html">Managing Metadata</a>.</p>
<h1 id="finding-the-target-of-a-link"><a class="header" href="#finding-the-target-of-a-link">Finding the Target of a Link</a></h1>
<p>您可以使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readSymbolicLink"><code>readSymbolicLink(Path)</code></a> 获取符号链接的目标方法，如下</p>
<pre><code>
Path link = ...;
try {
    System.out.format(&quot;Target of link&quot; +
        &quot; '%s' is '%s'%n&quot;, link,
        Files.readSymbolicLink(link));
} catch (IOException x) {
    System.err.println(x);
}
</code></pre>
<p>如果 <code>Path</code> 不是符号链接，则此方法会抛出一个 <code>NotLinkException</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="random-access-files"><a class="header" href="#random-access-files">Random Access Files</a></h1>
<p><em>随机访问文件</em>允许对文件内容进行非顺序或随机访问。</p>
<p>要随机访问文件，您可以打开文件，查找特定位置，然后读取或写入该文件。</p>
<p>此功能可通过 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html"><code>SeekableByteChannel</code></a> 接口实现。 <code>SeekableByteChannel</code> 接口使用当前位置的概念扩展了通道 I/O。</p>
<p>方法使您能够设置或查询位置，然后您可以从该位置读取数据或将数据写入该位置。 </p>
<p>API 由几个易于使用的方法组成：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#position--"><code>position</code></a> – 返回channel的当前位置 </li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#position-long-"><code>position(long)</code></a> – 设置channel位置</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#read-java.nio.ByteBuffer-"><code>read(ByteBuffer)</code></a> – Reads bytes into the buffer from the channel</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#write-java.nio.ByteBuffer-"><code>write(ByteBuffer)</code></a> – Writes bytes from the buffer to the channel</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/SeekableByteChannel.html#truncate-long-"><code>truncate(long)</code></a> – 截断连接到通道的文件（或其他实体）</li>
</ul>
<p><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#channelio">使用通道 I/O 读取和写入文件</a> 显示 <code>Path.newByteChannel</code> 方法返回一个</p>
<p><code>SeekableByteChannel</code>。</p>
<p>在默认文件系统上，您可以按原样使用该通道，也可以将其转换为 [<code>FileChannel</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/channels /FileChannel.html) 让您可以访问更高级的功能，例如将文件区域直接映射到内存以加快访问速度、锁定文件区域或从绝对位置读取和写入字节而不影响通道的当前位置</p>
<p>The following code snippet opens a file for both reading and writing by using one of the <code>newByteChannel</code> methods.</p>
<p>以下代码片段使用“newByteChannel”方法之一打开一个文件以供读取和写入。</p>
<p>返回的 <code>SeekableByteChannel</code> 被转换为 <code>FileChannel</code>。</p>
<p>然后，从文件的开头读取 12 个字节，以及字符串“我在这里！” 写在那个位置。</p>
<p>将文件中的当前位置移到末尾，并附加从开头开始的 12 个字节。</p>
<p>最后附加字符串：“我在这里！”</p>
<pre><code class="language-java">String s = &quot;I was here!\n&quot;;
byte data[] = s.getBytes();
ByteBuffer out = ByteBuffer.wrap(data);

ByteBuffer copy = ByteBuffer.allocate(12);

try (FileChannel fc = (FileChannel.open(file, READ, WRITE))) {
    // Read the first 12
    // bytes of the file.
    int nread;
    do {
        nread = fc.read(copy);
    } while (nread != -1 &amp;&amp; copy.hasRemaining());

    // Write &quot;I was here!&quot; at the beginning of the file.
    fc.position(0);
    while (out.hasRemaining())
        fc.write(out);
    out.rewind();

    // Move to the end of the file.  Copy the first 12 bytes to
    // the end of the file.  Then write &quot;I was here!&quot; again.
    long length = fc.size();
    fc.position(length-1);
    copy.flip();
    while (copy.hasRemaining())
        fc.write(copy);
    while (out.hasRemaining())
        fc.write(out);
} catch (IOException x) {
    System.out.println(&quot;I/O Exception: &quot; + x);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="legacy-file-io-code"><a class="header" href="#legacy-file-io-code">Legacy File I/O Code</a></h1>
<p>与遗留代码的互操作性</p>
<p>在 Java SE 7 版本之前，java.io.File 类是用于文件 I/O 的机制，但它有几个缺点。</p>
<ul>
<li>
<p>许多方法在失败时不会抛出异常，因此无法获得有用的错误消息。</p>
<p>例如，如果文件删除失败，程序会收到“删除失败”，但不知道是因为文件不存在、用户没有权限还是存在其他问题。 .</p>
</li>
<li>
<p><code>rename</code> 方法在跨平台上无法一致地工作。.</p>
</li>
<li>
<p>没有对符号链接的真正支持。.</p>
</li>
<li>
<p>需要对元数据提供更多支持，例如文件权限、文件所有者和其他安全属性。.</p>
</li>
<li>
<p>访问文件元数据效率低下。.</p>
</li>
<li>
<p>许多 <code>File</code> 方法没有扩展。</p>
<p>通过服务器请求大型目录列表可能会导致挂起。</p>
<p>大目录还可能导致内存资源问题，从而导致拒绝服务。.</p>
</li>
<li>
<p>如果存在循环符号链接，则无法编写可靠的代码来递归遍历文件树并做出适当的响应</p>
</li>
</ul>
<p>也许您有使用 <code>java.io.File</code> 的遗留代码，并希望利用 <code>java.nio.file.Path</code> 功能对您的代码影响最小。</p>
<p><code>java.io.File</code> 类提供了 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/File.html#toPath--"><code>toPath</code></a> 方法，它</p>
<p>将旧式 <code>File</code> 实例转换为 <code>java.nio.file.Path</code> 实例，如下所示：</p>
<pre><code>Path input = file.toPath();
</code></pre>
<p>然后，您可以利用“Path”类可用的丰富功能集。</p>
<p>例如，假设您有一些删除文件的代码：</p>
<pre><code>file.delete();
</code></pre>
<p>您可以修改此代码以使用 <code>Files.delete</code> 方法:</p>
<pre><code>Path fp = file.toPath();
Files.delete(fp);
</code></pre>
<p>Conversely, the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#toFile--"><code>Path.toFile</code></a> method constructs a <code>java.io.File</code> object for a <code>Path</code> object.</p>
<h1 id="mapping-javaiofile-functionality-to-javaniofile"><a class="header" href="#mapping-javaiofile-functionality-to-javaniofile">Mapping java.io.File Functionality to java.nio.file</a></h1>
<p>由于文件 I/O 的 Java 实现已在 Java SE 7 版本中完全重新架构，因此您无法将一种方法替换为另一种方法。</p>
<p>如果您想使用 java.nio.file 包提供的丰富功能，最简单的解决方案是使用 File.toPath 方法，如上一节中建议的那样。</p>
<p>但是，如果您不想使用该方法或它不足以满足您的需要，则必须重写文件 I/O 代码。</p>
<p>两个 API 之间没有一一对应关系，但下表让您大致了解 java.io.File API 中的哪些功能映射到 java.nio.file API 中的功能，并告诉您可以在哪里</p>
<table><thead><tr><th>java.io.File Functionality</th><th>java.nio.file Functionality</th><th>Tutorial Coverage</th></tr></thead><tbody>
<tr><td><code>java.io.File</code></td><td><code>java.nio.file.Path</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathClass.html">The Path Class</a></td></tr>
<tr><td><code>java.io.RandomAccessFile</code></td><td>The <code>SeekableByteChannel</code> functionality.</td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/rafs.html">Random Access Files</a></td></tr>
<tr><td><code>File.canRead</code>, <code>canWrite</code>, <code>canExecute</code></td><td><code>Files.isReadable</code>, <code>Files.isWritable</code>, and <code>Files.isExecutable</code>. On UNIX file systems, the <a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html">Managing Metadata (File and File Store Attributes)</a> package is used to check the nine file permissions.</td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/check.html">Checking a File or Directory</a> <a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html">Managing Metadata</a></td></tr>
<tr><td><code>File.isDirectory()</code>, <code>File.isFile()</code>, and <code>File.length()</code></td><td><code>Files.isDirectory(Path, LinkOption...)</code>, <code>Files.isRegularFile(Path, LinkOption...)</code>, and <code>Files.size(Path)</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html">Managing Metadata</a></td></tr>
<tr><td><code>File.lastModified()</code> and <code>File.setLastModified(long)</code></td><td><code>Files.getLastModifiedTime(Path, LinkOption...)</code> and <code>Files.setLastMOdifiedTime(Path, FileTime)</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html">Managing Metadata</a></td></tr>
<tr><td>The <code>File</code> methods that set various attributes: <code>setExecutable</code>, <code>setReadable</code>, <code>setReadOnly</code>, <code>setWritable</code></td><td>These methods are replaced by the <code>Files</code> method <code>setAttribute(Path, String, Object, LinkOption...)</code>.</td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html">Managing Metadata</a></td></tr>
<tr><td><code>new File(parent, &quot;newfile&quot;)</code></td><td><code>parent.resolve(&quot;newfile&quot;)</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html">Path Operations</a></td></tr>
<tr><td><code>File.renameTo</code></td><td><code>Files.move</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/move.html">Moving a File or Directory</a></td></tr>
<tr><td><code>File.delete</code></td><td><code>Files.delete</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/delete.html">Deleting a File or Directory</a></td></tr>
<tr><td><code>File.createNewFile</code></td><td><code>Files.createFile</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#createFile">Creating Files</a></td></tr>
<tr><td><code>File.deleteOnExit</code></td><td>Replaced by the <code>DELETE_ON_CLOSE</code> option specified in the <code>createFile</code> method.</td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#createFile">Creating Files</a></td></tr>
<tr><td><code>File.createTempFile</code></td><td><code>Files.createTempFile(Path, String, FileAttributes&lt;?&gt;)</code>, <code>Files.createTempFile(Path, String, String, FileAttributes&lt;?&gt;)</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#createFile">Creating Files</a> <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#createStream">Creating and Writing a File by Using Stream I/O</a> <a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#channelio">Reading and Writing Files by Using Channel I/O</a></td></tr>
<tr><td><code>File.exists</code></td><td><code>Files.exists</code> and <code>Files.notExists</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/check.html">Verifying the Existence of a File or Directory</a></td></tr>
<tr><td><code>File.compareTo</code> and <code>equals</code></td><td><code>Path.compareTo</code> and <code>equals</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#compare">Comparing Two Paths</a></td></tr>
<tr><td><code>File.getAbsolutePath</code> and <code>getAbsoluteFile</code></td><td><code>Path.toAbsolutePath</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#convert">Converting a Path</a></td></tr>
<tr><td><code>File.getCanonicalPath</code> and <code>getCanonicalFile</code></td><td><code>Path.toRealPath</code> or <code>normalize</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#convert">Converting a Path (<code>toRealPath</code>)</a> <a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#normal">Removing Redundancies From a Path (<code>normalize</code>)</a></td></tr>
<tr><td><code>File.toURI</code></td><td><code>Path.toURI</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#convert">Converting a Path</a></td></tr>
<tr><td><code>File.isHidden</code></td><td><code>Files.isHidden</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#info">Retrieving Information About the Path</a></td></tr>
<tr><td><code>File.list</code> and <code>listFiles</code></td><td><code>Path.newDirectoryStream</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#listdir">Listing a Directory's Contents</a></td></tr>
<tr><td><code>File.mkdir</code> and <code>mkdirs</code></td><td><code>Files.createDirectory</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#create">Creating a Directory</a></td></tr>
<tr><td><code>File.listRoots</code></td><td><code>FileSystem.getRootDirectories</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#listall">Listing a File System's Root Directories</a></td></tr>
<tr><td><code>File.getTotalSpace</code>, <code>File.getFreeSpace</code>, <code>File.getUsableSpace</code></td><td><code>FileStore.getTotalSpace</code>, <code>FileStore.getUnallocatedSpace</code>, <code>FileStore.getUsableSpace</code>, <code>FileStore.getTotalSpace</code></td><td><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#store">File Store Attributes</a></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-metadata"><a class="header" href="#managing-metadata">Managing Metadata</a></h1>
<p>File and File Store Attributes</p>
<p><em>元数据</em>的定义是“关于其他数据的数据”。</p>
<p>对于文件系统，数据包含在其文件和目录中，元数据跟踪有关每个对象的信息</p>
<p>它是常规文件、目录还是链接？</p>
<p>它的大小、创建日期、上次修改日期、文件所有者、组所有者和访问权限是多少？</p>
<p>文件系统的元数据通常称为其<em>文件属性</em>。 </p>
<p><code>Files</code> 类包括可用于获取文件的单个属性或设置属性的方法。</p>
<table><thead><tr><th>Methods</th><th>Comment</th></tr></thead><tbody>
<tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#size-java.nio.file.Path-"><code>size(Path)</code></a></td><td>以字节为单位返回指定文件的大小。</td></tr>
<tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isDirectory-java.nio.file.Path-java.nio.file.LinkOption...-"><code>isDirectory(Path, LinkOption)</code></a></td><td>如果指定的 <code>Path</code> 定位的文件是目录，则返回 true。</td></tr>
<tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isRegularFile-java.nio.file.Path-java.nio.file.LinkOption...-"><code>isRegularFile(Path, LinkOption...)</code></a></td><td>如果指定的 <code>Path</code> 定位到一个普通文件，则返回 true。</td></tr>
<tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isSymbolicLink-java.nio.file.Path-"><code>isSymbolicLink(Path)</code></a></td><td>如果指定的 <code>Path</code> 定位到一个符号链接文件，则返回 true。</td></tr>
<tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isHidden-java.nio.file.Path-"><code>isHidden(Path)</code></a></td><td>如果指定的 <code>Path</code> 找到被文件系统视为隐藏的文件，则返回 true。</td></tr>
<tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getLastModifiedTime-java.nio.file.Path-java.nio.file.LinkOption...-"><code>getLastModifiedTime(Path, LinkOption...)</code></a> <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setLastModifiedTime-java.nio.file.Path-java.nio.file.attribute.FileTime-"><code>setLastModifiedTime(Path, FileTime)</code></a></td><td>返回或设置指定文件的最后修改时间</td></tr>
<tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getOwner-java.nio.file.Path-java.nio.file.LinkOption...-"><code>getOwner(Path, LinkOption...)</code></a> <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setOwner-java.nio.file.Path-java.nio.file.attribute.UserPrincipal-"><code>setOwner(Path, UserPrincipal)</code></a></td><td>Returns or sets the owner of the file.</td></tr>
<tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getPosixFilePermissions-java.nio.file.Path-java.nio.file.LinkOption...-"><code>getPosixFilePermissions(Path, LinkOption...)</code></a> <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setPosixFilePermissions-java.nio.file.Path-java.util.Set-"><code>setPosixFilePermissions(Path, Set)</code></a></td><td>Returns or sets a file's POSIX file permissions.</td></tr>
<tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getAttribute-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-"><code>getAttribute(Path, String, LinkOption...)</code></a> <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-"><code>setAttribute(Path, String, Object, LinkOption...)</code></a></td><td>Returns or sets the value of a file attribute.</td></tr>
</tbody></table>
<p>如果程序大约同时需要多个文件属性，则使用检索单个属性的方法可能效率低下</p>
<p>重复访问文件系统以检索单个属性会对性能产生不利影响。</p>
<p>出于这个原因，<code>Files</code> 类提供了两个 <code>readAttributes</code> 方法来在一次批量操作中获取文件的属性。</p>
<table><thead><tr><th>Method</th><th>Comment</th></tr></thead><tbody>
<tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAttributes-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-"><code>readAttributes(Path, String, LinkOption...)</code></a></td><td>Reads a file's attributes as a bulk operation. The <code>String</code> parameter identifies the attributes to be read.</td></tr>
<tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-"><code>readAttributes(Path, Class, LinkOption...)</code></a></td><td>Reads a file's attributes as a bulk operation. The <code>Class&lt;A&gt;</code> parameter is the type of attributes requested and the method returns an object of that class.</td></tr>
</tbody></table>
<p>在展示 readAttributes 方法的示例之前，应该提到不同的文件系统对于应该跟踪哪些属性有不同的概念。</p>
<p>出于这个原因，相关的文件属性被组合到视图中。</p>
<p>视图映射到特定的文件系统实现，例如 POSIX 或 DOS，或者映射到公共功能，例如文件所有权。</p>
<p>The supported views are as follows:</p>
<ul>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/BasicFileAttributeView.html"><code>BasicFileAttributeView</code></a> </p>
<ul>
<li>提供所有文件系统实现需要支持的基本属性的视图。</li>
</ul>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/DosFileAttributeView.html"><code>DosFileAttributeView</code></a> </p>
<ul>
<li>使用支持 DOS 属性的文件系统支持的标准四位扩展基本属性视图。</li>
</ul>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFileAttributeView.html"><code>PosixFileAttributeView</code></a></p>
<ul>
<li>
<p>使用支持 POSIX 系列标准的文件系统（如 UNIX）支持的属性扩展基本属性视图。</p>
<p>这些属性包括文件所有者、组所有者和九个相关的访问权限。</p>
</li>
</ul>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/FileOwnerAttributeView.html"><code>FileOwnerAttributeView</code></a></p>
<ul>
<li>任何支持文件所有者概念的文件系统实现都支持。</li>
</ul>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/AclFileAttributeView.html"><code>AclFileAttributeView</code></a> </p>
<ul>
<li>支持读取或更新文件的访问控制列表 (ACL)。</li>
<li>支持 NFSv4 ACL 模型。</li>
<li>也可能支持具有到 NFSv4 模型的明确定义的映射的任何 ACL 模型，例如 Windows ACL 模型。</li>
</ul>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/UserDefinedFileAttributeView.html"><code>UserDefinedFileAttributeView</code></a> </p>
<ul>
<li>启用对用户定义的元数据的支持。</li>
<li>该视图可以映射到系统支持的任何扩展机制。</li>
<li>例如，在 Solaris OS 中，您可以使用此视图来存储文件的 MIME 类型。</li>
</ul>
</li>
</ul>
<p>一个特定的文件系统实现可能只支持基本的文件属性视图，或者它可能支持这些文件属性视图中的几个。</p>
<p>文件系统实现可能支持未包含在此 API 中的其他属性视图。</p>
<p>在大多数情况下，您不必直接处理任何 FileAttributeView 接口。 </p>
<p>（如果您确实需要直接使用 FileAttributeView，则可以通过 getFileAttributeView(Path, Class, LinkOption...) 方法访问它。）</p>
<p><code>readAttributes</code> 方法使用泛型，可用于读取任何文件属性视图的属性。</p>
<p>本页其余部分的示例使用 <code>readAttributes</code> 方法。</p>
<p>The remainder of this section covers the following topics:</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#basic">Basic File Attributes</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#time">Setting Time Stamps</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#dos">DOS File Attributes</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#posix">POSIX File Permissions</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#lookup">Setting a File or Group Owner</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#user">User-Defined File Attributes</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#store">File Store Attributes</a></li>
</ul>
<h1 id="basic-file-attributes"><a class="header" href="#basic-file-attributes">Basic File Attributes</a></h1>
<p>如前所述，要读取文件的基本属性，您可以使用“Files.readAttributes”方法之一，该方法在一次批量操作中读取所有基本属性。</p>
<p>这比单独访问文件系统以读取每个单独的属性要高效得多。 </p>
<p>varargs 参数当前支持 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/LinkOption.html"><code>LinkOption</code></a> 枚举，<code>NOFOLLOW_LINKS</code>。</p>
<p>当您不希望遵循符号链接时，请使用此选项。</p>
<hr />
<p><strong>关于时间戳的一句话：</strong> 基本属性集包括三个时间戳：<code>creationTime</code>、<code>lastModifiedTime</code> 和<code>lastAccessTime</code>。</p>
<p>在特定实现中可能不支持这些时间戳中的任何一个，在这种情况下，相应的访问器方法返回特定于实现的值。</p>
<p>如果支持，时间戳将作为 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/FileTime.html"><code>FileTime</code></a> 对象返回。</p>
<hr />
<p>以下代码片段读取并打印给定文件的基本文件属性，并使用 [<code>BasicFileAttributes</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file /attribute/BasicFileAttributes.html) 类。</p>
<pre><code class="language-java">Path file = ...;
BasicFileAttributes attr = Files.readAttributes(file, BasicFileAttributes.class);

System.out.println(&quot;creationTime: &quot; + attr.creationTime());
System.out.println(&quot;lastAccessTime: &quot; + attr.lastAccessTime());
System.out.println(&quot;lastModifiedTime: &quot; + attr.lastModifiedTime());

System.out.println(&quot;isDirectory: &quot; + attr.isDirectory());
System.out.println(&quot;isOther: &quot; + attr.isOther());
System.out.println(&quot;isRegularFile: &quot; + attr.isRegularFile());
System.out.println(&quot;isSymbolicLink: &quot; + attr.isSymbolicLink());
System.out.println(&quot;size: &quot; + attr.size());
</code></pre>
<p>除了此示例中显示的访问器方法之外，还有一个 <code>fileKey</code> 方法，该方法返回唯一标识文件的对象，或者如果没有文件键可用则返回 <code>null</code>。 </p>
<h2 id="setting-time-stamps"><a class="header" href="#setting-time-stamps">Setting Time Stamps</a></h2>
<p>The following code snippet sets the last modified time in milliseconds:</p>
<pre><code class="language-java">Path file = ...;
BasicFileAttributes attr =
    Files.readAttributes(file, BasicFileAttributes.class);
long currentTime = System.currentTimeMillis();
FileTime ft = FileTime.fromMillis(currentTime);
Files.setLastModifiedTime(file, ft);
}
</code></pre>
<h1 id="dos-file-attributes"><a class="header" href="#dos-file-attributes">DOS File Attributes</a></h1>
<p>DOS 文件属性也受 DOS 以外的文件系统支持，例如 Samba。</p>
<p>以下代码段使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/DosFileAttributes.html"><code>DosFileAttributes</code></a> 类的方法。 </p>
<pre><code>Path file = ...;
try {
    DosFileAttributes attr =
        Files.readAttributes(file, DosFileAttributes.class);
    System.out.println(&quot;isReadOnly is &quot; + attr.isReadOnly());
    System.out.println(&quot;isHidden is &quot; + attr.isHidden());
    System.out.println(&quot;isArchive is &quot; + attr.isArchive());
    System.out.println(&quot;isSystem is &quot; + attr.isSystem());
} catch (UnsupportedOperationException x) {
    System.err.println(&quot;DOS file&quot; +
        &quot; attributes not supported:&quot; + x);
}
</code></pre>
<p>但是，您可以使用 [<code>setAttribute(Path, String, Object, LinkOption...)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/ file/Files.html#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-) 方法，如下：</p>
<pre><code class="language-java">Path file = ...;
Files.setAttribute(file, &quot;dos:hidden&quot;, true);
</code></pre>
<h1 id="posix-file-permissions"><a class="header" href="#posix-file-permissions">POSIX File Permissions</a></h1>
<p><em>POSIX</em> 是 Portable Operating System Interface for UNIX 的首字母缩写，是一组 IEEE 和 ISO 标准，旨在确保不同风格的 UNIX 之间的互操作性。</p>
<p>如果程序符合这些 POSIX 标准，它应该很容易移植到其他符合 POSIX 的操作系统。</p>
<p>除了文件所有者和组所有者之外，POSIX 还支持九种文件权限：文件所有者、同一组成员和“其他人”的读、写和执行权限。</p>
<p>以下代码片段读取给定文件的 POSIX 文件属性并将它们打印到标准输出。</p>
<p>该代码使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFileAttributes.html"><code>PosixFileAttributes</code></a> 类中的方法。</p>
<pre><code class="language-java">Path file = ...;
PosixFileAttributes attr =
    Files.readAttributes(file, PosixFileAttributes.class);
System.out.format(&quot;%s %s %s%n&quot;,
    attr.owner().getName(),
    attr.group().getName(),
    PosixFilePermissions.toString(attr.permissions()));
</code></pre>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFilePermissions.html"><code>PosixFilePermissions</code></a> helper 类提供了几个有用的方法，如下：</p>
<ul>
<li><code>toString</code> 方法，在前面的代码片段中使用，将文件权限转换为字符串（例如，<code>rw-r--r--</code>）。</li>
<li><code>fromString</code> 方法接受一个表示文件权限的字符串并构造一个文件权限的 <code>Set</code>。</li>
<li><code>asFileAttribute</code> 方法接受文件权限的 <code>Set</code> 并构造一个可以传递给 <code>Path.createFile</code> 或 <code>Path.createDirectory</code> 方法的文件属性。</li>
</ul>
<p>以下代码片段从一个文件中读取属性并创建一个新文件，将原始文件中的属性分配给新文件：</p>
<pre><code class="language-java">Path sourceFile = ...;
Path newFile = ...;
PosixFileAttributes attrs =
    Files.readAttributes(sourceFile, PosixFileAttributes.class);
FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; attr =
    PosixFilePermissions.asFileAttribute(attrs.permissions());
Files.createFile(file, attr);
</code></pre>
<p><code>asFileAttribute</code> 方法将权限包装为一个 <code>FileAttribute</code>。</p>
<p>然后代码尝试创建一个具有这些权限的新文件。</p>
<p>请注意，<code>umask</code> 也适用，因此新文件可能比请求的权限更安全。</p>
<p>要将文件的权限设置为表示为硬编码字符串的值，您可以使用以下代码：</p>
<pre><code>Path file = ...;
Set&lt;PosixFilePermission&gt; perms =
    PosixFilePermissions.fromString(&quot;rw-------&quot;);
FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; attr =
    PosixFilePermissions.asFileAttribute(perms);
Files.setPosixFilePermissions(file, perms);
</code></pre>
<p><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Chmod.java"><code>Chmod</code></a> 示例以类似于 <code>chmod</code> 实用程序的方式递归更改文件的权限。</p>
<h2 id="setting-a-file-or-group-owner"><a class="header" href="#setting-a-file-or-group-owner">Setting a File or Group Owner</a></h2>
<p>要将名称转换为对象，您可以将其存储为文件所有者或组所有者</p>
<p>您可以使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/UserPrincipalLookupService.html"><code>UserPrincipalLookupService</code></a> 服务。</p>
<p>此服务将名称或组名称作为字符串查找，并返回表示该字符串的“UserPrincipal”对象。</p>
<p>您可以通过使用 [<code>FileSystem.getUserPrincipalLookupService</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/ FileSystem.html#getUserPrincipalLookupService--) 方法。</p>
<p>以下代码片段显示了如何使用<code>setOwner</code> 方法设置文件所有者： </p>
<pre><code class="language-java">Path file = ...;
UserPrincipal owner = file.GetFileSystem().getUserPrincipalLookupService()
        .lookupPrincipalByName(&quot;sally&quot;);
Files.setOwner(file, owner);
</code></pre>
<p><code>Files</code> 类中没有用于设置组所有者的特殊用途方法。</p>
<p>但是，直接这样做的安全方法是通过 POSIX 文件属性查看</p>
<pre><code>Path file = ...;
GroupPrincipal group =
    file.getFileSystem().getUserPrincipalLookupService()
        .lookupPrincipalByGroupName(&quot;green&quot;);
Files.getFileAttributeView(file, PosixFileAttributeView.class)
     .setGroup(group);
</code></pre>
<h2 id="user-defined-file-attributes"><a class="header" href="#user-defined-file-attributes">User-Defined File Attributes</a></h2>
<p>如果您的文件系统实现支持的文件属性不足以满足您的需求，您可以使用“UserDefinedAttributeView”来创建和跟踪您自己的文件属性。</p>
<p>一些实现将此概念映射到诸如 NTFS 替代数据流之类的功能以及文件系统（如 ext3 和 ZFS）上的扩展属性。</p>
<p>大多数实现都对值的大小施加了限制，例如，ext3 将大小限制为 4 KB。</p>
<p>可以使用以下代码片段将文件的 MIME 类型存储为用户定义的属性:</p>
<pre><code class="language-java">Path file = ...;
UserDefinedFileAttributeView view = Files
    .getFileAttributeView(file, UserDefinedFileAttributeView.class);
view.write(&quot;user.mimetype&quot;,
           Charset.defaultCharset().encode(&quot;text/html&quot;);
</code></pre>
<p>To read the MIME type attribute, you would use this code snippet:</p>
<pre><code class="language-java">Path file = ...;
UserDefinedFileAttributeView view = Files
.getFileAttributeView(file,UserDefinedFileAttributeView.class);
String name = &quot;user.mimetype&quot;;
ByteBuffer buf = ByteBuffer.allocate(view.size(name));
view.read(name, buf);
buf.flip();
String value = Charset.defaultCharset().decode(buf).toString();
</code></pre>
<p><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Xdd.java"><code>Xdd</code></a> 示例展示了如何获取、设置和删除用户定义的属性。 </p>
<p><strong>注意：</strong> 在 Linux 中，您可能必须启用扩展属性才能使用户定义的属性起作用。</p>
<p>如果在尝试访问用户定义的属性视图时收到 <code>UnsupportedOperationException</code>，则需要重新挂载文件系统。</p>
<p>以下命令为 ext3 文件系统重新挂载具有扩展属性的根分区。</p>
<p>如果此命令不适用于您的 Linux 风格，请查阅文档。</p>
<pre><code>$ sudo mount -o remount,user_xattr /
</code></pre>
<p>如果您想让更改永久生效，请在 <code>/etc/fstab</code> 中添加一个条目。</p>
<h2 id="file-store-attributes"><a class="header" href="#file-store-attributes">File Store Attributes</a></h2>
<p>您可以使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileStore.html"><code>FileStore</code></a> 类来了解有关文件存储的信息，例如如何有很多空间可用。 </p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getFileStore-java.nio.file.Path-"><code>getFileStore(Path)</code></a> 方法</p>
<p>获取指定文件的文件存储。</p>
<p>以下代码片段打印特定文件所在的文件存储的空间使用情况</p>
<pre><code class="language-java">Path file = ...;
FileStore store = Files.getFileStore(file);

long total = store.getTotalSpace() / 1024;
long used = (store.getTotalSpace() -
             store.getUnallocatedSpace()) / 1024;
long avail = store.getUsableSpace() / 1024;
</code></pre>
<p><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/DiskUsage.java"><code>DiskUsage</code></a> 示例使用此 API 打印默认文件系统中所有存储的磁盘空间信息。</p>
<p>此示例使用 <code>FileSystem</code> 类中的 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getFileStores--"><code>getFileStores</code></a> 方法来</p>
<p>获取文件系统的所有文件存储。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-useful-methods"><a class="header" href="#other-useful-methods">Other Useful Methods</a></h1>
<p>一些有用的方法在本课的其他地方不适用，在此处进行了介绍。</p>
<p>本节涵盖以下内容：:</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/misc.html#mime">Determining MIME Type</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/misc.html#default">Default File System</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/misc.html#separator">Path String Separator</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/misc.html#stores">File System's File Stores</a></li>
</ul>
<h1 id="determining-mime-type"><a class="header" href="#determining-mime-type">Determining MIME Type</a></h1>
<p>要确定文件的 MIME 类型，您可能会找到 [<code>probeContentType(Path)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html# probeContentType-java.nio.file.Path-) 方法很有用。</p>
<pre><code class="language-java">try {
    String type = Files.probeContentType(filename);
    if (type == null) {
        System.err.format(&quot;'%s' has an&quot; + &quot; unknown filetype.%n&quot;, filename);
    } else if (!type.equals(&quot;text/plain&quot;) {
        System.err.format(&quot;'%s' is not&quot; + &quot; a plain text file.%n&quot;, filename);
        continue;
    }
} catch (IOException x) {
    System.err.println(x);
}
</code></pre>
<p>请注意，如果无法确定内容类型，<code>probeContentType</code> 将返回 null。</p>
<p>这种方法的实现是高度特定于平台的，并且不是绝对可靠的。</p>
<p>内容类型由平台的默认文件类型检测器确定。</p>
<p>例如，如果检测器根据<code>.class</code> 扩展名确定文件的内容类型为<code>application/x-java</code>，它可能会被愚弄。</p>
<p>如果默认值不足以满足您的需求，您可以提供自定义 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/spi/FileTypeDetector.html"><code>FileTypeDetector</code></a> </p>
<p><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Email.java"><code>Email</code></a> 示例使用了 <code>probeContentType</code> 方法。</p>
<h1 id="default-file-system"><a class="header" href="#default-file-system">Default File System</a></h1>
<p>要检索默认文件系统，请使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystems.html#getDefault--"><code>getDefault</code></a> 方法。</p>
<p>通常，这个 <code>FileSystems</code> 方法（注意复数）被链接到 <code>FileSystem</code> 方法之一（注意单数），如下所示：</p>
<pre><code>PathMatcher matcher =
    FileSystems.getDefault().getPathMatcher(&quot;glob:*.*&quot;);
</code></pre>
<h1 id="path-string-separator"><a class="header" href="#path-string-separator">Path String Separator</a></h1>
<p>POSIX 文件系统的路径分隔符是正斜杠<code>/</code>，而对于Microsoft Windows 是反斜杠<code>\</code>。</p>
<p>其他文件系统可能使用其他分隔符。</p>
<p>要检索默认文件系统的 <code>Path</code> 分隔符，您可以使用以下方法之一：</p>
<pre><code>String separator = File.separator;
String separator = FileSystems.getDefault().getSeparator();
</code></pre>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getSeparator--"><code>getSeparator</code></a> 方法也用于检索可用的文件系统的路径分隔符</p>
<h1 id="file-systems-file-stores"><a class="header" href="#file-systems-file-stores">File System's File Stores</a></h1>
<p>一个文件系统有一个或多个文件存储来保存它的文件和目录。 </p>
<p><em>file store</em> 代表底层存储设备。</p>
<p>在 UNIX 操作系统中，每个挂载的文件系统都由一个文件存储区表示。</p>
<p>在 Microsoft Windows 中，每个卷都由一个文件存储区表示：<code>C:</code>、<code>D:</code> 等等。.</p>
<p>要检索文件系统的所有文件存储列表，您可以使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.getFileStores.html#getFileStores--"><code>getFileStores</code></a> 方法。</p>
<p>此方法返回一个 <code>Iterable</code>，它允许您使用 <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html">enhanced for</a> 语句遍历所有根目录。</p>
<pre><code>for (FileStore store: FileSystems.getDefault().getFileStores()) {
   ...
}
</code></pre>
<p>如果要检索特定文件所在的文件存储，请使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#getFileStore-java.nio.file.Path-"><code>getFileStore</code></a></p>
<p><code>Files</code> 类中的 方法</p>
<pre><code class="language-java">Path file = ...;
FileStore store= Files.getFileStore(file);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Java SE 7 版本中引入的 NIO.2 API 提供了开发可用于管理文件系统对象的自定义文件系统提供程序的能力</p>
<p><em>文件系统</em>本质上是一个容器，其中包含被称为文件系统对象的有组织的同质元素</p>
<p>文件系统提供对文件系统对象的访问。 </p>
<p><em>文件系统对象</em>可以是文件存储、文件或目录。 </p>
<p><em>文件存储</em>是存储文件的卷或分区。</p>
<p>例如，在 Windows 平台等本机文件系统中，众所周知的驱动器如 <code>c:</code> 或 <code>d:</code> 是文件存储</p>
<p>在 Solaris 操作系统上，<code>/</code>（根）和挂载目录被视为文件存储。</p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/spi/FileSystemProvider.html"><code>java.nio.file.spi.FileSystemProvider</code></a> 类允许您开发</p>
<p>自定义文件系统提供程序。</p>
<p>自定义文件系统提供程序在以下情况下很有用：</p>
<ul>
<li>
<p>开发基于内存或基于 zip 文件的文件系统</p>
</li>
<li>
<p>开发容错分布式文件系统</p>
</li>
<li>
<p>替换或补充默认文件系统提供程序。</p>
<p>自定义提供程序可以通过执行特定操作来扩充默认提供程序，例如记录所有系统操作，并将其他例行操作委托给默认提供程序。</p>
</li>
</ul>
<h1 id="overview-of-the-javaniofilespifilesystemprovider-class"><a class="header" href="#overview-of-the-javaniofilespifilesystemprovider-class">Overview of the <code>java.nio.file.spi.FileSystemProvider</code> Class</a></h1>
<p>自定义文件系统提供程序必须实现 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/spi/FileSystemProvider.html"><code>java.nio.file.spi.FileSystemProvider</code></a> 类。</p>
<p>文件系统提供程序由 <strong>URI schema</strong> 标识，例如 <code>file</code>、<code>jar</code>、<code>memory</code>、<code>cd</code>。</p>
<p><code>java.nio.file.spi.FileSystemProvider</code> 类的实现是 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html"><code>java.nio.file.FileSystem</code></a> 类的 工厂类</p>
<p>文件系统的 URI 具有与创建它的文件系统提供程序的 URI 方案相匹配的 URI 方案。</p>
<p>[<code>newFileSystem</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/spi/FileSystemProvider.html#newFileSystem-java.net.URI-java.util.Map -) 方法用于创建文件系统和 [<code>getFileSystem</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/spi/FileSystemProvider.html#getFileSystem- java.net.URI-) 方法用于检索对现有文件系统的引用。</p>
<h1 id="implementing-a-custom-file-system-provider"><a class="header" href="#implementing-a-custom-file-system-provider">Implementing a Custom File System Provider</a></h1>
<p>本节描述使用 <code>java.nio.file.spi.FileSystemProvider</code> API 创建自定义文件系统提供程序所需的高级步骤</p>
<p>DK 安装的 <code>demo/nio/zipfs</code> 中附带的 <code>ZipFileSystemProvider</code> 类是自定义文件系统提供程序的一个示例。</p>
<p>有关 zip 文件系统提供程序的信息，请参阅 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/io/fsp/filesystemprovider.html#resources">资源</a>。</p>
<h2 id="implementing-the-custom-file-system-provider-class"><a class="header" href="#implementing-the-custom-file-system-provider-class">Implementing the Custom File System Provider Class</a></h2>
<p>实现自定义文件系统提供程序类涉及以下操作：</p>
<ul>
<li>
<p>创建一个自定义文件系统提供程序类，例如“MyFileSystemProvider”，它扩展了“java.nio.file.spi.FileSystemProvider”类。.</p>
</li>
<li>
<p>为文件系统提供者定义一个 <code>URI schema</code>，例如 <code>jar</code>。 <code>getScheme</code> 方法应该返回这个提供者的 URI schema</p>
</li>
<li>
<p>创建内部缓存以跟踪此提供程序创建的文件系统</p>
</li>
<li>
<p>实现 <code>newFileSystem</code> 方法。该方法将在指定路径创建一个新的自定义文件系统，并将该文件系统添加到缓存中。如果文件系统，此方法应该抛出 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemAlreadyExistsException.html"><code>java.nio.file.FileSystemAlreadyExistsException</code></a> 异常已存在于指定路径。</p>
</li>
<li>
<p>实现<code>getFileSystem</code> 方法。此方法应搜索缓存并返回对应于给定 URI 的文件系统的先前创建的实例。 </p>
</li>
<li>
<p>根据文件系统提供者的要求，实现 <code>newFileChannel</code> 方法或 <code>newAsynchronousFileChannel</code> 方法。</p>
<p>此方法应返回一个 FileChannel 对象，该对象允许在文件系统中读取或写入文件</p>
</li>
</ul>
<h2 id="implementing-the-custom-file-system-class"><a class="header" href="#implementing-the-custom-file-system-class">Implementing the Custom File System Class</a></h2>
<p>实现自定义文件系统类涉及以下操作</p>
<ul>
<li>创建一个扩展 <code>java.nio.file.FileSystem</code> 类的类，例如 <code>MyFileSystem</code>.</li>
<li>根据所需文件系统的特性实现文件系统类的方法。文件系统的一些特征如下:
<ul>
<li>Number of roots – 文件系统可以有一个文件的单一层次结构，一个根目录，或多个层次结构</li>
<li>Read and write access – 文件系统可以是只读的或读/写的.</li>
<li>File store – 文件系统需要底层文件存储。可以为文件设置的属性将因底层文件存储而异.</li>
</ul>
</li>
</ul>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/io/fsp/zipfilesystemprovider.html">Zip File System Provider</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/io/fsp/zipfilesystemproviderprops.html">Zip File System Properties</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finding-files"><a class="header" href="#finding-files">Finding Files</a></h1>
<p>如果您曾经使用过 shell 脚本，那么您很可能使用过模式匹配来定位文件。</p>
<p>事实上，您可能已经广泛使用它。</p>
<p>如果您没有使用过，模式匹配会使用特殊字符来创建模式，然后可以将文件名与该模式进行比较</p>
<p>例如，在大多数 shell 脚本中，星号 <code>*</code> 可以匹配任意数量的字符。</p>
<p>例如，以下命令列出当前目录中所有以 <code>.html</code> 结尾的文件：</p>
<pre><code>% ls *.html
</code></pre>
<p><code>java.nio.file</code> 包为这个有用的特性提供了编程支持。</p>
<p>每个文件系统实现都提供了一个 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/PathMatcher.html"><code>PathMatcher</code></a>。</p>
<p>您可以使用 [<code>getPathMatcher(String)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher <code>FileSystem</code> 类中的 -java.lang.String-) 方法。</p>
<p>以下代码片段获取默认文件系统的路径匹配器：</p>
<pre><code class="language-java">String pattern = ...;
PathMatcher matcher =
    FileSystems.getDefault().getPathMatcher(&quot;glob:&quot; + pattern);
</code></pre>
<p>传递给<code>getPathMatcher</code> 的字符串参数指定要匹配的语法风格和模式。</p>
<p>此示例指定 <em>glob</em> 语法。</p>
<p>如果您不熟悉 glob 语法，请参阅 <a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob">什么是 Glob</a>。</p>
<p>Glob 语法易于使用且灵活，但如果您愿意，也可以使用正则表达式或 <em>regex</em> 语法。</p>
<p>有关正则表达式的更多信息，请参阅 <a href="https://docs.oracle.com/javase/tutorial/essential/regex/index.html">正则表达式</a> 课程。</p>
<p>某些文件系统实现可能支持其他语法。</p>
<p>如果你想使用其他形式的基于字符串的模式匹配，你可以创建你自己的 <code>PathMatcher</code> 类。</p>
<p>本页中的示例使用 glob 语法。</p>
<p>一旦你创建了你的“PathMatcher”实例，你就可以将文件与之匹配。 </p>
<p><code>PathMatcher</code> 接口有一个方法，[<code>matches</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/PathMatcher.html#matches-java.nio。 </p>
<p>file.Path-)，它接受一个 <code>Path</code> 参数并返回一个布尔值：它要么匹配模式，要么不匹配。</p>
<p>以下代码片段查找以 <code>.java</code> 或 <code>.class</code> 结尾的文件，并将这些文件打印到标准输出：</p>
<pre><code class="language-java">PathMatcher matcher =
    FileSystems.getDefault().getPathMatcher(&quot;glob:*.{java,class}&quot;);

Path filename = ...;
if (matcher.matches(filename)) {
    System.out.println(filename);
}
</code></pre>
<h1 id="recursive-pattern-matching"><a class="header" href="#recursive-pattern-matching">Recursive Pattern Matching</a></h1>
<p>搜索与特定模式匹配的文件与遍历文件树密切相关。</p>
<p>多少次您知道文件在文件系统的<em>某处</em>，但在哪里？</p>
<p>或者，您可能需要在文件树中查找具有特定文件扩展名的所有文件。</p>
<p><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Find.java"><code>Find</code></a> 示例正是这样做的。 </p>
<p><code>Find</code> 类似于 UNIX 的 <code>find</code> 实用程序，但在功能上有所缩减。</p>
<p>您可以扩展此示例以包含其他功能。</p>
<p>例如，<code>find</code> 实用程序支持<code>-prune</code> 标志从搜索中排除整个子树。</p>
<p>您可以通过在 <code>preVisitDirectory</code> 方法中返回 <code>SKIP_SUBTREE</code> 来实现该功能。</p>
<p>要实现跟随符号链接的 <code>-L</code> 选项，您可以使用四参数 <code>walkFileTree</code> 方法并传入 <code>FOLLOW_LINKS</code> 枚举（但请确保在 <code>visitFile</code> 方法中测试循环链接） </p>
<p>.</p>
<p>要运行 Find 应用程序，请使用以下格式：</p>
<pre><code>% java Find &lt;path&gt; -name &quot;&lt;glob_pattern&gt;&quot;
</code></pre>
<p>该模式放在引号内，因此外壳不会解释任何通配符。例如：</p>
<pre><code>% java Find . -name &quot;*.html&quot;
</code></pre>
<p>Here is the source code for the <code>Find</code> example:</p>
<pre><code class="language-java">/**
 * Sample code that finds files that match the specified glob pattern.
 * For more information on what constitutes a glob pattern, see
 * https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob
 *
 * The file or directories that match the pattern are printed to
 * standard out.  The number of matches is also printed.
 *
 * When executing this application, you must put the glob pattern
 * in quotes, so the shell will not expand any wild cards:
 *              java Find . -name &quot;*.java&quot;
 */

import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import static java.nio.file.FileVisitResult.*;
import static java.nio.file.FileVisitOption.*;
import java.util.*;


public class Find {

    public static class Finder
        extends SimpleFileVisitor&lt;Path&gt; {

        private final PathMatcher matcher;
        private int numMatches = 0;

        Finder(String pattern) {
            matcher = FileSystems.getDefault()
                    .getPathMatcher(&quot;glob:&quot; + pattern);
        }

        // Compares the glob pattern against
        // the file or directory name.
        void find(Path file) {
            Path name = file.getFileName();
            if (name != null &amp;&amp; matcher.matches(name)) {
                numMatches++;
                System.out.println(file);
            }
        }

        // Prints the total number of
        // matches to standard out.
        void done() {
            System.out.println(&quot;Matched: &quot;
                + numMatches);
        }

        // Invoke the pattern matching
        // method on each file.
        @Override
        public FileVisitResult visitFile(Path file,
                BasicFileAttributes attrs) {
            find(file);
            return CONTINUE;
        }

        // Invoke the pattern matching
        // method on each directory.
        @Override
        public FileVisitResult preVisitDirectory(Path dir,
                BasicFileAttributes attrs) {
            find(dir);
            return CONTINUE;
        }

        @Override
        public FileVisitResult visitFileFailed(Path file,
                IOException exc) {
            System.err.println(exc);
            return CONTINUE;
        }
    }

    static void usage() {
        System.err.println(&quot;java Find &lt;path&gt;&quot; +
            &quot; -name \&quot;&lt;glob_pattern&gt;\&quot;&quot;);
        System.exit(-1);
    }

    public static void main(String[] args)
        throws IOException {

        if (args.length &lt; 3 || !args[1].equals(&quot;-name&quot;))
            usage();

        Path startingDir = Paths.get(args[0]);
        String pattern = args[2];

        Finder finder = new Finder(pattern);
        Files.walkFileTree(startingDir, finder);
        finder.done();
    }
}
</code></pre>
<p>Recursively walking a file tree is covered in <a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html">Walking the File Tree</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-10"><a class="header" href="#前言-10">前言</a></h1>
<p>Files 类是 java.nio.file 包的另一个主要入口点。</p>
<p>此类提供了一组丰富的静态方法，用于读取、写入和操作文件和目录。 </p>
<p>Files 方法适用于 Path 对象的实例。</p>
<p>在继续其余部分之前，您应该熟悉以下常见概念：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#resources">Releasing System Resources</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#exception">Catching Exceptions</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#varargs">Varargs</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#atomic">Atomic Operations</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#chaining">Method Chaining</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob">What <em>Is</em> a Glob?</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#linkaware">Link Awareness</a></li>
</ul>
<h2 id="releasing-system-resources"><a class="header" href="#releasing-system-resources">Releasing System Resources</a></h2>
<p>此 API 中使用的许多资源（例如流或通道）实现或扩展了 [<code>java.io.Closeable</code>](https://docs.oracle.com/javase/8/docs/api/java /io/Closeable.html)接口。 </p>
<p><code>Closeable</code> 资源的一个要求是，当不再需要时，必须调用 <code>close</code> 方法来释放资源。</p>
<p>忽略关闭资源会对应用程序的性能产生负面影响。</p>
<p>下一节中描述的 <code>try-</code>with-resources 语句会为您处理这一步。</p>
<h2 id="catching-exceptions"><a class="header" href="#catching-exceptions">Catching Exceptions</a></h2>
<p>对于文件 I/O，意外情况是生活中的事实：文件在预期时存在（或不存在），程序无权访问文件系统，默认文件系统实现不支持特定功能 等等。可能会遇到许多错误。</p>
<p>所有访问文件系统的方法都可以抛出<code>IOException</code>。</p>
<p>最好的做法是通过将这些方法嵌入 Java SE 7 版本中引入的 <code>try-</code>with-resources 语句来捕获这些异常。 </p>
<p><code>try-with-resources</code> 语句的优点是编译器会自动生成代码以在不再需要时关闭资源。</p>
<pre><code class="language-java">Charset charset = Charset.forName(&quot;US-ASCII&quot;);
String s = ...;
try (BufferedWriter writer = Files.newBufferedWriter(file, charset)) {
    writer.write(s, 0, s.length());
} catch (IOException x) {
    System.err.format(&quot;IOException: %s%n&quot;, x);
}
</code></pre>
<p>For more information, see <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">The try-with-resources Statement</a>.</p>
<p>或者，您可以将文件 I/O 方法嵌入到“try”块中，然后在“catch”块中捕获任何异常。如果您的代码打开了任何流或通道，您应该在“finally”块中关闭它们。</p>
<pre><code>Charset charset = Charset.forName(&quot;US-ASCII&quot;);
String s = ...;
BufferedWriter writer = null;
try {
    writer = Files.newBufferedWriter(file, charset);
    writer.write(s, 0, s.length());
} catch (IOException x) {
    System.err.format(&quot;IOException: %s%n&quot;, x);
} finally {
    if (writer != null) writer.close();
}
</code></pre>
<p>For more information, see <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html">Catching and Handling Exceptions</a>.</p>
<p>除了<code>IOException</code>，许多特定的异常扩展了<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html"><code>FileSystemException</code></a>。</p>
<p>这个类有一些有用的方法返回涉及的文件 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getFile--">(<code>getFile</code>)</a>，详细消息字符串<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getMessage--">(<code>getMessage</code>)</a>，原因</p>
<p>文件系统操作失败 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getReason--">(<code>getReason</code>)</a>，以及“其他&quot; 涉及的文件，如果有的话 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getOtherFile--">(<code>getOtherFile</code>)</a>。</p>
<p>The following code snippet shows how the <code>getFile</code> ethod might be used:</p>
<pre><code>try (...) {
    ...    
} catch (NoSuchFileException x) {
    System.err.format(&quot;%s does not exist\n&quot;, x.getFile());
}
</code></pre>
<h2 id="varargs"><a class="header" href="#varargs">Varargs</a></h2>
<p>当指定标志时，几个“文件”方法接受任意数量的参数。</p>
<p>例如，在下面的方法签名中，<code>CopyOption</code> 参数后面的省略号表示该方法接受可变数量的参数或 <em>varargs</em>，因为它们通常被调用：</p>
<pre><code>Path Files.move(Path, Path, CopyOption...)
</code></pre>
<p>当一个方法接受一个 varargs 参数时，你可以向它传递一个逗号分隔的值列表或一个值数组 (<code>CopyOption[]</code>)。</p>
<p>在 <code>move</code> 示例中，可以按如下方式调用该方法：</p>
<pre><code>import static java.nio.file.StandardCopyOption.*;

Path source = ...;
Path target = ...;
Files.move(source,
           target,
           REPLACE_EXISTING,
           ATOMIC_MOVE);
</code></pre>
<p>For more information about varargs syntax, see <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/arguments.html#varargs">Arbitrary Number of Arguments</a>.</p>
<h2 id="atomic-operations"><a class="header" href="#atomic-operations">Atomic Operations</a></h2>
<p>一些 Files 方法，例如 move，可以在某些文件系统中原子地执行某些操作。</p>
<p>原子文件操作是不能被中断或“部分”执行的操作。</p>
<p>要么执行整个操作，要么操作失败。</p>
<h2 id="method-chaining"><a class="header" href="#method-chaining">Method Chaining</a></h2>
<p>许多文件 I/O 方法都支持方法链的概念。</p>
<p>首先调用一个返回对象的方法。</p>
<p>然后立即调用该对象上的一个方法，该方法返回另一个对象，依此类推。</p>
<p>许多 I/O 示例使用以下技术： </p>
<pre><code class="language-java">String value = Charset.defaultCharset().decode(buf).toString();
UserPrincipal group =
    file.getFileSystem().getUserPrincipalLookupService().
         lookupPrincipalByName(&quot;me&quot;);
</code></pre>
<p>此技术生成紧凑的代码，并使您能够避免声明不需要的临时变量。</p>
<h2 id="what-is-a-glob"><a class="header" href="#what-is-a-glob">What <em>Is</em> a Glob?</a></h2>
<p><code>Files</code> 类中的两个方法接受一个 glob 参数，但什么是 <em>glob</em>？</p>
<p>您可以使用 glob 语法来指定模式匹配行为。</p>
<p>glob 模式被指定为一个字符串，并与其他字符串匹配，例如目录或文件名。 </p>
<p>Glob 语法遵循几个简单的规则：</p>
<ul>
<li>
<p>An asterisk, <code>*</code></p>
<p>匹配任意数量的字符（包括无）。</p>
</li>
<li>
<p>Two asterisks, <code>**</code>,</p>
<p>像 <code>*</code> 一样工作，但跨越目录边界。此语法通常用于匹配完整路径。</p>
</li>
<li>
<p>A question mark, <code>?</code></p>
<p>matches exactly one character.</p>
</li>
<li>
<p>Braces specify a collection of subpatterns. For example:</p>
<ul>
<li><code>{sun,moon,stars}</code> matches &quot;sun&quot;, &quot;moon&quot;, or &quot;stars&quot;.</li>
<li><code>{temp*,tmp*}</code> matches all strings beginning with &quot;temp&quot; or &quot;tmp&quot;.</li>
</ul>
</li>
<li>
<p>方括号表示一组单个字符，或者当使用连字符 (-) 时，表示一系列字符。</p>
<ul>
<li><code>[aeiou]</code> matches any lowercase vowel.</li>
<li><code>[0-9]</code> matches any digit.</li>
<li><code>[A-Z]</code> matches any uppercase letter.</li>
<li><code>[a-z,A-Z]</code> matches any uppercase or lowercase letter.</li>
</ul>
<p>在方括号内，*、? 和 \ 匹配本身</p>
</li>
<li>
<p>所有其他字符匹配自己。 .</p>
</li>
<li>
<p>要匹配 <code>*</code>、<code>?</code> 或其他特殊字符，您可以使用反斜杠字符 <code>\</code> 对它们进行转义。</p>
<p>例如：<code>\\</code> 匹配单个反斜杠，而<code>\?</code> 匹配问号。</p>
</li>
</ul>
<p>以下是 glob 语法的一些示例：</p>
<ul>
<li><code>*.html</code> – Matches all strings that end in <em>.html</em></li>
<li><code>???</code> – Matches all strings with exactly three letters or digits</li>
<li><code>*[0-9]*</code> – Matches all strings containing a numeric value</li>
<li><code>*.{htm,html,pdf}</code> – Matches any string ending with <em>.htm</em>, <em>.html</em> or <em>.pdf</em></li>
<li><code>a?*.java</code> – Matches any string beginning with <code>a</code>, followed by at least one letter or digit, and ending with <em>.java</em></li>
<li><code>{foo*,*[0-9]*}</code> – Matches any string beginning with <em>foo</em> or any string containing a numeric value</li>
</ul>
<hr />
<p><strong>Note:</strong> If you are typing the glob pattern at the keyboard and it contains one of the special characters, you must put the pattern in quotes (<code>&quot;*&quot;</code>), use the backslash (<code>\*</code>), or use whatever escape mechanism is supported at the command line.</p>
<hr />
<p>glob 语法功能强大且易于使用。但是，如果它不能满足您的需求，您也可以使用正则表达式。. For more information, see the <a href="https://docs.oracle.com/javase/tutorial/essential/regex/index.html">Regular Expressions</a> lesson.</p>
<p>For more information about the glob syntax, see the API specification for the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-"><code>getPathMatcher</code></a> method in the <code>FileSystem</code> class.</p>
<h2 id="link-awareness"><a class="header" href="#link-awareness">Link Awareness</a></h2>
<p>Files 类是“链接感知的”。</p>
<p>每个 Files 方法要么检测遇到符号链接时要做什么，要么提供一个选项，使您可以配置遇到符号链接时的行为。</p>
<h1 id="checking-a-file-or-directory"><a class="header" href="#checking-a-file-or-directory">Checking a File or Directory</a></h1>
<p>您有一个表示文件或目录的 Path 实例，但该文件是否存在于文件系统中？</p>
<p>它可读吗？可写？可执行？</p>
<h2 id="验证文件或目录是否存在"><a class="header" href="#验证文件或目录是否存在">验证文件或目录是否存在</a></h2>
<p><code>Path</code> 类中的方法是语法上的，这意味着它们对 <code>Path</code> 实例进行操作。</p>
<p>但最终您必须访问文件系统以验证特定的“Path”是否存在。</p>
<p>您可以使用 [<code>exists(Path, LinkOption...)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#exists- java.nio.file.Path-java.nio.file.LinkOption...-) 和 [<code>notExists(Path, LinkOption...)</code>](https://docs.oracle.com/javase/8/ docs/api/java/nio/file/Files.html#notExists-java.nio.file.Path-java.nio.file.LinkOption...-) 方法。</p>
<p>请注意，<code>!Files.exists(path)</code> 不等同于 <code>Files.notExists(path)</code>。</p>
<p>您可以使用 [<code>exists(Path, LinkOption...)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#exists- java.nio.file.Path-java.nio.file.LinkOption...-) 和 [<code>notExists(Path, LinkOption...)</code>](https://docs.oracle.com/javase/8/ docs/api/java/nio/file/Files.html#notExists-java.nio.file.Path-java.nio.file.LinkOption...-) 方法。</p>
<p>请注意，<code>!Files.exists(path)</code> 不等同于 <code>Files.notExists(path)</code>。</p>
<p>当您测试文件是否存在时，可能会出现三种结果：-</p>
<ul>
<li>该文件已被验证存在。</li>
<li>该文件经验证不存在</li>
<li>该文件的状态未知。当程序无权访问该文件时，可能会出现此结果。</li>
</ul>
<p>如果 <code>exists</code> 和 <code>notExists</code> 都返回 <code>false</code>，则无法验证文件是否存在。</p>
<h2 id="检查文件可访问性"><a class="header" href="#检查文件可访问性">检查文件可访问性</a></h2>
<p>要验证程序是否可以根据需要访问文件，您可以使用 [<code>isReadable(Path)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files .html#isReadable-java.nio.file.Path-), [<code>isWritable(Path)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files. html#isWritable-java.nio.file.Path-) 和 [<code>isExecutable(Path)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files. html#isExecutable-java.nio.file.Path-) 方法。</p>
<p>以下代码片段验证特定文件是否存在以及程序是否能够执行该文件。</p>
<pre><code>Path file = ...;
boolean isRegularExecutableFile = Files.isRegularFile(file) &amp;
         Files.isReadable(file) &amp; Files.isExecutable(file);
</code></pre>
<hr />
<p><strong>Note:</strong> 这些方法中的任何一个完成，但不能保证可以访问该文件。</p>
<p>许多应用程序中的一个常见安全漏洞是执行检查然后访问文件。</p>
<p>有关更多信息，请使用您最喜欢的搜索引擎查找“TOCTTOU”（发音为 <em>TOCK-too</em>）。</p>
<p><a href="https://www.cnblogs.com/liqiuhao/p/9450093.html">关于 TOCTTOU攻击的简介</a></p>
<hr />
<h2 id="检查两个路径是否定位到同一个文件"><a class="header" href="#检查两个路径是否定位到同一个文件">检查两个路径是否定位到同一个文件</a></h2>
<p>当您有一个使用符号链接的文件系统时，可能有两个不同的路径来定位同一个文件。 </p>
<p>[<code>isSameFile(Path, Path)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isSameFile-java.nio.file.Path- java.nio.file.Path-) 方法比较两个路径以确定它们是否在文件系统上定位相同的文件。</p>
<pre><code class="language-java">Path p1 = ...;
Path p2 = ...;

if (Files.isSameFile(p1, p2)) {
    // Logic when the paths locate the same file
}
</code></pre>
<h1 id="deleting-a-file-or-directory"><a class="header" href="#deleting-a-file-or-directory">Deleting a File or Directory</a></h1>
<p>您可以删除文件、目录或链接。</p>
<p>对于符号链接，将删除链接而不是链接的目标。</p>
<p>对于目录，目录必须为空，否则删除失败。</p>
<p><code>Files</code> 类提供了两种删除方法。 </p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#delete-java.nio.file.Path-"><code>delete(Path)</code></a> 方法</p>
<p>删除文件或在删除失败时抛出异常。</p>
<p>例如，如果文件不存在，则会抛出“NoSuchFileException”。</p>
<p>您可以捕获异常以确定删除失败的原因，如下所示：</p>
<pre><code>try {
    Files.delete(path);
} catch (NoSuchFileException x) {
    System.err.format(&quot;%s: no such&quot; + &quot; file or directory%n&quot;, path);
} catch (DirectoryNotEmptyException x) {
    System.err.format(&quot;%s not empty%n&quot;, path);
} catch (IOException x) {
    // File permission problems are caught here.
    System.err.println(x);
}
</code></pre>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#deleteIfExists-java.nio.file.Path-"><code>deleteIfExists(Path)</code></a> 方法</p>
<p>也删除文件，但如果文件不存在，则不会抛出异常。</p>
<p>当您有多个线程删除文件并且您不想仅仅因为一个线程首先这样做而抛出异常时，静默失败很有用。</p>
<h1 id="copying-a-file-or-directory"><a class="header" href="#copying-a-file-or-directory">Copying a File or Directory</a></h1>
<p>您可以使用 [<code>copy(Path, Path, CopyOption...)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/ Files.html#copy-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-) 方法。</p>
<p>如果目标文件存在，复制将失败，除非指定了<code>REPLACE_EXISTING</code> 选项。</p>
<p>可以复制目录。</p>
<p>但是，目录中的文件不会被复制，因此即使原始目录包含文件，新目录也是空的。</p>
<p>复制符号链接时，会复制链接的目标。</p>
<p>如果您想复制链接本身，而不是链接的内容，请指定<code>NOFOLLOW_LINKS</code>或<code>REPLACE_EXISTING</code>选项。</p>
<p>此方法采用 varargs 参数。</p>
<p>支持以下 <code>StandardCopyOption</code> 和 <code>LinkOption</code> 枚举：</p>
<ul>
<li><code>REPLACE_EXISTING</code> 
<ul>
<li>即使目标文件已经存在，也执行复制。</li>
<li>如果目标是符号链接，则复制链接本身（而不是链接的目标）。</li>
<li>如果目标是非空目录，则复制失败，并出现“DirectoryNotEmptyException”异常。</li>
</ul>
</li>
<li><code>COPY_ATTRIBUTES</code>
<ul>
<li>将与文件关联的文件属性复制到目标文件。</li>
<li>跨平台支持  <code>last-modified-time</code> </li>
</ul>
</li>
<li><code>NOFOLLOW_LINKS</code>
<ul>
<li>表示不应遵循符号链接。如果要复制的文件是符号链接，则复制链接（而不是链接的目标）。</li>
</ul>
</li>
</ul>
<p>如果您不熟悉 <code>enums</code>，请参阅 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html">Enum 类型</a>。</p>
<pre><code>import static java.nio.file.StandardCopyOption.*;
...
Files.copy(source, target, REPLACE_EXISTING);
</code></pre>
<p>除了文件复制之外，“Files”类还定义了可用于在文件和流之间进行复制的方法。 </p>
<p>[<code>copy(InputStream, Path, CopyOptions...)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.io .InputStream-java.nio.file.Path-java.nio.file.CopyOption...-) 方法可用于将所有字节从输入流复制到文件。 </p>
<p>[<code>copy(Path, OutputStream)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.nio.file.Path- java.io.OutputStream-) 方法可用于将文件中的所有字节复制到输出流。</p>
<p><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Copy.java"><code>Copy</code></a> 示例使用 <code>copy</code> 和 <code>Files.walkFileTree</code> 方法来支持递归复制。</p>
<p>有关详细信息，请参阅 <a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html">遍历文件树</a>。</p>
<h1 id="moving-a-file-or-directory"><a class="header" href="#moving-a-file-or-directory">Moving a File or Directory</a></h1>
<p>您可以使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#move-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-"><code>move(Path, Path, CopyOption...)</code></a> 方法。</p>
<p>如果目标文件存在，则移动失败，除非指定了<code>REPLACE_EXISTING</code> 选项。</p>
<p>可以移动空目录。</p>
<p>如果目录不为空，则当目录可以移动而不移动该目录的内容时，则允许移动。</p>
<p>在 UNIX 系统上，在同一分区内移动目录通常包括重命名目录。</p>
<p>在这种情况下，即使目录包含文件，此方法也能工作。</p>
<p>此方法采用 varargs 参数 - 支持以下 <code>StandardCopyOption</code> 枚举：</p>
<ul>
<li>
<p><code>REPLACE_EXISTING</code></p>
<ul>
<li>即使目标文件已经存在，也执行移动。</li>
<li>如果目标是符号链接，则符号链接会被替换，但它指向的内容不受影响。</li>
</ul>
</li>
<li>
<p><code>ATOMIC_MOVE</code></p>
<ul>
<li>
<p>将移动作为原子文件操作执行。</p>
</li>
<li>
<p>如果文件系统不支持原子移动，则会抛出异常。</p>
</li>
<li>
<p>使用“ATOMIC_MOVE”，您可以将文件移动到目录中，并确保任何观察该目录的进程都访问一个完整的文件。</p>
</li>
</ul>
</li>
</ul>
<pre><code>import static java.nio.file.StandardCopyOption.*;
...
Files.move(source, target, REPLACE_EXISTING);
</code></pre>
<p>尽管您可以如图所示在单个目录上实现 <code>move</code> 方法，但该方法最常与文件树递归机制一起使用。</p>
<p>有关详细信息，请参阅 <a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html">遍历文件树</a>。</p>
<p>2</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-writing-and-creating-files"><a class="header" href="#reading-writing-and-creating-files">Reading, Writing, and Creating Files</a></h1>
<p>此页面讨论读取、写入、创建和打开文件的详细信息。</p>
<p>有多种文件 I/O 方法可供选择。</p>
<p>为了帮助理解 API，下图按复杂性排列了文件 I/O 方法。</p>
<p><strong>文件 I/O 方法从不太复杂到更复杂排列</strong></p>
<table><thead><tr><th>方法名</th><th>使用场景</th></tr></thead><tbody>
<tr><td><code>ReadAllBytes</code> <code>readAllLines</code></td><td>小文件读取</td></tr>
<tr><td><code>newBufferedReader</code> <code>newBufferedWriter</code></td><td>text中等文件</td></tr>
<tr><td><code>newInputSream</code> <code>newOutputStream</code></td><td>streams、unbuffered  use   with existing APIS</td></tr>
<tr><td><code>newByteChannel</code></td><td>channels and bytebuffers</td></tr>
<tr><td><code>FileChannel</code></td><td>advanced features file-locking memory-mapped io</td></tr>
</tbody></table>
<p>注意：创建新文件的方法使您能够为文件指定一组可选的初始属性。</p>
<p>例如，在支持 POSIX 标准集的文件系统（如 UNIX）上，您可以在创建文件时指定文件所有者、组所有者或文件权限。</p>
<p>管理元数据页面解释了文件属性，以及如何访问和设置它们。</p>
<p>This page has the following topics:</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#openOptions">The <code>OpenOptions</code> Parameter</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#common">Commonly Used Methods for Small Files</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#textfiles">Buffered I/O Methods for Text Files</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#streams">Methods for Unbuffered Streams and Interoperable with <code>java.io</code> APIs</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#channels">Methods for Channels and <code>ByteBuffers</code></a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#creating">Methods for Creating Regular and Temporary Files</a></li>
</ul>
<h2 id="the-openoptions-parameter"><a class="header" href="#the-openoptions-parameter">The <code>OpenOptions</code> Parameter</a></h2>
<p>本节中的一些方法采用可选的 OpenOptions 参数。</p>
<p>此参数是可选的，API 会告诉您在未指定任何方法时该方法的默认行为是什么。</p>
<p>The following <code>StandardOpenOptions</code> enums are supported:</p>
<ul>
<li><code>WRITE</code> – 写访问</li>
<li><code>APPEND</code> – 将新数据附加到文件末尾。此选项与 <code>WRITE</code> 或 <code>CREATE</code> 选项一起使用。</li>
<li><code>TRUNCATE_EXISTING</code> – 将文件截断为零字节。此选项与<code>WRITE</code> 选项一起使用。</li>
<li><code>CREATE_NEW</code> – 创建一个新文件并在文件已存在时抛出异常。</li>
<li><code>CREATE</code> – 如果文件存在则打开文件，如果不存在则创建新文件。</li>
<li><code>DELETE_ON_CLOSE</code> – 当流关闭时删除文件。此选项对临时文件很有用。</li>
<li><code>SPARSE</code> – 提示新创建的文件将是稀疏的。在某些文件系统（例如 NTFS）上使用此高级选项，在这些系统中，可以以更有效的方式存储具有数据“间隙”的大文件，而这些空白间隙不会占用磁盘空间。</li>
<li><code>SYNC</code> – 保持文件（内容和元数据）与底层存储设备同步。</li>
<li><code>DSYNC</code> – 保持文件内容与底层存储设备同步。</li>
</ul>
<h1 id="commonly-used-methods-for-small-files"><a class="header" href="#commonly-used-methods-for-small-files">Commonly Used Methods for Small Files</a></h1>
<h2 id="reading-all-bytes-or-lines-from-a-file"><a class="header" href="#reading-all-bytes-or-lines-from-a-file">Reading All Bytes or Lines from a File</a></h2>
<p>如果您有一个小文件，并且希望一次性读取其全部内容，则可以使用 readAllBytes(Path) 或 readAllLines(Path, Charset) 方法。</p>
<p>这些方法会为您处理大部分工作，例如打开和关闭流，但不适用于处理大文件。</p>
<pre><code class="language-java">Path file = ...;
byte[] fileArray;
fileArray = Files.readAllBytes(file);
</code></pre>
<h2 id="writing-all-bytes-or-lines-to-a-file"><a class="header" href="#writing-all-bytes-or-lines-to-a-file">Writing All Bytes or Lines to a File</a></h2>
<p>您可以使用其中一种写入方法将字节或行写入文件</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#write-java.nio.file.Path-byte:A-java.nio.file.OpenOption...-"><code>write(Path, byte[\], OpenOption...)</code></a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#write-java.nio.file.Path-java.lang.Iterable-java.nio.charset.Charset-java.nio.file.OpenOption...-"><code>write(Path, Iterable&lt; extends CharSequence&gt;, Charset, OpenOption...)</code></a></li>
</ul>
<pre><code class="language-java">Path file = ...;
byte[] buf = ...;
Files.write(file, buf);
</code></pre>
<h1 id="文本文件的缓冲-io-方法"><a class="header" href="#文本文件的缓冲-io-方法">文本文件的缓冲 I/O 方法</a></h1>
<p>The <code>java.nio.file</code> package supports channel I/O, which moves data in buffers,绕过一些可能成为流 I/O 瓶颈的层。</p>
<h2 id="reading-a-file-by-using-buffered-stream-io"><a class="header" href="#reading-a-file-by-using-buffered-stream-io">Reading a File by Using Buffered Stream I/O</a></h2>
<p><code>newBufferedReader(Path, Charset)</code> 方法打开一个文件进行读取，返回一个 BufferedReader，可用于以高效的方式从文件中读取文本。</p>
<p>以下代码片段展示了如何使用 newBufferedReader 方法从文件中读取数据。该文件以“US-ASCII”编码。</p>
<pre><code class="language-java">Charset charset = Charset.forName(&quot;US-ASCII&quot;);
try (BufferedReader reader = Files.newBufferedReader(file, charset)) {
    String line = null;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException x) {
    System.err.format(&quot;IOException: %s%n&quot;, x);
}
</code></pre>
<h2 id="writing-a-file-by-using-buffered-stream-io"><a class="header" href="#writing-a-file-by-using-buffered-stream-io">Writing a File by Using Buffered Stream I/O</a></h2>
<p>您可以使用 [<code>newBufferedWriter(Path, Charset, OpenOption...)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newBufferedWriter- java.nio.file.Path-java.nio.charset.Charset-java.nio.file.OpenOption...-) 使用 <code>BufferedWriter</code> 写入文件的方法。</p>
<pre><code>Charset charset = Charset.forName(&quot;US-ASCII&quot;);
String s = ...;
try (BufferedWriter writer = Files.newBufferedWriter(file, charset)) {
    writer.write(s, 0, s.length());
} catch (IOException x) {
    System.err.format(&quot;IOException: %s%n&quot;, x);
}
</code></pre>
<h1 id="无缓冲流和可与-javaio-api-互操作的方法"><a class="header" href="#无缓冲流和可与-javaio-api-互操作的方法">无缓冲流和可与 java.io API 互操作的方法</a></h1>
<h2 id="reading-a-file-by-using-stream-io"><a class="header" href="#reading-a-file-by-using-stream-io">Reading a File by Using Stream I/O</a></h2>
<p>要打开文件进行读取，您可以使用 <code>newInputStream(Path, OpenOption...)</code> 方法。</p>
<p>此方法返回一个无缓冲的输入流，用于从文件中读取字节。</p>
<pre><code class="language-java">Path file = ...;
try (InputStream in = Files.newInputStream(file);
    BufferedReader reader =
      new BufferedReader(new InputStreamReader(in))) {
    String line = null;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException x) {
    System.err.println(x);
}
</code></pre>
<h2 id="creating-and-writing-a-file-by-using-stream-io"><a class="header" href="#creating-and-writing-a-file-by-using-stream-io">Creating and Writing a File by Using Stream I/O</a></h2>
<p>您可以使用 newOutputStream(Path, OpenOption...) 方法创建文件、附加到文件或写入文件。</p>
<p>此方法打开或创建用于写入字节的文件并返回无缓冲的输出流。</p>
<p>该方法采用可选的 OpenOption 参数。</p>
<p>如果未指定打开选项，并且文件不存在，则会创建一个新文件。</p>
<p>如果文件存在，则将其截断。</p>
<p>此选项等效于使用 CREATE 和 TRUNCATE_EXISTING 选项调用方法。</p>
<p>以下示例打开一个日志文件。</p>
<p>如果文件不存在，则创建它。</p>
<p>如果文件存在，则将其打开以进行追加。</p>
<pre><code class="language-java">import static java.nio.file.StandardOpenOption.*;
import java.nio.file.*;
import java.io.*;

public class LogFileTest {

  public static void main(String[] args) {

    // Convert the string to a
    // byte array.
    String s = &quot;Hello World! &quot;;
    byte data[] = s.getBytes();
    Path p = Paths.get(&quot;./logfile.txt&quot;);

    try (OutputStream out = new BufferedOutputStream(
      Files.newOutputStream(p, CREATE, APPEND))) {
      out.write(data, 0, data.length);
    } catch (IOException x) {
      System.err.println(x);
    }
  }
}
</code></pre>
<h1 id="methods-for-channels-and-bytebuffers"><a class="header" href="#methods-for-channels-and-bytebuffers">Methods for Channels and <code>ByteBuffers</code></a></h1>
<h3 id="reading-and-writing-files-by-using-channel-io"><a class="header" href="#reading-and-writing-files-by-using-channel-io">Reading and Writing Files by Using Channel I/O</a></h3>
<p><strong>流 I/O 一次读取一个字符，而通道 I/O 一次读取一个缓冲区。</strong> </p>
<p>ByteChannel 接口提供基本的读写功能。 </p>
<p>SeekableByteChannel 是一个 ByteChannel，它能够在通道中保持位置并更改该位置。 </p>
<p>SeekableByteChannel 还支持截断与通道关联的文件并查询文件的大小。</p>
<p>移动到文件中的不同点然后从该位置读取或写入该位置的能力使得随机访问文件成为可能。</p>
<p>There are two methods for reading and writing channel I/O.</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newByteChannel-java.nio.file.Path-java.nio.file.OpenOption...-"><code>newByteChannel(Path, OpenOption...)</code></a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newByteChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-"><code>newByteChannel(Path, Set, FileAttribute...)</code></a></li>
</ul>
<p>注意：newByteChannel 方法返回 SeekableByteChannel 的一个实例。</p>
<p>使用默认文件系统，您可以将此可查找字节通道转换为 FileChannel 以提供对更高级功能的访问，例如将文件区域直接映射到内存以加快访问速度、锁定文件区域以便其他进程无法访问它，或者</p>
<p>从绝对位置读取和写入字节而不影响通道的当前位置。</p>
<p>两个 <code>newByteChannel</code> 方法都允许您指定一个 <code>OpenOption</code> 选项列表。</p>
<p>支持<code>newOutputStream</code> 方法使用的相同<a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#openOptions">打开选项</a>，</p>
<p>此外还有一个选项：<code>READ</code> 是必需的，因为 <code>SeekableByteChannel</code> 支持读取和写入。</p>
<p>指定 READ 打开读取通道。</p>
<p>指定 WRITE 或 APPEND 打开写入通道。</p>
<p>如果没有指定这些选项，则打开通道进行读取。</p>
<pre><code class="language-java">public static void readFile(Path path) throws IOException {

    // Files.newByteChannel() defaults to StandardOpenOption.READ
    try (SeekableByteChannel sbc = Files.newByteChannel(path)) {
        final int BUFFER_CAPACITY = 10;
        ByteBuffer buf = ByteBuffer.allocate(BUFFER_CAPACITY);

        // Read the bytes with the proper encoding for this platform. If
        // you skip this step, you might see foreign or illegible
        // characters.
        String encoding = System.getProperty(&quot;file.encoding&quot;);
        while (sbc.read(buf) &gt; 0) {
            buf.flip();
            System.out.print(Charset.forName(encoding).decode(buf));
            buf.clear();
        }
    }    
}
</code></pre>
<p>以下示例是为 UNIX 和其他 POSIX 文件系统编写的，它创建一个具有特定文件权限集的日志文件。</p>
<p>此代码创建一个日志文件或附加到日志文件（如果它已经存在）。</p>
<p>创建的日志文件具有所有者的读/写权限和组的只读权限。</p>
<pre><code class="language-java">import static java.nio.file.StandardOpenOption.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.io.*;
import java.util.*;

public class LogFilePermissionsTest {

  public static void main(String[] args) {
  
    // Create the set of options for appending to the file.
    Set&lt;OpenOption&gt; options = new HashSet&lt;OpenOption&gt;();
    options.add(APPEND);
    options.add(CREATE);

    // Create the custom permissions attribute.
    Set&lt;PosixFilePermission&gt; perms =
      PosixFilePermissions.fromString(&quot;rw-r-----&quot;);
    FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; attr =
      PosixFilePermissions.asFileAttribute(perms);

    // Convert the string to a ByteBuffer.
    String s = &quot;Hello World! &quot;;
    byte data[] = s.getBytes();
    ByteBuffer bb = ByteBuffer.wrap(data);
    
    Path file = Paths.get(&quot;./permissions.log&quot;);

    try (SeekableByteChannel sbc =
      Files.newByteChannel(file, options, attr)) {
      sbc.write(bb);
    } catch (IOException x) {
      System.out.println(&quot;Exception thrown: &quot; + x);
    }
  }
}
</code></pre>
<h1 id="methods-for-creating-regular-and-temporary-files"><a class="header" href="#methods-for-creating-regular-and-temporary-files">Methods for Creating Regular and Temporary Files</a></h1>
<h2 id="creating-files"><a class="header" href="#creating-files">Creating Files</a></h2>
<p>您可以使用 [<code>createFile(Path, FileAttribute)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/ Files.html#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-) 方法。</p>
<p>例如，如果在创建时，您希望文件具有一组特定的文件权限，请使用 <code>createFile</code> 方法来实现。</p>
<p>如果未指定任何属性，则使用默认属性创建文件。</p>
<p>如果文件已经存在，<code>createFile</code> 会抛出异常。</p>
<p><code>createFile</code> 方法检查文件的存在并创建具有指定属性的文件在单个原子操作中，这使得该过程更安全地抵御恶意代码。</p>
<p>以下代码片段创建了一个具有默认属性的文件</p>
<pre><code>Path file = ...;
try {
    // Create the empty file with default permissions, etc.
    Files.createFile(file);
} catch (FileAlreadyExistsException x) {
    System.err.format(&quot;file named %s&quot; +
        &quot; already exists%n&quot;, file);
} catch (IOException x) {
    // Some other sort of failure, such as permissions.
    System.err.format(&quot;createFile error: %s%n&quot;, x);
}
</code></pre>
<p><a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html#posix">POSIX 文件权限</a> 有一个使用 <code>createFile(Path, FileAttribute)</code> 创建文件的例子</p>
<p>具有预设权限。</p>
<p>您还可以使用 <code>newOutputStream</code> 方法创建新文件，如<a href="https://docs.oracle.com/javase/tutorial/essential/io/file.html#createStream">使用流 I/O 创建和写入文件</a>。</p>
<p>如果您打开一个新的输出流并立即关闭它，则会创建一个空文件。</p>
<h2 id="creating-temporary-files"><a class="header" href="#creating-temporary-files">Creating Temporary Files</a></h2>
<p>您可以使用以下 <code>createTempFile</code> 方法之一创建临时文件：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempFile-java.nio.file.Path-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-"><code>createTempFile(Path, String, String, FileAttribute)</code></a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempFile-java.lang.String-java.lang.String-java.nio.file.attribute.FileAttribute...-"><code>createTempFile(String, String, FileAttribute)</code></a></li>
</ul>
<p>第一种方法允许代码为临时文件指定一个目录，</p>
<p>第二种方法在默认临时文件目录中创建一个新文件。</p>
<p>这两种方法都允许您为文件名指定后缀，第一种方法还允许您指定前缀。</p>
<p>以下代码片段给出了第二种方法的示例：</p>
<pre><code>try {
    Path tempFile = Files.createTempFile(null, &quot;.myapp&quot;);
    System.out.format(&quot;The temporary file&quot; +
        &quot; has been created: %s%n&quot;, tempFile)
;
} catch (IOException x) {
    System.err.format(&quot;IOException: %s%n&quot;, x);
}
</code></pre>
<p>The result of running this file would be something like the following:</p>
<pre><code>The temporary file has been created: /tmp/509668702974537184.myapp
</code></pre>
<p>临时文件名的具体格式是平台特定的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="watching-a-directory-for-changes"><a class="header" href="#watching-a-directory-for-changes">Watching a Directory for Changes</a></h1>
<p>您是否曾经发现自己在使用 IDE 或其他编辑器编辑文件时会出现一个对话框，通知您其中一个打开的文件在文件系统上已更改并需要重新加载？</p>
<p>或者，像 NetBeans IDE 一样，应用程序只是悄悄地更新文件而不通知您。</p>
<p>要实现此功能，称为文件更改通知，程序必须能够检测文件系统上相关目录中发生的情况。</p>
<p>一种方法是轮询文件系统以查找更改，但这种方法效率低下。</p>
<p>它不能扩展到有数百个打开的文件或目录需要监控的应用程序。</p>
<p><code>java.nio.file</code> 包提供了一个文件更改通知 API，称为 Watch Service API。</p>
<p>此 API 使您能够向监视服务注册一个（或多个）目录。</p>
<p>注册时，您告诉服务您对哪些类型的事件感兴趣：文件创建、文件删除或文件修改。</p>
<p>当服务检测到感兴趣的事件时，会将其转发到注册进程。</p>
<p>已注册的进程有一个线程（或线程池），专门用于监视它已注册的任何事件。</p>
<p>当一个事件进入时，它会根据需要进行处理。</p>
<p>This section covers the following:</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html#overview">Watch Service Overview</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html#try">Try It Out</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html#register">Creating a Watch Service and Registering for Events</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html#process">Processing Events</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html#name">Retrieving the File Name</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html#concerns">When to Use and Not Use This API</a></li>
</ul>
<h1 id="watch-service-overview"><a class="header" href="#watch-service-overview">Watch Service Overview</a></h1>
<p><code>WatchService</code> API 是相当低级的，允许您对其进行自定义。</p>
<p>您可以按原样使用它，也可以选择在此机制之上创建一个高级 API，以便它适合您的特定需求。</p>
<p>以下是实施监控服务所需的基本步骤：-:</p>
<ul>
<li>
<p>为文件系统创建一个<code>WatchService</code>“观察者”。.</p>
</li>
<li>
<p>对于您要监视的每个目录，将其注册到观察者。</p>
<p>注册目录时，您可以指定要通知的事件类型。</p>
<p>对于您注册的每个目录，您都会收到一个“WatchKey”实例。.</p>
</li>
<li>
<p>实现无限循环以等待传入事件。</p>
<p>当一个事件发生时，密钥被发出信号并放入观察者的队列中。.</p>
</li>
<li>
<p>从观察者的队列中检索密钥。</p>
<p>您可以从密钥中获取文件名。.</p>
</li>
<li>
<p>检索密钥的每个待处理事件（可能有多个事件）并根据需要进行处理。.</p>
</li>
<li>
<p>重置密钥，并继续等待事件。.</p>
</li>
<li>
<p>关闭服务：当线程退出或关闭时（通过调用它的 <code>closed</code> 方法），watch 服务就会退出。</p>
</li>
</ul>
<p><code>WatchKeys</code> 是线程安全的，可以与 <code>java.nio.concurrent</code> 包一起使用。</p>
<p>您可以将 <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html">线程池</a> 用于这项工作。</p>
<h1 id="try-it-out"><a class="header" href="#try-it-out">Try It Out</a></h1>
<p>因为这个 API 更高级，所以在继续之前尝试一下。</p>
<p>将 <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/WatchDir.java"><code>WatchDir</code></a> 示例保存到您的计算机，并编译它。</p>
<p>创建一个将传递给示例的 <code>test</code> 目录。 </p>
<p><code>WatchDir</code> 使用单个线程来处理所有事件，因此它在等待事件时会阻止键盘输入。</p>
<p>在单独的窗口中或在后台运行程序，如下所示：</p>
<pre><code>java WatchDir test &amp;
</code></pre>
<p>在 <code>test</code> 目录中创建、删除和编辑文件。</p>
<p>当这些事件中的任何一个发生时，都会向控制台打印一条消息。</p>
<p>完成后，删除 <code>test</code> 目录，<code>WatchDir</code> 退出。</p>
<p>或者，如果您愿意，可以手动终止该进程。</p>
<p>您还可以通过指定 <code>-r</code> 选项来查看整个文件树。</p>
<p>当您指定 <code>-r</code> 时，<code>WatchDir</code> <a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html">walks </a></p>
<h1 id="creating-a-watch-service-and-registering-for-events"><a class="header" href="#creating-a-watch-service-and-registering-for-events">Creating a Watch Service and Registering for Events</a></h1>
<p>第一步是使用创建一个新的 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html"><code>WatchService</code></a>    <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#newWatchService"><code>newWatchService</code></a></p>
<p><code>FileSystem</code>类中的方法，如下：</p>
<pre><code>WatchService watcher = FileSystems.getDefault().newWatchService();
</code></pre>
<p>接下来，向监视服务注册一个或多个对象。</p>
<p>任何实现 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Watchable.html"><code>Watchable</code></a> 接口的对象都可以注册。 </p>
<p><code>Path</code> 类实现了 <code>Watchable</code> 接口，因此每个要监控的目录都注册为一个 <code>Path</code> 对象。</p>
<p>与任何 <code>Watchable</code> 一样，<code>Path</code> 类实现了两个 <code>register</code> 方法。</p>
<p>该页面使用了两个参数的版本，[<code>register(WatchService, WatchEvent.Kind...)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path .html#register-java.nio.file.WatchService-java.nio.file.WatchEvent.Kind...-)。 </p>
<p>（三参数版本采用“WatchEvent.Modifier”，目前尚未实现。）</p>
<p>向监视服务注册对象时，指定要监视的事件类型。</p>
<p>支持的 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/StandardWatchEventKinds.html"><code>StandardWatchEventKinds</code></a> 事件类型如下： -</p>
<ul>
<li>
<p><code>ENTRY_CREATE</code> – A directory entry is created.</p>
</li>
<li>
<p><code>ENTRY_DELETE</code> – A directory entry is deleted.</p>
</li>
<li>
<p><code>ENTRY_MODIFY</code> – A directory entry is modified.</p>
</li>
<li>
<p><code>OVERFLOW</code> –表示事件可能已丢失或丢弃。</p>
<p>您不必注册“OVERFLOW”事件即可接收它。</p>
</li>
</ul>
<p>The following code snippet shows how to register a <code>Path</code> instance for all three event types:</p>
<pre><code class="language-java">import static java.nio.file.StandardWatchEventKinds.*;

Path dir = ...;
try {
    WatchKey key = dir.register(watcher,
                           ENTRY_CREATE,
                           ENTRY_DELETE,
                           ENTRY_MODIFY);
} catch (IOException x) {
    System.err.println(x);
}
</code></pre>
<h1 id="processing-events"><a class="header" href="#processing-events">Processing Events</a></h1>
<p>事件处理循环中的事件顺序如下：:</p>
<ol>
<li>
<p>Get a watch key. Three methods are provided:</p>
<ul>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html#poll--"><code>poll</code></a> – 如果可用，返回排队的键。如果不可用，立即返回一个 <code>null</code> 值.</p>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html#poll-long-java.util.concurrent.TimeUnit-"><code>poll(long, TimeUnit)</code></a> – 返回一个排队的键，如果有的话。</p>
<p>如果排队的密钥不是立即可用的，程序将等待指定的时间。 </p>
<p><code>TimeUnit</code> 参数确定指定的时间是纳秒、毫秒还是其他时间单位.</p>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html#take--"><code>take</code></a> – 返回一个排队的键。</p>
<p>如果没有可用的排队键，则此方法等待.</p>
</li>
</ul>
</li>
<li>
<p>Process the pending events for the key. You fetch the <code>List</code> of <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchEvent.html"><code>WatchEvents</code></a>from the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchKey.html#pollEvents--"><code>pollEvents</code></a> method.</p>
</li>
<li>
<p>使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchEvent.html#kind--"><code>kind</code></a> 方法检索事件类型。</p>
<p>无论密钥注册了什么事件，都有可能收到“OVERFLOW”事件。</p>
<p>您可以选择处理溢出或忽略它，但您应该对其进行测试。</p>
</li>
<li>
<p>检索与事件关联的文件名。</p>
<p>文件名存储为事件的上下文，因此 [<code>context</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchEvent.html#context- -) 方法用于检索它。</p>
</li>
<li>
<p>After the events for the key have been processed, you need to put the key back into a <code>ready</code> state by invoking <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchEvent.html#reset--"><code>reset</code></a>. If this method returns <code>false</code>, the key is no longer valid and the loop can exit. This step is very <strong>important</strong>. If you fail to invoke <code>reset</code>, this key will not receive any further events.</p>
</li>
</ol>
<p>A watch key has a state. 在任何给定时间，它的状态可能是以下之一:</p>
<ul>
<li>
<p><code>Ready</code> 已准备好接受事件。首次创建时，key处于就绪状态.</p>
</li>
<li>
<p><code>Signaled</code> 表示一个或多个事件正在排队。</p>
<p>一旦密钥发出信号，它就不再处于就绪状态，直到 [<code>reset</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchKey.html #reset--) 方法被调用。 </p>
</li>
<li>
<p><code>Invalid</code></p>
<p>表示该键不再处于活动状态。</p>
<p>当发生以下事件之一时会发生此状态</p>
<ul>
<li>The process explicitly cancels the key by using the <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchKey.html#cancel--"><code>cancel</code></a> method.</li>
<li>The directory becomes inaccessible.</li>
<li>The watch service is <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/WatchService.html#close--">closed</a>.</li>
</ul>
</li>
</ul>
<p>这是事件处理循环的示例。</p>
<p>它取自 <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Email.java"><code>Email</code></a> 示例，该示例监视目录，等待新文件出现。</p>
<p>当一个新文件可用时，通过使用 [<code>probeContentType(Path)</code>](https://docs.oracle.com/javase/8/docs/ api/java/nio/file/Files.html#probeContentType-java.nio.file.Path-) 方法。</p>
<p>其目的是将 <code>text/plain</code> 文件通过电子邮件发送到别名，但实现细节留给读者。</p>
<p><strong>The methods specific to the watch service API are shown in bold:</strong></p>
<pre><code class="language-java">for (;;) {

    // wait for key to be signaled
    WatchKey key;
    try {
        key = watcher.take();
    } catch (InterruptedException x) {
        return;
    }

    for (WatchEvent&lt;?&gt; event: key.pollEvents()) {
        WatchEvent.Kind&lt;?&gt; kind = event.kind();

        // This key is registered only
        // for ENTRY_CREATE events,
        // but an OVERFLOW event can
        // occur regardless if events
        // are lost or discarded.
        if (kind == OVERFLOW) {
            continue;
        }

        // The filename is the
        // context of the event.
        WatchEvent&lt;Path&gt; ev = (WatchEvent&lt;Path&gt;)event;
        Path filename = ev.context();

        // Verify that the new
        //  file is a text file.
        try {
            // Resolve the filename against the directory.
            // If the filename is &quot;test&quot; and the directory is &quot;foo&quot;,
            // the resolved name is &quot;test/foo&quot;.
            Path child = dir.resolve(filename);
            if (!Files.probeContentType(child).equals(&quot;text/plain&quot;)) {
                System.err.format(&quot;New file '%s'&quot; +
                    &quot; is not a plain text file.%n&quot;, filename);
                continue;
            }
        } catch (IOException x) {
            System.err.println(x);
            continue;
        }

        // Email the file to the
        //  specified email alias.
        System.out.format(&quot;Emailing file %s%n&quot;, filename);
        //Details left to reader....
    }

    // Reset the key -- this step is critical if you want to
    // receive further watch events.  If the key is no longer valid,
    // the directory is inaccessible so exit the loop.
    boolean valid = key.reset();
    if (!valid) {
        break;
    }
}
</code></pre>
<h1 id="retrieving-the-file-name"><a class="header" href="#retrieving-the-file-name">Retrieving the File Name</a></h1>
<p>从事件上下文中检索文件名。 </p>
<p><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Email.java"><code>Email</code></a> 示例使用以下代码检索文件名：</p>
<pre><code>WatchEvent&lt;Path&gt; ev = (WatchEvent&lt;Path&gt;)event;
Path filename = ev.context();
</code></pre>
<p>当您编译 <code>Email</code> 示例时，它会生成以下错误：</p>
<pre><code>Note: Email.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
</code></pre>
<p>此错误是将 <code>WatchEvent</code> 转换为 <code>WatchEvent</code> 的代码行造成的。 </p>
<p><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/WatchDir.java"><code>WatchDir</code></a> 示例通过创建一个实用程序 <code>cast</code> 方法来抑制未经检查的警告，从而避免了这个错误，如</p>
<p>如下：</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
static &lt;T&gt; WatchEvent&lt;T&gt; cast(WatchEvent&lt;?&gt; event) {
    return (WatchEvent&lt;Path&gt;)event;
}
</code></pre>
<h1 id="when-to-use-and-not-use-this-api"><a class="header" href="#when-to-use-and-not-use-this-api">When to Use and Not Use This API</a></h1>
<p>Watch Service API 是为需要收到文件更改事件通知的应用程序设计的。</p>
<p>它非常适合任何应用程序，如编辑器或 IDE，可能有许多打开的文件并需要确保文件与文件系统同步。</p>
<p>它也非常适合监视目录的应用程序服务器，可能等待<code>.jsp</code> 或<code>.jar</code> 文件删除，以便部署它们。</p>
<p>此 API <em>不是</em>设计用于索引硬盘驱动器。</p>
<p>大多数文件系统实现都具有对文件更改通知的本机支持。 </p>
<p>Watch Service API 在可用的情况下利用此支持。</p>
<p>但是，当文件系统不支持此机制时，Watch Service 将轮询文件系统，等待事件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-and-reading-directories"><a class="header" href="#creating-and-reading-directories">Creating and Reading Directories</a></h1>
<p>前面讨论的一些方法，例如删除、处理文件、链接和目录。</p>
<p>但是如何列出文件系统 <strong>root</strong>的所有目录呢？</p>
<p>如何列出目录的内容或创建目录？</p>
<p>本节涵盖以下特定于目录的功能：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#listall">Listing a File System's Root Directories</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#create">Creating a Directory</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#createTemp">Creating a Temporary Directory</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#listdir">Listing a Directory's Contents</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#glob">Filtering a Directory Listing By Using Globbing</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/dirs.html#filter">Writing Your Own Directory Filter</a></li>
</ul>
<h1 id="listing-a-file-systems-root-directories"><a class="header" href="#listing-a-file-systems-root-directories">Listing a File System's Root Directories</a></h1>
<p>您可以使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#"><code>FileSystem.getRootDirectories</code></a> 列出文件系统的所有根目录</p>
<p>此方法返回一个 <code>Iterable</code>，它使您能够使用 <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html">enhanced for</a> 语句遍历所有根目录。</p>
<p>以下代码片段打印默认文件系统的根目录</p>
<pre><code>Iterable&lt;Path&gt; dirs = FileSystems.getDefault().getRootDirectories();
for (Path name: dirs) {
    System.err.println(name);
}
</code></pre>
<h1 id="creating-a-directory"><a class="header" href="#creating-a-directory">Creating a Directory</a></h1>
<p>您可以使用 [<code>createDirectory(Path, FileAttribute)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectory- java.nio.file.Path-java.nio.file.attribute.FileAttribute...-) 方法。</p>
<p>如果您不指定任何 <code>FileAttributes</code>，新目录将具有默认属性。</p>
<pre><code>Path dir = ...;
Files.createDirectory(path);
</code></pre>
<p>以下代码片段在具有特定权限的 POSIX 文件系统上创建一个新目录：</p>
<pre><code class="language-java">Set&lt;PosixFilePermission&gt; perms =
    PosixFilePermissions.fromString(&quot;rwxr-x---&quot;);
FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; attr =
    PosixFilePermissions.asFileAttribute(perms);
Files.createDirectory(file, attr);
</code></pre>
<p>要在一个或多个父目录可能尚不存在时创建一个多级目录，您可以使用便捷方法 [<code>createDirectories(Path, FileAttribute)</code>](https://docs.oracle.com/javase/ 8/docs/api/java/nio/file/Files.html#createDirectories-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-)。</p>
<p>与 <code>createDirectory(Path, FileAttribute)</code> 方法一样，您可以指定一组可选的初始文件属性。</p>
<p>以下代码片段使用默认属性：</p>
<pre><code>Files.createDirectories(Paths.get(&quot;foo/bar/test&quot;));
</code></pre>
<p>根据需要从上到下创建目录。</p>
<p>在 <code>foo/bar/test</code> 示例中，如果 <code>foo</code> 目录不存在，则会创建它。</p>
<p>接下来，如果需要，创建 <code>bar</code> 目录，最后创建 <code>test</code> 目录。</p>
<p>在创建一些（但不是全部）父目录后，此方法可能会失败。</p>
<h1 id="creating-a-temporary-directory"><a class="header" href="#creating-a-temporary-directory">Creating a Temporary Directory</a></h1>
<p>You can create a temporary directory using one of <code>createTempDirectory</code> methods:</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempDirectory-java.nio.file.Path-java.lang.String-java.nio.file.attribute.FileAttribute...-"><code>createTempDirectory(Path, String, FileAttribute...)</code></a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createTempDirectory-java.lang.String-java.nio.file.attribute.FileAttribute...-"><code>createTempDirectory(String, FileAttribute...)</code></a></li>
</ul>
<p>第一种方法允许代码指定临时目录的位置，第二种方法在默认临时文件目录中创建一个新目录。</p>
<h1 id="listing-a-directorys-contents"><a class="header" href="#listing-a-directorys-contents">Listing a Directory's Contents</a></h1>
<p>您可以使用 [<code>newDirectoryStream(Path)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#newDirectoryStream -java.nio.file.Path-) 方法。</p>
<p>此方法返回一个实现 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/DirectoryStream.html"><code>DirectoryStream</code></a> 接口的对象。</p>
<p>实现<code>DirectoryStream</code> 接口的类也实现了<code>Iterable</code>，因此您可以遍历目录流，读取所有对象。</p>
<p>这种方法可以很好地扩展到非常大的目录。</p>
<hr />
<p><strong>记住：</strong> 返回的 <code>DirectoryStream</code> 是一个 <em>stream</em>。</p>
<p>如果你没有使用 <code>try-</code>with-resources 语句，不要忘记在 <code>finally</code> 块中关闭流。 </p>
<p><code>try-</code>with-resources 语句会为您处理这个问题。</p>
<hr />
<pre><code class="language-java">Path dir = ...;
try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir)) {
    for (Path file: stream) {
        System.out.println(file.getFileName());
    }
} catch (IOException | DirectoryIteratorException x) {
    // IOException can never be thrown by the iteration.
    // In this snippet, it can only be thrown by newDirectoryStream.
    System.err.println(x);
}
</code></pre>
<p>迭代器返回的“Path”对象是针对目录解析的条目的名称。</p>
<p>因此，如果您要列出 <code>/tmp</code> 目录的内容，则条目将以 <code>/tmp/a</code>、<code>/tmp/b</code> 等形式返回。</p>
<p>此方法返回目录的全部内容：文件、链接、子目录和隐藏文件。</p>
<p>如果您想对检索的内容更有选择性，您可以使用其他 <code>newDirectoryStream</code> 方法之一，如本页稍后所述。</p>
<p>请注意，如果在目录迭代过程中出现异常，则会抛出“DirectoryIteratorException”，并将“IOException”作为原因。</p>
<p>迭代器方法不能抛出异常异常。</p>
<h1 id="filtering-a-directory-listing-by-using-globbing"><a class="header" href="#filtering-a-directory-listing-by-using-globbing">Filtering a Directory Listing By Using Globbing</a></h1>
<p>如果您只想获取每个名称与特定模式匹配的文件和子目录，您可以使用 [<code>newDirectoryStream(Path, String)</code>](https://docs.oracle.com/javase/8/docs /api/java/nio/file/Files.html#newDirectoryStream-java.nio.file.Path-java.lang.String-) 方法，它提供了一个内置的 glob 过滤器。</p>
<p>For example, the following code snippet lists files relating to Java: <em>.class</em>, <em>.java</em>, and <em>.jar</em> files.:</p>
<pre><code>Path dir = ...;
try (DirectoryStream&lt;Path&gt; stream =
     Files.newDirectoryStream(dir, &quot;*.{java,class,jar}&quot;)) {
    for (Path entry: stream) {
        System.out.println(entry.getFileName());
    }
} catch (IOException x) {
    // IOException can never be thrown by the iteration.
    // In this snippet, it can // only be thrown by newDirectoryStream.
    System.err.println(x);
}
</code></pre>
<h1 id="writing-your-own-directory-filter"><a class="header" href="#writing-your-own-directory-filter">Writing Your Own Directory Filter</a></h1>
<p>也许您想根据模式匹配以外的某些条件过滤目录的内容。</p>
<p>您可以通过实现 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/DirectoryStream.Filter.html"><code>DirectoryStream.Filter</code></a> 接口来创建自己的过滤器。</p>
<p>这个接口包含一个方法，<code>accept</code>，它确定一个文件是否满足搜索要求。</p>
<p>例如，以下代码片段实现了一个仅检索目录的过滤器：</p>
<pre><code>DirectoryStream.Filter&lt;Path&gt; filter =
    newDirectoryStream.Filter&lt;Path&gt;() {
    public boolean accept(Path file) throws IOException {
        try {
            return (Files.isDirectory(path));
        } catch (IOException x) {
            // Failed to determine if it's a directory.
            System.err.println(x);
            return false;
        }
    }
};
</code></pre>
<p>创建过滤器后，可以使用 [<code>newDirectoryStream(Path, DirectoryStream.Filter)</code>](https://docs.oracle.com/javase/8/docs/api/java/nio/file /Files.html#newDirectoryStream-java.nio.file.Path-java.nio.file.DirectoryStream.Filter-) 方法。</p>
<p>以下代码片段使用 <code>isDirectory</code> 过滤器仅将目录的子目录打印到标准输出：</p>
<pre><code>Path dir = ...;
try (DirectoryStream&lt;Path&gt;
                       stream = Files.newDirectoryStream(dir, filter)) {
    for (Path entry: stream) {
        System.out.println(entry.getFileName());
    }
} catch (IOException x) {
    System.err.println(x);
}
</code></pre>
<p>此方法仅用于过滤单个目录。</p>
<p>但是，如果要查找文件树中的所有子目录，则可以使用 <a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html">Walking the File Tree</a> 机制</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-path-and-other-file-system-facts"><a class="header" href="#what-is-a-path-and-other-file-system-facts">What Is a Path? (And Other File System Facts)</a></h1>
<p>文件系统在某种形式的媒体（通常是一个或多个硬盘驱动器）上存储和组织文件，以便可以轻松检索这些文件。</p>
<p>今天使用的大多数文件系统将文件存储在树（或分层）结构中。</p>
<p>树的顶部是一个（或多个）根节点。</p>
<p>在根节点下，有文件和目录（Microsoft Windows 中的文件夹）。</p>
<p>每个目录可以包含文件和子目录，而这些文件和子目录又可以包含文件和子目录等等，其深度可能几乎是无限的。</p>
<h2 id="what-is-a-path"><a class="header" href="#what-is-a-path">What Is a Path?</a></h2>
<p>Microsoft Windows 支持多个根节点。</p>
<p>每个根节点映射到一个卷，例如 C:\ 或 D:\。 </p>
<p>Solaris OS 支持单个根节点，用斜杠字符 / 表示。</p>
<p><strong>文件由其在文件系统中的路径标识，从根节点开始。</strong></p>
<p>用于分隔目录名称的字符（也称为定界符）特定于文件系统：Solaris OS 使用正斜杠 (/)，而 Microsoft Windows 使用反斜杠 ()。</p>
<h2 id="relative-or-absolute"><a class="header" href="#relative-or-absolute">Relative or Absolute?</a></h2>
<p>路径要么是相对的，要么是绝对的。</p>
<p>绝对路径始终包含根元素和定位文件所需的完整目录列表。</p>
<p>例如，/home/sally/statusReport 是绝对路径。</p>
<p>定位文件所需的所有信息都包含在路径字符串中。</p>
<p>相对路径需要与另一个路径结合才能访问文件。</p>
<p>例如，joe/foo 是一个相对路径。</p>
<p>如果没有更多信息，程序就无法可靠地定位文件系统中的 joe/foo 目录。</p>
<h2 id="symbolic-links"><a class="header" href="#symbolic-links">Symbolic Links</a></h2>
<p>文件系统对象通常是目录或文件。</p>
<p>每个人都熟悉这些对象。</p>
<p>但是一些文件系统也支持符号链接的概念。</p>
<p>符号链接也称为符号链接或软链接。符号链接是一种特殊文件，用作对另一个文件的引用。</p>
<p>大多数情况下，符号链接对应用程序是透明的，对符号链接的操作会自动重定向到链接的目标。 </p>
<p>（被指向的文件或目录称为链接的目标。）例外情况是符号链接被删除或重命名，在这种情况下，链接本身被删除，或重命名而不是链接的目标。</p>
<p>符号链接通常对用户是透明的。</p>
<p>读取或写入符号链接与读取或写入任何其他文件或目录相同。</p>
<p>在实际场景中，大多数文件系统自由使用符号链接。</p>
<p>偶尔，一个不小心创建的符号链接会导致循环引用。</p>
<p>当链接的目标指向原始链接时，就会发生循环引用。</p>
<p>循环引用可能是间接的：目录 a 指向目录 b，目录 b 指向目录 c，其中包含一个指向目录 a 的子目录。</p>
<p>当程序递归遍历目录结构时，循环引用可能会造成严重破坏。</p>
<p>但是，这种情况已被考虑在内，不会导致您的程序无限循环。</p>
<h1 id="the-path-class"><a class="header" href="#the-path-class">The Path Class</a></h1>
<p>As its name implies,</p>
<p>顾名思义，Path 类是文件系统中路径的编程表示。 </p>
<p>Path 对象包含用于构造路径的文件名和目录列表，用于检查、定位和操作文件。</p>
<p><code>Path</code> 实例反映了底层平台</p>
<p>在 Solaris OS 中，<code>Path</code> 使用 Solaris 语法（<code>/home/joe/foo</code>），而在 Microsoft Windows 中，<code>Path</code> 使用 Windows 语法（<code>C:\home\joe\foo</code>）。 </p>
<p>与“Path”对应的文件或目录可能不存在。</p>
<p>您可以创建一个 <code>Path</code> 实例并以各种方式操作它</p>
<p>append to it</p>
<p>extract pieces of it</p>
<p>compare it to another path</p>
<p>在适当的时候，您可以使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html"><code>Files</code></a> 类中的方法来</p>
<ul>
<li>检查<code>Path</code> 对应的文件是否存在</li>
<li>create the file</li>
<li>open it</li>
<li>delete it</li>
<li>change its permissions</li>
</ul>
<h1 id="path-operations"><a class="header" href="#path-operations">Path Operations</a></h1>
<p>Path 类包括各种方法获取有关路径的信息、访问路径的元素、将路径转换为其他形式或提取路径的一部分</p>
<p>还有匹配路径字符串的方法和删除路径中冗余的方法。</p>
<p>本课讨论这些 Path 方法，有时称为句法操作，<strong>因为它们对路径本身进行操作并且不访问文件系统。</strong></p>
<h2 id="creating-a-path"><a class="header" href="#creating-a-path">Creating a Path</a></h2>
<p>在定义时，路径被提供了一系列一个或多个名称。</p>
<p>可能包含根元素或文件名，但两者都不是必需的。</p>
<p>路径可能只包含一个目录或文件名。</p>
<pre><code class="language-java">Path p1 = Paths.get(&quot;/tmp/foo&quot;);
Path p2 = Paths.get(args[0]);
Path p3 = Paths.get(URI.create(&quot;file:///Users/joe/FileTest.java&quot;));
</code></pre>
<p><strong>Paths.get 方法是以下代码的简写：</strong></p>
<pre><code class="language-java">Path p4 = FileSystems.getDefault().getPath(&quot;/users/sally&quot;);
</code></pre>
<p>以下示例创建 /u/joe/logs/foo.log 假设您的主目录是 /u/joe，或者 C:\joe\logs\foo.log（如果您使用的是 Windows）。</p>
<pre><code class="language-java">Path p5 = Paths.get(System.getProperty(&quot;user.home&quot;),&quot;logs&quot;, &quot;foo.log&quot;);
</code></pre>
<h2 id="retrieving-information-about-a-path"><a class="header" href="#retrieving-information-about-a-path">Retrieving Information about a Path</a></h2>
<p>您可以将 Path 视为将这些名称元素存储为序列。</p>
<p>目录结构中的最高元素将位于索引 0。目录结构中的最低元素将位于索引 [n-1]，其中 n 是路径中名称元素的数量。</p>
<p>可以使用这些索引检索单个元素或 Path 的子序列的方法。</p>
<pre><code class="language-java">// None of these methods requires that the file corresponding
// to the Path exists.
// Microsoft Windows syntax
Path path = Paths.get(&quot;C:\\home\\joe\\foo&quot;);

// Solaris syntax
Path path = Paths.get(&quot;/home/joe/foo&quot;);

System.out.format(&quot;toString: %s%n&quot;, path.toString());
System.out.format(&quot;getFileName: %s%n&quot;, path.getFileName());
System.out.format(&quot;getName(0): %s%n&quot;, path.getName(0));
System.out.format(&quot;getNameCount: %d%n&quot;, path.getNameCount());
System.out.format(&quot;subpath(0,2): %s%n&quot;, path.subpath(0,2));
System.out.format(&quot;getParent: %s%n&quot;, path.getParent());
System.out.format(&quot;getRoot: %s%n&quot;, path.getRoot());
</code></pre>
<p><strong>方法表</strong></p>
<table><thead><tr><th>Method Invoked</th><th>Returns in the Solaris OS</th><th>Returns in Microsoft Windows</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>toString</code></td><td><code>/home/joe/foo</code></td><td><code>C:\home\joe\foo</code></td><td>返回 <code>Path</code> 的字符串表示形式。 <br />如果路径是使用 <code>Filesystems.getDefault().getPath(String)</code> 或 <code>Paths.get</code>（后者是 <code>getPath</code> 的一种便捷方法）创建的，则该方法会执行轻微的语法清理。<br />例如，在 UNIX 操作系统中，它会将输入字符串 <code>//home/joe/foo</code> 更正为 <code>/home/joe/foo</code>。</td></tr>
<tr><td><code>getFileName</code></td><td><code>foo</code></td><td><code>foo</code></td><td>返回文件名或名称元素序列的最后一个元素。</td></tr>
<tr><td><code>getName(0)</code></td><td><code>home</code></td><td><code>home</code></td><td>返回与指定索引对应的路径元素。<br/><br/>第 0 个元素是最接近根的路径元素。</td></tr>
<tr><td><code>getNameCount</code></td><td><code>3</code></td><td><code>3</code></td><td>返回路径中的元素数。</td></tr>
<tr><td><code>subpath(0,2)</code></td><td><code>home/joe</code></td><td><code>home\joe</code></td><td>返回由开始和结束索引指定的 <code>Path</code> 的子序列（不包括根元素）。</td></tr>
<tr><td><code>getParent</code></td><td><code>/home/joe</code></td><td><code>\home\joe</code></td><td>返回父目录的路径</td></tr>
<tr><td><code>getRoot</code></td><td><code>/</code></td><td><code>C:\</code></td><td>Returns the root of the path.</td></tr>
</tbody></table>
<p>前面的示例显示了绝对路径的输出。在以下示例中，指定了相对路径：</p>
<pre><code class="language-java">// Solaris syntax
Path path = Paths.get(&quot;sally/bar&quot;);
or
// Microsoft Windows syntax
Path path = Paths.get(&quot;sally\\bar&quot;);
</code></pre>
<p>Here is the output for Windows and the Solaris OS:</p>
<table><thead><tr><th>Method Invoked</th><th>Returns in the Solaris OS</th><th>Returns in Microsoft Windows</th></tr></thead><tbody>
<tr><td><code>toString</code></td><td><code>sally/bar</code></td><td><code>sally\bar</code></td></tr>
<tr><td><code>getFileName</code></td><td><code>bar</code></td><td><code>bar</code></td></tr>
<tr><td><code>getName(0)</code></td><td><code>sally</code></td><td><code>sally</code></td></tr>
<tr><td><code>getNameCount</code></td><td><code>2</code></td><td><code>2</code></td></tr>
<tr><td><code>subpath(0,1)</code></td><td><code>sally</code></td><td><code>sally</code></td></tr>
<tr><td><code>getParent</code></td><td><code>sally</code></td><td><code>sally</code></td></tr>
<tr><td><code>getRoot</code></td><td><code>null</code></td><td><code>null</code></td></tr>
</tbody></table>
<h2 id="removing-redundancies-from-a-path"><a class="header" href="#removing-redundancies-from-a-path">Removing Redundancies From a Path</a></h2>
<p>许多文件系统使用“.” 符号表示当前目录，“..”表示父目录。</p>
<p>您可能会遇到路径包含冗余目录信息的情况。</p>
<p>也许服务器被配置为将其日志文件保存在&quot;<code>/dir/logs/.</code>&quot;中。</p>
<p>您想从路径中删除尾随的 &quot;<code>/.</code>&quot; </p>
<p>The following examples both include redundancies:</p>
<pre><code>/home/./joe/foo
/home/sally/../joe/foo
</code></pre>
<p>重要的是要注意，<code>normalize</code> 在清理路径时不会检查文件系统。<strong>这是一个纯粹的语法操作。</strong></p>
<p>在第二个例子中，如果 <code>sally</code> 是一个符号链接，删除 <code>sally/..</code> 可能会导致一个 <code>Path</code> 不再定位目标文件。</p>
<p>要清理路径同时确保结果找到正确的文件，您可以使用 <code>toRealPath</code> 方法。</p>
<p>This method is described in the next section, <a href="https://docs.oracle.com/javase/tutorial/essential/io/pathOps.html#convert">Converting a Path</a>.</p>
<h2 id="converting-a-path"><a class="header" href="#converting-a-path">Converting a Path</a></h2>
<p>您可以使用三种方法来转换路径。</p>
<h3 id="touri"><a class="header" href="#touri">toURI</a></h3>
<p>如果需要将路径转换为可以从浏览器打开的字符串，可以使用 toUri。</p>
<pre><code class="language-java">Path p1 = Paths.get(&quot;/home/logfile&quot;);
// Result is file:///home/logfile
System.out.format(&quot;%s%n&quot;, p1.toUri());
</code></pre>
<h3 id="toabsolutepath"><a class="header" href="#toabsolutepath">toAbsolutePath</a></h3>
<p><strong>toAbsolutePath</strong> 方法将路径转换为绝对路径。</p>
<p>如果传入的路径已经是绝对路径，则返回相同的 Path 对象。 </p>
<p>toAbsolutePath 方法在处理用户输入的文件名时非常有用。</p>
<pre><code class="language-java">public class FileTest {
    public static void main(String[] args) {

        if (args.length &lt; 1) {
            System.out.println(&quot;usage: FileTest file&quot;);
            System.exit(-1);
        }

        // Converts the input string to a Path object.
        Path inputPath = Paths.get(args[0]);

        // Converts the input Path
        // to an absolute path.
        // Generally, this means prepending
        // the current working
        // directory.  If this example
        // were called like this:
        //     java FileTest foo
        // the getRoot and getParent methods
        // would return null
        // on the original &quot;inputPath&quot;
        // instance.  Invoking getRoot and
        // getParent on the &quot;fullPath&quot;
        // instance returns expected values.
        Path fullPath = inputPath.toAbsolutePath();
    }
}
</code></pre>
<p>toAbsolutePath 方法转换用户输入并返回一个 Path，该 Path 在查询时返回有用的值。</p>
<p>该文件不需要存在即可使用此方法。</p>
<h3 id="torealpath"><a class="header" href="#torealpath">toRealPath</a></h3>
<p>toRealPath 方法返回现有文件的真实路径。</p>
<p>此方法将多个操作合二为一：</p>
<ul>
<li>
<p>如果 true 传递给此方法并且文件系统支持符号链接，则此方法解析路径中的任何符号链接。</p>
</li>
<li>
<p>如果 Path 是相对的，则返回绝对路径。</p>
</li>
<li>
<p>如果 Path 包含任何冗余元素，则返回删除了这些元素的路径。</p>
</li>
</ul>
<p>如果文件不存在或无法访问，此方法将引发异常。</p>
<p>当您想要处理任何这些情况时，您可以捕获异常。</p>
<pre><code class="language-java">try {
    Path fp = path.toRealPath();
} catch (NoSuchFileException x) {
    System.err.format(&quot;%s: no such&quot; + &quot; file or directory%n&quot;, path);
    // Logic for case when file doesn't exist.
} catch (IOException x) {
    System.err.format(&quot;%s%n&quot;, x);
    // Logic for other sort of file error.
}
</code></pre>
<h2 id="joining-two-paths"><a class="header" href="#joining-two-paths">Joining Two Paths</a></h2>
<p>您可以使用 <code>resolve</code> 方法组合路径。</p>
<p>您传入一个 <em>partial path</em> ，这是一个不包含根元素的路径，并且该部分路径被附加到原始路径。</p>
<p>For example, consider the following code snippet:</p>
<pre><code>// Solaris
Path p1 = Paths.get(&quot;/home/joe/foo&quot;);
// Result is /home/joe/foo/bar
System.out.format(&quot;%s%n&quot;, p1.resolve(&quot;bar&quot;));

or

// Microsoft Windows
Path p1 = Paths.get(&quot;C:\\home\\joe\\foo&quot;);
// Result is C:\home\joe\foo\bar
System.out.format(&quot;%s%n&quot;, p1.resolve(&quot;bar&quot;));
</code></pre>
<p>将绝对路径传递给 <code>resolve</code> 方法返回传入的路径：``` // 结果是 /home/joe Paths.get(&quot;foo&quot;).resolve(&quot;/home/joe&quot;); </p>
<pre><code>// Result is /home/joe
Paths.get(&quot;foo&quot;).resolve(&quot;/home/joe&quot;);
</code></pre>
<h2 id="creating-a-path-between-two-paths"><a class="header" href="#creating-a-path-between-two-paths">Creating a Path Between Two Paths</a></h2>
<p>The <code>Path</code> class supports <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#equals-java.lang.Object-"><code>equals</code></a>, enabling you to test two paths for equality.</p>
<p><code>Path</code> 类支持 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#equals-java.lang.Object-"><code>equals</code></a>，使您能够测试两条路径是否相等。 </p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#startsWith-java.nio.file.Path-"><code>startsWith</code></a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#endsWith-java.nio.file.Path-"><code>endsWith </code></a> 方法使您能够测试路径是否</p>
<p>以特定字符串开头或结尾。</p>
<p>这些方法很容易使用。</p>
<p>For example:</p>
<pre><code>Path path = ...;
Path otherPath = ...;
Path beginning = Paths.get(&quot;/home&quot;);
Path ending = Paths.get(&quot;foo&quot;);

if (path.equals(otherPath)) {
    // equality logic here
} else if (path.startsWith(beginning)) {
    // path begins with &quot;/home&quot;
} else if (path.endsWith(ending)) {
    // path ends with &quot;foo&quot;
}
</code></pre>
<h2 id="iterablecompareable"><a class="header" href="#iterablecompareable">Iterable、Compareable</a></h2>
<p><code>Path</code> 类实现了 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html"><code>Iterable</code></a> 接口。 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#iterator--"><code>iterator</code></a> 方法返回一个对象，该对象使您能够迭代路径中的名称元素。</p>
<p>返回的第一个元素是最接近目录树中根的元素。</p>
<pre><code>Path path = ...;
for (Path name: path) {
    System.out.println(name);
}
</code></pre>
<p><code>Path</code> 类还实现了 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html"><code>Comparable</code></a> 接口。</p>
<p>您可以使用对排序很有用的 <code>compareTo</code> 来比较 <code>Path</code> 对象。</p>
<p>您还可以将 <code>Path</code> 对象放入 <code>Collection</code>。</p>
<p>有关此强大功能的更多信息，请参阅 <a href="https://docs.oracle.com/javase/tutorial/collections/index.html">Collections</a> 跟踪。</p>
<p>当你想验证两个 <code>Path</code> 对象是否定位到同一个文件时，你可以使用 <code>isSameFile</code> 方法，如<a href="https://docs.oracle.com/javase/tutorial/essential/io/check.html#same">检查两个路径是否定位到同一个文件</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="walking-the-file-tree"><a class="header" href="#walking-the-file-tree">Walking the File Tree</a></h1>
<p>您是否需要创建一个应用程序来递归访问文件树中的所有文件？</p>
<p>也许您需要删除树中的每个 .class 文件，或者查找去年未访问过的每个文件。</p>
<p>您可以使用 FileVisitor 接口执行此操作。</p>
<p>This section covers the following:</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html#filevisitor">The FileVisitor Interface</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html#invoke">Kickstarting the Process</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html#order">Considerations When Creating a FileVisitor</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html#return">Controlling the Flow</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/walk.html#ex">Examples</a></li>
</ul>
<h1 id="the-filevisitor-interface"><a class="header" href="#the-filevisitor-interface">The FileVisitor Interface</a></h1>
<p>要遍历文件树，首先需要实现一个 <code>FileVisitor</code></p>
<p><code>FileVisitor</code> 指定了遍历过程中关键点所需的行为：</p>
<ol>
<li>访问文件时</li>
<li>在访问目录之前</li>
<li>访问目录后</li>
<li>当发生故障时</li>
</ol>
<p>该接口有四种方法对应于这些情况：-</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html#preVisitDirectory-T-java.nio.file.attribute.BasicFileAttributes-"><code>preVisitDirectory</code></a> – 在访问目录条目之前调用.</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html#postVisitDirectory-T-java.io.IOException-"><code>postVisitDirectory</code></a> – 在访问目录中的所有条目后调用。如果遇到任何错误，则将特定异常传递给方法.</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html#visitFile-T-java.nio.file.attribute.BasicFileAttributes-"><code>visitFile</code></a> –  在被访问的文件上调用。文件的<code>BasicFileAttributes</code> 传递给方法，或者您可以使用<a href="https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html">文件属性</a> 包读取特定的一组属性。例如，您可以选择读取文件的<code>DosFileAttributeView</code> 来确定文件是否设置了“隐藏”位。</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitor.html#visitFileFailedy-T-java.io.IOException-"><code>visitFileFailed</code></a> – 当无法访问文件时调用。特定的异常被传递给方法。您可以选择是否抛出异常、将其打印到控制台或日志文件等。</li>
</ul>
<p>如果您不需要实现所有四个 <code>FileVisitor</code> 方法，而不是实现 <code>FileVisitor</code> 接口，您可以扩展 [<code>SimpleFileVisitor</code>](https://docs.oracle.com/javase/8/ docs/api/java/nio/file/SimpleFileVisitor.html) 类 </p>
<p>该类实现了<code>FileVisitor</code> 接口，访问树中的所有文件，并在遇到错误时抛出<code>IOError</code>。</p>
<p>您可以扩展此类并仅覆盖您需要的方法。</p>
<p>这是一个扩展 <code>SimpleFileVisitor</code> 以打印文件树中所有条目的示例。</p>
<p>无论条目是常规文件、符号链接、目录还是其他“未指定”类型的文件，它都会打印条目。</p>
<p>它还打印每个文件的大小（以字节为单位）。</p>
<p>遇到的任何异常都会打印到控制台。</p>
<p>The <code>FileVisitor</code> methods are shown in bold:</p>
<pre><code class="language-java">import static java.nio.file.FileVisitResult.*;

public static class PrintFiles
    extends SimpleFileVisitor&lt;Path&gt; {

    // Print information about
    // each type of file.
    @Override
    public FileVisitResult visitFile(Path file,
                                   BasicFileAttributes attr) {
        if (attr.isSymbolicLink()) {
            System.out.format(&quot;Symbolic link: %s &quot;, file);
        } else if (attr.isRegularFile()) {
            System.out.format(&quot;Regular file: %s &quot;, file);
        } else {
            System.out.format(&quot;Other: %s &quot;, file);
        }
        System.out.println(&quot;(&quot; + attr.size() + &quot;bytes)&quot;);
        return CONTINUE;
    }

    // Print each directory visited.
    @Override
    public FileVisitResult postVisitDirectory(Path dir,
                                          IOException exc) {
        System.out.format(&quot;Directory: %s%n&quot;, dir);
        return CONTINUE;
    }

    // If there is some error accessing
    // the file, let the user know.
    // If you don't override this method
    // and an error occurs, an IOException 
    // is thrown.
    @Override
    public FileVisitResult visitFileFailed(Path file,
                                       IOException exc) {
        System.err.println(exc);
        return CONTINUE;
    }
}
</code></pre>
<h1 id="kickstarting-the-process"><a class="header" href="#kickstarting-the-process">Kickstarting the Process</a></h1>
<p>一旦你实现了你的<code>FileVisitor</code>，你如何启动文件遍历？ <code>Files</code> 类中有两个 <code>walkFileTree</code> 方法。</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#walkFileTree-java.nio.file.Path-java.nio.file.FileVisitor-"><code>walkFileTree(Path, FileVisitor)</code></a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#walkFileTree-java.nio.file.Path-java.util.Set-int-java.nio.file.FileVisitor-"><code>walkFileTree(Path, Set, int, FileVisitor)</code></a></li>
</ul>
<p>第一种方法只需要一个起点和一个“FileVisitor”的实例。</p>
<p>您可以调用 <code>PrintFiles</code> 文件访问器，如下所示：</p>
<pre><code class="language-java">Path startingDir = ...;
PrintFiles pf = new PrintFiles();
Files.walkFileTree(startingDir, pf);
</code></pre>
<p>第二个 <code>walkFileTree</code> 方法使您可以额外指定访问级别数的限制和一组 [<code>FileVisitOption</code>](https://docs.oracle.com/javase/8/docs/api/java/nio /file/FileVisitOption.html) 枚举。</p>
<p>如果你想确保这个方法遍历整个文件树，你可以为最大深度参数指定<code>Integer.MAX_VALUE</code>。您可以指定 <code>FileVisitOption</code> 枚举，<code>FOLLOW_LINKS</code>，表示应该遵循符号链接。</p>
<p>This code snippet shows how the four-argument method can be invoked:</p>
<pre><code class="language-java">import static java.nio.file.FileVisitResult.*;

Path startingDir = ...;

EnumSet&lt;FileVisitOption&gt; opts = EnumSet.of(FOLLOW_LINKS);

Finder finder = new Finder(pattern);
Files.walkFileTree(startingDir, opts, Integer.MAX_VALUE, finder);
</code></pre>
<h1 id="considerations-when-creating-a-filevisitor"><a class="header" href="#considerations-when-creating-a-filevisitor">Considerations When Creating a FileVisitor</a></h1>
<p>文件树深度优先遍历，但您不能对访问子目录的迭代顺序做出任何假设。</p>
<p>如果您的程序将更改文件系统，则需要仔细考虑如何实现“FileVisitor”。</p>
<p>例如，如果您正在编写递归删除，则在删除目录本身之前首先删除目录中的文件。</p>
<p>如果您正在编写递归copy，则在尝试将文件复制到其中（在“visitFiles”中）之前，您可以在“preVisitDirectory”中创建新目录。</p>
<p>如果要保留源目录的属性（类似于UNIX的<code>cp -p</code>命令）</p>
<p>你需要<em>在</em>文件被复制之后，在<code>postVisitDirectory</code>中这样做。 </p>
<p><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Copy.java"><code>Copy</code></a> 示例展示了如何执行此操作。</p>
<p>如果您正在编写文件搜索，则在 <code>visitFile</code> 方法中执行比较。</p>
<p>此方法会找到所有符合条件的文件，但不会找到目录。</p>
<p>如果要同时查找文件和目录，还必须在<code>preVisitDirectory</code> 或<code>postVisitDirectory</code> 方法中执行比较。 </p>
<p><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Find.java"><code>Find</code></a> 示例展示了如何执行此操作。</p>
<p>您需要决定是否要遵循符号链接。</p>
<p>例如，如果您要删除文件，则可能不建议使用符号链接。</p>
<p>如果您正在复制文件树，您可能希望允许它。</p>
<p>默认情况下，<code>walkFileTree</code> 不遵循符号链接。</p>
<p>为文件调用<code>visitFile</code> 方法。</p>
<p>如果你已经指定了 <code>FOLLOW_LINKS</code> 选项并且你的文件树有一个到父目录的循环链接，循环目录会在 <code>visitFileFailed</code> 方法中报告为 <code>FileSystemLoopException</code>。</p>
<p>以下代码片段显示了如何捕获循环链接，并且来自 <a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Copy.java"><code>Copy</code></a> 示例：</p>
<pre><code>@Override
public FileVisitResult
    visitFileFailed(Path file,
        IOException exc) {
    if (exc instanceof FileSystemLoopException) {
        System.err.println(&quot;cycle detected: &quot; + file);
    } else {
        System.err.format(&quot;Unable to copy:&quot; + &quot; %s: %s%n&quot;, file, exc);
    }
    return CONTINUE;
}
</code></pre>
<h1 id="controlling-the-flow"><a class="header" href="#controlling-the-flow">Controlling the Flow</a></h1>
<p>也许您想遍历文件树以查找特定目录，并且在找到时希望进程终止。</p>
<p>也许您想跳过特定目录。</p>
<p><code>FileVisitor</code> 方法返回一个 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitResult.html"><code>FileVisitResult</code></a> 值。</p>
<p>您可以中止文件遍历过程或控制您在 <code>FileVisitor</code> 方法中返回的值是否访问目录：</p>
<ul>
<li>
<p><code>CONTINUE</code> – 表示文件遍历应该继续。如果<code>preVisitDirectory</code> 方法返回<code>CONTINUE</code>，则访问该目录。</p>
</li>
<li>
<p><code>TERMINATE</code> – 立即中止文件遍历。返回此值后，不再调用进一步的文件遍历方法。</p>
</li>
<li>
<p><code>SKIP_SUBTREE</code> – 当<code>preVisitDirectory</code> 返回这个值时，指定的目录及其子目录将被跳过。这个分支是从树上“剪掉”的。.</p>
</li>
<li>
<p><code>SKIP_SIBLINGS</code> – 当<code>preVisitDirectory</code> 返回这个值时，指定的目录不会被访问，<code>postVisitDirectory</code> 不会被调用，并且没有进一步的未访问的兄弟节点被访问。</p>
<p>如果从<code>postVisitDirectory</code> 方法返回，则不会访问其他兄弟节点。</p>
<p>本质上，在指定的目录中不会再发生任何事情。</p>
</li>
</ul>
<p>In this code snippet, any directory named <code>SCCS</code> is skipped:</p>
<pre><code>import static java.nio.file.FileVisitResult.*;

public FileVisitResult
     preVisitDirectory(Path dir,
         BasicFileAttributes attrs) {
    (if (dir.getFileName().toString().equals(&quot;SCCS&quot;)) {
         return SKIP_SUBTREE;
    }
    return CONTINUE;
}
</code></pre>
<p>在这个代码片段中，一旦找到特定文件，文件名就会打印到标准输出，文件遍历终止</p>
<pre><code>import static java.nio.file.FileVisitResult.*;

// The file we are looking for.
Path lookingFor = ...;

public FileVisitResult
    visitFile(Path file,
        BasicFileAttributes attr) {
    if (file.getFileName().equals(lookingFor)) {
        System.out.println(&quot;Located file: &quot; + file);
        return TERMINATE;
    }
    return CONTINUE;
}
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>The following examples demonstrate the file walking mechanism:</p>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Find.java"><code>Find</code></a> – Recurses a file tree looking for files and directories that match a particular glob pattern. This example is discussed in <a href="https://docs.oracle.com/javase/tutorial/essential/io/find.html">Finding Files</a>.</li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Chmod.java"><code>Chmod</code></a> – Recursively changes permissions on a file tree (for POSIX systems only).</li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/Copy.java"><code>Copy</code></a> – Recursively copies a file tree.</li>
<li><a href="https://docs.oracle.com/javase/tutorial/essential/io/examples/WatchDir.java"><code>WatchDir</code></a> – Demonstrates the mechanism that watches a directory for files that have been created, deleted or modified. Calling this program with the <code>-r</code> option watches an entire tree for changes. For more information about the file notification service, see <a href="https://docs.oracle.com/javase/tutorial/essential/io/notification.html">Watching a Directory for Changes</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是-servlet"><a class="header" href="#什么是-servlet">什么是 Servlet?</a></h1>
<p><strong>基于请求-响应 模型的框架</strong></p>
<ul>
<li>提供基于请求/响应发送模型的网络服务，解码基于 <em><a href="24.Servlet%E8%A7%84%E8%8C%83/..%5CWeb%5CHTTP%5CMIME.html">MIME</a></em> 的请求，并且格式化基于 <a href="24.Servlet%E8%A7%84%E8%8C%83/..%5CWeb%5CHTTP%5CMIME.html"><em>MIME</em></a> 的响应</li>
<li>必须支持基于 HTTP 协议的请求/响应模型</li>
</ul>
<p><strong>Servlet 执行以下主要任务</strong>：</p>
<ul>
<li><strong>读取客户端（浏览器）发送的显式的数据</strong>。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。</li>
<li><strong>读取客户端（浏览器）发送的隐式的 HTTP 请求数据</strong>。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li>
<li><strong>处理数据并生成结果</strong>。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。</li>
<li><strong>发送显式的数据（即文档）到客户端（浏览器）</strong>。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li>
<li><strong>发送隐式的 HTTP 响应到客户端（浏览器）</strong>。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。</li>
</ul>
<h1 id="servlet接口"><a class="header" href="#servlet接口">Servlet接口</a></h1>
<p><a href="24.Servlet%E8%A7%84%E8%8C%83/httpServlet.html">基于Http协议的servlet接口</a></p>
<h1 id="servlet-生命周期"><a class="header" href="#servlet-生命周期">Servlet <strong>生命周期</strong></a></h1>
<h2 id="servlet"><a class="header" href="#servlet"><strong>servlet</strong></a></h2>
<p><strong>动作</strong></p>
<pre><code>init
service(resquest,respoonse)
destroy
</code></pre>
<p><em>contextPath + servletPath = url</em> </p>
<h1 id="请求"><a class="header" href="#请求">请求</a></h1>
<h2 id="请求数据获取"><a class="header" href="#请求数据获取"><strong>请求数据获取</strong></a></h2>
<ul>
<li>**getParameter()：**您可以调用 request.getParameter() 方法来获取表单参数的值。</li>
<li>**getParameterValues()：**如果参数出现一次以上，则调用该方法，并返回多个值，例如复选框。</li>
<li>**getParameterNames()：**如果您想要得到当前请求中的所有参数的完整列表，则调用该方法。</li>
</ul>
<h2 id="请求头"><a class="header" href="#请求头"><strong>请求头</strong></a></h2>
<table><thead><tr><th style="text-align: left">头信息</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">Accept</td><td style="text-align: left">这个头信息指定浏览器或其他客户端可以处理的 MIME 类型。值 <strong>image/png</strong> 或 <strong>image/jpeg</strong> 是最常见的两种可能值。</td></tr>
<tr><td style="text-align: left">Accept-Charset</td><td style="text-align: left">这个头信息指定浏览器可以用来显示信息的字符集。例如 ISO-8859-1。</td></tr>
<tr><td style="text-align: left">Accept-Encoding</td><td style="text-align: left">这个头信息指定浏览器知道如何处理的编码类型。值 <strong>gzip</strong> 或 <strong>compress</strong> 是最常见的两种可能值。</td></tr>
<tr><td style="text-align: left">Accept-Language</td><td style="text-align: left">这个头信息指定客户端的首选语言，在这种情况下，Servlet 会产生多种语言的结果。例如，en、en-us、ru 等。</td></tr>
<tr><td style="text-align: left">Authorization</td><td style="text-align: left">这个头信息用于客户端在访问受密码保护的网页时识别自己的身份。</td></tr>
<tr><td style="text-align: left">Connection</td><td style="text-align: left">这个头信息指示客户端是否可以处理持久 HTTP 连接。持久连接允许客户端或其他浏览器通过单个请求来检索多个文件。值 <strong>Keep-Alive</strong> 意味着使用了持续连接。</td></tr>
<tr><td style="text-align: left">Content-Length</td><td style="text-align: left">这个头信息只适用于 POST 请求，并给出 POST 数据的大小（以字节为单位）。</td></tr>
<tr><td style="text-align: left">Cookie</td><td style="text-align: left">这个头信息把之前发送到浏览器的 cookies 返回到服务器。</td></tr>
<tr><td style="text-align: left">Host</td><td style="text-align: left">这个头信息指定原始的 URL 中的主机和端口。</td></tr>
<tr><td style="text-align: left">If-Modified-Since</td><td style="text-align: left">这个头信息表示只有当页面在指定的日期后已更改时，客户端想要的页面。如果没有新的结果可以使用，服务器会发送一个 304 代码，表示 <strong>Not Modified</strong> 头信息。</td></tr>
<tr><td style="text-align: left">If-Unmodified-Since</td><td style="text-align: left">这个头信息是 If-Modified-Since 的对立面，它指定只有当文档早于指定日期时，操作才会成功。</td></tr>
<tr><td style="text-align: left">Referer</td><td style="text-align: left">这个头信息指示所指向的 Web 页的 URL。例如，如果您在网页 1，点击一个链接到网页 2，当浏览器请求网页 2 时，网页 1 的 URL 就会包含在 Referer 头信息中。</td></tr>
<tr><td style="text-align: left">User-Agent</td><td style="text-align: left">这个头信息识别发出请求的浏览器或其他客户端，并可以向不同类型的浏览器返回不同的内容。</td></tr>
</tbody></table>
<h2 id="api读取"><a class="header" href="#api读取"><strong>API读取</strong></a></h2>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">方法 &amp; 描述</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><strong>Cookie[] getCookies()</strong> 返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><strong>Enumeration getAttributeNames()</strong> 返回一个枚举，包含提供给该请求可用的属性名称。</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><strong>Enumeration getHeaderNames()</strong> 返回一个枚举，包含在该请求中包含的所有的头名。</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><strong>Enumeration getParameterNames()</strong> 返回一个 String 对象的枚举，包含在该请求中包含的参数的名称。</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left"><strong>HttpSession getSession()</strong> 返回与该请求关联的当前 session 会话，或者如果请求没有 session 会话，则创建一个。</td></tr>
<tr><td style="text-align: left">6</td><td style="text-align: left"><strong>HttpSession getSession(boolean create)</strong> 返回与该请求关联的当前 HttpSession，或者如果没有当前会话，且创建是真的，则返回一个新的 session 会话。</td></tr>
<tr><td style="text-align: left">7</td><td style="text-align: left"><strong>Locale getLocale()</strong> 基于 Accept-Language 头，返回客户端接受内容的首选的区域设置。</td></tr>
<tr><td style="text-align: left">8</td><td style="text-align: left"><strong>Object getAttribute(String name)</strong> 以对象形式返回已命名属性的值，如果没有给定名称的属性存在，则返回 null。</td></tr>
<tr><td style="text-align: left">9</td><td style="text-align: left"><strong>ServletInputStream getInputStream()</strong> 使用 ServletInputStream，以二进制数据形式检索请求的主体。</td></tr>
<tr><td style="text-align: left">10</td><td style="text-align: left"><strong>String getAuthType()</strong> 返回用于保护 Servlet 的身份验证方案的名称，例如，&quot;BASIC&quot; 或 &quot;SSL&quot;，如果JSP没有受到保护则返回 null。</td></tr>
<tr><td style="text-align: left">11</td><td style="text-align: left"><strong>String getCharacterEncoding()</strong> 返回请求主体中使用的字符编码的名称。</td></tr>
<tr><td style="text-align: left">12</td><td style="text-align: left"><strong>String getContentType()</strong> 返回请求主体的 MIME 类型，如果不知道类型则返回 null。</td></tr>
<tr><td style="text-align: left">13</td><td style="text-align: left"><strong>String getContextPath()</strong> 返回指示请求上下文的请求 URI 部分。</td></tr>
<tr><td style="text-align: left">14</td><td style="text-align: left"><strong>String getHeader(String name)</strong> 以字符串形式返回指定的请求头的值。</td></tr>
<tr><td style="text-align: left">15</td><td style="text-align: left"><strong>String getMethod()</strong> 返回请求的 HTTP 方法的名称，例如，GET、POST 或 PUT。</td></tr>
<tr><td style="text-align: left">16</td><td style="text-align: left"><strong>String getParameter(String name)</strong> 以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。</td></tr>
<tr><td style="text-align: left">17</td><td style="text-align: left"><strong>String getPathInfo()</strong> 当请求发出时，返回与客户端发送的 URL 相关的任何额外的路径信息。</td></tr>
<tr><td style="text-align: left">18</td><td style="text-align: left"><strong>String getProtocol()</strong> 返回请求协议的名称和版本。</td></tr>
<tr><td style="text-align: left">19</td><td style="text-align: left"><strong>String getQueryString()</strong> 返回包含在路径后的请求 URL 中的查询字符串。</td></tr>
<tr><td style="text-align: left">20</td><td style="text-align: left"><strong>String getRemoteAddr()</strong> 返回发送请求的客户端的互联网协议（IP）地址。</td></tr>
<tr><td style="text-align: left">21</td><td style="text-align: left"><strong>String getRemoteHost()</strong> 返回发送请求的客户端的完全限定名称。</td></tr>
<tr><td style="text-align: left">22</td><td style="text-align: left"><strong>String getRemoteUser()</strong> 如果用户已通过身份验证，则返回发出请求的登录用户，或者如果用户未通过身份验证，则返回 null。</td></tr>
<tr><td style="text-align: left">23</td><td style="text-align: left"><strong>String getRequestURI()</strong> 从协议名称直到 HTTP 请求的第一行的查询字符串中，返回该请求的 URL 的一部分。</td></tr>
<tr><td style="text-align: left">24</td><td style="text-align: left"><strong>String getRequestedSessionId()</strong> 返回由客户端指定的 session 会话 ID。</td></tr>
<tr><td style="text-align: left">25</td><td style="text-align: left"><strong>String getServletPath()</strong> 返回调用 JSP 的请求的 URL 的一部分。</td></tr>
<tr><td style="text-align: left">26</td><td style="text-align: left"><strong>String[] getParameterValues(String name)</strong> 返回一个字符串对象的数组，包含所有给定的请求参数的值，如果参数不存在则返回 null。</td></tr>
<tr><td style="text-align: left">27</td><td style="text-align: left"><strong>boolean isSecure()</strong> 返回一个布尔值，指示请求是否使用安全通道，如 HTTPS。</td></tr>
<tr><td style="text-align: left">28</td><td style="text-align: left"><strong>int getContentLength()</strong> 以字节为单位返回请求主体的长度，并提供输入流，或者如果长度未知则返回 -1。</td></tr>
<tr><td style="text-align: left">29</td><td style="text-align: left"><strong>int getIntHeader(String name)</strong> 返回指定的请求头的值为一个 int 值。</td></tr>
<tr><td style="text-align: left">30</td><td style="text-align: left"><strong>int getServerPort()</strong> 返回接收到这个请求的端口号。</td></tr>
<tr><td style="text-align: left">31</td><td style="text-align: left"><strong>int getParameterMap()</strong> 将参数封装成 Map 类型。</td></tr>
</tbody></table>
<h1 id="响应"><a class="header" href="#响应">响应</a></h1>
<h2 id="响应头"><a class="header" href="#响应头"><strong>响应头</strong></a></h2>
<table><thead><tr><th style="text-align: left">头信息</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">Allow</td><td style="text-align: left">这个头信息指定服务器支持的请求方法（GET、POST 等）。</td></tr>
<tr><td style="text-align: left">Cache-Control</td><td style="text-align: left">这个头信息指定响应文档在何种情况下可以安全地缓存。可能的值有：<strong>public、private</strong> 或 <strong>no-cache</strong> 等。Public 意味着文档是可缓存，Private 意味着文档是单个用户私用文档，且只能存储在私有（非共享）缓存中，no-cache 意味着文档不应被缓存。</td></tr>
<tr><td style="text-align: left">Connection</td><td style="text-align: left">这个头信息指示浏览器是否使用持久 HTTP 连接。值 <strong>close</strong> 指示浏览器不使用持久 HTTP 连接，值 <strong>keep-alive</strong> 意味着使用持久连接。</td></tr>
<tr><td style="text-align: left">Content-Disposition</td><td style="text-align: left">这个头信息可以让您请求浏览器要求用户以给定名称的文件把响应保存到磁盘。</td></tr>
<tr><td style="text-align: left">Content-Encoding</td><td style="text-align: left">在传输过程中，这个头信息指定页面的编码方式。</td></tr>
<tr><td style="text-align: left">Content-Language</td><td style="text-align: left">这个头信息表示文档编写所使用的语言。例如，en、en-us、ru 等。</td></tr>
<tr><td style="text-align: left">Content-Length</td><td style="text-align: left">这个头信息指示响应中的字节数。只有当浏览器使用持久（keep-alive）HTTP 连接时才需要这些信息。</td></tr>
<tr><td style="text-align: left">Content-Type</td><td style="text-align: left">这个头信息提供了响应文档的 MIME（Multipurpose Internet Mail Extension）类型。</td></tr>
<tr><td style="text-align: left">Expires</td><td style="text-align: left">这个头信息指定内容过期的时间，在这之后内容不再被缓存。</td></tr>
<tr><td style="text-align: left">Last-Modified</td><td style="text-align: left">这个头信息指示文档的最后修改时间。然后，客户端可以缓存文件，并在以后的请求中通过 <strong>If-Modified-Since</strong> 请求头信息提供一个日期。</td></tr>
<tr><td style="text-align: left">Location</td><td style="text-align: left">这个头信息应被包含在所有的带有状态码的响应中。在 300s 内，这会通知浏览器文档的地址。浏览器会自动重新连接到这个位置，并获取新的文档。</td></tr>
<tr><td style="text-align: left">Refresh</td><td style="text-align: left">这个头信息指定浏览器应该如何尽快请求更新的页面。您可以指定页面刷新的秒数。</td></tr>
<tr><td style="text-align: left">Retry-After</td><td style="text-align: left">这个头信息可以与 503（Service Unavailable 服务不可用）响应配合使用，这会告诉客户端多久就可以重复它的请求。</td></tr>
<tr><td style="text-align: left">Set-Cookie</td><td style="text-align: left">这个头信息指定一个与页面关联的 cookie。</td></tr>
</tbody></table>
<h2 id="api-3"><a class="header" href="#api-3"><strong>API</strong></a></h2>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">方法 &amp; 描述</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><strong>String encodeRedirectURL(String url)</strong> 为 sendRedirect 方法中使用的指定的 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><strong>String encodeURL(String url)</strong> 对包含 session 会话 ID 的指定 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><strong>boolean containsHeader(String name)</strong> 返回一个布尔值，指示是否已经设置已命名的响应报头。</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><strong>boolean isCommitted()</strong> 返回一个布尔值，指示响应是否已经提交。</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left"><strong>void addCookie(Cookie cookie)</strong> 把指定的 cookie 添加到响应。</td></tr>
<tr><td style="text-align: left">6</td><td style="text-align: left"><strong>void addDateHeader(String name, long date)</strong> 添加一个带有给定的名称和日期值的响应报头。</td></tr>
<tr><td style="text-align: left">7</td><td style="text-align: left"><strong>void addHeader(String name, String value)</strong> 添加一个带有给定的名称和值的响应报头。</td></tr>
<tr><td style="text-align: left">8</td><td style="text-align: left"><strong>void addIntHeader(String name, int value)</strong> 添加一个带有给定的名称和整数值的响应报头。</td></tr>
<tr><td style="text-align: left">9</td><td style="text-align: left"><strong>void flushBuffer()</strong> 强制任何在缓冲区中的内容被写入到客户端。</td></tr>
<tr><td style="text-align: left">10</td><td style="text-align: left"><strong>void reset()</strong> 清除缓冲区中存在的任何数据，包括状态码和头。</td></tr>
<tr><td style="text-align: left">11</td><td style="text-align: left"><strong>void resetBuffer()</strong> 清除响应中基础缓冲区的内容，不清除状态码和头。</td></tr>
<tr><td style="text-align: left">12</td><td style="text-align: left"><strong>void sendError(int sc)</strong> 使用指定的状态码发送错误响应到客户端，并清除缓冲区。</td></tr>
<tr><td style="text-align: left">13</td><td style="text-align: left"><strong>void sendError(int sc, String msg)</strong> 使用指定的状态发送错误响应到客户端。</td></tr>
<tr><td style="text-align: left">14</td><td style="text-align: left"><strong>void sendRedirect(String location)</strong> 使用指定的重定向位置 URL 发送临时重定向响应到客户端。</td></tr>
<tr><td style="text-align: left">15</td><td style="text-align: left"><strong>void setBufferSize(int size)</strong> 为响应主体设置首选的缓冲区大小。</td></tr>
<tr><td style="text-align: left">16</td><td style="text-align: left"><strong>void setCharacterEncoding(String charset)</strong> 设置被发送到客户端的响应的字符编码（MIME 字符集）例如，UTF-8。</td></tr>
<tr><td style="text-align: left">17</td><td style="text-align: left"><strong>void setContentLength(int len)</strong> 设置在 HTTP Servlet 响应中的内容主体的长度，该方法设置 HTTP Content-Length 头。</td></tr>
<tr><td style="text-align: left">18</td><td style="text-align: left"><strong>void setContentType(String type)</strong> 如果响应还未被提交，设置被发送到客户端的响应的内容类型。</td></tr>
<tr><td style="text-align: left">19</td><td style="text-align: left"><strong>void setDateHeader(String name, long date)</strong> 设置一个带有给定的名称和日期值的响应报头。</td></tr>
<tr><td style="text-align: left">20</td><td style="text-align: left"><strong>void setHeader(String name, String value)</strong> 设置一个带有给定的名称和值的响应报头。</td></tr>
<tr><td style="text-align: left">21</td><td style="text-align: left"><strong>void setIntHeader(String name, int value)</strong> 设置一个带有给定的名称和整数值的响应报头。</td></tr>
<tr><td style="text-align: left">22</td><td style="text-align: left"><strong>void setLocale(Locale loc)</strong> 如果响应还未被提交，设置响应的区域。</td></tr>
<tr><td style="text-align: left">23</td><td style="text-align: left"><strong>void setStatus(int sc)</strong> 为该响应设置状态码。</td></tr>
</tbody></table>
<h2 id="实例"><a class="header" href="#实例"><strong>实例</strong></a></h2>
<pre><code class="language-java">  // 设置刷新自动加载时间为 5 秒
        response.setIntHeader(&quot;Refresh&quot;, 5);
        // 设置响应内容类型
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);

        //使用默认时区和语言环境获得一个日历
        Calendar cale = Calendar.getInstance();
        //将Calendar类型转换成Date类型
        Date tasktime=cale.getTime();
        //设置日期输出的格式
        SimpleDateFormat df=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        //格式化输出
        String nowTime = df.format(tasktime);
        PrintWriter out = response.getWriter();
        String title = &quot;自动刷新 Header 设置&quot;;
        String docType =
                &quot;&lt;!DOCTYPE html&gt;\n&quot;;
        out.println(docType +
                &quot;&lt;html&gt;\n&quot; +
                &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot;+
                &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +
                &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +
                &quot;&lt;p&gt;当前时间是：&quot; + nowTime + &quot;&lt;/p&gt;\n&quot;);
</code></pre>
<h1 id="http状态码"><a class="header" href="#http状态码">Http状态码</a></h1>
<h2 id="实例-1"><a class="header" href="#实例-1"><strong>实例</strong></a></h2>
<pre><code>HTTP/1.1 200 OK
Content-Type: text/html
Header2: ...
...
HeaderN: ...
  (Blank Line)
&lt;!doctype ...&gt;
&lt;html&gt;
&lt;head&gt;...&lt;/head&gt;
&lt;body&gt;
...
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="状态码"><a class="header" href="#状态码"><strong>状态码</strong></a></h2>
<table><thead><tr><th style="text-align: left">代码</th><th style="text-align: left">消息</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">100</td><td style="text-align: left">Continue</td><td style="text-align: left">只有请求的一部分已经被服务器接收，但只要它没有被拒绝，客户端应继续该请求。</td></tr>
<tr><td style="text-align: left">101</td><td style="text-align: left">Switching Protocols</td><td style="text-align: left">服务器切换协议。</td></tr>
<tr><td style="text-align: left">200</td><td style="text-align: left">OK</td><td style="text-align: left">请求成功。</td></tr>
<tr><td style="text-align: left">201</td><td style="text-align: left">Created</td><td style="text-align: left">该请求是完整的，并创建一个新的资源。</td></tr>
<tr><td style="text-align: left">202</td><td style="text-align: left">Accepted</td><td style="text-align: left">该请求被接受处理，但是该处理是不完整的。</td></tr>
<tr><td style="text-align: left">203</td><td style="text-align: left">Non-authoritative Information</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">204</td><td style="text-align: left">No Content</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">205</td><td style="text-align: left">Reset Content</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">206</td><td style="text-align: left">Partial Content</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">300</td><td style="text-align: left">Multiple Choices</td><td style="text-align: left">链接列表。用户可以选择一个链接，进入到该位置。最多五个地址。</td></tr>
<tr><td style="text-align: left">301</td><td style="text-align: left">Moved Permanently</td><td style="text-align: left">所请求的页面已经转移到一个新的 URL。</td></tr>
<tr><td style="text-align: left">302</td><td style="text-align: left">Found</td><td style="text-align: left">所请求的页面已经临时转移到一个新的 URL。</td></tr>
<tr><td style="text-align: left">303</td><td style="text-align: left">See Other</td><td style="text-align: left">所请求的页面可以在另一个不同的 URL 下被找到。</td></tr>
<tr><td style="text-align: left">304</td><td style="text-align: left">Not Modified</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">305</td><td style="text-align: left">Use Proxy</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">306</td><td style="text-align: left"><em>Unused</em></td><td style="text-align: left">在以前的版本中使用该代码。现在已不再使用它，但代码仍被保留。</td></tr>
<tr><td style="text-align: left">307</td><td style="text-align: left">Temporary Redirect</td><td style="text-align: left">所请求的页面已经临时转移到一个新的 URL。</td></tr>
<tr><td style="text-align: left">400</td><td style="text-align: left">Bad Request</td><td style="text-align: left">服务器不理解请求。</td></tr>
<tr><td style="text-align: left">401</td><td style="text-align: left">Unauthorized</td><td style="text-align: left">所请求的页面需要用户名和密码。</td></tr>
<tr><td style="text-align: left">402</td><td style="text-align: left">Payment Required</td><td style="text-align: left"><em>您还不能使用该代码。</em></td></tr>
<tr><td style="text-align: left">403</td><td style="text-align: left">Forbidden</td><td style="text-align: left">禁止访问所请求的页面。</td></tr>
<tr><td style="text-align: left">404</td><td style="text-align: left">Not Found</td><td style="text-align: left">服务器无法找到所请求的页面。.</td></tr>
<tr><td style="text-align: left">405</td><td style="text-align: left">Method Not Allowed</td><td style="text-align: left">在请求中指定的方法是不允许的。</td></tr>
<tr><td style="text-align: left">406</td><td style="text-align: left">Not Acceptable</td><td style="text-align: left">服务器只生成一个不被客户端接受的响应。</td></tr>
<tr><td style="text-align: left">407</td><td style="text-align: left">Proxy Authentication Required</td><td style="text-align: left">在请求送达之前，您必须使用代理服务器的验证。</td></tr>
<tr><td style="text-align: left">408</td><td style="text-align: left">Request Timeout</td><td style="text-align: left">请求需要的时间比服务器能够等待的时间长，超时。</td></tr>
<tr><td style="text-align: left">409</td><td style="text-align: left">Conflict</td><td style="text-align: left">请求因为冲突无法完成。</td></tr>
<tr><td style="text-align: left">410</td><td style="text-align: left">Gone</td><td style="text-align: left">所请求的页面不再可用。</td></tr>
<tr><td style="text-align: left">411</td><td style="text-align: left">Length Required</td><td style="text-align: left">&quot;Content-Length&quot; 未定义。服务器无法处理客户端发送的不带 Content-Length 的请求信息。</td></tr>
<tr><td style="text-align: left">412</td><td style="text-align: left">Precondition Failed</td><td style="text-align: left">请求中给出的先决条件被服务器评估为 false。</td></tr>
<tr><td style="text-align: left">413</td><td style="text-align: left">Request Entity Too Large</td><td style="text-align: left">服务器不接受该请求，因为请求实体过大。</td></tr>
<tr><td style="text-align: left">414</td><td style="text-align: left">Request-url Too Long</td><td style="text-align: left">服务器不接受该请求，因为 URL 太长。当您转换一个 &quot;post&quot; 请求为一个带有长的查询信息的 &quot;get&quot; 请求时发生。</td></tr>
<tr><td style="text-align: left">415</td><td style="text-align: left">Unsupported Media Type</td><td style="text-align: left">服务器不接受该请求，因为媒体类型不被支持。</td></tr>
<tr><td style="text-align: left">417</td><td style="text-align: left">Expectation Failed</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">500</td><td style="text-align: left">Internal Server Error</td><td style="text-align: left">未完成的请求。服务器遇到了一个意外的情况。</td></tr>
<tr><td style="text-align: left">501</td><td style="text-align: left">Not Implemented</td><td style="text-align: left">未完成的请求。服务器不支持所需的功能。</td></tr>
<tr><td style="text-align: left">502</td><td style="text-align: left">Bad Gateway</td><td style="text-align: left">未完成的请求。服务器从上游服务器收到无效响应。</td></tr>
<tr><td style="text-align: left">503</td><td style="text-align: left">Service Unavailable</td><td style="text-align: left">未完成的请求。服务器暂时超载或死机。</td></tr>
<tr><td style="text-align: left">504</td><td style="text-align: left">Gateway Timeout</td><td style="text-align: left">网关超时。</td></tr>
<tr><td style="text-align: left">505</td><td style="text-align: left">HTTP Version Not Supported</td><td style="text-align: left">服务器不支持&quot;HTTP协议&quot;版本。</td></tr>
</tbody></table>
<h2 id="设置-http-状态代码的方法"><a class="header" href="#设置-http-状态代码的方法">设置 HTTP 状态代码的方法</a></h2>
<p>下面的方法可用于在 Servlet 程序中设置 HTTP 状态码。这些方法通过 <em>HttpServletResponse</em> 对象可用。</p>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">方法 &amp; 描述</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><strong>public void setStatus ( int statusCode )</strong> 该方法设置一个任意的状态码。setStatus 方法接受一个 int（状态码）作为参数。如果您的响应包含了一个特殊的状态码和文档，请确保在使用 <em>PrintWriter</em> 实际返回任何内容之前调用 setStatus。</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><strong>public void sendRedirect(String url)</strong> 该方法生成一个 302 响应，连同一个带有新文档 URL 的 <em>Location</em> 头。</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><strong>public void sendError(int code, String message)</strong> 该方法发送一个状态码（通常为 404），连同一个在 HTML 文档内部自动格式化并发送到客户端的短消息。</td></tr>
</tbody></table>
<h1 id="servlet-过滤器"><a class="header" href="#servlet-过滤器">Servlet 过滤器</a></h1>
<blockquote>
<p>Servlet 过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。</p>
</blockquote>
<p>根据规范建议的各种类型的过滤器：</p>
<ul>
<li>身份验证过滤器（Authentication Filters）。</li>
<li>数据压缩过滤器（Data compression Filters）。</li>
<li>加密过滤器（Encryption Filters）。</li>
<li>触发资源访问事件过滤器。</li>
<li>图像转换过滤器（Image Conversion Filters）。</li>
<li>日志记录和审核过滤器（Logging and Auditing Filters）。</li>
<li>MIME-TYPE 链过滤器（MIME-TYPE Chain Filters）。</li>
<li>标记化过滤器（Tokenizing Filters）。</li>
<li>XSL/T 过滤器（XSL/T Filters），转换 XML 内容。</li>
</ul>
<p><strong>Servlet 过滤器方法</strong></p>
<p>过滤器是一个实现了 javax.servlet.Filter 接口的 Java 类。javax.servlet.Filter 接口定义了三个方法：</p>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">方法 &amp; 描述</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><strong>public void doFilter (ServletRequest, ServletResponse, FilterChain)</strong> 该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter方法。FilterChain用户访问后续过滤器。</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><strong>public void init(FilterConfig filterConfig)</strong> web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><strong>public void destroy()</strong> Servlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源。</td></tr>
</tbody></table>
<p><strong>FilterConfig</strong> </p>
<p>FilterConfig 使用, Filter 的 init 方法中提供了一个 FilterConfig 对象。</p>
<p>如 web.xml 文件配置如下：</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.runoob.test.LogFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;Site&lt;/param-name&gt;
        &lt;param-value&gt;菜鸟教程&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;

&lt;filter&gt;
  &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;com.runoob.test.LogFilter&lt;/filter-class&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;Site&lt;/param-name&gt;
    &lt;param-value&gt;菜鸟教程&lt;/param-value&gt;
  &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;LogFilter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<p>在 init 方法使用 FilterConfig 对象获取参数：</p>
<pre><code>public void  init(FilterConfig config) throws ServletException {
    // 获取初始化参数
    String site = config.getInitParameter(&quot;Site&quot;); 
    // 输出初始化参数
    System.out.println(&quot;网站名称: &quot; + site); 
}
</code></pre>
<p><strong>过滤器的应用顺序</strong></p>
<p>web.xml 中的 filter-mapping 元素的顺序决定了 Web 容器应用过滤器到 Servlet 的顺序</p>
<p><code>&lt;dispatcher&gt;</code>的意义</p>
<p><code>&lt;dispatcher&gt;</code>指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是<code>REQUEST</code>,<code>INCLUDE</code>,<code>FORWARD</code>和<code>ERROR</code>之一，默认<code>REQUEST</code>。用户可以设置多个<code>&lt;dispatcher&gt;</code>子元素用来指定 Filter 对资源的多种调用方式进行拦截。</p>
<ul>
<li><code>REQUEST</code>：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。</li>
<li><code>INCLUDE</code>：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</li>
<li><code>FORWARD</code>：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</li>
<li><code>ERROR</code>：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。</li>
</ul>
<h2 id="servlet-异常处理"><a class="header" href="#servlet-异常处理"><strong>Servlet 异常处理</strong></a></h2>
<p><strong>web.xml</strong>处理</p>
<pre><code class="language-xml">&lt;!-- servlet 定义 --&gt;
&lt;servlet&gt;
        &lt;servlet-name&gt;ErrorHandler&lt;/servlet-name&gt;
        &lt;servlet-class&gt;ErrorHandler&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;!-- servlet 映射 --&gt;
&lt;servlet-mapping&gt;
        &lt;servlet-name&gt;ErrorHandler&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/ErrorHandler&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;!-- error-code 相关的错误页面 --&gt;
&lt;error-page&gt;
    &lt;error-code&gt;404&lt;/error-code&gt;
    &lt;location&gt;/ErrorHandler&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
    &lt;error-code&gt;403&lt;/error-code&gt;
    &lt;location&gt;/ErrorHandler&lt;/location&gt;
&lt;/error-page&gt;

&lt;!-- exception-type 相关的错误页面 --&gt;
&lt;error-page&gt;
    &lt;exception-type&gt;
          javax.servlet.ServletException
    &lt;/exception-type &gt;
    &lt;location&gt;/ErrorHandler&lt;/location&gt;
&lt;/error-page&gt;

&lt;error-page&gt;
    &lt;exception-type&gt;java.io.IOException&lt;/exception-type &gt;
    &lt;location&gt;/ErrorHandler&lt;/location&gt;
&lt;/error-page&gt;

通用的错误处理程序，那么应该定义下面的 error-page
&lt;error-page&gt;
    &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type &gt;
    &lt;location&gt;/ErrorHandler&lt;/location&gt;
&lt;/error-page&gt;
</code></pre>
<p><strong>错误处理handler</strong></p>
<pre><code class="language-java">{
    Throwable throwable = (Throwable)
    request.getAttribute(&quot;javax.servlet.error.exception&quot;);
    Integer statusCode = (Integer)
    request.getAttribute(&quot;javax.servlet.error.status_code&quot;);
    String servletName = (String)
    request.getAttribute(&quot;javax.servlet.error.servlet_name&quot;);
    if (servletName == null){
        servletName = &quot;Unknown&quot;;
    }
    String requestUri = (String)
    request.getAttribute(&quot;javax.servlet.error.request_uri&quot;);
    if (requestUri == null){
        requestUri = &quot;Unknown&quot;;
    }
    // 设置响应内容类型
    response.setContentType(&quot;text/html;charset=UTF-8&quot;);

    PrintWriter out = response.getWriter();
    String title = &quot;Error/Exception 信息&quot;;
   
    String docType = &quot;&lt;!DOCTYPE html&gt;\n&quot;;
    out.println(docType +
        &quot;&lt;html&gt;\n&quot; +
         &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +
         &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot;);
       out.println(&quot;&lt;h1&gt;菜鸟教程异常信息实例演示&lt;/h1&gt;&quot;);
       if (throwable == null &amp;&amp; statusCode == null){
          out.println(&quot;&lt;h2&gt;错误信息丢失&lt;/h2&gt;&quot;);
          out.println(&quot;请返回 &lt;a href=\&quot;&quot; + 
        response.encodeURL(&quot;http://localhost:8080/&quot;) + 
            &quot;\&quot;&gt;主页&lt;/a&gt;。&quot;);
       }else if (statusCode != null) {
          out.println(&quot;错误代码 : &quot; + statusCode);
    }else{
           out.println(&quot;&lt;h2&gt;错误信息&lt;/h2&gt;&quot;);
          out.println(&quot;Servlet Name : &quot; + servletName + 
                          &quot;&lt;/br&gt;&lt;/br&gt;&quot;);
          out.println(&quot;异常类型 : &quot; + 
                          throwable.getClass( ).getName( ) + 
                          &quot;&lt;/br&gt;&lt;/br&gt;&quot;);
          out.println(&quot;请求 URI: &quot; + requestUri + 
                          &quot;&lt;br&gt;&lt;br&gt;&quot;);
          out.println(&quot;异常信息: &quot; + 
                              throwable.getMessage( ));
       }
       out.println(&quot;&lt;/body&gt;&quot;);
       out.println(&quot;&lt;/html&gt;&quot;);
}
</code></pre>
<p><strong>请求属性 - 错误/异常</strong></p>
<p>以下是错误处理的 Servlet 可以访问的请求属性列表，用来分析错误/异常的性质。</p>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">属性 &amp; 描述</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><strong>javax.servlet.error.status_code</strong> 该属性给出状态码，状态码可被存储，并在存储为 java.lang.Integer 数据类型后可被分析。</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><strong>javax.servlet.error.exception_type</strong> 该属性给出异常类型的信息，异常类型可被存储，并在存储为 java.lang.Class 数据类型后可被分析。</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><strong>javax.servlet.error.message</strong> 该属性给出确切错误消息的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><strong>javax.servlet.error.request_uri</strong> 该属性给出有关 URL 调用 Servlet 的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left"><strong>javax.servlet.error.exception</strong> 该属性给出异常产生的信息，信息可被存储，并在存储为 java.lang.Throwable 数据类型后可被分析。</td></tr>
<tr><td style="text-align: left">6</td><td style="text-align: left"><strong>javax.servlet.error.servlet_name</strong> 该属性给出 Servlet 的名称，名称可被存储，并在存储为 java.lang.String 数据类型后可被分析。</td></tr>
</tbody></table>
<h1 id="cookie处理"><a class="header" href="#cookie处理">Cookie处理</a></h1>
<blockquote>
<p>Cookie 是存储在客户端计算机上的文本文件，并保留了各种跟踪信息</p>
</blockquote>
<h2 id="识别返回用户包括三个步骤"><a class="header" href="#识别返回用户包括三个步骤"><strong>识别返回用户包括三个步骤</strong>：</a></h2>
<ul>
<li>服务器脚本向浏览器发送一组 Cookie。例如：姓名、年龄或识别号码等。</li>
<li>浏览器将这些信息存储在本地计算机上，以备将来使用。</li>
<li>当下一次浏览器向 Web 服务器发送任何请求时，浏览器会把这些 Cookie 信息发送到服务器，服务器将使用这些信息来识别用户。</li>
</ul>
<h2 id="编码与解码-1"><a class="header" href="#编码与解码-1"><strong>编码与解码</strong></a></h2>
<p><em>Servlet Cookie 处理需要对中文进行编码与解码</em></p>
<h2 id="cookie-剖析"><a class="header" href="#cookie-剖析"><strong>Cookie 剖析</strong></a></h2>
<blockquote>
<p>Cookie 通常设置在 HTTP 头信息中（虽然 JavaScript 也可以直接在浏览器上设置一个 Cookie）。设置 Cookie 的 Servlet 会发送如下的头信息</p>
</blockquote>
<pre><code>HTTP/1.1 200 OK
Date: Fri, 04 Feb 2000 21:03:38 GMT
Server: Apache/1.3.9 (UNIX) PHP/4.0b3
Set-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT; 
                 path=/; domain=runoob.com
Connection: close
Content-Type: text/html
</code></pre>
<p>正如您所看到的，Set-Cookie 头包含了一个名称值对、一个 GMT 日期、一个路径和一个域。名称和值会被 URL 编码。expires 字段是一个指令，告诉浏览器在给定的时间和日期之后&quot;忘记&quot;该 Cookie。</p>
<p><strong>Cooke的表示信息</strong></p>
<ul>
<li>名称</li>
<li>值</li>
<li>过期时间 GMT格式</li>
<li>适用路径</li>
<li>域</li>
</ul>
<p><strong>API</strong></p>
<h2 id="servlet-cookie-方法"><a class="header" href="#servlet-cookie-方法">Servlet Cookie 方法</a></h2>
<p>以下是在 Servlet 中操作 Cookie 时可使用的有用的方法列表。</p>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">方法 &amp; 描述</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><strong>public void setDomain(String pattern)</strong> 该方法设置 cookie 适用的域，例如 runoob.com。</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><strong>public String getDomain()</strong> 该方法获取 cookie 适用的域，例如 runoob.com。</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><strong>public void setMaxAge(int expiry)</strong> 该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><strong>public int getMaxAge()</strong> 该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left"><strong>public String getName()</strong> 该方法返回 cookie 的名称。名称在创建后不能改变。</td></tr>
<tr><td style="text-align: left">6</td><td style="text-align: left"><strong>public void setValue(String newValue)</strong> 该方法设置与 cookie 关联的值。</td></tr>
<tr><td style="text-align: left">7</td><td style="text-align: left"><strong>public String getValue()</strong> 该方法获取与 cookie 关联的值。</td></tr>
<tr><td style="text-align: left">8</td><td style="text-align: left"><strong>public void setPath(String uri)</strong> 该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。</td></tr>
<tr><td style="text-align: left">9</td><td style="text-align: left"><strong>public String getPath()</strong> 该方法获取 cookie 适用的路径。</td></tr>
<tr><td style="text-align: left">10</td><td style="text-align: left"><strong>public void setSecure(boolean flag)</strong> 该方法设置布尔值，表示 cookie 是否应该只在加密的（即 SSL）连接上发送。</td></tr>
<tr><td style="text-align: left">11</td><td style="text-align: left"><strong>public void setComment(String purpose)</strong> 设置cookie的注释。该注释在浏览器向用户呈现 cookie 时非常有用。</td></tr>
<tr><td style="text-align: left">12</td><td style="text-align: left"><strong>public String getComment()</strong> 获取 cookie 的注释，如果 cookie 没有注释则返回 null。</td></tr>
</tbody></table>
<p><strong>删除cookie</strong></p>
<ul>
<li>读取一个现有的 cookie，并把它存储在 Cookie 对象中。</li>
<li>使用 <strong>setMaxAge()</strong> 方法设置 cookie 的年龄为零，来删除现有的 cookie。</li>
<li>把这个 cookie 添加到响应头。</li>
<li>一个负值意味着cookie不连续存储，并且在浏览器推出的时候删除。</li>
</ul>
<h1 id="session跟踪"><a class="header" href="#session跟踪">Session跟踪</a></h1>
<blockquote>
<p>HTTP 是一种&quot;无状态&quot;协议，这意味着每次客户端检索网页时，客户端打开一个单独的连接到 Web 服务器，服务器会自动不保留之前客户端请求的任何记录。</p>
</blockquote>
<p>但是仍然有以下<strong>三种方式来维持 Web 客户端和 Web 服务器之间的 session 会话</strong>：</p>
<h2 id="维持会话的三种方式"><a class="header" href="#维持会话的三种方式">维持会话的三种方式</a></h2>
<h3 id="cookies"><a class="header" href="#cookies">Cookies</a></h3>
<p>一个 Web 服务器可以分配一个唯一的 session 会话 ID 作为每个 Web 客户端的 cookie，对于客户端的后续请求可以使用接收到的 cookie 来识别。</p>
<h3 id="隐藏的表单字段"><a class="header" href="#隐藏的表单字段">隐藏的表单字段</a></h3>
<p>一个 Web 服务器可以发送一个隐藏的 HTML 表单字段，以及一个唯一的 session 会话 ID，如下所示：</p>
<pre><code>&lt;input type=&quot;hidden&quot; name=&quot;sessionid&quot; value=&quot;12345&quot;&gt;
</code></pre>
<p>该条目意味着，当表单被提交时，指定的名称和值会被自动包含在 GET 或 POST 数据中。每次当 Web 浏览器发送回请求时，session_id 值可以用于保持不同的 Web 浏览器的跟踪。</p>
<p>这可能是一种保持 session 会话跟踪的有效方式，但是点击常规的超文本链接（<A HREF...>）不会导致表单提交，因此隐藏的表单字段也不支持常规的 session 会话跟踪。</p>
<h3 id="url-重写"><a class="header" href="#url-重写">URL 重写</a></h3>
<p>您可以在每个 URL 末尾追加一些额外的数据来标识 session 会话，服务器会把该 session 会话标识符与已存储的有关 session 会话的数据相关联。</p>
<p>例如，http://w3cschool.cc/file.htm;sessionid=12345，session 会话标识符被附加为 sessionid=12345，标识符可被 Web 服务器访问以识别客户端。</p>
<p>URL 重写是一种更好的维持 session 会话的方式，它在浏览器不支持 cookie 时能够很好地工作，但是它的缺点是会动态生成每个 URL 来为页面分配一个 session 会话 ID，即使是在很简单的静态 HTML 页面中也会如此。</p>
<h2 id="httpsession-对象"><a class="header" href="#httpsession-对象">HttpSession 对象</a></h2>
<blockquote>
<p>该接口提供了一种跨多个页面请求或访问网站时识别用户以及存储有关用户信息的方式。</p>
</blockquote>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">方法 &amp; 描述</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><strong>public Object getAttribute(String name)</strong> 该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><strong>public Enumeration getAttributeNames()</strong> 该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><strong>public long getCreationTime()</strong> 该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><strong>public String getId()</strong> 该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left"><strong>public long getLastAccessedTime()</strong> 该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td></tr>
<tr><td style="text-align: left">6</td><td style="text-align: left"><strong>public int getMaxInactiveInterval()</strong> 该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。</td></tr>
<tr><td style="text-align: left">7</td><td style="text-align: left"><strong>public void invalidate()</strong> 该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。</td></tr>
<tr><td style="text-align: left">8</td><td style="text-align: left"><strong>public boolean isNew()</strong> 如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。</td></tr>
<tr><td style="text-align: left">9</td><td style="text-align: left"><strong>public void removeAttribute(String name)</strong> 该方法将从该 session 会话移除指定名称的对象。</td></tr>
<tr><td style="text-align: left">10</td><td style="text-align: left"><strong>public void setAttribute(String name, Object value)</strong> 该方法使用指定的名称绑定一个对象到该 session 会话。</td></tr>
<tr><td style="text-align: left">11</td><td style="text-align: left"><strong>public void setMaxInactiveInterval(int interval)</strong> 该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。</td></tr>
</tbody></table>
<p>提供了</p>
<ul>
<li>session唯一标识</li>
<li>session创建信息</li>
<li>session是否有效,什么时候过期</li>
<li>session中的属性 维护</li>
</ul>
<h2 id="开启session追踪实例"><a class="header" href="#开启session追踪实例"><strong>开启session追踪实例</strong></a></h2>
<pre><code class="language-java">  // 如果不存在 session 会话，则创建一个 session 对象
        HttpSession session = request.getSession(true);
        // 获取 session 创建时间
        Date createTime = new Date(session.getCreationTime());
        // 获取该网页的最后一次访问时间
        Date lastAccessTime = new Date(session.getLastAccessedTime());
         
        //设置日期输出的格式  
        SimpleDateFormat df=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    
        String title = &quot;Servlet Session 实例 - 菜鸟教程&quot;;
        Integer visitCount = new Integer(0);
        String visitCountKey = new String(&quot;visitCount&quot;);
        String userIDKey = new String(&quot;userID&quot;);
        String userID = new String(&quot;Runoob&quot;);
        if(session.getAttribute(visitCountKey) == null) {
            session.setAttribute(visitCountKey, new Integer(0));
        }

    
        // 检查网页上是否有新的访问者
        if (session.isNew()){
            title = &quot;Servlet Session 实例 - 菜鸟教程&quot;;
             session.setAttribute(userIDKey, userID);
        } else {
             visitCount = (Integer)session.getAttribute(visitCountKey);
             visitCount = visitCount + 1;
             userID = (String)session.getAttribute(userIDKey);
        }
        session.setAttribute(visitCountKey,  visitCount);
    
        // 设置响应内容类型
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter out = response.getWriter();
    
        String docType = &quot;&lt;!DOCTYPE html&gt;\n&quot;;
        out.println(docType +
                &quot;&lt;html&gt;\n&quot; +
                &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +
                &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +
                &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +
                 &quot;&lt;h2 align=\&quot;center\&quot;&gt;Session 信息&lt;/h2&gt;\n&quot; +
                &quot;&lt;table border=\&quot;1\&quot; align=\&quot;center\&quot;&gt;\n&quot; +
                &quot;&lt;tr bgcolor=\&quot;#949494\&quot;&gt;\n&quot; +
                &quot;  &lt;th&gt;Session 信息&lt;/th&gt;&lt;th&gt;值&lt;/th&gt;&lt;/tr&gt;\n&quot; +
                &quot;&lt;tr&gt;\n&quot; +
                &quot;  &lt;td&gt;id&lt;/td&gt;\n&quot; +
                &quot;  &lt;td&gt;&quot; + session.getId() + &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot; +
                &quot;&lt;tr&gt;\n&quot; +
                &quot;  &lt;td&gt;创建时间&lt;/td&gt;\n&quot; +
                &quot;  &lt;td&gt;&quot; +  df.format(createTime) + 
                &quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot; +
                &quot;&lt;tr&gt;\n&quot; +
                &quot;  &lt;td&gt;最后访问时间&lt;/td&gt;\n&quot; +
                &quot;  &lt;td&gt;&quot; + df.format(lastAccessTime) + 
                &quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot; +
                &quot;&lt;tr&gt;\n&quot; +
                &quot;  &lt;td&gt;用户 ID&lt;/td&gt;\n&quot; +
                &quot;  &lt;td&gt;&quot; + userID + 
                &quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot; +
                &quot;&lt;tr&gt;\n&quot; +
                &quot;  &lt;td&gt;访问统计：&lt;/td&gt;\n&quot; +
                &quot;  &lt;td&gt;&quot; + visitCount + &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot; +
                &quot;&lt;/table&gt;\n&quot; +
                &quot;&lt;/body&gt;&lt;/html&gt;&quot;); 
    }
</code></pre>
<h2 id="删除-session-会话数据"><a class="header" href="#删除-session-会话数据"><strong>删除 Session 会话数据</strong></a></h2>
<p>当您完成了一个用户的 session 会话数据，您有以下几种选择：</p>
<ul>
<li>**移除一个特定的属性：**您可以调用 <em>public void removeAttribute(String name)</em> 方法来删除与特定的键相关联的值。</li>
<li>**删除整个 session 会话：**您可以调用 <em>public void invalidate()</em> 方法来丢弃整个 session 会话。</li>
<li>**设置 session 会话过期时间：**您可以调用 <em>public void setMaxInactiveInterval(int interval)</em> 方法来单独设置 session 会话超时。</li>
<li>**注销用户：**如果使用的是支持 servlet 2.4 的服务器，您可以调用 <strong>logout</strong> 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。</li>
<li>**web.xml 配置：**如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：</li>
</ul>
<pre><code>  &lt;session-config&gt;
    &lt;session-timeout&gt;15&lt;/session-timeout&gt;
  &lt;/session-config&gt;
</code></pre>
<blockquote>
<p>上面实例中的超时时间是以分钟为单位，将覆盖 Tomcat 中默认的 30 分钟超时时间。</p>
</blockquote>
<blockquote>
<p>在一个 Servlet 中的 getMaxInactiveInterval() 方法会返回 session 会话的超时时间，以秒为单位。所以，如果在 web.xml 中配置 session 会话超时时间为 15 分钟，那么 getMaxInactiveInterval() 会返回 900。</p>
</blockquote>
<h1 id="文件上传-1"><a class="header" href="#文件上传-1">文件上传</a></h1>
<h2 id="示例-8"><a class="header" href="#示例-8"><strong>示例</strong></a></h2>
<pre><code class="language-java">{

        // 检测是否为多媒体上传
        if (!ServletFileUpload.isMultipartContent(request)) {
            // 如果不是则停止
            PrintWriter writer = response.getWriter();
            writer.println(&quot;Error: 表单必须包含 enctype=multipart/form-data&quot;);
            writer.flush();
            return;
        }
 
        // 配置上传参数
        DiskFileItemFactory factory = new DiskFileItemFactory();
        // 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中
        factory.setSizeThreshold(MEMORY_THRESHOLD);
        // 设置临时存储目录
        factory.setRepository(new File(System.getProperty(&quot;java.io.tmpdir&quot;)));
 
        ServletFileUpload upload = new ServletFileUpload(factory);
         
        // 设置最大文件上传值
        upload.setFileSizeMax(MAX_FILE_SIZE);
         
        // 设置最大请求值 (包含文件和表单数据)
        upload.setSizeMax(MAX_REQUEST_SIZE);

        // 中文处理
        upload.setHeaderEncoding(&quot;UTF-8&quot;); 

        // 构造临时路径来存储上传的文件
        // 这个路径相对当前应用的目录
        String uploadPath = request.getServletContext().getRealPath(&quot;./&quot;) + File.separator + UPLOAD_DIRECTORY;
       
         
        // 如果目录不存在则创建
        File uploadDir = new File(uploadPath);
        if (!uploadDir.exists()) {
            uploadDir.mkdir();
        }
 
        try {
            // 解析请求的内容提取文件数据
            @SuppressWarnings(&quot;unchecked&quot;)
            List&lt;FileItem&gt; formItems = upload.parseRequest(request);
 
            if (formItems != null &amp;&amp; formItems.size() &gt; 0) {
                // 迭代表单数据
                for (FileItem item : formItems) {
                    // 处理不在表单中的字段
                    if (!item.isFormField()) {
                        String fileName = new File(item.getName()).getName();
                        String filePath = uploadPath + File.separator + fileName;
                        File storeFile = new File(filePath);
                        storeFile.delete();
                        // 保存文件到硬盘
                        item.write(storeFile);
                        request.setAttribute(&quot;message&quot;,
                            &quot;文件上传成功!&quot;);
                        HttpSession session = request.getSession();
                        Object fileList = session.getAttribute(&quot;fileList&quot;);
                        if(fileList == null){
                            fileList = new ArrayList&lt;&gt;();
                            session.setAttribute(&quot;fileList&quot;,fileList);
                        }
                        ((List&lt;File&gt;)(fileList)).add(storeFile);
                    }
                }
            }
        } catch (Exception ex) {
            request.setAttribute(&quot;message&quot;,
                    &quot;错误信息: &quot; + ex.getMessage());
        }
        // 跳转到 message.jsp
        response.sendRedirect(&quot;/xjq/message.jsp&quot;);
    }
</code></pre>
<h2 id="理解"><a class="header" href="#理解">理解</a></h2>
<pre><code>由 apache的 common-io comon-file-upload 实现的  http文件上传
包括校验 文件类型, multipart-file 文件分割符
由 deferedOutputStream代理实现, 一开始 读入 内存, 达到 阈值之后 写入文件
然后用户 将由 内存的文件或者 物理磁盘的文件 写入 用户的文件中
</code></pre>
<h1 id="servlet-国际化"><a class="header" href="#servlet-国际化">Servlet 国际化</a></h1>
<h2 id="三大术语"><a class="header" href="#三大术语">三大术语</a></h2>
<ul>
<li>**国际化（i18n）：**这意味着一个网站提供了不同版本的翻译成访问者的语言或国籍的内容。</li>
<li>**本地化（l10n）：**这意味着向网站添加资源，以使其适应特定的地理或文化区域，例如网站翻译成印地文（Hindi）。</li>
<li>**区域设置（locale）：**这是一个特殊的文化或地理区域。它通常指语言符号后跟一个下划线和一个国家符号。例如 &quot;en_US&quot; 表示针对 US 的英语区域设置。</li>
</ul>
<h2 id="获取locale"><a class="header" href="#获取locale">获取Locale</a></h2>
<pre><code>java.util.Locale request.getLocale() 
</code></pre>
<h2 id="localeapi"><a class="header" href="#localeapi">LocaleAPI</a></h2>
<p>下面列出了重要的区域设置方法，您可以使用它们来检测请求者的地理位置、语言和区域设置。下面所有的方法都显示了请求者浏览器中设置的国家名称和语言名称。</p>
<table><thead><tr><th style="text-align: left">序号</th><th style="text-align: left">方法 &amp; 描述</th></tr></thead><tbody>
<tr><td style="text-align: left">1</td><td style="text-align: left"><strong>String getCountry()</strong> 该方法以 2 个大写字母形式的 ISO 3166 格式返回该区域设置的国家/地区代码。</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left"><strong>String getDisplayCountry()</strong> 该方法返回适合向用户显示的区域设置的国家的名称。</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left"><strong>String getLanguage()</strong> 该方法以小写字母形式的 ISO 639 格式返回该区域设置的语言代码。</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left"><strong>String getDisplayLanguage()</strong> 该方法返回适合向用户显示的区域设置的语言的名称。</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left"><strong>String getISO3Country()</strong> 该方法返回该区域设置的国家的三个字母缩写。</td></tr>
<tr><td style="text-align: left">6</td><td style="text-align: left"><strong>String getISO3Language()</strong> 该方法返回该区域设置的语言的三个字母的缩写。</td></tr>
</tbody></table>
<h2 id="实例-2"><a class="header" href="#实例-2"><strong>实例</strong></a></h2>
<pre><code class="language-java">import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import java.util.Locale;

public class GetLocale extends HttpServlet{
    
  public void doGet(HttpServletRequest request,
                    HttpServletResponse response)
            throws ServletException, IOException
  {
      // 获取客户端的区域设置
      Locale locale = request.getLocale();
      String language = locale.getLanguage();
      String country = locale.getCountry();

      // 设置响应内容类型
      response.setContentType(&quot;text/html;charset=UTF-8&quot;);
      PrintWriter out = response.getWriter();

      String title = &quot;检测区域设置&quot;;
      String docType = &quot;&lt;!DOCTYPE html&gt; \n&quot;;
      out.println(docType +
        &quot;&lt;html&gt;\n&quot; +
        &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +
        &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +
        &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + language + &quot;&lt;/h1&gt;\n&quot; +
        &quot;&lt;h2 align=\&quot;center\&quot;&gt;&quot; + country + &quot;&lt;/h2&gt;\n&quot; +
        &quot;&lt;/body&gt;&lt;/html&gt;&quot;);
  }
} 
</code></pre>
<h2 id="根据区域设定语言"><a class="header" href="#根据区域设定语言">根据区域设定语言</a></h2>
<pre><code class="language-java">import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import java.util.Locale;

public class DisplaySpanish extends HttpServlet{
    
  public void doGet(HttpServletRequest request,
                    HttpServletResponse response)
            throws ServletException, IOException
  {
    // 设置响应内容类型
    response.setContentType(&quot;text/html;charset=UTF-8&quot;);
    PrintWriter out = response.getWriter();
    // 设置西班牙语言代码
    response.setHeader(&quot;Content-Language&quot;, &quot;es&quot;);

    String title = &quot;En Espa&amp;ntilde;ol&quot;;
    String docType = &quot;&lt;!DOCTYPE html&gt; \n&quot;;
     out.println(docType +
     &quot;&lt;html&gt;\n&quot; +
     &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +
     &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +
     &quot;&lt;h1&gt;&quot; + &quot;En Espa&amp;ntilde;ol:&quot; + &quot;&lt;/h1&gt;\n&quot; +
     &quot;&lt;h1&gt;&quot; + &quot;&amp;iexcl;Hola Mundo!&quot; + &quot;&lt;/h1&gt;\n&quot; +
     &quot;&lt;/body&gt;&lt;/html&gt;&quot;);
  }
} 
</code></pre>
<h2 id="根据区域设置日期"><a class="header" href="#根据区域设置日期">根据区域设置日期</a></h2>
<pre><code class="language-java">import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import java.util.Locale;
import java.text.DateFormat;
import java.util.Date;

public class DateLocale extends HttpServlet{
    
  public void doGet(HttpServletRequest request,
                    HttpServletResponse response)
            throws ServletException, IOException
  {
    // 设置响应内容类型
    response.setContentType(&quot;text/html;charset=UTF-8&quot;);
    PrintWriter out = response.getWriter();
    // 获取客户端的区域设置
    Locale locale = request.getLocale( );
    String date = DateFormat.getDateTimeInstance(
                                  DateFormat.FULL, 
                                  DateFormat.SHORT, 
                                  locale).format(new Date( ));

    String title = &quot;特定于区域设置的日期&quot;;
    String docType = &quot;&lt;!DOCTYPE html&gt; \n&quot;;
      out.println(docType +
      &quot;&lt;html&gt;\n&quot; +
      &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +
      &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +
      &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + date + &quot;&lt;/h1&gt;\n&quot; +
      &quot;&lt;/body&gt;&lt;/html&gt;&quot;);
  }
} 
</code></pre>
<h2 id="根据区域设置货币"><a class="header" href="#根据区域设置货币">根据区域设置货币</a></h2>
<pre><code class="language-java">import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import java.util.Locale;
import java.text.NumberFormat;
import java.util.Date;

public class CurrencyLocale extends HttpServlet{
    
  public void doGet(HttpServletRequest request,
                    HttpServletResponse response)
            throws ServletException, IOException
  {
    // 设置响应内容类型
    response.setContentType(&quot;text/html;charset=UTF-8&quot;);
    PrintWriter out = response.getWriter();
    // 获取客户端的区域设置
    Locale locale = request.getLocale( );
    NumberFormat nft = NumberFormat.getCurrencyInstance(locale);
    String formattedCurr = nft.format(1000000);

    String title = &quot;特定于区域设置的货币&quot;;
    String docType = &quot;&lt;!DOCTYPE html&gt; \n&quot;;
      out.println(docType +
      &quot;&lt;html&gt;\n&quot; +
      &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +
      &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +
      &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + formattedCurr + &quot;&lt;/h1&gt;\n&quot; +
      &quot;&lt;/body&gt;&lt;/html&gt;&quot;);
  }
} 
</code></pre>
<h2 id="根据区域设置百分比"><a class="header" href="#根据区域设置百分比">根据区域设置百分比</a></h2>
<pre><code class="language-java">import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import java.util.Locale;
import java.text.NumberFormat;
import java.util.Date;

public class PercentageLocale extends HttpServlet{
    
  public void doGet(HttpServletRequest request,
                    HttpServletResponse response)
            throws ServletException, IOException
  {
    // 设置响应内容类型
    response.setContentType(&quot;text/html;charset=UTF-8&quot;);
    PrintWriter out = response.getWriter();
    // 获取客户端的区域设置
    Locale locale = request.getLocale( );
    NumberFormat nft = NumberFormat.getPercentInstance(locale);
    String formattedPerc = nft.format(0.51);

    String title = &quot;特定于区域设置的百分比&quot;;
    String docType = &quot;&lt;!DOCTYPE html&gt; \n&quot;;
      out.println(docType +
      &quot;&lt;html&gt;\n&quot; +
      &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot; +
      &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +
      &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + formattedPerc + &quot;&lt;/h1&gt;\n&quot; +
      &quot;&lt;/body&gt;&lt;/html&gt;&quot;);
  }
} 
</code></pre>
<h1 id="其他"><a class="header" href="#其他">其他</a></h1>
<h2 id="jsp的理解"><a class="header" href="#jsp的理解"><strong>JSP的理解</strong></a></h2>
<pre><code class="language-2">一种特殊的servlet
含HTML的内容是 response
含Java代码的是 get,或post
</code></pre>
<h2 id="重定向"><a class="header" href="#重定向"><strong>重定向</strong></a></h2>
<pre><code>      // 设置响应内容类型
      response.setContentType(&quot;text/html;charset=UTF-8&quot;);

      // 要重定向的新位置
      String site = new String(&quot;http://www.runoob.com&quot;);

      response.setStatus(response.SC_MOVED_TEMPORARILY);
      response.setHeader(&quot;Location&quot;, site);    
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是过滤器"><a class="header" href="#什么是过滤器">什么是过滤器</a></h1>
<p>它可以改变 HTTP 请求的内容，响应，及 header 信息。过滤器通常不产生
响应或像 servlet 那样对请求作出响应，而是修改或调整到资源的请求，修改或调整来自资源的响应。过滤器可以作用于动态或静态内容。</p>
<h1 id="过滤器组件示例"><a class="header" href="#过滤器组件示例">过滤器组件示例</a></h1>
<p>■ 验证过滤器
■ 日志记录和审计过滤器
■ 图像转换过滤器
■ 数据压缩过滤器
■ 加密过滤器
■ 词法（Tokenizing）过滤器
■ 触发资源访问事件过滤器
■ 转换 XML 内容的 XSL/T 过滤器
■ MIME-类型链过滤器
■ 缓存过滤器</p>
<h1 id="filter概念"><a class="header" href="#filter概念">Filter概念</a></h1>
<p>Filter 在部署描述符中通过<filter>元素声明。
一个过滤器或一组过滤器可以通过在部署描述符中定义<filter-mapping>来为调用配置</p>
<p><strong>过滤器的 doFilter 方法通常会被实现为如下或如下形式的子集</strong></p>
<ul>
<li>该方法检查请求的头。</li>
<li>该方法可以用自定义的ServletRequest或HttpServletRequest实现包装请求对象为了修改请求的头或数据</li>
<li>该方法可以用自定义的ServletResponse 或 HttpServletResponse实现包装传入doFilter方法的响应对象用
于修改响应的头或数据。</li>
</ul>
<p><strong>重试机制</strong></p>
<p>过滤器可能抛出一个异常以表示处理过程中出错了。如果过滤器在 doFilter 处理过程中抛出
<strong>UnavailableException，容器必须停止处理剩下的过滤器链。 如果异常没有标识为永久的( isPermanent 属性)，它或许选择稍候重试整个链。</strong></p>
<p>当链中的最后的过滤器被调用，下一个实体访问的是链最后的目标 servlet 或资源</p>
<p>在容器能把服务中的过滤器实例移除之前，容器必须先调用过滤器的 destroy 方法以便过滤器释放资源并执行其他的清理工作。</p>
<h1 id="包装请求和响应"><a class="header" href="#包装请求和响应">包装请求和响应</a></h1>
<p>过滤器的核心概念是包装请求或响应，以便它可以覆盖行为执行过滤任务。在这个模型中，开发人员不仅
可以覆盖请求和响应对象上已有的方法，也能提供新的API以适用于对过滤器链中剩下的过滤器或目标web
资源做特殊的过滤任务。例如，开发人员可能希望用更高级别的输出对象如 output stream 或 writer 来扩展
响应对象，如 API，允许 DOM 对象写回客户端。
为了支持这种风格的过滤器，容器必须支持如下要求。当过滤器调用容器的过滤器链实现的 doFilter 方法
时，容器必须确保请求和响应对象传到过滤器链中的下一个实体，或如果过滤器是链中最后一个，将传入
目标 web 资源，且与调用过滤器传入 doFilter 方法的对象是一样的。
当 调 用 者 包 装 请 求 或 响 应 对 象 时 ， 对 包 装 对 象 的 要 求 同 样 适 用 于 从 servlet 或 过 滤 器 到
RequestDispatcher.forward 或 RequestDispatcher.include 的调用。在这种情况下，调用 servlet 看到的请求和
响应对象与调用 servlet 或过滤器传入的包装对象必须是一样的。</p>
<h1 id="过滤器环境"><a class="header" href="#过滤器环境">过滤器环境</a></h1>
<p>可以使用部署描述符中的<init-params>元素把一组初始化参数关联到过滤器。这些参数的名字和值在过滤
器运行期间可以使用过滤器的FilterConfig对象的getInitParameter和getInitParameterNames方法得到。另外，
FilterConfig 提供访问 Web 应用的 ServletContext 用于加载资源，记录日志，在 ServletContext 的属性列表存
储状态。链中最后的过滤器和目标 servlet 或资源必须执行在同一个调用线程。</p>
<h1 id="在-在-web-应用中配置过滤器"><a class="header" href="#在-在-web-应用中配置过滤器">在 在 Web 应用中配置过滤器</a></h1>
<p>@WebFilter </p>
<p>■ filter-name: 用于映射过滤器到 servlet 或 URL
■ filter-class: 由容器用于表示过滤器类型
■ init-params: 过滤器的初始化参数</p>
<p>容器必须为部署描述符中定义的
每个过滤器声明实例化一个 Java 类实例。因此，如果开发人员对同一个过滤器类声明了两次，<strong>则容器将实例化两个相同的过滤器类的实例</strong>。</p>
<p><strong>定义</strong></p>
<pre><code class="language-xml">&lt;filter&gt;
&lt;filter-name&gt;Image Filter&lt;/filter-name&gt;
&lt;filter-class&gt;com.acme.ImageFilter&lt;/filter-class&gt;
&lt;/filter&gt;
</code></pre>
<p><strong>指定servlet过滤</strong></p>
<pre><code class="language-xml">&lt;filter-mapping&gt;
&lt;filter-name&gt;Multipe Mappings Filter&lt;/filter-name&gt;
&lt;url-pattern&gt;/foo/*&lt;/url-pattern&gt;
&lt;servlet-name&gt;Servlet1&lt;/servlet-name&gt;
&lt;servlet-name&gt;Servlet2&lt;/servlet-name&gt;
&lt;url-pattern&gt;/bar/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<p><strong>servlet url</strong></p>
<pre><code class="language-xml">&lt;filter-mapping&gt;
&lt;filter-name&gt;Logging Filter&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<ol>
<li>首先， <url-pattern>按照在部署描述符中的出现顺序匹配过滤器映射。</li>
<li>接下来，<servlet-name>按照在部署描述符中的出现顺序匹配过滤器映射。</li>
</ol>
<h1 id="过滤器和-requestdispatcher"><a class="header" href="#过滤器和-requestdispatcher">过滤器和 RequestDispatcher</a></h1>
<p>Java Servlet 规范自从 2.4 新版本以来，能够在请求分派器 forward()和 include()调用情况下配置可被调用的
过滤器。
通过在部署描述符中使用新的<dispatcher>元素，开发人员可以为 filter-mapping 指定是否想要过滤器应用到
请求，当：</p>
<ol>
<li>请求直接来自客户端。
可以由一个带有 REQUEST 值的<dispatcher>元素，或者没有任何<dispatcher>元素来表示。
2.使用表示匹配<url-pattern> 或 <servlet-name>的 Web 组件的请求分派器的 forward()调用情况下处理请求。
可以由一个带有 FORWARD 值的<dispatcher>元素表示。
3.使用表示匹配<url-pattern> 或 <servlet-name>的 Web 组件的请求分派器的 include()调用情况下处理请求。
50
可以由一个带有 INCLUDE 值的<dispatcher>元素表示。</li>
<li>使用第 106 页“错误处理”指定的错误页面机制处理匹配<url-pattern>的错误资源的请求。
可以由一个带有 ERROR 值的<dispatcher>元素表示。</li>
<li>使用第 10 页指定的“异步处理”中的异步上下文分派机制对 web 组件使用 dispatch 调用处理请求。
可以由一个带有 ASYNC 值的<dispatcher>元素表示。</li>
<li>或之上 1，2，3，4 或 5 的任何组合。</li>
</ol>
<pre><code class="language-xml">&lt;filter-mapping&gt;
&lt;filter-name&gt;Logging Filter&lt;/filter-name&gt;
&lt;url-pattern&gt;/products/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<p>客户端以/products/...开始的请求将导致 Logging Filter 被调用，但不是在以路径/products/...开始的请求分派
器调用情况下。LoggingFilter 将在初始请求分派和恢复请求时被调用。如下代码：</p>
<pre><code class="language-xml">&lt;filter-mapping&gt;
&lt;filter-name&gt;Logging Filter&lt;/filter-name&gt;
&lt;servlet-name&gt;ProductServlet&lt;/servlet-name&gt;
&lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="servlet接口-1"><a class="header" href="#servlet接口-1">Servlet接口</a></h1>
<h2 id="请求处理"><a class="header" href="#请求处理">请求处理</a></h2>
<h3 id="请求方法"><a class="header" href="#请求方法">请求方法</a></h3>
<h4 id="doget"><a class="header" href="#doget">doGet</a></h4>
<p>一般用于查询,资源获取</p>
<h4 id="dopost"><a class="header" href="#dopost">doPost</a></h4>
<p>用于修改服务器资源</p>
<h4 id="doput"><a class="header" href="#doput">doPut</a></h4>
<p>用于文件上传</p>
<h4 id="dodelete"><a class="header" href="#dodelete">doDelete</a></h4>
<p>删除资源</p>
<h4 id="dohead"><a class="header" href="#dohead">doHead</a></h4>
<p>只返回DoGet请求的 头</p>
<h4 id="dooptions"><a class="header" href="#dooptions">doOptions</a></h4>
<p>返回HttpServlet支持的 方法,通过 Allow 响应头返回支持的 HTTP 操作，如 GET、POST</p>
<h4 id="dotrace"><a class="header" href="#dotrace">doTrace</a></h4>
<p>返回的响应包含 TRACE 请求的所有头信息</p>
<h4 id="有条件-get-支持"><a class="header" href="#有条件-get-支持">有条件 GET 支持</a></h4>
<p><em>HttpServlet</em> 定义了用于支持有条件 GET 操作的 <em>getLastModified</em> 方法。所谓的有条件 GET 操作是指客户端
通过 GET 请求获取资源时，当资源自第一次获取那个时间点发生更改后才再次发生数据，否则将使用客户
端缓存的数据。在一些适当的场合，实现此方法可以更有效的利用网络资源，减少不必要的数据发送</p>
<h2 id="servlet实例数量"><a class="header" href="#servlet实例数量">Servlet实例数量</a></h2>
<p><strong>单实例的Servlet</strong></p>
<ul>
<li>
<p>通过注解描述的（第 8 章 注解和可插拔性）或者在 Web 应用程序的部署描述符（第 14 章 部署描述符）中描述的 servlet 声明，控制着 servlet 容器如何提供 servlet 实例</p>
</li>
<li>
<p>对于未托管在分布式环境中（默认）的 <em>servlet</em> 而言，<em>servlet</em> 容器对于每一个 <em>Servlet</em> 声明必须且只能产生一
个实例。不过，如果 Servlet 实现了 <em>SingleThreadModel</em> 接口，servlet 容器可以选择实例化多个实例以便处
理高负荷请求或者串行化请求到一个特定实例。
如果 <em>servlet</em> 以分布式方式进行部署，容器可以为每个虚拟机（JVM）的每个 <em>Servlet</em> 声明产生一个实例。但
是，如果在分布式环境中 servlet 实现了 SingleThreadModel 接口，此时容器可以为每个容器的 JVM 实例化
多个 Servlet 实例</p>
</li>
</ul>
<p><em><strong>SingleThreadModel</strong></em></p>
<ul>
<li>
<p>它保证在  同一时刻 只能由一个 线程执行 <em>service</em>方法 </p>
</li>
<li>
<p>实现的方式大致由两种</p>
<ul>
<li>针对 单实例 进行 同步锁定</li>
<li>针对 多实例 维护实例池 , 分配空闲实例</li>
</ul>
</li>
<li>
<p>但是 仍然避免不了 线程安全问题, 尤其是在 多个servlet针对  <em>session</em>的attribute时</p>
</li>
<li>
<p>最好的办法是 不要编写 有状态的 <em>servlet</em></p>
</li>
<li>
<p>已经过时</p>
</li>
</ul>
<h2 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h2>
<h3 id="加载和实例化"><a class="header" href="#加载和实例化">加载和实例化</a></h3>
<p>Servlet 容器负责加载和实例化 Servlet。<strong>加载和实例化可以发生在容器启动时，或者延迟初始化直到容器决定有请求需要处理时</strong>。当 Servlet 引擎启动后，servlet 容器必须定位所需要的 Servlet 类。Servlet 容器使用普通的 Java 类加载设施加载 Servlet 类。可以从本地文件系统或远程文件系统或者其他网络服务加载。加载
完 Servlet 类后，容器就可以实例化它并使用了</p>
<h3 id="初始化-6"><a class="header" href="#初始化-6">初始化</a></h3>
<p>一旦一个 Servlet 对象实例化完毕，容器接下来必须在处理客户端请求之前初始化该 Servlet 实例。初始化
的目的是以便 Servlet 能读取持久化配置数据，<strong>初始化一些代价高的资源（比如 JDBC API 连接）</strong>，或者执
行一些一次性的动作。</p>
<pre><code class="language-java">init(ServletConfig config)
</code></pre>
<p><strong>初始化时的错误条件</strong>
在初始化阶段，servlet 实现可能抛出 UnavailableException 或 ServletException 异常。在这种情况下，Servlet
不能放置到活动服务中，而且 Servlet 容器必须释放它。如果初始化没有成功，destroy 方法不应该被调用。
在实例初始化失败后容器可能再实例化和初始化一个新的实例。此规则的例外是，<strong>当抛出的</strong>
<strong>UnavailableException 表示一个不可用的最小时间，容器在创建和初始化一个新的 servlet 实例之前必须等待</strong>
<strong>一段时间</strong>。</p>
<h3 id="请求处理-1"><a class="header" href="#请求处理-1">请求处理</a></h3>
<h4 id="forward与include"><a class="header" href="#forward与include">forward与include</a></h4>
<ul>
<li>
<p><em>forward</em></p>
<p>一旦调用forward,<strong>除了保留forward前的response里的header外</strong>，其它的都不保留</p>
<pre><code class="language-java">//该命令 会立马 分派到指定servlet
request.getRequestDispatcher(&quot;/forwardDemo02&quot;).forward(request,response);
</code></pre>
</li>
<li>
<p><em>include</em> </p>
<p>包含 该URL的 内容,(<em>printer</em>) 其他 <em>header</em> 都不要</p>
</li>
<li>
<p>forward include之间的数据共享可以通过  <em>request.attribute</em> 实现</p>
</li>
</ul>
<h4 id="多线程问题"><a class="header" href="#多线程问题"><strong>多线程问题</strong></a></h4>
<p>不要编写有状态的 <em>Servlet</em></p>
<h4 id="请求处理时的异常"><a class="header" href="#请求处理时的异常">请求处理时的异常</a></h4>
<p><em>UnavailableException</em></p>
<p><strong>永久性不可用</strong></p>
<ul>
<li>Servlet 容器必须从服务中移除这个 Servlet，调用它的 destroy 方法，并释放 Servlet 实例。</li>
<li>所有被容器拒绝的请求，都会返回一个 SC_NOT_FOUND (404) 响
应。</li>
</ul>
<p><strong>临时不可用</strong></p>
<ul>
<li>返回一个 SC_SERVICE_UNAVAILABLE (503)</li>
<li>同时会返回一个 Retry-After 头指示此 Servlet 什么时候可用</li>
</ul>
<p>容器可以选择忽略永久性和临时性不可用的区别，并把 UnavailableExceptions 视为永久性的，从而 Servlet 抛出 UnavailableException 后需要把它从服务中移除。</p>
<h4 id="异步处理"><a class="header" href="#异步处理">异步处理</a></h4>
<blockquote>
<p>Filter 及/或 Servlet 在生成响应之前必须等待一些资源或事件以便完成请求处理,比如，Servlet 在进行生成一个响应之前可能等待一个可用的 JDBC 连接，或者一个远程 web 服务的响应，或者一个 JMS 消息，或者一个应用程序事件, 在 Servlet 中等待是一个低效的操作，因为这是阻塞操作，从而白白占用一个
线程或其他一些受限资源</p>
</blockquote>
<p><strong>异步请求事件顺序</strong></p>
<ul>
<li>收到请求, 通过一系列的 <em>filter</em></li>
<li>处理请求参数</li>
<li>发出请求去获取一些资源或数据 例如获取JDBC连接,发起Web远程服务</li>
<li>servlet 不产生响应并返回</li>
<li>过了一段时间后，所请求的资源变为可用，此时处理线程继续处理事件，要么在同一个线程，要么通过
AsyncContext 分派到容器中的一个资源上</li>
</ul>
<p><strong>异步的操作</strong></p>
<pre><code>startAsync() //使用原生的未经包装的 request对象
startAsync(req,resp)//包装的 req,resp对象
complete() //完成
</code></pre>
<p><strong>异步的限制</strong></p>
<ul>
<li>
<p>所有涉及到 异步调用链的  filter必须是支持异步的</p>
</li>
<li>
<p>当 从一个异步servlet 分派到 同步servlet 时, servlet结束后,会自动调用 complete</p>
</li>
<li>
<p>同步 servlet 不能 分派到 异步servlet</p>
</li>
<li>
<p>异步servlet 的响应 等到 调用 complete 才返回</p>
</li>
<li>
<p>异步超时之后 会自动 提交响应</p>
</li>
</ul>
<pre><code class="language-java">{
        System.out.println(&quot;servlet1&quot;);
        System.out.println(req.getClass());
        System.out.println(response.getClass());
        AsyncContext asyncContext = req.startAsync();
        if(asyncContext.hasOriginalRequestAndResponse()){
            asyncContext.start(()-&gt;{
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 设置响应内容类型
                response.setContentType(&quot;text/html;charset=UTF-8&quot;);
                //格式化输出
                PrintWriter out;
                try {
                    out = response.getWriter();
                    String title = &quot;自动刷新 Header 设置 - 菜鸟教程实例&quot;;
                    String docType =
                            &quot;&lt;!DOCTYPE html&gt;\n&quot;;
                    out.println(docType +
                            &quot;&lt;html&gt;\n&quot; +
                            &quot;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot;+
                            &quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot; +
                            &quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot; +
                            &quot;&lt;p&gt;当前时间是：&quot; + LocalDateTime.now() + &quot;&lt;/p&gt;\n&quot;);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                asyncContext.dispatch();
            });
        }else{
            //开始干另一件事
            System.out.println(&quot;异步处理完毕了哈哈哈&quot;);
            asyncContext.complete();
        }
        System.out.println(&quot;立即返回&quot;);
    }
</code></pre>
<p><strong>升级处理</strong></p>
<ul>
<li>
<p>在 HTTP/1.1，Upgrade 通用头（general-header）允许客户端指定其支持和希望使用的其他通信协议。如果
服务器找到合适的切换协议，那么新的协议将在之后的通信中使用。</p>
</li>
<li>
<p>Servlet 容器提供了 HTTP 升级机制。不过，Servlet 容器本身不知道任何升级协议。协议处理封装在 <em>HttpUpgradeHandler</em> 协议处理器。<strong>在容器和HttpUpgradeHandler 协议处理器之间通过字节流进行数据读取或写入</strong></p>
</li>
<li>
<p>流程</p>
<ul>
<li>当收到一个升级（upgrade）请求，servlet 可以调用 HttpServletRequest.upgrade 方法启动升级处理。该方法
实例化给定的 HttpUpgradeHandler 类，返回的 HttpUpgradeHandler 实例可以被进一步的定制。</li>
<li>应用准备发送一个合适的响应到客户端。</li>
<li>退出 servlet service 方法之后，servlet 容器完成所有过滤器的处理并标记连接已交给 HttpUpgradeHandler 协议处理器处理。</li>
<li>然后调用 HttpUpgradeHandler 协议处理器的 init 方法，传入一个 WebConnection 以允许 HttpUpgradeHandler 协议处理器访问数据流。</li>
<li>Servlet 过滤器仅处理初始的 HTTP 请求和响应，然后它们将不会再参与到后续的通信中。换句话说，一旦请求被升级，它们将不会被调用。</li>
<li>协议处理器（ProtocolHandler）可以使用非阻塞 IO（non blocking IO）消费和生产消息。当处理 HTTP 升级时，开发人员负责线程安全的访问 ServletInputStream 和 ServletOutputStream。当升级处理已经完成，将调用 HttpUpgradeHandler.destroy 方法。</li>
</ul>
</li>
</ul>
<h3 id="终止服务"><a class="header" href="#终止服务"><strong>终止服务</strong></a></h3>
<ul>
<li>
<p>Servlet 容器没必要保持装载的 Servlet 持续任何特定的一段时间。</p>
</li>
<li>
<p>一个 Servlet 实例可能会在 servlet 容器内保持活跃（active）持续一段时间（以毫秒为单位），Servlet 容器的寿命可能是几天，几个月，或几年，或者是任何之间的时间。当 Servlet 容器确定 servlet 应该从服务中移除时，将调用 Servlet 接口的 destroy 方法以允许 Servlet 释放它使
用的任何资源和保存任何持久化的状态。例如，当想要节省内存资源或它被关闭时，容器可以做这个。</p>
</li>
<li>
<p>在 servlet 容器调用 destroy 方法之前，它必须让当前正在执行 service 方法的任何线程完成执行，或者超过
了服务器定义的时间限制。一旦调用了 servlet 实例的 destroy 方法，容器无法再路由其他请求到该 servlet 实例了。如果容器需要再次使用该 servlet，它必须用该 servlet 类的一个新的实例。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http协议参数"><a class="header" href="#http协议参数">Http协议参数</a></h1>
<p><strong>POST参数可用时</strong></p>
<p>1。该请求是一个 HTTP或 HTTPS请求。
2。HTTP方法是 POST。
3。内容类型是 application/x-www-form-urlencoded
4。该 servlet已经对 request 对象的任意 getParameter方法进行了初始调用</p>
<p><strong>容器从 URI查询字符串和 POST 数据中填充参数</strong>。</p>
<p><strong>参数以一系列的名-值对的形式保存</strong>。</p>
<p><strong>任何给定的参数的名称可存在多个参数值</strong>。
<strong>ServletRequest 接口</strong>的下列方法可访问这些参数：</p>
<ul>
<li>getParameter</li>
<li>getParameterNames</li>
<li>getParameterValues</li>
<li>getParameterMap</li>
</ul>
<h1 id="文件上传-2"><a class="header" href="#文件上传-2">文件上传</a></h1>
<blockquote>
<p>当数据以 multipart/form-data的格式发送时，servlet 容器支持文件上传</p>
</blockquote>
<p><strong>坑点1</strong></p>
<ul>
<li>
<p>会有两种输入流 <em>FileInputStream</em> <em>ByteArrayInputStream</em></p>
</li>
<li>
<p><em>InputStream</em> 每调用一次都会 包装一遍,导致<em>ByteArrayInputStream</em>维护的变量失效</p>
<p><em>DiskFileItem.getInputStream</em></p>
<pre><code>{
        if (!isInMemory()) {
            return new FileInputStream(dfos.getFile());
        }

        if (cachedContent == null) {
            cachedContent = dfos.getData();
        }
        return new ByteArrayInputStream(cachedContent);
    }
</code></pre>
</li>
</ul>
<p><strong>注解 <em>MultipartConfig</em></strong></p>
<ul>
<li>使得servlet支持 文件上传</li>
<li><em>location</em> 指定临时文件位置</li>
<li><em>maxFileSize</em> 指定文件最大大小</li>
<li><em>maxRequestSize</em> 指定请求头最大大小</li>
<li><em>fileSizeThreshold</em> 指定文件 多少被写进磁盘</li>
</ul>
<h1 id="属性"><a class="header" href="#属性">属性</a></h1>
<p>■ getAttribute
■ getAttributeNames
■ setAttribute</p>
<p>只有一个属性值可与一个属性名称相关联。以前缀 java.和 javax.开头的属性名称是本规范的保留定义。
同样地，以前缀 sun.和 com.sun.，oracle 和 com.oracle 开头的属性名是 Oracle Corporation 的保留定
义。建议属性集中所有属性的命名与 Java 编程语言的规范 1 为包命名建议的反向域名约定一致</p>
<h1 id="头"><a class="header" href="#头">头</a></h1>
<p>■ getHeader
■ getHeaders
■ getHeaderNames</p>
<h1 id="请求路径"><a class="header" href="#请求路径">请求路径</a></h1>
<p>**Context Path ** 项目路径</p>
<p><strong>Servlet Path</strong> <em>servletpath</em></p>
<p><strong>PathInfo</strong></p>
<p><em>requestURI = contextPath + servletPath + pathInfo</em></p>
<pre><code>/catalog/lawn/index.html 
	ContextPath: /catalog
	ServletPath: /lawn
	PathInfo: /index.html
/catalog/garden/implements/ 
	ContextPath: /catalog
	ServletPath: /garden
	PathInfo: /implements/
/catalog/help/feedback.jsp 
	ContextPath: /catalog
	ServletPath: /help/feedback.jsp
	PathInfo: null
</code></pre>
<p><strong>路径转换方法</strong>
在 API中有两个方便的方法，允许开发者获得与某个特定的路径等价的文件系统路径。这些方法是：</p>
<ul>
<li>
<p>ServletContext.getRealPath</p>
</li>
<li>
<p>HttpServletRequest.getPathTranslated
getRealPath 方法需要一个字符串参数，并返回一个字符串形式的路径，这个路径对应一个在本地文件系统
上的文件。getPathTranslated 方法推断出请求的 pathInfo 的实际路径（译者注：把 URL 中 servlet 名称之后，
查询字符串之前的路径信息转化成实际的路径）。
这些方法在 servlet 容器无法确定一个有效的文件路径 的情况下，如 Web 应用程序从归档中，在不能访问
本地的远程文件系统上，或在一个数据库中执行时，这些方法必须返回null。JAR文件中META-INF/resources
目录下的资源，只有当调用 getRealPath()方法时才认为容器已经从包含它的 JAR 文件中解压，在这种情况
下，必须返回解压缩后位置</p>
</li>
</ul>
<h1 id="非阻塞io"><a class="header" href="#非阻塞io">非阻塞IO</a></h1>
<blockquote>
<p>非阻塞 IO 仅对在 Servlet 和 Filter（“异步处理”）中的异步请求处理和升级处理
（“升级处理”）有效</p>
</blockquote>
<p><em>ReadListener</em></p>
<p><em>onDataAvailable</em></p>
<p><em>onAllDataRead</em></p>
<p><em>onError</em></p>
<h1 id="cookie"><a class="header" href="#cookie">Cookie</a></h1>
<p>HttpOnly cookie 暗示客户端它们不会暴
露给客户端脚本代码</p>
<h1 id="ssl属性"><a class="header" href="#ssl属性">SSL属性</a></h1>
<p><strong>协议属性</strong></p>
<table><thead><tr><th>属性</th><th>属性名称</th><th>Java 类型</th></tr></thead><tbody>
<tr><td>密码套件</td><td>javax.servlet.request.cipher_suite</td><td>String</td></tr>
<tr><td>算法的位大小</td><td>javax.servlet.request.key_size</td><td>Integer</td></tr>
<tr><td>SSL 会话 id</td><td>javax.servlet.request.ssl_session_id</td><td>String</td></tr>
</tbody></table>
<p>如果有一个与请求相关的 SSL 证书，它必须由 servlet 容器以 java.security.cert.X509Certificate 类型的对象数组暴露给 servlet 程序员并可通过一个 javax.servlet.request.X509Certificate 类型的 ServletRequest 属性访问。
这个数组的顺序是按照信任的升序顺序。证书链中的第一个证书是由客户端设置的，第二个是用来验证第
一个的，等等。</p>
<h1 id="国际化"><a class="header" href="#国际化">国际化</a></h1>
<p>getLocale
getLocales</p>
<p>getLocale 方法将返回客户端要接受内容的首选语言环境。要了解更多关于 Accept-Language 头必须被解
释为确定客户端首选语言的信息，请参阅 RFC 2616（HTTP/1.1）14.4 节。
getLocales 方法将返回一个 Locale 对象的枚举，从首选语言环境开始顺序递减，这些语言环境是可被客户
接受的语言环境。
如果客户端没有指定首选语言环境，getLocale方法返回的语言环境必须是 servlet容器默认的语言环境，而
getLocales方法必须返回只包含一个默认语言环境的 Local 元素的枚举。</p>
<h1 id="请求数据编码"><a class="header" href="#请求数据编码">请求数据编码</a></h1>
<p>目前，许多浏览器不随着 Content-Type 头一起发送字符编码限定符，而是根据读取 HTTP 请求确定字符编码。如果客户端请求没有指定请求默认的字符编码，容器用来创建请求读取器和解析 POST 数据的编码必须是“ISO-8859-1”。然而，为了向开发人员说明客户端没有指定请求默认的字符编码，在这种情况下，客户端发送字符编码失败，容器从 getCharacterEncoding方法返回 null。
如果客户端没有设置字符编码，并使用不同的编码来编码请求数据，而不是使用上面描述的默认的字符编
码 ， 那 么 可 能 会 发 生 破 坏 。 为 了 弥 补 这 种 情 况 ， ServletRequest 接 口 添 加 了 一 个 新 的 方 法
<em>setCharacterEncoding(String enc)</em>。</p>
<p>开发人员可以通过调用此方法来覆盖由容器提供的字符编码。<strong>必须在解析任何 post 数据或从请求读取任何输入之前调用此方法</strong>。</p>
<p>此方法一旦调用，将不会影响已经读取的数据的编码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="缓冲"><a class="header" href="#缓冲">缓冲</a></h1>
<p><em>ServletResponse</em> 接口的如下方法允许 servlet 访问和设置缓冲信息：</p>
<pre><code>getBufferSize 如果没有使用缓冲，该方法必须返回一个 int 值 0
setBufferSize 
isCommitted 是否有任何响应字节已经返回到客户端
reset 当响应没有提交时，reset 方法清空缓冲区的数据,。头信息，状态码也要被清空
resetBuffer 将清空缓冲区中的内容，但不清空请求头和状态码
如果响应已经提交并且 reset 或 resetBuffer 方法已被调用，则必须抛出 IllegalStateException，响应及它关联的缓冲区将保持不变
flushBuffer 当使用缓冲区时，容器必须立即刷出填满的缓冲区内容到客户端。如果这是最早发送到客户端的数据，且认为响应被提交了
</code></pre>
<h1 id="非阻塞-io"><a class="header" href="#非阻塞-io">非阻塞 IO</a></h1>
<p>非阻塞 IO 仅对在 Servlet 和 Filter（“异步处理”）中的异步请求处理和升级处理
（“升级处理”）有效。否则，当调用 ServletInputStream.setReadListener 或
ServletOutputStream.setWriteListener 方法时将抛出 IllegalStateException。</p>
<p><em>WriteListener</em></p>
<p><em>ServletOutputStream</em></p>
<pre><code>boolean isReady(). 如果往 ServletOutputStream 写会成功，则该方法返回 true，其他情况会返回 false。
如果该方法返回 true，可以在 ServletOutputStream 上执行写操作。如果没有后续的数据能写到
ServletOutputStream，那么直到底层的数据被刷出之前该方法将一直返回 false。且在此时容器将调用
WriteListener 的 onWritePossible 方法。随后调用该方法将返回 true。
■ void setWriteListener(WriteListener listener). 关联 WriteListener 和当且的 ServletOutputStream，当
ServletOutputStream 可以写入数据时容器会调用 WriteListener 的回调方法。注册了 WriteListener 将开
始非阻塞 IO。此时再切换到传统的阻塞 IO 是非法的。
</code></pre>
<h1 id="简便方法"><a class="header" href="#简便方法">简便方法</a></h1>
<p>HttpServletResponse 提供了如下简便方法：
■ sendRedirect
■ sendError</p>
<p>sendRedirect 方法将设置适当的 header 和内容体,将客户端重定向到另一个地址。使用相对 URL 路径调用该方法是合法的，但是底层的容器必须将传回到客户端的相对地址转换为全路径 URL。无论出于什么原因，如 果 给 定 的 URL 是 不 完 整 的 ， 且 不 能 转 换 为 一 个 有 效 的 URL ， 那 么 该 方 法 必 须 抛 出IllegalArgumentException。
sendError 方法将设置适当的 header 和内容体用于返回给客户端返回错误消息。可以 sendError 方法提供一个可选的 String 参数用于指定错误的内容体。
如果响应已经提交并终止，这两个方法将对提交的响应产生负作用。</p>
<p><strong>这两个方法调用后 servlet 将不会产生到客户端的后续的输出</strong>。这两个方法调用后如果有数据继续写到响应，这些数据被忽略。 如果数据已经写到响应的缓冲区，但没有返回到客户端（例如，响应没有提交），<strong>则响应缓冲区中的数据必须被清空并使用这两个方法设置的数据替换。</strong></p>
<p>如果响应已提交，这两个方法必须抛出 IllegalStateException。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="servletcontext作用范围"><a class="header" href="#servletcontext作用范围">ServletContext作用范围</a></h1>
<p>ServletContext 是非分布式的且仅存在于一个 JVM 中</p>
<blockquote>
<p>每个 JVM 的每个 Web 应用将有一个 ServletContext 实例</p>
</blockquote>
<h1 id="初始化参数"><a class="header" href="#初始化参数">初始化参数</a></h1>
<blockquote>
<p>容器启动的初始化参数</p>
</blockquote>
<p><em>getInitParameter</em>
<em>getInitParameterNames</em></p>
<h1 id="配置方法"><a class="header" href="#配置方法">配置方法</a></h1>
<ul>
<li>
<p>从 Servlet 3.0 开始,可以以编程方式定义 Servlet、Filter 和它们映射到的url 模式,</p>
<p><strong>这些方法只能从 <em>ServletContextListener</em> 实现的 <em>contexInitialized</em> 方法或者</strong>
<strong><em>ServletContainerInitializer</em> 实现的 <em>onStartup</em> 方法进行的应用初始化过程中调用</strong>。 </p>
</li>
<li>
<p>也可以查找关联到 Servlet 或 Filter 的一个 Registration 对象实例，或者到 Servlet 或 Filter 的所有 Registration对象的 map。</p>
</li>
<li>
<p>如果 ServletContext 传到了 ServletContextListener 的 contextInitialized 方法，但该 ServletContextListener 即没 有在 web.xml 或 web-fragment.xml 中声明也没有使用@WebListener 注解，则在 ServletContext 中定义的用于Servlet、Filter 和 Listener 的编程式配置的所有方法必须抛出 UnsupportedOperationException</p>
</li>
</ul>
<h2 id="编程式添加和配置-servlet"><a class="header" href="#编程式添加和配置-servlet">编程式添加和配置 Servlet</a></h2>
<pre><code class="language-java">addServlet(String servletName, String className)
addServlet(String servletName, Servlet servlet)
addServlet(String servletName, Class &lt;? extends Servlet&gt; servletClass)
&lt;T extends Servlet&gt; T createServlet(Class&lt;T&gt; clazz)
ServletRegistration getServletRegistration(String servletName)
Map&lt;String, ? extends ServletRegistration&gt; getServletRegistrations()
</code></pre>
<h2 id="编程式添加和配置-filter"><a class="header" href="#编程式添加和配置-filter">编程式添加和配置 Filter</a></h2>
<pre><code class="language-java">addFilter(String filterName, String className)
addFilter(String filterName, Filter filter)
addFilter(String filterName, Class &lt;? extends Filter&gt; filterClass)
&lt;T extends Filter&gt; T createFilter(Class&lt;T&gt; clazz)
FilterRegistration getFilterRegistration(String filterName)
Map&lt;String, ? extends FilterRegistration&gt; getFilterRegistrations()
</code></pre>
<h2 id="编程式添加和配置-listener"><a class="header" href="#编程式添加和配置-listener">编程式添加和配置 Listener</a></h2>
<p><strong>listener接口</strong></p>
<pre><code class="language-java">javax.servlet.ServletContextAttributeListener
javax.servlet.ServletRequestListener
javax.servlet.ServletRequestAttributeListener
javax.servlet.http.HttpSessionListener
javax.servlet.http.HttpSessionAttributeListener
javax.servlet.http.HttpSessionIdListener
</code></pre>
<p><strong>配置API</strong></p>
<pre><code>&lt;T extends EventListener&gt; void addListener(T t)
void addListener(String className)
&lt;T extends EventListener&gt; void addListener(T t)
void addListener(Class &lt;? extends EventListener&gt; listenerClass)
&lt;T extends EventListener&gt; void createListener(Class&lt;T&gt; clazz)
</code></pre>
<p><strong>编程式添加<em>servlet,filter,listener</em> 时注解请求处理</strong></p>
<pre><code>@ServletSecurity、@RunAs、@DeclareRoles、@MultipartConfig。
这些注解 需要确保在手动 添加时,已经被处理到,
// 使用DI 去自动处理
</code></pre>
<h1 id="上下文属性"><a class="header" href="#上下文属性">上下文属性</a></h1>
<p>setAttribute
getAttribute
getAttributeNames
removeAttribute</p>
<h1 id="资源"><a class="header" href="#资源">资源</a></h1>
<p>ServletContext 接口提供了直接访问 Web 应用中静态内容层次结构的文件的方法，包括 HTML，GIF 和 JPEG
文件：
<em>getResource</em>
<em>getResourceAsStream</em>
getResource 和 getResourceAsStream 方法需要一个以“/”开头的 String 字符串作为参数，</p>
<ul>
<li>
<p><strong>给定的资源路径是相对于上下文的根</strong>，</p>
</li>
<li>
<p>或者相对于 web 应用的 <strong>WEB-INF/lib 目录下的 JAR 文件中的 META-INF/resources目录</strong>。</p>
<p>这两个方法首先根据请求的资源查找 web 应用上下文的根，然后查找所有 WEB-INF/lib 目录下的 JAR
文件。<strong>查找 WEB-INF/lib 目录中 JAR 文件的顺序是不确定的</strong>。这种层次结构的文件可以存在于服务器的文
件系统，Web 应用的归档文件，远程服务器，或在其他位置。</p>
</li>
<li>
<p><strong>可以使用 getResourcePaths(String path)方法访问 Web 应用中的资源的完整列表。</strong></p>
</li>
</ul>
<h1 id="多主机和-servlet-上下文"><a class="header" href="#多主机和-servlet-上下文">多主机和 Servlet 上下文</a></h1>
<p>ServletContext 接口的 getVirtualServerName 方法允许访问 ServletContext 部署在的逻辑主机的配置名字。该
方法必须对所有部署在逻辑主机上的所有 servlet context 返回同一个名字。且该方法返回的名字必须是明确
的、每个逻辑主机稳定的、和适合用于关联服务器配置信息和逻辑主机</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tomcat编程式启动"><a class="header" href="#tomcat编程式启动">tomcat编程式启动</a></h1>
<h2 id="引入-tomcat内置库"><a class="header" href="#引入-tomcat内置库">引入 tomcat内置库</a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
            &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;
            &lt;version&gt;8.5.35&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
        &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
        &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
        &lt;version&gt;8.5.35&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="调用main方法"><a class="header" href="#调用main方法">调用Main方法</a></h2>
<pre><code class="language-java">public class MainApplication {
    public static void main(String[] args) throws LifecycleException {
        Tomcat tomcat = new Tomcat();
        tomcat.setPort(8080);
        tomcat.addWebapp(&quot;/&quot;,&quot;D://tomcat/&quot;);
        tomcat.start();
        tomcat.getServer().await();
    }
}
</code></pre>
<h2 id="初始化其他"><a class="header" href="#初始化其他">初始化其他</a></h2>
<h2 id="spi接口-1"><a class="header" href="#spi接口-1">SPI接口</a></h2>
<p><strong>接口</strong></p>
<p><em>javax.servlet.ServletContainerInitializer</em></p>
<p>tomcat容器启动时，使用  <em>SPI</em> 机制 调用 其所有实现类，并执行 <em>onStartup</em> 方法</p>
<pre><code>public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)
</code></pre>
<h2 id="注解-1"><a class="header" href="#注解-1"><strong>注解</strong></a></h2>
<pre><code>@HandlesTypes(WebApplicationInitializer.class)
</code></pre>
<p>会获取该接口的所有实现类 并再调用 <em>onStartUp</em> 时 传递给客户端</p>
<h1 id="示例-9"><a class="header" href="#示例-9">示例</a></h1>
<blockquote>
<p>org.springframework.web.SpringServletContainerInitializer</p>
</blockquote>
<p>这是springMVC启动时的加载类</p>
<pre><code class="language-java">	public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)
			throws ServletException {

		List&lt;WebApplicationInitializer&gt; initializers = Collections.emptyList();
		//实例化所有WebApplicationInitializer
		if (webAppInitializerClasses != null) {
			initializers = new ArrayList&lt;&gt;(webAppInitializerClasses.size());
			for (Class&lt;?&gt; waiClass : webAppInitializerClasses) {
				// Be defensive: Some servlet containers provide us with invalid classes,
				// no matter what @HandlesTypes says...
				if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;
						WebApplicationInitializer.class.isAssignableFrom(waiClass)) {
					try {
						initializers.add((WebApplicationInitializer)
								ReflectionUtils.accessibleConstructor(waiClass).newInstance());
					}
					catch (Throwable ex) {
						throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);
					}
				}
			}
		}

		if (initializers.isEmpty()) {
			servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);
			return;
		}

		servletContext.log(initializers.size() + &quot; Spring WebApplicationInitializers detected on classpath&quot;);
		AnnotationAwareOrderComparator.sort(initializers);
		for (WebApplicationInitializer initializer : initializers) {
			initializer.onStartup(servletContext);
		}
	}
</code></pre>
<p>然后配置SPI 的 service</p>
<p><img src="24.Servlet%E8%A7%84%E8%8C%83//images/spring-web-spi-metainfo.png" alt="" /></p>
<p><strong>文件内容为</strong></p>
<pre><code>org.springframework.web.SpringServletContainerInitializer
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="会话"><a class="header" href="#会话">会话</a></h1>
<blockquote>
<p>超文本传输协议（HTTP）被设计为一种无状态协议。为构建有效的 Web 应用，必须与来自一个特定的客户端的请求彼此是相互关联。随时间的推移，演变了许多会话跟踪机制，这些机制直接使用对程序员而言是困难或麻烦的。</p>
</blockquote>
<p>该规范定义了一个简单的 HttpSession 接口，允许 servlet 容器使用几种方法来跟踪用户会话，而不会使应用开发人员陷入到这些方法的细节中。</p>
<h1 id="会话跟踪机制"><a class="header" href="#会话跟踪机制">会话跟踪机制</a></h1>
<h2 id="cookies-1"><a class="header" href="#cookies-1">Cookies</a></h2>
<ul>
<li>
<p>通过 HTTP cookie 的会话跟踪是最常用的会话跟踪机制，且所有 servlet 容器都应该支持</p>
</li>
<li>
<p>容器向客户端发送一个 cookie，客户端后续到服务器的请求都将返回该 cookie，明确地将请求与会话关联。会话跟踪 cookie 的标准名字必须是 JSESSIONID，所有 3.0 兼容的容器必须支持。容器也允许通过容器指定的配置自定义会话跟踪 cookie 的名字</p>
<p>见 <em>SessionCookieConfig</em></p>
</li>
<li>
<p>所有 servlet 容器必须提供能够配置容器是否标记会话跟踪 cookie 为 HttpOnly</p>
</li>
<li>
<p>如果 web 应用为其会话跟踪 cookie 配置了一个自定义的名字，则如果会话 id 编码到 URL 中那么相同的自定义名字也将用于 URI 参数的名字（假如 URL 重写已开启）。</p>
</li>
</ul>
<h2 id="ssl-会话"><a class="header" href="#ssl-会话">SSL 会话</a></h2>
<p>安全套接字层，在 HTTPS 使用的加密技术，有一种内置机制允许多个来自客户端的请求被明确识别为同一会话。Servlet 容器可以很容易地使用该数据来定义会话。</p>
<h1 id="url-重写-1"><a class="header" href="#url-重写-1">URL 重写</a></h1>
<p>URL 重写是会话跟踪的最低标准。当客户端不接受 cookie 时，服务器可使用 URL 重写作为会话跟踪的基
础。URL 重写涉及添加数据、会话 ID、容器解析 URL 路径从而请求与会话相关联。
会话 ID 必须被编码为 URL 字符串中的一个路径参数。参数的名字必须是 jsessionid。下面是一个 URL 包
含编码的路径信息的例子：</p>
<pre><code>http://www.myserver.com/catalog/index.html;jsessionid=1234
</code></pre>
<p>URL 重写在日志、书签、referer header、缓存的 HTML、URL 工具条中暴露会话标识。在支持 cookie 或 SSL
会话的情况下，不应该使用 URL 重写作为会话跟踪机制。</p>
<p>URL 重写在日志、书签、referer header、缓存的 HTML、URL 工具条中暴露会话标识。在支持 cookie 或 SSL
会话的情况下，不应该使用 URL 重写作为会话跟踪机制。</p>
<h2 id="创建会话"><a class="header" href="#创建会话">创建会话</a></h2>
<p>如果以下之一是 true，会话被认为是“新”的：
■ 客户端还不知道会话
■ 客户端选择不加入会话。</p>
<p>直到客户端“加入”到 HTTP 会话之前它都被认为是新的</p>
<p>与每个会话相关联是一个包含唯一标识符的字符串，也被称为会话 ID。会话 ID 的值能通过调用
<em>javax.servlet.http.HttpSession.getId()</em> 获 取 ， 且 能 在 创 建 后 通 过 调 用
*javax.servlet.http.HttpServletRequest.changeSessionId()*改变</p>
<h1 id="会话范围"><a class="header" href="#会话范围">会话范围</a></h1>
<p>HttpSession 对象必须被限定在应用（或 servlet 上下文）级别。底层的机制，如使用 cookie 建立会话，不同的上下文可以是相同，但所引用的对象，包括包括该对象中的属性，决不能在容器上下文之间共享。
用一个例子来说明该要求： 如果 servlet 使用 RequestDispatcher 来调用另一个 Web 应用的 servlet，任何创建的会话和被调用 servlet 所见的必须不同于来自调用会话所见的。
此外，一个上下文的会话在请求进入那个上下文时必须是可恢复的，不管是直接访问它们关联的上下文还
是在请求目标分派时创建的会话。</p>
<h1 id="绑定-session-属性"><a class="header" href="#绑定-session-属性">绑定 Session 属性</a></h1>
<p>servlet 可以按名称绑定对象属性到 HttpSession 实现，任何绑定到会话的对象可用于任意其他的 Servlet，其
属于同一个 ServletContext 且处理属于相同会话中的请求。
一 些 对 象 可 能 需 要 在 它 们 被 放 进 会 话 或 从 会 话 中 移 除 时 得 到 通 知 。 这 些 信 息 可 以 从
HttpSessionBindingListener 接口实现的对象中获取。这个接口定义了以下方法，用于标识一个对象被绑定到
会话或从会话解除绑定时。
■ valueBound
■ valueUnbound
在对象对 HttpSession 接口的 getAttribute 方法可用之前 valueBound 方法必须被调用。在对象对 HttpSession
接口的 getAttribute 方法不可用之后 valueUnbound 方法必须被调用。</p>
<h1 id="会话超时"><a class="header" href="#会话超时">会话超时</a></h1>
<p>在 HTTP 协议中，当客户端不再处于活动状态时没有显示的终止信号。这意味着当客户端不再处于活跃状
态时可以使用的唯一机制是超时时间。
Servlet 容器定义了默认的会话超时时间，且可以通过 HttpSession 接口的 getMaxInactiveInterval 方法获取。
开发人员可以使用 HttpSession 接口的 setMaxInactiveInterval 方法改变超时时间。这些方法的超时时间以秒
为单位。根据定义，如果超时时间设置为 0 或更小的值，会话将永不过期。会话不会生效，直到所有 servlet
使用的会话已经退出其 service 方法。一旦会话已失效,新的请求必须不能看到该会话。</p>
<h1 id="最后访问时间"><a class="header" href="#最后访问时间">最后访问时间</a></h1>
<p>HttpSession 接口的 getLastAccessedTime 方法允许 servlet 确定在当前请求之前的会话的最后访问时间。当会
话中的请求是 servlet 容器第一个处理的时该会话被认为是访问了</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="servlet-是什么"><a class="header" href="#servlet-是什么">Servlet 是什么？</a></h1>
<p>Servlet（Server Applet），全称Java Servlet，未有中文译文。是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</p>
<p>Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p>
<h1 id="servlet由来"><a class="header" href="#servlet由来">Servlet由来</a></h1>
<p><strong>java appplet客户端运行程序</strong></p>
<p>Servlet 是在服务器上运行的小程序。这个词是在 Java applet的环境中创造的，Java applet 是一种当作单独文件跟网页一起发送的小程序，它通常用于在客户端运行，结果得到为用户进行运算或者根据用户互作用定位图形等服务。</p>
<p><strong>CGI服务端运行程序</strong></p>
<p>服务器上需要一些程序，常常是根据用户输入访问数据库的程序。这些通常是使用公共网关接口（Common Gateway Interface，CGI）应用程序完成的。然而，在服务器上运行 Java，这种程序可使用 Java 编程语言实现。在通信量大的服务器上，JavaServlet 的优点在于它们的执行速度更快于 CGI 程序。各个用户请求被激活成单个程序中的一个线程，而无需创建单独的进程，这意味着服务器端处理请求的系统开销将明显降低。</p>
<p><strong>实现过程</strong></p>
<p>最早支持 Servlet 技术的是 JavaSoft 的 Java Web Server。此后，一些其它的基于 Java 的 Web Server 开始支持标准的 Servlet API。Servlet 的主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。这个过程为：</p>
<ol>
<li>客户端发送请求至服务器端；</li>
<li>服务器将请求信息发送至 Servlet；</li>
<li>Servlet 生成响应内容并将其传给服务器。响应内容动态生成，通常取决于客户端的请求；</li>
<li>服务器将响应返回给客户端。</li>
</ol>
<p>一个 Servlet 就是 Java 编程语言中的一个类，它被用来扩展服务器的性能，服务器上驻留着可以通过“请求-响应”编程模型来访问的应用程序。虽然 Servlet 可以对任何类型的请求产生响应，但通常只用来扩展 Web 服务器的应用程序。
目前最新版本为 4.0。</p>
<h1 id="servlet命名"><a class="header" href="#servlet命名">Servlet命名</a></h1>
<p>Servlet 的命名可以看出 sun 命名的特点，如 Applet 表示小应用程序；Scriptlet = Script + Applet，表示小脚本程序；同样 Servlet = Service + Applet，表示小服务程序。</p>
<h1 id="servlet-包"><a class="header" href="#servlet-包">Servlet 包</a></h1>
<p>Servlet 可以使用 <strong>javax.servlet</strong> 和 <strong>javax.servlet.http</strong> 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。</p>
<h1 id="servlet-环境设置"><a class="header" href="#servlet-环境设置">Servlet 环境设置</a></h1>
<h2 id="设置-web-服务器tomcat"><a class="header" href="#设置-web-服务器tomcat">设置 Web 服务器：Tomcat</a></h2>
<p><strong>省略</strong></p>
<h2 id="设置-classpath"><a class="header" href="#设置-classpath">设置 CLASSPATH</a></h2>
<p>由于 Servlet 不是 Java 平台标准版的组成部分，所以您必须为编译器指定 Servlet 类的路径。</p>
<pre><code>setenv CATALINA=/usr/local/apache-tomcat-5.5.29
setenv CLASSPATH $CATALINA/common/lib/servlet-api.jar:$CLASSPATH
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="注解-2"><a class="header" href="#注解-2">注解</a></h1>
<blockquote>
<p><em>metadata-complete</em> 属性标识 是否应该在部署时检查jar文件的类文件，以查找注解和web片段</p>
</blockquote>
<p><em>@WebServlet</em></p>
<ul>
<li>该注解在一个类上指定并包含声明 Servlet 的元数据。</li>
<li>如果没有指定 Servlet 名字则默认是全限定类名。</li>
<li>被注解的 sevlet必须指定至少一个 url 模式进行部署。</li>
<li>如果同一个 Servlet 类以不同的名字声明在部署描述符中，必须实例
化一个新的 Servlet 实例。</li>
</ul>
<p><em>@WebFilter</em></p>
<p>注解的 urlPatterns 属性, servletNames 属性 或 value 属性必须被指</p>
<p><em>@WebInitParam</em></p>
<p>指定必须传递到 Servlet 或 Filter 的任何初始化参数。它是 WebServlet 和 WebFilter 注解的一个属性。</p>
<p><em>@WebListener</em></p>
<pre><code>■ javax.servlet.ServletContextListener
■ javax.servlet.ServletContextAttributeListener
■ javax.servlet.ServletRequestListener
■ javax.servlet.ServletRequestAttributeListener
■ javax.servlet.http.HttpSessionListener
■ javax.servlet.http.HttpSessionAttributeListener
■ javax.servlet.http.HttpSessionIdListener
</code></pre>
<p><em>@MultipartConfig</em></p>
<p>表示请求期望是 mime/multipart 类型</p>
<p>默认的 <em>welcome-file-list</em> 有  <em>index.html  index.jsp</em></p>
<h1 id="web-fragment"><a class="header" href="#web-fragment">web fragment</a></h1>
<ul>
<li>
<p>webfragment 是 web应用部署描述符的 一个逻辑分区,使用跟 web.xml一致,除了 根元素改为 <em>web-fragment</em>, 文件名改为 <em>web-fragment.xml.</em></p>
</li>
<li>
<p>如果一个jar包 需要带有 <em>web-fragment.xml.</em> 则应放在 jar下 <em>meta-inf</em>/ 目录</p>
</li>
<li>
<p>示例</p>
<pre><code class="language-xml">&lt;web-fragment&gt;
&lt;servlet&gt;
&lt;servlet-name&gt;welcome&lt;/servlet-name&gt;
&lt;servlet-class&gt;
WelcomeServlet
&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;listener&gt;
&lt;listener-class&gt;
RequestListener
&lt;/listener-class&gt;
&lt;/listener&gt;
&lt;/web-fragment&gt;
</code></pre>
</li>
</ul>
<h1 id="webxml-和-和-web-fragmentxml-顺序"><a class="header" href="#webxml-和-和-web-fragmentxml-顺序">web.xml 和 和 web-fragment.xml 顺序</a></h1>
<h2 id="绝对顺序"><a class="header" href="#绝对顺序">绝对顺序</a></h2>
<p><strong>absolute-ordering</strong></p>
<blockquote>
<p>在 web.xml 中的<absolute-ordering>元素。在一个 web.xml 中仅能有一个<absolute-ordering>
元素。</p>
</blockquote>
<p>相对顺序 必须被忽略</p>
<pre><code class="language-xml">&lt;web-app&gt;
&lt;absolute-ordering&gt;
&lt;name&gt;MyFragment3&lt;/name&gt;
&lt;name&gt;MyFragment2&lt;/name&gt;
&lt;/absolute-ordering&gt;
...
&lt;/web-app&gt;
</code></pre>
<h2 id="相对顺序"><a class="header" href="#相对顺序">相对顺序</a></h2>
<blockquote>
<p>在 web-fragment.xml 中的<ordering>元素，一个 web-fragment.xml 只能有一个<ordering>元素</p>
</blockquote>
<pre><code class="language-xml">web-fragment.xml
&lt;web-fragment&gt;
&lt;name&gt;MyFragment1&lt;/name&gt;
&lt;ordering&gt;&lt;after&gt;&lt;name&gt;MyFragment2&lt;/name&gt;&lt;/after&gt;&lt;/ordering&gt;
...
&lt;/web-fragment&gt;

&lt;before&gt;
&lt;others/&gt;
&lt;name&gt;
B
&lt;/name&gt;
&lt;/before&gt;

&lt;after&gt;
&lt;others/&gt;
&lt;/after&gt;
&lt;before&gt;
&lt;name&gt;
C
&lt;/name&gt;
&lt;/before&gt;
</code></pre>
<h1 id="装配-webxmlweb-fragmentxml-描述符和注解"><a class="header" href="#装配-webxmlweb-fragmentxml-描述符和注解">装配 web.xmlweb-fragment.xml 描述符和注解</a></h1>
<ol>
<li>如果有关的 Listener、Servlet 和 Filter 的顺序必须指定，那么必须指定在 web-fragment.xml 或 web.xml。</li>
<li>顺序将依据它们定义在描述符中的顺序，和依赖于 web.xml 中的 absolute-ordering 元素或
web-fragment.xml 中的 ordering 元素，如果存在。
a. 匹配请求的过滤器链的顺序是它们在 web.xml 中声明的顺序。
b. Servlet 在请求处理时实例化或在部署时立即实例化。在后一种情况，以它们的 load-on-startup 元素
表示的顺序实例化。
c. 在之前发布的规范，上下文 Listener 以随机顺序调用。在 Servlet3.0，Listener 以它们在 web.xml 中
声明的顺序调用，如下所示：
i. javax.servlet.ServletContextListener 实 现 的 contextInitialized 方 法 以 声 明 时 顺 序 调 用 ，
contextDestroyed 以相反顺序调用。
ii. javax.servlet.ServletRequestListener 实 现 的 requestInitialized 以 声 明 时 顺 序 调 用 ，
64
requestDestroyed 方法以相反顺序调用。
iii. javax.servlet.http.HttpSessionListener 实 现 的 sessionCreated 方 法 以 声 明 时 顺 序 调 用 ，
sessionDestroyed 方法以相反顺序调用。
iv. 当 相 应 的 事 件 触 发 时 ， javax.servlet.ServletContextAttributeListener 、
javax.servlet.ServletRequestAttributeListener和javax.servlet.HttpSessionAttributeListener 的方法按照
它们声明的顺序调用。</li>
<li>如果在 web.xml 使用 enabled 元素禁用引入的 servlet，那么该 servlet 将不可以指定 url-pattern。</li>
<li>当在 web.xml、web-fragment.xml 和 注解之间解析发生冲突时 web 应用的 web.xml 具有最高优先级。</li>
<li>如果没有在描述符中指定 metadata-complete 或在部署描述符中设置为 false，通过组合出现在注解和描
述符中的 metadata 导出有效的 metadata。合并的规则具体如下：
a. 在 web fragment 中的配置设置用于扩充那些已指定在主 web.xml 的配置设置，使用这种方式就好像
它们指定在同一个 web.xml。
b. 添加到主 web.xml 的 web fragment 中的配置设置的顺序由 8-70 页的 8.2.2 节“web.xml 和
web-fragment.xml 顺序”指定。
c. 当主 web.xml 的 metadata-complete 属性设置为 true，被认为是完整的且在部署时不会扫描注解和
fragment。如果有 absolute-ordering 和 ordering 元素将被忽略。当设置 fragment 上的为 true 时，
metadata-complete 属性仅适用于在特定的 jar 包中扫描注解。
d. 除非 metadata-complete 设置为 true，否则 web fragment 被合并到主 web.xml。合并发生在相关
fragment 的注解处理之后。
e. 当使用 web fragment 扩充 web.xml 时以下被认为配置冲突：
i. 多个<init-param>元素使用相同的<param-name>但不同的<param-value>
ii. 多个<mime-mapping>元素使用相同的<extension>但不同的<mime-type>
f. 上面的配置冲突被解析为如下：
i. 在主 web.xml 和 web fragment 之间的配置冲突被解析为在 web.xml 的配置具有高优先级。
ii. 在两个 web fragment 之间的配置冲突，冲突的中心元素没有出现在主 web.xml，将导致一个错
误。必须记录一个有用的消息，且应用必须部署失败。
g. 上面的冲突被解析后，这些额外的规则适用：
i. 可以在多个 web-frament 中声明任意多次元素并生成到 web.xml。比如，<context-param>元素可
以以不同的名字添加。
ii. 如果指定在web.xml中的覆盖了指定在web-fragment中的同名的值，则可以声明任意多次元素。
iii. 如果是最少出现零次且最多出现一次的元素存在于 web fragment，且没有在主 web.xml 中，则
主 web.xml 继承 web fragment 的设置。如果元素出现在主 web.xml 和 web fragment，则主 web.xml
的配置设置具有高优先级。例如，如果在主 web.xml 和 web fragment 中都声明了相同的 servlet，
且声明在 web fragment 中的 servlet 指定了<load-on-startup>元素，且没在主 web.xml 指定，则 web
fragment 的<load-on-startup>元素将被使用并合并到 web.xml。
iv. 如果是最少出现零次且最多出现一次的元素指定在两个 web fragment，且没有出现在主
65
web.xml，则认为是错误的。例如，如果两个 web fragment 声明了相同的 Servlet，但具有不同的
<load-on-startup>元素，且相同的 Servlet 也声明在主 web.xml，但没有<load-on-startup>，则必须报
告一个错误。
v. <welcome-file>声明是可添加的。
vi. 具有相同<servlet-name>的<servlet-mapping>元素可以添加到多个 web-fragment。在 web.xml 中
指定的<servlet-mapping>覆盖在 web-fragment 中指定的同名的<servlet-name>的<servlet-mapping>。
vii. 具有相同<filter-name>的<filter-mapping>元素可以添加到多个 web-fragment。在 web.xml 中指
定的<filter-mapping>覆盖在 web-fragment 中指定的同名的<filter-name>的<filter-mapping>。
viii. 具有相同<listener-class>的多个<listener>元素被当作一个<listener>声明。
ix. 合并产生的 web.xml 被认为是<distributable>，仅当所有它的 web fragment 也被标记为
<distributable>。
x. web fragment 的顶级<icon>和它的孩子元素，<display-name>，和<description>元素被忽略。
xi. jsp-property-group 是可添加的。当绑定静态资源到 jar 包的 META-INF/resources 目录，推荐
jsp-config 元素使用 url-pattern，反对使用 extension 映射。此外，如果存在一个 fragment 的 JSP 资
源，则应该在一个与 fragment 同名的子目录中。这有助于防止一个 web-fragment 的
jsp-property-group 受到来自应用的主 docroot 中的 JSP 的影响和受到来自一个 fragment 的
META-INF/resources 的 JSP 的影响。
h. 对于所有资源引用元素 (env-entry, ejb-ref, ejb-local-ref, service-ref, resource-ref, resource-env-ref,
message-destination-ref, persistence-context-ref and persistence-unit-ref) 如下规则适用：
i. 如果任意资源引用元素出现在 web fragment，主 web.xml 继承 web fragment 的值。 如果该元素
同时出现在主 web.xml 和 web fragment，使用相同的名字，web.xml 具有高优先级。所有 fragment
的子元素除下面指定的 injection-target 被合并到主 web.xml。例如，如果主 web.xml 和 web fragment
都使用相同的<resource-ref-name>声明一个<resource-ref>，将使用 web.xml 中的<resource-ref>且不
会合并 fragment 中的任意子元素除下面声明的<injection-target>。
ii. 如果资源引用元素指定在两个 fragment，当没有指定在主 web.xml 中，且资源引用元素的所有
属性和子元素都是一样的，资源引用将被合并到主 web.xml。如果使用相同名字在两个 fragment
中指定资源引用元素，且没有在 web.xml 中指定，属性和子元素是不一样的，那么被认为是错误
的。错误必须被报告且应用必须部署失败。例如，如果两个 web fragment 使用相同的
<resource-ref-name>声明了<resource-ref>但类型一个指定为 javax.sql.DataSource 另一个指定为
JavaMail，这是错误的且应用必须部署失败。
iii. 对于在 fragment 中使用相同名称的<injection-target> 的资源引用元素将被合并到主 web.xml。
i. 除了上面定义的 web-fragment.xml 的合并规则之外，下面的规则适用于使用资源引用注解
(@Resource, @Resources, @EJB, @EJBs, @WebServiceRef, @WebServiceRefs, @PersistenceContext,
@PersistenceContexts,@PersistenceUnit, and @PersistenceUnits)。
如果资源引用注解应用到类上，这等价于定义了一个资源，但是这不等价于定义一个
injection-target。在这种情况下上述规则适用于 injection-target 元素。
如果在字段上使用资源引用注解，这等价于在 web.xml 定义 injection-target 元素。但是如果在描述
符中没有injection-target元素，那么fragment中的injection-target仍将被合并到上面定义的web.xml。
66
如果从另一方面来说，在主 web.xml 中有一个 injection-target 并同时有一个同资源名的资源引用注
解，那么这被认为是对资源引用注解的覆盖。在这种情况下，由于在描述符中指定了一个
injection-target，上述定义的规则将适用于除了覆盖的资源引用注解。
j. 如果在两个 fragment 中指定了 data-source 元素，而没有出现在主 web.xml，且 data-source 元素的所有属
性和子元素都是一样的，data-source 将被合并到主 web.xml。如果在两个 fragment 中指定同名的 data-source
元素，而没有出现在主 web.xml 且两个 fragment 的属性和子元素不是一样的，这被认为是错误的。在这种
情况下，必须报告一个错误且引用必须部署失败。</li>
</ol>
<h1 id="共享库--运行时可插拔性"><a class="header" href="#共享库--运行时可插拔性">共享库 / 运行时可插拔性</a></h1>
<p>除了支持 fragment 和使用注解的外，要求之一是我们不仅能 plug-in 绑定在 WEB-INF/lib 下的，也能 plugin
73
框架共享副本—包括能 plug-in 到容器的如建议在 web 容器之上的 JAX-WS、JAX-RS 和 JSF。
ServletContainerInitializer 允许处理这样的使用情况下，如下所述。
ServletContainerInitializer 类通过 jar services API 查找。对于每一个应用，应用启动时，由容器创建一个
ServletContainerInitializer 实 例 。 框 架 提 供 的 ServletContainerInitializer 实 现 必 须 绑 定 在 jar 包 的
META-INF/services 目录中的一个叫做 javax.servlet.ServletContainerInitializer 的文件，根据 jar services API，
指定 ServletContainerInitializer 的实现。
除 ServletContainerInitializer 外，我们还有一个注解—HandlesTypes。在 ServletContainerInitializer 实现上的
HandlesTypes 注解用于表示感兴趣的一些类，它们可能指定了 HandlesTypes 的 value 中的注解（类型、方
法或自动级别的注解），或者是其类型的超类继承/实现了这些类之一。无论是否设置了 metadata-complete，
HandlesTypes 注解将应用。
当检测一个应用的类看是否它们匹配 ServletContainerInitializer 的 HandlesTypes 指定的条件时，如果应用的
一个或多个可选的 JAR 包缺失，容器可能遇到类装载问题。由于容器不能决定是否这些类型的类装载失败
将阻止应用正常工作，它必须忽略它们，同时也提供一个将记录它们的配置选项。
如果 ServletContainerInitializer 实现没有@HandlesTypes 注解，或如果没有匹配任何指定的 HandlesType，那
么它会为每个应用使用 null 值的集合调用一次。这将允许 initializer 基于应用中可用的资源决定是否需要初
始化 Servlet/Filter。
在任何 Servlet Listener 的事件被触发之前，当应用正在启动时，ServletContainerInitializer 的 onStartup 方法
将被调用。
ServletContainerInitializer’s 的 onStartup 得到一个类的 Set，其或者继承/实现 initializer 表示感兴趣的类，或
者它是使用指定在@HandlesTypes 注解中的任意类注解的。
下面一个具体的例子展示了这是如何工作的。
让我们学习 JAX-WS web service 运行时。
JAX-WS 运行时实现通常不是绑定到每个 war 包。其实现将绑定一个 ServletContainerInitializer 的实现（如
下所示）且容器将查找使用的 services API（绑定在 jar 包中的 META-INF/services 目录中的一个叫做
javax.servlet.ServletContainerInitializer 的文件，它将指出如下所示的 JAXWSServletContainerInitializer）。
@HandlesTypes(WebService.class)
JAXWSServletContainerInitializer implements ServletContainerInitializer {
public void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx) throws ServletException {
// 在此，使用 JAX-WS 特定的代码来初始化运行库和设置 mapping 等。
ServletRegistration reg = ctx.addServlet(&quot;JAXWSServlet&quot;, &quot;com.sun.webservice.JAXWSServlet&quot;);
reg.addServletMapping(&quot;/foo&quot;);
}
}
框架的 jar 包也可能被绑定到 war 报目录中的 WEB-INF/lib 目录。如果 ServletContainerInitializer 被绑定到
应用的WEB-INF/lib目录内的一个JAR包中，它的onStartup方法在绑定到的应用启动期间将被仅调用一次。
如果，相反，ServletContainerInitialzer 被绑定到 WEB-INF/lib 目录外的一个 JAR 包中，但仍能被运行时的
服务提供商查找机制发现时，每次启动应用时，它的 onStartup 方法将被调用。
ServletContainerInitializer 接口的实现将被运行时的服务查找机制或语义上与它等价的容器特定机制发现。
在任一种情况，web fragment JAR 包的 ServletContainerInitializer 服务被排除于一个 absolute ordering 必须
74
被忽略，这些服务被发现的顺序必须遵照应用的类装载委托模型。</p>
<h1 id="jsp-容器可插拔性"><a class="header" href="#jsp-容器可插拔性">JSP 容器可插拔性</a></h1>
<p>ServletContainerInitializer 和编程式注册特性可以在 Servlet 和 JSP 容器之间提供一个清晰的职责分离，通过
由 Servlet 容器只负责解析 web.xml 和 web-fragment.xml 资源，而解析标签库描述符（TLD）资源委托给 JSP
容器。
在此之前，web 容器必须扫描 TLD 资源寻找任何 Listener 声明。使用 Servlet3.0 和后续版本后，该职责可
以委托给 JSP 容器。JSP 容器是内嵌到一个 Servlet3.0 兼容的 Servlet 容器中，可以提供它自己的
ServletContainerInitializer 实现，搜索传递到它的 onStartup 方法的 ServletContext 参数寻找任何 TLD 资源，
扫描这些资源寻找 Listener 声明，并向 ServletContext 注册相关的 Listener。
另外，Servlet3.0 之前，JSP 容器用于必须扫描应用的部署描述符寻找 jsp-config 相关的配置。使用 Servlet3.0
和后续版本后，Servlet 容器必须提供通过 ServletContext.getJspConfigDescriptor 方法得到应用的 web.xml 和
web-fragment.xml 部署描述符中的任何 jsp-config 相关的配置。
在 TLD 中发现的和编程注册的任何 ServletContextListener 在它们提供的功能上是有限的。任何试图调用一
个在 Servlet3.0 中加入的 ServletContext API 方法将导致一个 UnsupportedOperationException。
另外，Servlet3.0 和后续版本兼容的 Servlet 容器必须提供一个名字为 javax.servlet.context.orderedLibs 的
ServletContext 属性，它的值（java.util.List&lt;java.lang.String&gt;类型）包含了由 ServletContext 所代表的应用的
WEB-INF/lib 目录中的 JAR 文件的名字列表，按照它们的 web fragment 名字的排序（可能排除如果 fragment
JAR 包已经被排除在 absolute-ordering），或者 null 如果应用没有指定任意绝对或相对顺序</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>本文档的目标是为编写测试的程序员，扩展作者和引擎作者以及构建工具和IDE供应商提供全面的参考文档。</p>
<h2 id="what-is-junit-5"><a class="header" href="#what-is-junit-5">What is JUnit 5?</a></h2>
<p>与以前的Junit版本不同，JUnit 5由来自三个不同子项目的几个不同模块组成。</p>
<p><strong>JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage</strong></p>
<p><strong>JUnit Platform</strong> </p>
<ul>
<li>The <strong>JUnit Platform</strong> serves as a foundation for <a href="https://junit.org/junit5/docs/current/user-guide/#launcher-api">launching testing frameworks</a> on the JVM.</li>
<li>It also defines the <code>TestEngine</code> API for developing a testing framework that runs on the platform. </li>
<li>Furthermore, the platform provides a <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-console-launcher">Console Launcher</a> to launch the platform from the command line and the <a href="https://junit.org/junit5/docs/current/user-guide/#junit-platform-suite-engine">JUnit Platform Suite Engine</a> for running a custom test suite using one or more test engines on the platform. </li>
<li>First-class support for the JUnit Platform also exists in popular IDEs (see <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-ide-intellij-idea">IntelliJ IDEA</a>, <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-ide-eclipse">Eclipse</a>, <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-ide-netbeans">NetBeans</a>, and <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-ide-vscode">Visual Studio Code</a>) and build tools (see <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-build-gradle">Gradle</a>, <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-build-maven">Maven</a>, and <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-build-ant">Ant</a>).</li>
</ul>
<p><strong>JUnit Jupiter</strong></p>
<p>JUnit Jupiter is the combination of the new <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests">programming model</a> and <a href="https://junit.org/junit5/docs/current/user-guide/#extensions">extension model</a> for writing tests and extensions in JUnit 5. The Jupiter sub-project provides a <code>TestEngine</code> for running Jupiter based tests on the platform.</p>
<p><strong>JUnit Vintage</strong></p>
<p><strong>JUnit Vintage</strong> provides a <code>TestEngine</code> for running JUnit 3 and JUnit 4 based tests on the platform. It requires JUnit 4.12 or later to be present on the class path or module path.</p>
<h3 id="supported-java-versions"><a class="header" href="#supported-java-versions">Supported Java Versions</a></h3>
<p>JUnit 5 requires Java 8 (or higher) at runtime. However, you can still test code that has been compiled with previous versions of the JDK.</p>
<h3 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h3>
<p>Ask JUnit 5 related questions on <a href="https://stackoverflow.com/questions/tagged/junit5">Stack Overflow</a> or chat with the community on <a href="https://gitter.im/junit-team/junit5">Gitter</a>.</p>
<h3 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h3>
<h4 id="downloading-junit-artifacts"><a class="header" href="#downloading-junit-artifacts">Downloading JUnit Artifacts</a></h4>
<p>To find out what artifacts are available for download and inclusion in your project, refer to <a href="https://junit.org/junit5/docs/current/user-guide/#dependency-metadata">Dependency Metadata</a>. To set up dependency management for your build, refer to <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-build">Build Support</a> and the <a href="https://junit.org/junit5/docs/current/user-guide/#overview-getting-started-example-projects">Example Projects</a>.</p>
<h4 id="junit-5-features"><a class="header" href="#junit-5-features">JUnit 5 Features</a></h4>
<p>To find out what features are available in JUnit 5 and how to use them, read the corresponding sections of this User Guide, organized by topic.</p>
<p>要了解JUnit 5中可用的功能以及如何使用它们，请阅读本用户指南的相应部分 (按主题组织)。</p>
<ul>
<li><a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests">Writing Tests in JUnit Jupiter</a></li>
<li><a href="https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4">Migrating from JUnit 4 to JUnit Jupiter</a></li>
<li><a href="https://junit.org/junit5/docs/current/user-guide/#running-tests">Running Tests</a></li>
<li><a href="https://junit.org/junit5/docs/current/user-guide/#extensions">Extension Model for JUnit Jupiter</a></li>
<li>Advanced Topics
<ul>
<li><a href="https://junit.org/junit5/docs/current/user-guide/#launcher-api">JUnit Platform Launcher API</a></li>
<li><a href="https://junit.org/junit5/docs/current/user-guide/#testkit">JUnit Platform Test Kit</a></li>
</ul>
</li>
</ul>
<h3 id="example-projects"><a class="header" href="#example-projects">Example Projects</a></h3>
<p>To see complete, working examples of projects that you can copy and experiment with, the <a href="https://github.com/junit-team/junit5-samples"><code>junit5-samples</code></a> repository is a good place to start. The <code>junit5-samples</code> repository hosts a collection of sample projects based on JUnit Jupiter, JUnit Vintage, and other testing frameworks. You’ll find appropriate build scripts (e.g., <code>build.gradle</code>, <code>pom.xml</code>, etc.) in the example projects. The links below highlight some of the combinations you can choose from.</p>
<ul>
<li>For Gradle and Java, check out the <code>junit5-jupiter-starter-gradle</code> project.</li>
<li>For Gradle and Kotlin, check out the <code>junit5-jupiter-starter-gradle-kotlin</code> project.</li>
<li>For Gradle and Groovy, check out the <code>junit5-jupiter-starter-gradle-groovy</code> project.</li>
<li>For Maven, check out the <code>junit5-jupiter-starter-maven</code> project.</li>
<li>For Ant, check out the <code>junit5-jupiter-starter-ant</code> project.</li>
</ul>
<h2 id="关于junit5"><a class="header" href="#关于junit5">关于JUnit5</a></h2>
<p>JUnit是常用的java单元测试框架，5是当前最新版本，其整体架构如下(图片来自网络)：</p>
<p><img src="21.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95_JUNIT5/../../images/junit_platform.png" alt="img" /></p>
<ul>
<li>从上图可见，整个Junit5可以划分成三层：顶层框架(Framework)、中间的引擎（Engine），底层的平台（Platform）；</li>
<li>官方定义Junit5由三部分组成：Platform、Jupiter、Vintage，功能如下；</li>
<li><strong>Platform</strong>：位于架构的最底层，是JVM上执行单元测试的基础平台，还对接了各种IDE（例如IDEA、eclipse），并且还与引擎层对接，定义了引擎层对接的API；</li>
<li><strong>Jupiter</strong>：位于引擎层，支持5版本的编程模型、扩展模型；</li>
<li><strong>Vintage</strong>：位于引擎层，用于执行低版本的测试用例；</li>
<li>可见整个Junit Platform是开放的，通过引擎API各种测试框架都可以接入；</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="下载安装"><a class="header" href="#下载安装">下载安装</a></h2>
<pre><code>https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console-standalone/1.8.2/junit-platform-console-standalone-1.8.2.jar
</code></pre>
<h2 id="启动与运行"><a class="header" href="#启动与运行">启动与运行</a></h2>
<p>ConsoleLauncher是一个命令行Java应用程序，可让您从控制台启动JUnit平台。例如，它可用于运行JUnit Vintage和JUnit Jupiter测试，并将测试执行结果打印到控制台。</p>
<p>包含所有依赖项的可执行junit-platform-console-standalone-1.8.2.jar将在junit-platform-console-standalone目录下的Maven中央存储库中发布。您可以运行独立的consoleauncher，如下所示。</p>
<pre><code>java -jar junit-platform-console-standalone-1.8.2.jar &lt;Options&gt;
</code></pre>
<p>Here’s an example of its output:</p>
<pre><code>├─ JUnit Vintage
│  └─ example.JUnit4Tests
│     └─ standardJUnit4Test ✔
└─ JUnit Jupiter
   ├─ StandardTests
   │  ├─ succeedingTest() ✔
   │  └─ skippedTest() ↷ for demonstration purposes
   └─ A special test case
      ├─ Custom test name containing spaces ✔
      ├─ ╯°□°)╯ ✔
      └─ 😱 ✔

Test run finished after 64 ms
[         5 containers found      ]
[         0 containers skipped    ]
[         5 containers started    ]
[         0 containers aborted    ]
[         5 containers successful ]
[         0 containers failed     ]
[         6 tests found           ]
[         1 tests skipped         ]
[         5 tests started         ]
[         0 tests aborted         ]
[         5 tests successful      ]
[         0 tests failed          ]
</code></pre>
<h3 id="exitcode"><a class="header" href="#exitcode">exitCode</a></h3>
<p>如果任何容器或测试失败，则consoleelauncher退出，状态代码为1。如果未发现任何测试，并且提供了 -- fail-If-no-tests命令行选项，则consoleauncher退出，状态代码为2。否则退出代码为0。</p>
<h2 id="options-1"><a class="header" href="#options-1">Options</a></h2>
<pre><code>Usage: ConsoleLauncher [-h] [--disable-ansi-colors] [--disable-banner]
                       [--fail-if-no-tests] [--scan-modules] [--scan-classpath[=PATH[;|:
                       PATH...]]]... [--details=MODE] [--details-theme=THEME]
                       [--reports-dir=DIR] [-c=CLASS]... [--config=KEY=VALUE]... [-cp=PATH
                       [;|:PATH...]]... [-d=DIR]... [-e=ID]... [-E=ID]...
                       [--exclude-package=PKG]... [-f=FILE]... [--include-package=PKG]...
                       [-m=NAME]... [-n=PATTERN]... [-N=PATTERN]... [-o=NAME]...
                       [-p=PKG]... [-r=RESOURCE]... [-t=TAG]... [-T=TAG]... [-u=URI]...
Launches the JUnit Platform from the console.
  -h, --help                 Display help information.
      --disable-ansi-colors  Disable ANSI colors in output (not supported by all
                               terminals).
      --disable-banner       Disable print out of the welcome message.
      --details=MODE         Select an output details mode for when tests are executed.
                               Use one of: none, summary, flat, tree, verbose. If 'none'
                               is selected, then only the summary and test failures are
                               shown. Default: tree.
      --details-theme=THEME  Select an output details tree theme for when tests are
                               executed. Use one of: ascii, unicode. Default: unicode.
      -cp, --classpath, --class-path=PATH[;|:PATH...]
                             Provide additional classpath entries -- for example, for
                               adding engines and their dependencies. This option can be
                               repeated.
      --fail-if-no-tests     Fail and return exit status code 2 if no tests are found.
      --reports-dir=DIR      Enable report output into a specified local directory (will
                               be created if it does not exist).
      --scan-modules         EXPERIMENTAL: Scan all resolved modules for test discovery.
  -o, --select-module=NAME   EXPERIMENTAL: Select single module for test discovery. This
                               option can be repeated.
      --scan-classpath, --scan-class-path[=PATH[;|:PATH...]]
                             Scan all directories on the classpath or explicit classpath
                               roots. Without arguments, only directories on the system
                               classpath as well as additional classpath entries supplied
                               via -cp (directories and JAR files) are scanned. Explicit
                               classpath roots that are not on the classpath will be
                               silently ignored. This option can be repeated.
  -u, --select-uri=URI       Select a URI for test discovery. This option can be repeated.
  -f, --select-file=FILE     Select a file for test discovery. This option can be
                               repeated.
  -d, --select-directory=DIR Select a directory for test discovery. This option can be
                               repeated.
  -p, --select-package=PKG   Select a package for test discovery. This option can be
                               repeated.
  -c, --select-class=CLASS   Select a class for test discovery. This option can be
                               repeated.
  -m, --select-method=NAME   Select a method for test discovery. This option can be
                               repeated.
  -r, --select-resource=RESOURCE
                             Select a classpath resource for test discovery. This option
                               can be repeated.
  -n, --include-classname=PATTERN
                             Provide a regular expression to include only classes whose
                               fully qualified names match. To avoid loading classes
                               unnecessarily, the default pattern only includes class
                               names that begin with &quot;Test&quot; or end with &quot;Test&quot; or
                               &quot;Tests&quot;. When this option is repeated, all patterns will
                               be combined using OR semantics. Default: [^(Test.*|.+[.$]
                               Test.*|.*Tests?)$]
  -N, --exclude-classname=PATTERN
                             Provide a regular expression to exclude those classes whose
                               fully qualified names match. When this option is repeated,
                               all patterns will be combined using OR semantics.
      --include-package=PKG  Provide a package to be included in the test run. This
                               option can be repeated.
      --exclude-package=PKG  Provide a package to be excluded from the test run. This
                               option can be repeated.
  -t, --include-tag=TAG      Provide a tag or tag expression to include only tests whose
                               tags match. When this option is repeated, all patterns
                               will be combined using OR semantics.
  -T, --exclude-tag=TAG      Provide a tag or tag expression to exclude those tests whose
                               tags match. When this option is repeated, all patterns
                               will be combined using OR semantics.
  -e, --include-engine=ID    Provide the ID of an engine to be included in the test run.
                               This option can be repeated.
  -E, --exclude-engine=ID    Provide the ID of an engine to be excluded from the test
                               run. This option can be repeated.
      --config=KEY=VALUE     Set a configuration parameter for test discovery and
                               execution. This option can be repeated.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependency-metadata"><a class="header" href="#dependency-metadata">Dependency Metadata</a></h1>
<p>Artifacts for final releases and milestones are deployed to <a href="https://search.maven.org/">Maven Central</a>, and snapshot artifacts are deployed to Sonatype’s <a href="https://oss.sonatype.org/content/repositories/snapshots">snapshots repository</a> under <a href="https://oss.sonatype.org/content/repositories/snapshots/org/junit/">/org/junit</a>.</p>
<h2 id="junit-platform"><a class="header" href="#junit-platform">JUnit Platform</a></h2>
<ul>
<li><strong>Group ID</strong>: <code>org.junit.platform</code></li>
<li><strong>Version</strong>: <code>1.8.2</code></li>
<li><strong>Artifact IDs</strong>:</li>
</ul>
<h3 id="junit-platform-commons"><a class="header" href="#junit-platform-commons">junit-platform-commons</a></h3>
<p>为 <em>JUnit Platform</em>  提供通用api和工具。用  <code>@API(status = INTERNAL)</code>   注释的任何API仅用于JUnit框架本身。不支持外部方对内部api的任何使用!</p>
<h3 id="junit-platform-console"><a class="header" href="#junit-platform-console">junit-platform-console</a></h3>
<p>Support for discovering and executing tests on the JUnit Platform from the console. See <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-console-launcher">Console Launcher</a> for details.</p>
<h3 id="junit-platform-console-standalone"><a class="header" href="#junit-platform-console-standalone">junit-platform-console-standalone</a></h3>
<p>An executable JAR with all dependencies included is provided in Maven Central under the <a href="https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console-standalone">junit-platform-console-standalone</a> directory. See <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-console-launcher">Console Launcher</a> for details.</p>
<h3 id="junit-platform-engine"><a class="header" href="#junit-platform-engine">junit-platform-engine</a></h3>
<p>Public API for test engines. See <a href="https://junit.org/junit5/docs/current/user-guide/#launcher-api-engines-custom">Registering a TestEngine</a> for details.</p>
<h3 id="junit-platform-jfr"><a class="header" href="#junit-platform-jfr">junit-platform-jfr</a></h3>
<p>Provides a <code>LauncherDiscoveryListener</code> and <code>TestExecutionListener</code> for Java Flight Recorder events on the JUnit Platform. See <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-listeners-flight-recorder">Flight Recorder Support</a> for details.</p>
<h3 id="junit-platform-launcher"><a class="header" href="#junit-platform-launcher">junit-platform-launcher</a></h3>
<p>Public API for configuring and launching test plans — typically used by IDEs and build tools. See <a href="https://junit.org/junit5/docs/current/user-guide/#launcher-api">JUnit Platform Launcher API</a> for details.</p>
<h3 id="junit-platform-reporting"><a class="header" href="#junit-platform-reporting">junit-platform-reporting</a></h3>
<p><code>TestExecutionListener</code> implementations that generate test reports — typically used by IDEs and build tools. See <a href="https://junit.org/junit5/docs/current/user-guide/#junit-platform-reporting">JUnit Platform Reporting</a> for details.</p>
<h3 id="junit-platform-runner"><a class="header" href="#junit-platform-runner">junit-platform-runner</a></h3>
<p>Runner for executing tests and test suites on the JUnit Platform in a JUnit 4 environment. See <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-junit-platform-runner">Using JUnit 4 to run the JUnit Platform</a> for details.</p>
<h3 id="junit-platform-suite"><a class="header" href="#junit-platform-suite">junit-platform-suite</a></h3>
<p>JUnit Platform Suite artifact that transitively pulls in dependencies on <code>junit-platform-suite-api</code> and <code>junit-platform-suite-engine</code> for simplified dependency management in build tools such as Gradle and Maven.</p>
<h3 id="junit-platform-suite-api"><a class="header" href="#junit-platform-suite-api">junit-platform-suite-api</a></h3>
<p>Annotations for configuring test suites on the JUnit Platform. Supported by the <a href="https://junit.org/junit5/docs/current/user-guide/#junit-platform-suite-engine">JUnit Platform Suite Engine</a> and the <a href="https://junit.org/junit5/docs/current/user-guide/#running-tests-junit-platform-runner">JUnitPlatform runner</a>.</p>
<h3 id="junit-platform-suite-commons"><a class="header" href="#junit-platform-suite-commons">junit-platform-suite-commons</a></h3>
<p>Common support utilities for executing test suites on the JUnit Platform.</p>
<h3 id="junit-platform-suite-engine"><a class="header" href="#junit-platform-suite-engine">junit-platform-suite-engine</a></h3>
<p>Engine that executes test suites on the JUnit Platform; only required at runtime. See <a href="https://junit.org/junit5/docs/current/user-guide/#junit-platform-suite-engine">JUnit Platform Suite Engine</a> for details.</p>
<h3 id="junit-platform-testkit"><a class="header" href="#junit-platform-testkit">junit-platform-testkit</a></h3>
<p>Provides support for executing a test plan for a given <code>TestEngine</code> and then accessing the results via a fluent API to verify the expected results.</p>
<p>为执行给定TestEngine的测试计划提供支持，然后通过fluent API访问结果以验证预期结果。</p>
<h2 id="junit-jupiter"><a class="header" href="#junit-jupiter">JUnit Jupiter</a></h2>
<ul>
<li><strong>Group ID</strong>: <code>org.junit.jupiter</code></li>
<li><strong>Version</strong>: <code>5.8.2</code></li>
<li><strong>Artifact IDs</strong>:</li>
</ul>
<h3 id="junit-jupiter-1"><a class="header" href="#junit-jupiter-1">junit-jupiter</a></h3>
<p>JUnit Jupiter aggregator artifact that transitively pulls in dependencies on <code>junit-jupiter-api</code>, <code>junit-jupiter-params</code>, and <code>junit-jupiter-engine</code> for simplified dependency management in build tools such as Gradle and Maven.</p>
<p><em>JUnit Jupiter aggregator artifact</em>，可传递地拉入对junit-jupiter-api，junit-jupiter-params和junit-jupiter-engine的依赖关系，以简化构建工具 (例如Gradle和Maven) 中的依赖关系。</p>
<h3 id="junit-jupiter-api"><a class="header" href="#junit-jupiter-api">junit-jupiter-api</a></h3>
<p>JUnit Jupiter API for <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests">writing tests</a> and <a href="https://junit.org/junit5/docs/current/user-guide/#extensions">extensions</a>.</p>
<h3 id="junit-jupiter-engine"><a class="header" href="#junit-jupiter-engine">junit-jupiter-engine</a></h3>
<p>JUnit Jupiter test engine implementation; only required at runtime.</p>
<h3 id="junit-jupiter-params"><a class="header" href="#junit-jupiter-params">junit-jupiter-params</a></h3>
<p>Support for <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests">parameterized tests</a> in JUnit Jupiter.</p>
<h3 id="junit-jupiter-migrationsupport"><a class="header" href="#junit-jupiter-migrationsupport">junit-jupiter-migrationsupport</a></h3>
<p>Support for migrating from JUnit 4 to JUnit Jupiter; only required for support for JUnit 4’s <code>@Ignore</code> annotation and for running selected JUnit 4 rules.</p>
<h2 id="junit-vintage"><a class="header" href="#junit-vintage">JUnit Vintage</a></h2>
<ul>
<li><strong>Group ID</strong>: <code>org.junit.vintage</code></li>
<li><strong>Version</strong>: <code>5.8.2</code></li>
<li><strong>Artifact ID</strong>:</li>
</ul>
<h3 id="junit-vintage-engine"><a class="header" href="#junit-vintage-engine"><code>junit-vintage-engine</code></a></h3>
<p>JUnit Vintage test engine implementation that allows one to run <em>vintage</em> JUnit tests on the JUnit Platform. <em>Vintage</em> tests include those written using JUnit 3 or JUnit 4 APIs or tests written using testing frameworks built on those APIs.</p>
<p>JUnit Vintage 测试引擎实现，允许在JUnit平台上运行老式JUnit测试。老式测试包括使用JUnit 3或JUnit 4 api编写的测试，或使用基于这些api构建的测试框架编写的测试。</p>
<h2 id="bill-of-materials-bom"><a class="header" href="#bill-of-materials-bom">Bill of Materials (BOM)</a></h2>
<p>The <em>Bill of Materials</em> POM provided under the following Maven coordinates can be used to ease dependency management when referencing multiple of the above artifacts using <a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Importing_Dependencies">Maven</a> or <a href="https://docs.gradle.org/current/userguide/managing_transitive_dependencies.html#sec:bom_import">Gradle</a>.</p>
<ul>
<li><strong>Group ID</strong>: <code>org.junit</code></li>
<li><strong>Artifact ID</strong>: <code>junit-bom</code></li>
<li><strong>Version</strong>: <code>5.8.2</code></li>
</ul>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>Most of the above artifacts have a dependency in their published Maven POMs on the following <em>@API Guardian</em> JAR.</p>
<p>以上大多数<em>artifacts</em>都在其发布的Maven POMs中依赖于以下 @ API Guardian JAR。</p>
<ul>
<li><strong>Group ID</strong>: <code>org.apiguardian</code></li>
<li><strong>Artifact ID</strong>: <code>apiguardian-api</code></li>
<li><strong>Version</strong>: <code>1.1.2</code></li>
</ul>
<p>In addition, most of the above artifacts have a direct or transitive dependency on the following <em>OpenTest4J</em> JAR.</p>
<ul>
<li><strong>Group ID</strong>: <code>org.opentest4j</code></li>
<li><strong>Artifact ID</strong>: <code>opentest4j</code></li>
<li><strong>Version</strong>: <code>1.2.0</code></li>
</ul>
<p><img src="https://junit.org/junit5/docs/current/user-guide/images/component-diagram.svg" alt="component diagram" /></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="annotations"><a class="header" href="#annotations">Annotations</a></h3>
<p>JUnit Jupiter supports the following annotations for configuring tests and extending the framework.</p>
<p>JUnit Jupiter支持以下用于配置测试和扩展框架的注释。除非另有说明，否则所有核心注释都位于<em>junit-jupiter-api</em>模块中的<em>org.junit.jupiter.api</em>包中。</p>
<table><thead><tr><th style="text-align: left">Annotation</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>@Test</code></td><td style="text-align: left">表示方法是一种测试方法。与JUnit 4的 @ Test注释不同，此注解不声明任何属性，因为JUnit Jupiter中的测试扩展基于其自己的专用注解进行操作。这样的方法是继承的，除非它们被覆盖。</td></tr>
<tr><td style="text-align: left"><code>@ParameterizedTest</code></td><td style="text-align: left">Denotes that a method is a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests">parameterized test</a>. 这样方法是继承的，除非它们被覆盖。</td></tr>
<tr><td style="text-align: left"><code>@RepeatedTest</code></td><td style="text-align: left">Denotes that a method is a test template for a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests">repeated test</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@TestFactory</code></td><td style="text-align: left">Denotes that a method is a test factory for <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-dynamic-tests">dynamic tests</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@TestTemplate</code></td><td style="text-align: left">Denotes that a method is a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-templates">template for test cases</a> designed to be invoked multiple times depending on the number of invocation contexts returned by the registered <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-test-templates">providers</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@TestClassOrder</code></td><td style="text-align: left">Used to configure the <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-classes">test class execution order</a> for <code>@Nested</code> test classes in the annotated test class. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@TestMethodOrder</code></td><td style="text-align: left">Used to configure the <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order-methods">test method execution order</a> for the annotated test class; similar to JUnit 4’s <code>@FixMethodOrder</code>. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@TestInstance</code></td><td style="text-align: left">Used to configure the <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> for the annotated test class. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@DisplayName</code></td><td style="text-align: left">Declares a custom <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-display-names">display name</a> for the test class or test method. Such annotations are not <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@DisplayNameGeneration</code></td><td style="text-align: left">Declares a custom <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-display-name-generator">display name generator</a> for the test class. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@BeforeEach</code></td><td style="text-align: left">Denotes that the annotated method should be executed <em>before</em> <strong>each</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, or <code>@TestFactory</code> method in the current class; analogous to JUnit 4’s <code>@Before</code>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@AfterEach</code></td><td style="text-align: left">Denotes that the annotated method should be executed <em>after</em> <strong>each</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, or <code>@TestFactory</code> method in the current class; analogous to JUnit 4’s <code>@After</code>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr>
<tr><td style="text-align: left"><code>@BeforeAll</code></td><td style="text-align: left">Denotes that the annotated method should be executed <em>before</em> <strong>all</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, and <code>@TestFactory</code> methods in the current class; analogous to JUnit 4’s <code>@BeforeClass</code>. Such methods are <em>inherited</em> (unless they are <em>hidden</em> or <em>overridden</em>) and must be <code>static</code> (unless the &quot;per-class&quot; <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> is used).</td></tr>
<tr><td style="text-align: left"><code>@AfterAll</code></td><td style="text-align: left">Denotes that the annotated method should be executed <em>after</em> <strong>all</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, and <code>@TestFactory</code> methods in the current class; analogous to JUnit 4’s <code>@AfterClass</code>. Such methods are <em>inherited</em> (unless they are <em>hidden</em> or <em>overridden</em>) and must be <code>static</code> (unless the &quot;per-class&quot; <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> is used).</td></tr>
<tr><td style="text-align: left"><code>@Nested</code></td><td style="text-align: left">Denotes that the annotated class is a non-static <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-nested">nested test class</a>. <code>@BeforeAll</code> and <code>@AfterAll</code> methods cannot be used directly in a <code>@Nested</code> test class unless the &quot;per-class&quot; <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> is used. Such annotations are not <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@Tag</code></td><td style="text-align: left">Used to declare <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-tagging-and-filtering">tags for filtering tests</a>, either at the class or method level; analogous to test groups in TestNG or Categories in JUnit 4. Such annotations are <em>inherited</em> at the class level but not at the method level.</td></tr>
<tr><td style="text-align: left"><code>@Disabled</code></td><td style="text-align: left">Used to <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-disabling">disable</a> a test class or test method; analogous to JUnit 4’s <code>@Ignore</code>. Such annotations are not <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@Timeout</code></td><td style="text-align: left">Used to fail a test, test factory, test template, or lifecycle method if its execution exceeds a given duration. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@ExtendWith</code></td><td style="text-align: left">Used to <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-registration-declarative">register extensions declaratively</a>. Such annotations are <em>inherited</em>.</td></tr>
<tr><td style="text-align: left"><code>@RegisterExtension</code></td><td style="text-align: left">Used to <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-registration-programmatic">register extensions programmatically</a> via fields. Such fields are <em>inherited</em> unless they are <em>shadowed</em>.</td></tr>
<tr><td style="text-align: left"><code>@TempDir</code></td><td style="text-align: left">Used to supply a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-built-in-extensions-TempDirectory">temporary directory</a> via field injection or parameter injection in a lifecycle method or test method; located in the <code>org.junit.jupiter.api.io</code> package.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<p>{% raw %}</p>
<p><strong><a href="https://www.toutiao.com/i6824762402345583111/">Mybatis通用mapper</a></strong></p>
<h2 id="sqlsession"><a class="header" href="#sqlsession">sqlsession</a></h2>
<h3 id="构建-sqlsessionfactory"><a class="header" href="#构建-sqlsessionfactory">构建 SqlSessionFactory</a></h3>
<h4 id="重载的各个方法"><a class="header" href="#重载的各个方法">重载的各个方法</a></h4>
<pre><code>SqlSessionFactory build(InputStream inputStream)
SqlSessionFactory build(InputStream inputStream, String environment)
SqlSessionFactory build(InputStream inputStream, Properties properties)
SqlSessionFactory build(InputStream inputStream, String env, Properties props)
SqlSessionFactory build(Configuration config)
</code></pre>
<h4 id="从核心配置文件构建"><a class="header" href="#从核心配置文件构建">从核心配置文件构建</a></h4>
<pre><code class="language-java">String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
</code></pre>
<h4 id="使用-java-代码构建"><a class="header" href="#使用-java-代码构建">使用 Java 代码构建</a></h4>
<pre><code class="language-java">DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();
TransactionFactory transactionFactory = new JdbcTransactionFactory();
Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);
Configuration configuration = new Configuration(environment);
configuration.addMapper(BlogMapper.class);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);
</code></pre>
<h3 id="构建-sqlsession"><a class="header" href="#构建-sqlsession">构建 sqlsession</a></h3>
<h4 id="重载方法"><a class="header" href="#重载方法">重载方法</a></h4>
<pre><code>SqlSession openSession()
SqlSession openSession(boolean autoCommit)
SqlSession openSession(Connection connection)
SqlSession openSession(TransactionIsolationLevel level)
SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level)
SqlSession openSession(ExecutorType execType)
SqlSession openSession(ExecutorType execType, boolean autoCommit)
SqlSession openSession(ExecutorType execType, Connection connection)
Configuration getConfiguration();
</code></pre>
<p>进行数据库操作要考虑的问题</p>
<ul>
<li><strong>数据库连接</strong></li>
<li><strong>事务处理</strong></li>
<li><strong>语句执行</strong></li>
</ul>
<p>默认的 openSession() 方法没有参数，它会创建具备如下特性的 SqlSession：</p>
<ul>
<li>事务作用域将会开启（也就是不自动提交）。</li>
<li>将由当前环境配置的 DataSource 实例中获取 Connection 对象。</li>
<li>事务隔离级别将会使用驱动或数据源的默认设置。</li>
<li>预处理语句不会被复用，也不会批量处理更新。</li>
</ul>
<h4 id="executortype"><a class="header" href="#executortype"><em>ExecutorType</em></a></h4>
<ul>
<li><code>ExecutorType.SIMPLE</code>：该类型的执行器没有特别的行为。它为每个语句的执行创建一个新的预处理语句。</li>
<li><code>ExecutorType.REUSE</code>：该类型的执行器会复用预处理语句。</li>
<li><code>ExecutorType.BATCH</code>：该类型的执行器会批量执行所有更新语句，如果 SELECT 在多个更新中间执行，将在必要时将多条更新语句分隔开来，以方便理解。</li>
</ul>
<h3 id="语句执行"><a class="header" href="#语句执行">语句执行</a></h3>
<h4 id="语句执行方法"><a class="header" href="#语句执行方法">语句执行方法</a></h4>
<pre><code>&lt;T&gt; T selectOne(String statement, Object parameter)
&lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter)
&lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement, Object parameter)
&lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, Object parameter, String mapKey)
int insert(String statement, Object parameter)
int update(String statement, Object parameter)
int delete(String statement, Object parameter)
</code></pre>
<p>游标（Cursor）与列表（List）返回的结果相同，不同的是，游标借助迭代器实现了数据的惰性加载。</p>
<h4 id="限制返回行数"><a class="header" href="#限制返回行数">限制返回行数</a></h4>
<pre><code>&lt;E&gt; List&lt;E&gt; selectList (String statement, Object parameter, RowBounds rowBounds)
&lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement, Object parameter, RowBounds rowBounds)
&lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowbounds)
void select (String statement, Object parameter, ResultHandler&lt;T&gt; handler)
void select (String statement, Object parameter, RowBounds rowBounds, ResultHandler&lt;T&gt; handler)
</code></pre>
<pre><code>RowBounds rowBounds = new RowBounds(offset, limit);
</code></pre>
<ol>
<li>
<p>数据库驱动决定了略过记录时的查询效率。为了获得最佳的性能，建议将 ResultSet 类型设置为 SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE（换句话说：不要使用 FORWARD_ONLY）。</p>
</li>
<li>
<p>如果 PreparedStatement 对象初始化时 resultSetType 参数设置为 TYPE_FORWARD_ONLY，在从 ResultSet（结果集）中读取记录的时，对于访问过的记录就自动释放了内存。而设置为 TYPE_SCROLL_INSENSITIVE 或 TYPE_SCROLL_SENSITIVE 时为了保证能游标能向上移动到任意位置，已经访问过的所有都保留在内存中不能释放。所以大量数据加载的时候，就 OOM 了。</p>
</li>
</ol>
<h4 id="结果行自定义处理"><a class="header" href="#结果行自定义处理">结果行自定义处理</a></h4>
<p>从版本 3.4.6 开始，<code>ResultHandler</code> 会在存储过程的 REFCURSOR 输出参数中传递使用的 <code>CALLABLE</code> 语句。</p>
<pre><code>package org.apache.ibatis.session;
public interface ResultHandler&lt;T&gt; {
  void handleResult(ResultContext&lt;? extends T&gt; context);
}
</code></pre>
<p>ResultContext 参数允许你访问结果对象和当前已被创建的对象数目，另外还提供了一个返回值为 Boolean 的 stop 方法，你可以使用此 stop 方法来停止 MyBatis 加载更多的结果。</p>
<p>使用 ResultHandler 的时候需要注意以下两个限制：</p>
<ul>
<li>使用带 ResultHandler 参数的方法时，收到的数据不会被缓存。</li>
<li>当使用高级的结果映射集（resultMap）时，MyBatis 很可能需要数行结果来构造一个对象。如果你使用了 ResultHandler，你可能会接收到关联（association）或者集合（collection）中尚未被完整填充的对象。</li>
</ul>
<h4 id="立即批量更新方法"><a class="header" href="#立即批量更新方法">立即批量更新方法</a></h4>
<pre><code>List&lt;BatchResult&gt; flushStatements()
</code></pre>
<p>当你将 <code>ExecutorType</code> 设置为 <code>ExecutorType.BATCH</code> 时，可以使用这个方法清除（执行）缓存在 JDBC 驱动类中的批量更新语句。</p>
<h4 id="事务控制方法"><a class="header" href="#事务控制方法">事务控制方法</a></h4>
<p>有四个方法用来控制事务作用域。</p>
<p>如果你已经设置了自动提交或你使用了外部事务管理器</p>
<p>这些方法就没什么作用了。然而，如果你正在使用由 Connection 实例控制的 JDBC 事务管理器，那么这四个方法就会派上用场：</p>
<pre><code>void commit()
void commit(boolean force)
void rollback()
void rollback(boolean force)
</code></pre>
<h2 id="configuration配置"><a class="header" href="#configuration配置">configuration（配置）</a></h2>
<h3 id="properties属性"><a class="header" href="#properties属性">properties（属性）</a></h3>
<h4 id="可以外部配置可以字面写入"><a class="header" href="#可以外部配置可以字面写入">可以外部配置,可以字面写入</a></h4>
<pre><code>&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;
  &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;
&lt;/properties&gt;
</code></pre>
<h4 id="可以使用载入的配置"><a class="header" href="#可以使用载入的配置">可以使用载入的配置</a></h4>
<pre><code>
&lt;dataSource type=&quot;POOLED&quot;&gt;
  &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
  &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
  &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
&lt;/dataSource&gt;
</code></pre>
<h4 id="代码传入变量"><a class="header" href="#代码传入变量">代码传入变量</a></h4>
<pre><code>可以通过
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);传入变量
</code></pre>
<h4 id="变量优先级"><a class="header" href="#变量优先级">变量优先级</a></h4>
<pre><code>变量优先级
properties标签体内的属性 &lt; properties指定的resource &lt; 方法传入的properties
</code></pre>
<h4 id="默认值"><a class="header" href="#默认值">默认值</a></h4>
<pre><code>开启占位符功能
&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;
  &lt;!-- ... --&gt;
  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt; &lt;!-- 启用默认值特性 --&gt;
&lt;/properties&gt;

&lt;property name=&quot;username&quot; value=&quot;${username:ut_user}&quot;/&gt;

</code></pre>
<h3 id="设置"><a class="header" href="#设置">设置</a></h3>
<ul>
<li>
<p><em>useActualParamName</em> true|false</p>
<ul>
<li>
<p>允许使用方法签名中的名称作为语句参数名称</p>
</li>
<li>
<p>采用 Java 8 编译，并且加上 <code>-parameters</code> 选项</p>
</li>
<li>
<p>(新增于 3.4.1)</p>
</li>
</ul>
</li>
</ul>
<h3 id="typealiases类型别名"><a class="header" href="#typealiases类型别名">typeAliases（类型别名）</a></h3>
<h4 id="类型别名"><a class="header" href="#类型别名">类型别名</a></h4>
<pre><code>&lt;typeAliases&gt;
  &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt;
  &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;
  &lt;typeAlias alias=&quot;Comment&quot; type=&quot;domain.blog.Comment&quot;/&gt;
  &lt;typeAlias alias=&quot;Post&quot; type=&quot;domain.blog.Post&quot;/&gt;
  &lt;typeAlias alias=&quot;Section&quot; type=&quot;domain.blog.Section&quot;/&gt;
  &lt;typeAlias alias=&quot;Tag&quot; type=&quot;domain.blog.Tag&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<h4 id="指定包名"><a class="header" href="#指定包名">指定包名</a></h4>
<pre><code>&lt;typeAliases&gt;
  &lt;package name=&quot;domain.blog&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<h4 id="注解-3"><a class="header" href="#注解-3">注解</a></h4>
<pre><code>@Alias(&quot;author&quot;)
</code></pre>
<h3 id="typehandlers类型处理器"><a class="header" href="#typehandlers类型处理器">typeHandlers（类型处理器）</a></h3>
<h4 id="内置类型处理器"><a class="header" href="#内置类型处理器">内置类型处理器</a></h4>
<p>从 3.4.5 开始，MyBatis 默认支持 JSR-310</p>
<table><thead><tr><th style="text-align: left">类型处理器</th><th style="text-align: left">Java 类型</th><th style="text-align: left">JDBC 类型</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>BooleanTypeHandler</code></td><td style="text-align: left"><code>java.lang.Boolean</code>, <code>boolean</code></td><td style="text-align: left">数据库兼容的 <code>BOOLEAN</code></td></tr>
<tr><td style="text-align: left"><code>ByteTypeHandler</code></td><td style="text-align: left"><code>java.lang.Byte</code>, <code>byte</code></td><td style="text-align: left">数据库兼容的 <code>NUMERIC</code> 或 <code>BYTE</code></td></tr>
<tr><td style="text-align: left"><code>ShortTypeHandler</code></td><td style="text-align: left"><code>java.lang.Short</code>, <code>short</code></td><td style="text-align: left">数据库兼容的 <code>NUMERIC</code> 或 <code>SMALLINT</code></td></tr>
<tr><td style="text-align: left"><code>IntegerTypeHandler</code></td><td style="text-align: left"><code>java.lang.Integer</code>, <code>int</code></td><td style="text-align: left">数据库兼容的 <code>NUMERIC</code> 或 <code>INTEGER</code></td></tr>
<tr><td style="text-align: left"><code>LongTypeHandler</code></td><td style="text-align: left"><code>java.lang.Long</code>, <code>long</code></td><td style="text-align: left">数据库兼容的 <code>NUMERIC</code> 或 <code>BIGINT</code></td></tr>
<tr><td style="text-align: left"><code>FloatTypeHandler</code></td><td style="text-align: left"><code>java.lang.Float</code>, <code>float</code></td><td style="text-align: left">数据库兼容的 <code>NUMERIC</code> 或 <code>FLOAT</code></td></tr>
<tr><td style="text-align: left"><code>DoubleTypeHandler</code></td><td style="text-align: left"><code>java.lang.Double</code>, <code>double</code></td><td style="text-align: left">数据库兼容的 <code>NUMERIC</code> 或 <code>DOUBLE</code></td></tr>
<tr><td style="text-align: left"><code>BigDecimalTypeHandler</code></td><td style="text-align: left"><code>java.math.BigDecimal</code></td><td style="text-align: left">数据库兼容的 <code>NUMERIC</code> 或 <code>DECIMAL</code></td></tr>
<tr><td style="text-align: left"><code>StringTypeHandler</code></td><td style="text-align: left"><code>java.lang.String</code></td><td style="text-align: left"><code>CHAR</code>, <code>VARCHAR</code></td></tr>
<tr><td style="text-align: left"><code>ClobReaderTypeHandler</code></td><td style="text-align: left"><code>java.io.Reader</code></td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left"><code>ClobTypeHandler</code></td><td style="text-align: left"><code>java.lang.String</code></td><td style="text-align: left"><code>CLOB</code>, <code>LONGVARCHAR</code></td></tr>
<tr><td style="text-align: left"><code>NStringTypeHandler</code></td><td style="text-align: left"><code>java.lang.String</code></td><td style="text-align: left"><code>NVARCHAR</code>, <code>NCHAR</code></td></tr>
<tr><td style="text-align: left"><code>NClobTypeHandler</code></td><td style="text-align: left"><code>java.lang.String</code></td><td style="text-align: left"><code>NCLOB</code></td></tr>
<tr><td style="text-align: left"><code>BlobInputStreamTypeHandler</code></td><td style="text-align: left"><code>java.io.InputStream</code></td><td style="text-align: left">-</td></tr>
<tr><td style="text-align: left"><code>ByteArrayTypeHandler</code></td><td style="text-align: left"><code>byte[]</code></td><td style="text-align: left">数据库兼容的字节流类型</td></tr>
<tr><td style="text-align: left"><code>BlobTypeHandler</code></td><td style="text-align: left"><code>byte[]</code></td><td style="text-align: left"><code>BLOB</code>, <code>LONGVARBINARY</code></td></tr>
<tr><td style="text-align: left"><code>DateTypeHandler</code></td><td style="text-align: left"><code>java.util.Date</code></td><td style="text-align: left"><code>TIMESTAMP</code></td></tr>
<tr><td style="text-align: left"><code>DateOnlyTypeHandler</code></td><td style="text-align: left"><code>java.util.Date</code></td><td style="text-align: left"><code>DATE</code></td></tr>
<tr><td style="text-align: left"><code>TimeOnlyTypeHandler</code></td><td style="text-align: left"><code>java.util.Date</code></td><td style="text-align: left"><code>TIME</code></td></tr>
<tr><td style="text-align: left"><code>SqlTimestampTypeHandler</code></td><td style="text-align: left"><code>java.sql.Timestamp</code></td><td style="text-align: left"><code>TIMESTAMP</code></td></tr>
<tr><td style="text-align: left"><code>SqlDateTypeHandler</code></td><td style="text-align: left"><code>java.sql.Date</code></td><td style="text-align: left"><code>DATE</code></td></tr>
<tr><td style="text-align: left"><code>SqlTimeTypeHandler</code></td><td style="text-align: left"><code>java.sql.Time</code></td><td style="text-align: left"><code>TIME</code></td></tr>
<tr><td style="text-align: left"><code>ObjectTypeHandler</code></td><td style="text-align: left">Any</td><td style="text-align: left"><code>OTHER</code> 或未指定类型</td></tr>
<tr><td style="text-align: left"><code>EnumTypeHandler</code></td><td style="text-align: left">Enumeration Type</td><td style="text-align: left">VARCHAR 或任何兼容的字符串类型，用来存储枚举的名称（而不是索引序数值）</td></tr>
<tr><td style="text-align: left"><code>EnumOrdinalTypeHandler</code></td><td style="text-align: left">Enumeration Type</td><td style="text-align: left">任何兼容的 <code>NUMERIC</code> 或 <code>DOUBLE</code> 类型，用来存储枚举的序数值（而不是名称）。</td></tr>
<tr><td style="text-align: left"><code>SqlxmlTypeHandler</code></td><td style="text-align: left"><code>java.lang.String</code></td><td style="text-align: left"><code>SQLXML</code></td></tr>
<tr><td style="text-align: left"><code>InstantTypeHandler</code></td><td style="text-align: left"><code>java.time.Instant</code></td><td style="text-align: left"><code>TIMESTAMP</code></td></tr>
<tr><td style="text-align: left"><code>LocalDateTimeTypeHandler</code></td><td style="text-align: left"><code>java.time.LocalDateTime</code></td><td style="text-align: left"><code>TIMESTAMP</code></td></tr>
<tr><td style="text-align: left"><code>LocalDateTypeHandler</code></td><td style="text-align: left"><code>java.time.LocalDate</code></td><td style="text-align: left"><code>DATE</code></td></tr>
<tr><td style="text-align: left"><code>LocalTimeTypeHandler</code></td><td style="text-align: left"><code>java.time.LocalTime</code></td><td style="text-align: left"><code>TIME</code></td></tr>
<tr><td style="text-align: left"><code>OffsetDateTimeTypeHandler</code></td><td style="text-align: left"><code>java.time.OffsetDateTime</code></td><td style="text-align: left"><code>TIMESTAMP</code></td></tr>
<tr><td style="text-align: left"><code>OffsetTimeTypeHandler</code></td><td style="text-align: left"><code>java.time.OffsetTime</code></td><td style="text-align: left"><code>TIME</code></td></tr>
<tr><td style="text-align: left"><code>ZonedDateTimeTypeHandler</code></td><td style="text-align: left"><code>java.time.ZonedDateTime</code></td><td style="text-align: left"><code>TIMESTAMP</code></td></tr>
<tr><td style="text-align: left"><code>YearTypeHandler</code></td><td style="text-align: left"><code>java.time.Year</code></td><td style="text-align: left"><code>INTEGER</code></td></tr>
<tr><td style="text-align: left"><code>MonthTypeHandler</code></td><td style="text-align: left"><code>java.time.Month</code></td><td style="text-align: left"><code>INTEGER</code></td></tr>
<tr><td style="text-align: left"><code>YearMonthTypeHandler</code></td><td style="text-align: left"><code>java.time.YearMonth</code></td><td style="text-align: left"><code>VARCHAR</code> 或 <code>LONGVARCHAR</code></td></tr>
<tr><td style="text-align: left"><code>JapaneseDateTypeHandler</code></td><td style="text-align: left"><code>java.time.chrono.JapaneseDate</code></td><td style="text-align: left"><code>DATE</code></td></tr>
</tbody></table>
<h4 id="自定义类型转换器"><a class="header" href="#自定义类型转换器">自定义类型转换器</a></h4>
<ul>
<li>
<p>实现 <code>org.apache.ibatis.type.TypeHandler</code> 接口</p>
</li>
<li>
<p>或继承一个很便利的类 <code>org.apache.ibatis.type.BaseTypeHandler</code></p>
</li>
</ul>
<pre><code class="language-java">@MappedJdbcTypes(JdbcType.VARCHAR)
public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; {

  @Override
  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i, parameter);
  }

  @Override
  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {
    return rs.getString(columnName);
  }

  @Override
  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return rs.getString(columnIndex);
  }

  @Override
  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    return cs.getString(columnIndex);
  }
}
</code></pre>
<h4 id="映射-javatype-与-jdbctype-的方式"><a class="header" href="#映射-javatype-与-jdbctype-的方式">映射 javaType 与 JDBCtype 的方式</a></h4>
<ul>
<li>泛型</li>
<li>@MappedTypes,@MappedJdbcTypes</li>
<li><code>&lt;typeHandlers&gt;</code> 标签中给定 javaType=&quot;String&quot;属性</li>
</ul>
<h4 id="手动给定或自动查找类型处理器"><a class="header" href="#手动给定或自动查找类型处理器">手动给定或自动查找类型处理器</a></h4>
<p>注意在使用自动发现功能的时候，只能通过注解方式来指定 JDBC 的类型。</p>
<pre><code>&lt;!-- mybatis-config.xml --&gt;
&lt;typeHandlers&gt;
  &lt;typeHandler handler=&quot;org.mybatis.example.ExampleTypeHandler&quot;/&gt;
&lt;/typeHandlers&gt;
</code></pre>
<pre><code>&lt;!-- mybatis-config.xml --&gt;
&lt;typeHandlers&gt;
  &lt;package name=&quot;org.mybatis.example&quot;/&gt;
&lt;/typeHandlers&gt;
</code></pre>
<h4 id="泛型类型处理器"><a class="header" href="#泛型类型处理器">泛型类型处理器</a></h4>
<ul>
<li>需要增加一个接受该类的 class 作为参数的构造器,这样 MyBatis 会在构造一个类型处理器实例的时候传入一个具体的类</li>
<li><code>EnumTypeHandler</code> 和 <code>EnumOrdinalTypeHandler</code> 都是泛型类型处理器</li>
</ul>
<pre><code>public class GenericTypeHandler&lt;E extends MyObject&gt; extends BaseTypeHandler&lt;E&gt; {

  private Class&lt;E&gt; type;

  public GenericTypeHandler(Class&lt;E&gt; type) {
    if (type == null) throw new IllegalArgumentException(&quot;Type argument cannot be null&quot;);
    this.type = type;
  }
</code></pre>
<h4 id="枚举类型"><a class="header" href="#枚举类型">枚举类型</a></h4>
<pre><code class="language-xml">&lt;!-- mybatis-config.xml --&gt;
&lt;typeHandlers&gt;
  &lt;typeHandler handler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot; javaType=&quot;java.math.RoundingMode&quot;/&gt;
&lt;/typeHandlers&gt;
</code></pre>
<p>显示的为 resultMap 指定 typehandler</p>
<pre><code class="language-xml">&lt;result column=&quot;roundingMode&quot; property=&quot;roundingMode&quot; typeHandler=&quot;org.apache.ibatis.type.EnumTypeHandler&quot;/&gt;
</code></pre>
<h3 id="objectfactory对象工厂"><a class="header" href="#objectfactory对象工厂">objectFactory（对象工厂）</a></h3>
<h4 id="简述-2"><a class="header" href="#简述-2">简述</a></h4>
<ul>
<li>每次 MyBatis 创建结果对象的新实例时，它都会使用一个对象工厂实例来完成实例化工作</li>
<li>默认的对象工厂需要做的仅仅是实例化目标类</li>
<li>要么通过默认无参构造方法，要么通过存在的参数映射来调用带有参数的构造方法</li>
<li>如果想覆盖对象工厂的默认行为，可以通过创建自己的对象工厂来实现</li>
</ul>
<h4 id="自定义对象工厂"><a class="header" href="#自定义对象工厂">自定义对象工厂</a></h4>
<pre><code class="language-java">public class ExampleObjectFactory extends DefaultObjectFactory {
  public Object create(Class type) {
    return super.create(type);
  }
  public Object create(Class type, List&lt;Class&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) {
    return super.create(type, constructorArgTypes, constructorArgs);
  }
  public void setProperties(Properties properties) {
    super.setProperties(properties);
  }
  public &lt;T&gt; boolean isCollection(Class&lt;T&gt; type) {
    return Collection.class.isAssignableFrom(type);
  }}
</code></pre>
<h4 id="配置-3"><a class="header" href="#配置-3">配置</a></h4>
<pre><code>&lt;objectFactory type=&quot;org.mybatis.example.ExampleObjectFactory&quot;&gt;
  &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;
&lt;/objectFactory&gt;
</code></pre>
<h3 id="plugins插件"><a class="header" href="#plugins插件">plugins（插件）</a></h3>
<h4 id="简述-3"><a class="header" href="#简述-3">简述</a></h4>
<ul>
<li>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用</li>
<li>可以拦截的列表
<ul>
<li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>
<li>ParameterHandler (getParameterObject, setParameters)</li>
<li>ResultSetHandler (handleResultSets, handleOutputParameters)</li>
<li>StatementHandler (prepare, parameterize, batch, update, query)</li>
</ul>
</li>
</ul>
<h4 id="自定义插件"><a class="header" href="#自定义插件">自定义插件</a></h4>
<pre><code>@Intercepts({@Signature(
  type= Executor.class,
  method = &quot;update&quot;,
  args = {MappedStatement.class,Object.class})})
public class ExamplePlugin implements Interceptor {
  private Properties properties = new Properties();
  public Object intercept(Invocation invocation) throws Throwable {
    // implement pre processing if need
    Object returnObject = invocation.proceed();
    // implement post processing if need
    return returnObject;
  }
  public void setProperties(Properties properties) {
    this.properties = properties;
  }
}
</code></pre>
<pre><code>&lt;!-- mybatis-config.xml --&gt;
&lt;plugins&gt;
  &lt;plugin interceptor=&quot;org.mybatis.example.ExamplePlugin&quot;&gt;
    &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;
  &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
<h4 id="覆盖配置类"><a class="header" href="#覆盖配置类">覆盖配置类</a></h4>
<ul>
<li>除了用插件来修改 MyBatis 核心行为以外,还可以通过完全覆盖配置类来达到目的</li>
<li>只需继承配置类后覆盖其中的某个方法，再把它传递到 SqlSessionFactoryBuilder.build(myConfig) 方法即可</li>
<li>这可能会极大影响 MyBatis 的行为，务请慎之又慎</li>
</ul>
<h3 id="environments环境配置"><a class="header" href="#environments环境配置">environments（环境配置）</a></h3>
<h4 id="简述-4"><a class="header" href="#简述-4">简述</a></h4>
<ul>
<li>MyBatis 可以配置成适应多种环境,多数据库</li>
<li>每个数据库对应一个 SqlSessionFactory 实例,每个 SqlSessionFactory 实例只能选择一种环境。</li>
</ul>
<pre><code class="language-java">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);
</code></pre>
<h4 id="environment-定义了如何配置数据库环境"><a class="header" href="#environment-定义了如何配置数据库环境">environment 定义了如何配置数据库环境</a></h4>
<pre><code>&lt;environments default=&quot;development&quot;&gt;
  &lt;environment id=&quot;development&quot;&gt;
    &lt;transactionManager type=&quot;JDBC&quot;&gt;
      &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;
    &lt;/transactionManager&gt;
    &lt;dataSource type=&quot;POOLED&quot;&gt;
      &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
      &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
      &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
      &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
    &lt;/dataSource&gt;
  &lt;/environment&gt;
&lt;/environments&gt;
</code></pre>
<h3 id="transactionmanager事务管理器"><a class="header" href="#transactionmanager事务管理器">transactionManager（事务管理器）</a></h3>
<h4 id="mybatis-中有两种类型的事务管理器也就是-typejdbcmanaged"><a class="header" href="#mybatis-中有两种类型的事务管理器也就是-typejdbcmanaged">MyBatis 中有两种类型的事务管理器（也就是 type=&quot;[JDBC|MANAGED]&quot;）：</a></h4>
<ul>
<li>
<p>jdbc</p>
<p>JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。</p>
</li>
<li>
<p>MANAGED</p>
<ul>
<li>不做任何操作,让容器来管理事务的整个生命周期</li>
<li>默认情况下它会关闭连接,然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为</li>
</ul>
<pre><code class="language-xml">&lt;transactionManager type=&quot;MANAGED&quot;&gt;
  &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;
&lt;/transactionManager&gt;
</code></pre>
</li>
<li>
<p>使用 Spring + MyBatis，则没有必要配置事务管理器,Spring 模块会使用自带的管理器来覆盖前面的配置。</p>
</li>
</ul>
<h4 id="自定义事务工厂事务处理类"><a class="header" href="#自定义事务工厂事务处理类">自定义事务工厂,事务处理类</a></h4>
<pre><code>public interface TransactionFactory {
  default void setProperties(Properties props) { // 从 3.5.2 开始，该方法为默认方法
    // 空实现
  }
  Transaction newTransaction(Connection conn);
  Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);
}
public interface Transaction {
  Connection getConnection() throws SQLException;
  void commit() throws SQLException;
  void rollback() throws SQLException;
  void close() throws SQLException;
  Integer getTimeout() throws SQLException;
}
</code></pre>
<h3 id="datasource数据源"><a class="header" href="#datasource数据源">dataSource（数据源）</a></h3>
<ul>
<li>
<p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源</p>
</li>
<li>
<p>有三种内建的数据源类型（也就是 type=&quot;[UNPOOLED|POOLED|JNDI]&quot;）：</p>
<ul>
<li>unpooled
<ul>
<li><code>driver</code> – 这是 JDBC 驱动的 Java 类全限定名（并不是 JDBC 驱动中可能包含的数据源类）。</li>
<li><code>url</code> – 这是数据库的 JDBC URL 地址。</li>
<li><code>username</code> – 登录数据库的用户名。</li>
<li><code>password</code> – 登录数据库的密码。</li>
<li><code>defaultTransactionIsolationLevel</code> – 默认的连接事务隔离级别。</li>
<li><code>defaultNetworkTimeout</code> – 等待数据库操作完成的默认网络超时时间（单位：毫秒）。查看 <code>java.sql.Connection#setNetworkTimeout()</code> 的 API 文档以获取更多信息。</li>
<li>driver.encoding=UTF8,这将通过 DriverManager.getConnection(url, driverProperties) 方法传递值为 <code>UTF8</code> 的 <code>encoding</code> 属性给数据库驱动。</li>
</ul>
</li>
<li>pooled
<ul>
<li><code>poolMaximumActiveConnections</code> – 在任意时间可存在的活动（正在使用）连接数量，默认值：10</li>
<li><code>poolMaximumIdleConnections</code> – 任意时间可能存在的空闲连接数。</li>
<li><code>poolMaximumCheckoutTime</code> – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）</li>
<li><code>poolTimeToWait</code> – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直失败且不打印日志），默认值：20000 毫秒（即 20 秒）。</li>
<li><code>poolMaximumLocalBadConnectionTolerance</code> – 这是一个关于坏连接容忍度的底层设置， 作用于每一个尝试从缓存池获取连接的线程。 如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 <code>poolMaximumIdleConnections</code> 与 <code>poolMaximumLocalBadConnectionTolerance</code> 之和。 默认值：3（新增于 3.4.5）</li>
<li><code>poolPingQuery</code> – 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动出错时返回恰当的错误消息。</li>
<li><code>poolPingEnabled</code> – 是否启用侦测查询。若开启，需要设置 <code>poolPingQuery</code> 属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句），默认值：false。</li>
<li><code>poolPingConnectionsNotUsedFor</code> – 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。</li>
</ul>
</li>
<li>JNDI:这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用
<ul>
<li><code>initial_context</code> – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么将会直接从 InitialContext 中寻找 data_source 属性。</li>
<li><code>data_source</code> – 这是引用数据源实例位置的上下文路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找</li>
</ul>
</li>
</ul>
</li>
<li>
<p>自定义数据源</p>
<pre><code>public interface DataSourceFactory {
  void setProperties(Properties props);
  DataSource getDataSource();
}
&lt;dataSource type=&quot;org.myproject.C3P0DataSourceFactory&quot;&gt;
  &lt;property name=&quot;driver&quot; value=&quot;org.postgresql.Driver&quot;/&gt;
  &lt;property name=&quot;url&quot; value=&quot;jdbc:postgresql:mydb&quot;/&gt;
  &lt;property name=&quot;username&quot; value=&quot;postgres&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
&lt;/dataSource&gt;
</code></pre>
</li>
</ul>
<p>databaseIdProvider（数据库厂商标识）</p>
<ul>
<li>
<p>MyBatis 可以根据不同的数据库厂商执行不同的语句</p>
</li>
<li>
<p>这种多厂商的支持是基于映射语句中的 <code>databaseId</code> 属性</p>
</li>
<li>
<p>MyBatis 会加载带有匹配当前数据库 <code>databaseId</code> 属性和所有不带 <code>databaseId</code> 属性的语句。 如果同时找到带有 <code>databaseId</code> 和不带 <code>databaseId</code> 的相同语句，则后者会被舍弃</p>
<pre><code>&lt;databaseIdProvider type=&quot;DB_VENDOR&quot; /&gt;

对应的 DB_VENDOR 实现会将 databaseId 设置为 DatabaseMetaData#getDatabaseProductName() 返回的字符串
</code></pre>
<databaseIdProvider type="DB_VENDOR">
  <property name="SQL Server" value="sqlserver"/>
  <property name="DB2" value="db2"/>
  <property name="Oracle" value="oracle" />
</databaseIdProvider>
<pre><code>
</code></pre>
</li>
<li>
<p>自定义数据库别名解析</p>
<pre><code class="language-java">public interface DatabaseIdProvider {
  default void setProperties(Properties p) { // 从 3.5.2 开始，该方法为默认方法
    // 空实现
  }
  String getDatabaseId(DataSource dataSource) throws SQLException;
}
</code></pre>
</li>
</ul>
<h3 id="mappers-配置映射器"><a class="header" href="#mappers-配置映射器">mappers 配置（映射器）</a></h3>
<p>告诉 MyBatis 到哪里去找到这些语句</p>
<pre><code>&lt;!-- 使用相对于类路径的资源引用 --&gt;
&lt;mappers&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<pre><code>&lt;!-- 使用完全限定资源定位符（URL） --&gt;
&lt;mappers&gt;
  &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;
  &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt;
  &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<pre><code>&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;
&lt;mappers&gt;
  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;
  &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt;
  &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<pre><code>&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;
&lt;mappers&gt;
  &lt;package name=&quot;org.mybatis.builder&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<h2 id="xml-映射文件"><a class="header" href="#xml-映射文件">XML 映射文件</a></h2>
<h3 id="xml-顶级元素"><a class="header" href="#xml-顶级元素">XML 顶级元素</a></h3>
<p><code>cache</code> – 该命名空间的缓存配置。</p>
<p><code>cache-ref</code> – 引用其它命名空间的缓存配置。</p>
<p><code>resultMap</code> – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</p>
<p><code>parameterMap</code> – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。</p>
<p><code>sql</code> – 可被其它语句引用的可重用语句块。</p>
<p><code>insert</code> – 映射插入语句。</p>
<p><code>update</code> – 映射更新语句。</p>
<p><code>delete</code> – 映射删除语句。</p>
<p><code>select</code> – 映射查询语句。</p>
<h3 id="select-元素属性"><a class="header" href="#select-元素属性">select 元素属性</a></h3>
<table><thead><tr><th><code>id</code></th><th>在命名空间中唯一的标识符，可以被用来引用这条语句。</th></tr></thead><tbody>
<tr><td><code>parameterType</code></td><td>将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td></tr>
<tr><td>parameterMap</td><td>用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。</td></tr>
<tr><td><code>resultType</code></td><td>期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。</td></tr>
<tr><td><code>resultMap</code></td><td>对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</td></tr>
<tr><td><code>flushCache</code></td><td>将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。</td></tr>
<tr><td><code>useCache</code></td><td>将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。</td></tr>
<tr><td><code>timeout</code></td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr>
<tr><td><code>fetchSize</code></td><td>这是一个给驱动的建议值，尝试让驱动程序每次批量返回的结果行数等于这个设置值。 默认值为未设置（unset）（依赖驱动）。</td></tr>
<tr><td><code>statementType</code></td><td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr>
<tr><td><code>resultSetType</code></td><td>FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖数据库驱动）。</td></tr>
<tr><td><code>databaseId</code></td><td>如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</td></tr>
<tr><td><code>resultOrdered</code></td><td>这个设置仅针对嵌套结果 select 语句：如果为 true，将会假设包含了嵌套结果集或是分组，当返回一个主结果行时，就不会产生对前面结果集的引用。 这就使得在获取嵌套结果集的时候不至于内存不够用。默认值：<code>false</code>。</td></tr>
<tr><td><code>resultSets</code></td><td>这个设置仅适用于多结果集的情况。它将列出语句执行后返回的结果集并赋予每个结果集一个名称，多个名称之间以逗号分隔。</td></tr>
</tbody></table>
<h3 id="insertupdatedelete"><a class="header" href="#insertupdatedelete">insert,update,delete</a></h3>
<table><thead><tr><th style="text-align: left">属性</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>id</code></td><td style="text-align: left">在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr>
<tr><td style="text-align: left"><code>parameterType</code></td><td style="text-align: left">将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td></tr>
<tr><td style="text-align: left"><code>parameterMap</code></td><td style="text-align: left">用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。</td></tr>
<tr><td style="text-align: left"><code>flushCache</code></td><td style="text-align: left">将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。</td></tr>
<tr><td style="text-align: left"><code>timeout</code></td><td style="text-align: left">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr>
<tr><td style="text-align: left"><code>statementType</code></td><td style="text-align: left">可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr>
<tr><td style="text-align: left"><code>useGeneratedKeys</code></td><td style="text-align: left">（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td></tr>
<tr><td style="text-align: left"><code>keyProperty</code></td><td style="text-align: left">（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr>
<tr><td style="text-align: left"><code>keyColumn</code></td><td style="text-align: left">（仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr>
<tr><td style="text-align: left"><code>databaseId</code></td><td style="text-align: left">如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</td></tr>
</tbody></table>
<h3 id="使用-selectkey"><a class="header" href="#使用-selectkey">使用 selectKey</a></h3>
<pre><code>&lt;insert id=&quot;insertAuthor&quot;&gt;
  &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;
    select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.SYSDUMMY1
  &lt;/selectKey&gt;
  insert into Author
    (id, username, password, email,bio, favourite_section)
  values
    (#{id}, #{username}, #{password}, #{email}, #{bio}, #{favouriteSection,jdbcType=VARCHAR})
&lt;/insert&gt;

&lt;selectKey
  keyProperty=&quot;id&quot;
  resultType=&quot;int&quot;
  order=&quot;BEFORE&quot;
  statementType=&quot;PREPARED&quot;&gt;
</code></pre>
<h3 id="使用-sql-片段"><a class="header" href="#使用-sql-片段">使用 sql 片段</a></h3>
<pre><code>定义
&lt;sql id=&quot;userColumns&quot;&gt; ${alias}.id,${alias}.username,${alias}.password &lt;/sql&gt;

使用
&lt;select id=&quot;select&quot; resultType=&quot;map&quot;&gt;
  select
    field1, field2, field3
  &lt;include refid=&quot;someinclude&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;Some&quot;/&gt;
    &lt;property name=&quot;include_target&quot; value=&quot;sometable&quot;/&gt;
  &lt;/include&gt;
&lt;/select&gt;

</code></pre>
<h3 id="参数"><a class="header" href="#参数">参数</a></h3>
<p>大多时候，你只须简单指定属性名，顶多要为可能为空的列指定 <code>jdbcType</code>，其他的事情交给 MyBatis 自己去推断就行了。</p>
<pre><code>简单类型的参数引用
#{id}
指定java与jdbc类型
#{property,javaType=int,jdbcType=NUMERIC}
指定类型处理器
#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}
数值类型使用精度
#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}
当参数模式时 out时 可能会修改
#{department, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=departmentResultMap}
jdbcType为游标时
#{department, mode=OUT, jdbcType=CURSOR, javaType=ResultSet, resultMap=departmentResultMap}

</code></pre>
<h3 id="字符串替换"><a class="header" href="#字符串替换">字符串替换</a></h3>
<ul>
<li>使用 <code>#{}</code> 参数语法时，MyBatis 会创建 <code>PreparedStatement</code> 参数占位符</li>
</ul>
<pre><code>ORDER BY ${columnName}

@Select(&quot;select * from user where ${column} = #{value}&quot;)
User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;value&quot;) String value);

</code></pre>
<h3 id="结果映射resultmap"><a class="header" href="#结果映射resultmap">结果映射（resultMap）</a></h3>
<h4 id="resultmap-的子元素"><a class="header" href="#resultmap-的子元素">resultMap 的子元素</a></h4>
<ul>
<li>
<p>constructor</p>
<p>- 用于在实例化类时，注入结果到构造方法中</p>
<ul>
<li><code>idArg</code> - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能</li>
<li><code>arg</code> - 将被注入到构造方法的一个普通结果</li>
</ul>
</li>
<li>
<p><code>id</code> – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能</p>
</li>
<li>
<p><code>result</code> – 注入到字段或 JavaBean 属性的普通结果</p>
</li>
<li>
<p>association– 一个复杂类型的关联；许多结果将包装成这种类型</p>
<ul>
<li>嵌套结果映射 – 关联可以是 <code>resultMap</code> 元素，或是对其它结果映射的引用</li>
</ul>
</li>
<li>
<p>collection– 一个复杂类型的集合</p>
<ul>
<li>嵌套结果映射 – 集合可以是 <code>resultMap</code> 元素，或是对其它结果映射的引用</li>
</ul>
</li>
<li>
<p>discriminator– 使用结果值来决定使用哪个 resultMap</p>
<ul>
<li>case– 基于某些值的结果映射</li>
<li>嵌套结果映射 – <code>case</code> 也是一个结果映射，因此具有相同的结构和元素；或者引用其它的结果映射</li>
</ul>
</li>
</ul>
<h4 id="resultmap-属性"><a class="header" href="#resultmap-属性">resultMap 属性</a></h4>
<table><thead><tr><th style="text-align: left">属性</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>id</code></td><td style="text-align: left">当前命名空间中的一个唯一标识，用于标识一个结果映射。</td></tr>
<tr><td style="text-align: left"><code>type</code></td><td style="text-align: left">类的完全限定名, 或者一个类型别名（关于内置的类型别名，可以参考上面的表格）。</td></tr>
<tr><td style="text-align: left"><code>autoMapping</code></td><td style="text-align: left">如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。默认值：未设置（unset）</td></tr>
</tbody></table>
<h4 id="id--result-元素"><a class="header" href="#id--result-元素">id &amp; result 元素</a></h4>
<ul>
<li>数据库字段名,字段类型</li>
<li>Java 属性名,属性类型</li>
<li>类型处理器</li>
</ul>
<h4 id="支持的-jdbc-类型"><a class="header" href="#支持的-jdbc-类型">支持的 JDBC 类型</a></h4>
<table><thead><tr><th><code>BIT</code></th><th><code>FLOAT</code></th><th><code>CHAR</code></th><th><code>TIMESTAMP</code></th><th><code>OTHER</code></th><th><code>UNDEFINED</code></th></tr></thead><tbody>
<tr><td><code>TINYINT</code></td><td><code>REAL</code></td><td><code>VARCHAR</code></td><td><code>BINARY</code></td><td><code>BLOB</code></td><td><code>NVARCHAR</code></td></tr>
<tr><td><code>SMALLINT</code></td><td><code>DOUBLE</code></td><td><code>LONGVARCHAR</code></td><td><code>VARBINARY</code></td><td><code>CLOB</code></td><td><code>NCHAR</code></td></tr>
<tr><td><code>INTEGER</code></td><td><code>NUMERIC</code></td><td><code>DATE</code></td><td><code>LONGVARBINARY</code></td><td><code>BOOLEAN</code></td><td><code>NCLOB</code></td></tr>
<tr><td><code>BIGINT</code></td><td><code>DECIMAL</code></td><td><code>TIME</code></td><td><code>NULL</code></td><td><code>CURSOR</code></td><td><code>ARRAY</code></td></tr>
</tbody></table>
<h4 id="constructor"><a class="header" href="#constructor">constructor</a></h4>
<pre><code>&lt;constructor&gt;
   &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot;/&gt;
   &lt;arg column=&quot;username&quot; javaType=&quot;String&quot;/&gt;
   &lt;arg column=&quot;age&quot; javaType=&quot;_int&quot;/&gt;
&lt;/constructor&gt;
</code></pre>
<p>从版本 3.4.3 开始，可以在指定参数名称的前提下，以任意顺序编写 arg 元素。</p>
<p>为了通过名称来引用构造方法参数，你可以添加 <code>@Param</code> 注解，或者使用 '-parameters' 编译选项并启用 <code>useActualParamName</code> 选项（默认开启）来编译项目</p>
<p>constructor 的属性</p>
<table><thead><tr><th style="text-align: left">属性</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>column</code></td><td style="text-align: left">数据库中的列名，或者是列的别名。一般情况下，这和传递给 <code>resultSet.getString(columnName)</code> 方法的参数一样。</td></tr>
<tr><td style="text-align: left"><code>javaType</code></td><td style="text-align: left">一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。</td></tr>
<tr><td style="text-align: left"><code>jdbcType</code></td><td style="text-align: left">JDBC 类型，所支持的 JDBC 类型参见这个表格之前的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可能存在空值的列指定这个类型。</td></tr>
<tr><td style="text-align: left"><code>typeHandler</code></td><td style="text-align: left">我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。</td></tr>
<tr><td style="text-align: left"><code>select</code></td><td style="text-align: left">用于加载复杂类型属性的映射语句的 ID，它会从 column 属性中指定的列检索数据，作为参数传递给此 select 语句。具体请参考关联元素。</td></tr>
<tr><td style="text-align: left"><code>resultMap</code></td><td style="text-align: left">结果映射的 ID，可以将嵌套的结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 <code>ResultSet</code>。这样的 <code>ResultSet</code> 将会将包含重复或部分数据重复的结果集。为了将结果集正确地映射到嵌套的对象树中，MyBatis 允许你 “串联”结果映射，以便解决嵌套结果集的问题。想了解更多内容，请参考下面的关联元素。</td></tr>
<tr><td style="text-align: left"><code>name</code></td><td style="text-align: left">构造方法形参的名字。从 3.4.3 版本开始，通过指定具体的参数名，你可以以任意顺序写入 arg 元素。参看上面的解释。</td></tr>
</tbody></table>
<h4 id="关联"><a class="header" href="#关联">关联</a></h4>
<p>MyBatis 有两种不同的方式加载关联：</p>
<ul>
<li>嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。</li>
<li>嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。</li>
</ul>
<h4 id="关联的嵌套-select-查询的"><a class="header" href="#关联的嵌套-select-查询的">关联的嵌套 Select 查询的</a></h4>
<table><thead><tr><th style="text-align: left">属性</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>column</code></td><td style="text-align: left">数据库中的列名，或者是列的别名。一般情况下，这和传递给 <code>resultSet.getString(columnName)</code> 方法的参数一样。 注意：在使用复合主键的时候，你可以使用 <code>column=&quot;{prop1=col1,prop2=col2}&quot;</code> 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 <code>prop1</code> 和 <code>prop2</code> 作为参数对象，被设置为对应嵌套 Select 语句的参数。</td></tr>
<tr><td style="text-align: left"><code>select</code></td><td style="text-align: left">用于加载复杂类型属性的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用 <code>column=&quot;{prop1=col1,prop2=col2}&quot;</code> 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 <code>prop1</code> 和 <code>prop2</code> 作为参数对象，被设置为对应嵌套 Select 语句的参数。</td></tr>
<tr><td style="text-align: left"><code>fetchType</code></td><td style="text-align: left">可选的。有效值为 <code>lazy</code> 和 <code>eager</code>。 指定属性后，将在映射中忽略全局配置参数 <code>lazyLoadingEnabled</code>，使用属性的值。</td></tr>
</tbody></table>
<pre><code>&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;selectAuthor&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  SELECT * FROM BLOG WHERE ID = #{id}
&lt;/select&gt;

&lt;select id=&quot;selectAuthor&quot; resultType=&quot;Author&quot;&gt;
  SELECT * FROM AUTHOR WHERE ID = #{id}
&lt;/select&gt;
</code></pre>
<h4 id="关联的嵌套结果映射"><a class="header" href="#关联的嵌套结果映射">关联的嵌套结果映射</a></h4>
<table><thead><tr><th style="text-align: left">属性</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>resultMap</code></td><td style="text-align: left">结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 <code>ResultSet</code>。这样的 <code>ResultSet</code> 有部分数据是重复的。 为了将结果集正确地映射到嵌套的对象树中, MyBatis 允许你“串联”结果映射，以便解决嵌套结果集的问题。使用嵌套结果映射的一个例子在表格以后。</td></tr>
<tr><td style="text-align: left"><code>columnPrefix</code></td><td style="text-align: left">当连接多个表时，你可能会不得不使用列别名来避免在 <code>ResultSet</code> 中产生重复的列名。指定 columnPrefix 列名前缀允许你将带有这些前缀的列映射到一个外部的结果映射中。 详细说明请参考后面的例子。</td></tr>
<tr><td style="text-align: left"><code>notNullColumn</code></td><td style="text-align: left">默认情况下，在至少一个被映射到属性的列不为空时，子对象才会被创建。 你可以在这个属性上指定非空的列来改变默认行为，指定后，Mybatis 将只在这些列非空时才创建一个子对象。可以使用逗号分隔来指定多个列。默认值：未设置（unset）。</td></tr>
<tr><td style="text-align: left"><code>autoMapping</code></td><td style="text-align: left">如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。注意，本属性对外部的结果映射无效，所以不能搭配 <code>select</code> 或 <code>resultMap</code> 元素使用。默认值：未设置（unset）。</td></tr>
</tbody></table>
<h4 id="关联的多结果集resultset"><a class="header" href="#关联的多结果集resultset">关联的多结果集（ResultSet）</a></h4>
<pre><code>SELECT * FROM BLOG WHERE ID = #{id}

SELECT * FROM AUTHOR WHERE ID = #{id}

&lt;select id=&quot;selectBlog&quot; resultSets=&quot;blogs,authors&quot; resultMap=&quot;blogResult&quot; statementType=&quot;CALLABLE&quot;&gt;
  {call getBlogsAndAuthors(#{id,jdbcType=INTEGER,mode=IN})}
&lt;/select&gt;

&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;
  &lt;association property=&quot;author&quot; javaType=&quot;Author&quot; resultSet=&quot;authors&quot; column=&quot;author_id&quot; foreignColumn=&quot;id&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;
    &lt;result property=&quot;password&quot; column=&quot;password&quot;/&gt;
    &lt;result property=&quot;email&quot; column=&quot;email&quot;/&gt;
    &lt;result property=&quot;bio&quot; column=&quot;bio&quot;/&gt;
  &lt;/association&gt;
&lt;/resultMap&gt;
</code></pre>
<p>存储过程执行下面的查询并返回两个结果集</p>
<h4 id="集合嵌套-select-查询"><a class="header" href="#集合嵌套-select-查询">集合嵌套 select 查询</a></h4>
<pre><code>&lt;collection property=&quot;posts&quot; ofType=&quot;domain.blog.Post&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
  &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
  &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt;
&lt;/collection&gt;

&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;collection property=&quot;posts&quot; javaType=&quot;ArrayList&quot; column=&quot;id&quot; ofType=&quot;Post&quot; select=&quot;selectPostsForBlog&quot;/&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;selectBlog&quot; resultMap=&quot;blogResult&quot;&gt;
  SELECT * FROM BLOG WHERE ID = #{id}
&lt;/select&gt;
&lt;select id=&quot;selectPostsForBlog&quot; resultType=&quot;Post&quot;&gt;
  SELECT * FROM POST WHERE BLOG_ID = #{id}
&lt;/select&gt;
</code></pre>
<h4 id="集合的嵌套结果映射"><a class="header" href="#集合的嵌套结果映射">集合的嵌套结果映射</a></h4>
<pre><code>&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;blog_id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;
</code></pre>
<h4 id="集合的多结果集resultset"><a class="header" href="#集合的多结果集resultset">集合的多结果集（ResultSet）</a></h4>
<pre><code>&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt;
  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot; resultSet=&quot;posts&quot; column=&quot;id&quot; foreignColumn=&quot;blog_id&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
    &lt;result property=&quot;subject&quot; column=&quot;subject&quot;/&gt;
    &lt;result property=&quot;body&quot; column=&quot;body&quot;/&gt;
  &lt;/collection&gt;
&lt;/resultMap&gt;
</code></pre>
<h4 id="鉴别器"><a class="header" href="#鉴别器">鉴别器</a></h4>
<pre><code>&lt;discriminator javaType=&quot;int&quot; column=&quot;draft&quot;&gt;
  &lt;case value=&quot;1&quot; resultType=&quot;DraftPost&quot;/&gt;
&lt;/discriminator&gt;
</code></pre>
<ul>
<li>
<p>一个数据库查询可能会返回多个不同的结果集</p>
</li>
<li>
<p>一个鉴别器的定义需要指定 column 和 javaType 属性。</p>
</li>
<li>
<p>column 指定了 MyBatis 查询被比较值的地方。 而 javaType 用来确保使用正确的相等测试</p>
</li>
<li>
<p>用什么字段 怎么测</p>
</li>
</ul>
<pre><code>&lt;resultMap id=&quot;vehicleResult&quot; type=&quot;Vehicle&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
  &lt;result property=&quot;vin&quot; column=&quot;vin&quot;/&gt;
  &lt;result property=&quot;year&quot; column=&quot;year&quot;/&gt;
  &lt;result property=&quot;make&quot; column=&quot;make&quot;/&gt;
  &lt;result property=&quot;model&quot; column=&quot;model&quot;/&gt;
  &lt;result property=&quot;color&quot; column=&quot;color&quot;/&gt;
  &lt;discriminator javaType=&quot;int&quot; column=&quot;vehicle_type&quot;&gt;
    &lt;case value=&quot;1&quot; resultMap=&quot;carResult&quot;/&gt;
    &lt;case value=&quot;2&quot; resultMap=&quot;truckResult&quot;/&gt;
    &lt;case value=&quot;3&quot; resultMap=&quot;vanResult&quot;/&gt;
    &lt;case value=&quot;4&quot; resultMap=&quot;suvResult&quot;/&gt;
  &lt;/discriminator&gt;
&lt;/resultMap&gt;
</code></pre>
<h4 id="自动映射"><a class="header" href="#自动映射">自动映射</a></h4>
<ol>
<li>MyBatis 会获取结果中返回的列名并在 Java 类中查找相同名字的属性（忽略大小写）</li>
<li>驼峰命名 与 下划线命名 转换 需要将 <code>mapUnderscoreToCamelCase</code> 设置为 true。</li>
<li>对于每一个结果映射，在 ResultSet 出现的列，如果没有设置手动映射，将被自动映射。在自动映射处理完毕后，再处理手动映射</li>
</ol>
<p>有三种自动映射等级：</p>
<ul>
<li><code>NONE</code> - 禁用自动映射。仅对手动映射的属性进行映射。</li>
<li><code>PARTIAL</code> - 对除在内部定义了嵌套结果映射（也就是连接的属性）以外的属性进行映射</li>
<li><code>FULL</code> - 自动映射所有属性。</li>
</ul>
<h3 id="缓存-1"><a class="header" href="#缓存-1">缓存</a></h3>
<ul>
<li>默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存</li>
<li>要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：<code>&lt;cache/&gt;</code></li>
</ul>
<h4 id="缓存规则"><a class="header" href="#缓存规则">缓存规则</a></h4>
<ul>
<li>
<p>映射语句文件中的所有 select 语句的结果将会被缓存。</p>
</li>
<li>
<p>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</p>
</li>
<li>
<p>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</p>
</li>
<li>
<p>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</p>
</li>
<li>
<p>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</p>
</li>
<li>
<p>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</p>
<pre><code>&lt;cache
  eviction=&quot;FIFO&quot;
  flushInterval=&quot;60000&quot;
  size=&quot;512&quot;
  readOnly=&quot;true&quot;/&gt;
</code></pre>
</li>
</ul>
<h4 id="清理策略"><a class="header" href="#清理策略">清理策略</a></h4>
<ul>
<li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li>
<li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li>
<li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li>
<li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li>
</ul>
<p>二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache=true 的 insert/delete/update 语句时，缓存会获得更新。</p>
<h4 id="使用自定义缓存"><a class="header" href="#使用自定义缓存">使用自定义缓存</a></h4>
<pre><code>&lt;cache type=&quot;com.domain.something.MyCustomCache&quot;/&gt;

public interface Cache {
  String getId();
  int getSize();
  void putObject(Object key, Object value);
  Object getObject(Object key);
  boolean hasKey(Object key);
  Object removeObject(Object key);
  void clear();
}

&lt;cache type=&quot;com.domain.something.MyCustomCache&quot;&gt;
  &lt;property name=&quot;cacheFile&quot; value=&quot;/tmp/my-custom-cache.tmp&quot;/&gt;
&lt;/cache&gt;
</code></pre>
<p>注意事项</p>
<ul>
<li>缓存的配置和缓存实例会被绑定到 SQL 映射文件的命名空间中</li>
<li>同一命名空间中的所有语句和缓存将通过命名空间绑定在一起</li>
<li>每条语句可以自定义与缓存交互的方式</li>
<li>共享不同命名空间缓存</li>
</ul>
<pre><code>&lt;cache-ref namespace=&quot;com.someone.application.data.SomeMapper&quot;/&gt;
</code></pre>
<pre><code>&lt;select ... flushCache=&quot;false&quot; useCache=&quot;true&quot;/&gt;
</code></pre>
<h2 id="动态-sql"><a class="header" href="#动态-sql">动态 sql</a></h2>
<p><a href="25.ORM_MyBatis/mybatis%E6%A0%87%E7%AD%BE.html">动态 sql</a></p>
<h2 id="sql-语句-javaapi-构建"><a class="header" href="#sql-语句-javaapi-构建">sql 语句 javaAPI 构建</a></h2>
<h3 id="示例-10"><a class="header" href="#示例-10">示例</a></h3>
<h4 id="示例-1"><a class="header" href="#示例-1">示例 1</a></h4>
<pre><code>private String selectPersonSql() {
  return new SQL() {{
    SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME&quot;);
    SELECT(&quot;P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON&quot;);
    FROM(&quot;PERSON P&quot;);
    FROM(&quot;ACCOUNT A&quot;);
    INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;);
    INNER_JOIN(&quot;COMPANY C on D.COMPANY_ID = C.ID&quot;);
    WHERE(&quot;P.ID = A.ID&quot;);
    WHERE(&quot;P.FIRST_NAME like ?&quot;);
    OR();
    WHERE(&quot;P.LAST_NAME like ?&quot;);
    GROUP_BY(&quot;P.ID&quot;);
    HAVING(&quot;P.LAST_NAME like ?&quot;);
    OR();
    HAVING(&quot;P.FIRST_NAME like ?&quot;);
    ORDER_BY(&quot;P.ID&quot;);
    ORDER_BY(&quot;P.FULL_NAME&quot;);
  }}.toString();
}
</code></pre>
<h4 id="示例-2"><a class="header" href="#示例-2">示例 2</a></h4>
<pre><code>// 匿名内部类风格
public String deletePersonSql() {
  return new SQL() {{
    DELETE_FROM(&quot;PERSON&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  }}.toString();
}

// Builder / Fluent 风格
public String insertPersonSql() {
  String sql = new SQL()
    .INSERT_INTO(&quot;PERSON&quot;)
    .VALUES(&quot;ID, FIRST_NAME&quot;, &quot;#{id}, #{firstName}&quot;)
    .VALUES(&quot;LAST_NAME&quot;, &quot;#{lastName}&quot;)
    .toString();
  return sql;
}

// 动态条件（注意参数需要使用 final 修饰，以便匿名内部类对它们进行访问）
public String selectPersonLike(final String id, final String firstName, final String lastName) {
  return new SQL() {{
    SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME&quot;);
    FROM(&quot;PERSON P&quot;);
    if (id != null) {
      WHERE(&quot;P.ID like #{id}&quot;);
    }
    if (firstName != null) {
      WHERE(&quot;P.FIRST_NAME like #{firstName}&quot;);
    }
    if (lastName != null) {
      WHERE(&quot;P.LAST_NAME like #{lastName}&quot;);
    }
    ORDER_BY(&quot;P.LAST_NAME&quot;);
  }}.toString();
}

public String deletePersonSql() {
  return new SQL() {{
    DELETE_FROM(&quot;PERSON&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  }}.toString();
}

public String insertPersonSql() {
  return new SQL() {{
    INSERT_INTO(&quot;PERSON&quot;);
    VALUES(&quot;ID, FIRST_NAME&quot;, &quot;#{id}, #{firstName}&quot;);
    VALUES(&quot;LAST_NAME&quot;, &quot;#{lastName}&quot;);
  }}.toString();
}

public String updatePersonSql() {
  return new SQL() {{
    UPDATE(&quot;PERSON&quot;);
    SET(&quot;FIRST_NAME = #{firstName}&quot;);
    WHERE(&quot;ID = #{id}&quot;);
  }}.toString();
}
</code></pre>
<h3 id="构建-sql-的-api"><a class="header" href="#构建-sql-的-api">构建 sql 的 API</a></h3>
<table><thead><tr><th>方法</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td><code>SELECT(String)``SELECT(String...)</code></td><td style="text-align: left">开始新的或追加到已有的 <code>SELECT</code>子句。可以被多次调用，参数会被追加到 <code>SELECT</code> 子句。 参数通常使用逗号分隔的列名和别名列表，但也可以是数据库驱动程序接受的任意参数。</td></tr>
<tr><td><code>SELECT_DISTINCT(String)</code><br /><code>SELECT_DISTINCT(String...)</code></td><td style="text-align: left">开始新的或追加到已有的 <code>SELECT</code>子句，并添加 <code>DISTINCT</code> 关键字到生成的查询中。可以被多次调用，参数会被追加到 <code>SELECT</code> 子句。 参数通常使用逗号分隔的列名和别名列表，但也可以是数据库驱动程序接受的任意参数。</td></tr>
<tr><td><code>FROM(String)``FROM(String...)</code></td><td style="text-align: left">开始新的或追加到已有的 <code>FROM</code>子句。可以被多次调用，参数会被追加到 <code>FROM</code>子句。 参数通常是一个表名或别名，也可以是数据库驱动程序接受的任意参数。</td></tr>
<tr><td><code>JOIN(String)</code><br /><code>JOIN(String...)</code><br /><code>INNER_JOIN(String)</code><br /><code>INNER_JOIN(String...)</code><br /><code>LEFT_OUTER_JOIN(String)</code><br /><code>LEFT_OUTER_JOIN(String...)</code><br /><code>RIGHT_OUTER_JOIN(String)</code><br /><code>RIGHT_OUTER_JOIN(String...)</code></td><td style="text-align: left">基于调用的方法，添加新的合适类型的 <code>JOIN</code> 子句。 参数可以包含一个由列和连接条件构成的标准连接。</td></tr>
<tr><td><code>WHERE(String)</code><br /><code>WHERE(String...)</code></td><td style="text-align: left">插入新的 <code>WHERE</code> 子句条件，并使用 <code>AND</code> 拼接。可以被多次调用，对于每一次调用产生的新条件，会使用 <code>AND</code> 拼接起来。要使用 <code>OR</code> 分隔，请使用 <code>OR()</code>。</td></tr>
<tr><td><code>OR()</code></td><td style="text-align: left">使用 <code>OR</code> 来分隔当前的 <code>WHERE</code> 子句条件。 可以被多次调用，但在一行中多次调用会生成错误的 <code>SQL</code>。</td></tr>
<tr><td><code>AND()</code></td><td style="text-align: left">使用 <code>AND</code> 来分隔当前的 <code>WHERE</code>子句条件。 可以被多次调用，但在一行中多次调用会生成错误的 <code>SQL</code>。由于 <code>WHERE</code> 和 <code>HAVING</code>都会自动使用 <code>AND</code> 拼接, 因此这个方法并不常用，只是为了完整性才被定义出来。</td></tr>
<tr><td><code>GROUP_BY(String)</code><br /><code>GROUP_BY(String...)</code></td><td style="text-align: left">追加新的 <code>GROUP BY</code> 子句，使用逗号拼接。可以被多次调用，每次调用都会使用逗号将新的条件拼接起来。</td></tr>
<tr><td><code>HAVING(String)</code><br /><code>HAVING(String...)</code></td><td style="text-align: left">追加新的 <code>HAVING</code> 子句。使用 AND 拼接。可以被多次调用，每次调用都使用<code>AND</code>来拼接新的条件。要使用 <code>OR</code> 分隔，请使用 <code>OR()</code>。</td></tr>
<tr><td><code>ORDER_BY(String)</code><br /><code>ORDER_BY(String...)</code></td><td style="text-align: left">追加新的 <code>ORDER BY</code> 子句，使用逗号拼接。可以多次被调用，每次调用会使用逗号拼接新的条件。</td></tr>
<tr><td><code>LIMIT(String)``LIMIT(int)</code></td><td style="text-align: left">追加新的 <code>LIMIT</code> 子句。 仅在 SELECT()、UPDATE()、DELETE() 时有效。 当在 SELECT() 中使用时，应该配合 OFFSET() 使用。（于 3.5.2 引入）</td></tr>
<tr><td><code>OFFSET(String)``OFFSET(long)</code></td><td style="text-align: left">追加新的 <code>OFFSET</code> 子句。 仅在 SELECT() 时有效。 当在 SELECT() 时使用时，应该配合 LIMIT() 使用。（于 3.5.2 引入）</td></tr>
<tr><td><code>OFFSET_ROWS(String)</code><br /><code>OFFSET_ROWS(long)</code></td><td style="text-align: left">追加新的 <code>OFFSET n ROWS</code> 子句。 仅在 SELECT() 时有效。 该方法应该配合 FETCH_FIRST_ROWS_ONLY() 使用。（于 3.5.2 加入）</td></tr>
<tr><td><code>FETCH_FIRST_ROWS_ONLY(String)</code><br /><code>FETCH_FIRST_ROWS_ONLY(int)</code></td><td style="text-align: left">追加新的 <code>FETCH FIRST n ROWS ONLY</code> 子句。 仅在 SELECT() 时有效。 该方法应该配合 OFFSET_ROWS() 使用。（于 3.5.2 加入）</td></tr>
<tr><td><code>DELETE_FROM(String)</code></td><td style="text-align: left">开始新的 delete 语句，并指定删除表的表名。通常它后面都会跟着一个 WHERE 子句！</td></tr>
<tr><td><code>INSERT_INTO(String)</code></td><td style="text-align: left">开始新的 insert 语句，并指定插入数据表的表名。后面应该会跟着一个或多个 VALUES() 调用，或 INTO_COLUMNS() 和 INTO_VALUES() 调用。</td></tr>
<tr><td><code>SET(String)``SET(String...)</code></td><td style="text-align: left">对 update 语句追加 &quot;set&quot; 属性的列表</td></tr>
<tr><td><code>UPDATE(String)</code></td><td style="text-align: left">开始新的 update 语句，并指定更新表的表名。后面都会跟着一个或多个 SET() 调用，通常也会有一个 WHERE() 调用。</td></tr>
<tr><td><code>VALUES(String, String)</code></td><td style="text-align: left">追加数据值到 insert 语句中。第一个参数是数据插入的列名，第二个参数则是数据值。</td></tr>
<tr><td><code>INTO_COLUMNS(String...)</code></td><td style="text-align: left">追加插入列子句到 insert 语句中。应与 INTO_VALUES() 一同使用。</td></tr>
<tr><td><code>INTO_VALUES(String...)</code></td><td style="text-align: left">追加插入值子句到 insert 语句中。应与 INTO_COLUMNS() 一同使用。</td></tr>
<tr><td><code>ADD_ROW()</code></td><td style="text-align: left">添加新的一行数据，以便执行批量插入。（于 3.5.2 引入）</td></tr>
</tbody></table>
<p>从版本 3.4.2 开始，你可以像下面这样使用可变长度参数：</p>
<pre><code class="language-java">public String selectPersonSql() {
  return new SQL()
    .SELECT(&quot;P.ID&quot;, &quot;A.USERNAME&quot;, &quot;A.PASSWORD&quot;, &quot;P.FULL_NAME&quot;, &quot;D.DEPARTMENT_NAME&quot;, &quot;C.COMPANY_NAME&quot;)
    .FROM(&quot;PERSON P&quot;, &quot;ACCOUNT A&quot;)
    .INNER_JOIN(&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;, &quot;COMPANY C on D.COMPANY_ID = C.ID&quot;)
    .WHERE(&quot;P.ID = A.ID&quot;, &quot;P.FULL_NAME like #{name}&quot;)
    .ORDER_BY(&quot;P.ID&quot;, &quot;P.FULL_NAME&quot;)
    .toString();
}
public String updatePersonSql() {
  return new SQL().UPDATE(&quot;PERSON&quot;).SET(&quot;FULL_NAME = #{fullName}&quot;, &quot;DATE_OF_BIRTH = #{dateOfBirth}&quot;).WHERE(&quot;ID = #{id}&quot;).toString();
}
public String insertPersonSql() {
  return new SQL()
    .INSERT_INTO(&quot;PERSON&quot;)
    .INTO_COLUMNS(&quot;ID&quot;, &quot;FULL_NAME&quot;)
    .INTO_VALUES(&quot;#{id}&quot;, &quot;#{fullName}&quot;)
    .toString();
}

</code></pre>
<p><code>&gt;3.5.2</code>构建批量插入语句：</p>
<pre><code class="language-java">public String insertPersonsSql() {
  // INSERT INTO PERSON (ID, FULL_NAME)
  //     VALUES (#{mainPerson.id}, #{mainPerson.fullName}) , (#{subPerson.id}, #{subPerson.fullName})
  return new SQL()
    .INSERT_INTO(&quot;PERSON&quot;)
    .INTO_COLUMNS(&quot;ID&quot;, &quot;FULL_NAME&quot;)
    .INTO_VALUES(&quot;#{mainPerson.id}&quot;, &quot;#{mainPerson.fullName}&quot;)
    .ADD_ROW()
    .INTO_VALUES(&quot;#{subPerson.id}&quot;, &quot;#{subPerson.fullName}&quot;)
    .toString();
}
</code></pre>
<p><code>&gt;3.5.2</code>限制返回结果数的 SELECT 语句</p>
<pre><code class="language-java">public String selectPersonsWithOffsetLimitSql() {
  // SELECT id, name FROM PERSON
  //     LIMIT #{limit} OFFSET #{offset}
  return new SQL()
    .SELECT(&quot;id&quot;, &quot;name&quot;)
    .FROM(&quot;PERSON&quot;)
    .LIMIT(&quot;#{limit}&quot;)
    .OFFSET(&quot;#{offset}&quot;)
    .toString();
}

public String selectPersonsWithFetchFirstSql() {
  // SELECT id, name FROM PERSON
  //     OFFSET #{offset} ROWS FETCH FIRST #{limit} ROWS ONLY
  return new SQL()
    .SELECT(&quot;id&quot;, &quot;name&quot;)
    .FROM(&quot;PERSON&quot;)
    .OFFSET_ROWS(&quot;#{offset}&quot;)
    .FETCH_FIRST_ROWS_ONLY(&quot;#{limit}&quot;)
    .toString();
}
</code></pre>
<h3 id="基于注解的-sql-开发"><a class="header" href="#基于注解的-sql-开发">基于注解的 sql 开发</a></h3>
<h4 id="读取数据库自动生成的主键"><a class="header" href="#读取数据库自动生成的主键">读取数据库自动生成的主键</a></h4>
<pre><code>@Insert(&quot;insert into table3 (id, name) values(#{nameId}, #{name})&quot;)
@SelectKey(statement=&quot;call next value for TestSequence&quot;, keyProperty=&quot;nameId&quot;, before=true, resultType=int.class)
int insertTable3(Name name);
</code></pre>
<pre><code>@Insert(&quot;insert into table2 (name) values(#{name})&quot;)
@SelectKey(statement=&quot;call identity()&quot;, keyProperty=&quot;nameId&quot;, before=false, resultType=int.class)
int insertTable2(Name name);
</code></pre>
<h4 id="自动刷新"><a class="header" href="#自动刷新">自动刷新</a></h4>
<pre><code>@Flush
List&lt;BatchResult&gt; flush();
</code></pre>
<h4 id="命名结果集"><a class="header" href="#命名结果集">命名结果集</a></h4>
<pre><code class="language-java">@Results(id = &quot;userResult&quot;, value = {
  @Result(property = &quot;id&quot;, column = &quot;uid&quot;, id = true),
  @Result(property = &quot;firstName&quot;, column = &quot;first_name&quot;),
  @Result(property = &quot;lastName&quot;, column = &quot;last_name&quot;)
})
@Select(&quot;select * from users where id = #{id}&quot;)
User getUserById(Integer id);

@Results(id = &quot;companyResults&quot;)
@ConstructorArgs({
  @Arg(column = &quot;cid&quot;, javaType = Integer.class, id = true),
  @Arg(column = &quot;name&quot;, javaType = String.class)
})
@Select(&quot;select * from company where id = #{id}&quot;)
Company getCompanyById(Integer id);
</code></pre>
<h4 id="使用-sqlprovider"><a class="header" href="#使用-sqlprovider">使用 sqlprovider</a></h4>
<pre><code class="language-java">@SelectProvider(type = UserSqlBuilder.class, method = &quot;buildGetUsersByName&quot;)
List&lt;User&gt; getUsersByName(String name);

class UserSqlBuilder {
  public static String buildGetUsersByName(final String name) {
    return new SQL(){{
      SELECT(&quot;*&quot;);
      FROM(&quot;users&quot;);
      if (name != null) {
        WHERE(&quot;name like #{value} || '%'&quot;);
      }
      ORDER_BY(&quot;id&quot;);
    }}.toString();
  }
}
</code></pre>
<pre><code class="language-java">@SelectProvider(type = UserSqlBuilder.class, method = &quot;buildGetUsersByName&quot;)
List&lt;User&gt; getUsersByName(String name);

class UserSqlBuilder {
  public static String buildGetUsersByName(final String name) {
    return new SQL(){{
      SELECT(&quot;*&quot;);
      FROM(&quot;users&quot;);
      if (name != null) {
        WHERE(&quot;name like #{value} || '%'&quot;);
      }
      ORDER_BY(&quot;id&quot;);
    }}.toString();
  }
}
</code></pre>
<pre><code class="language-java">@SelectProvider(type = UserSqlBuilder.class, method = &quot;buildGetUsersByName&quot;)
List&lt;User&gt; getUsersByName(
    @Param(&quot;name&quot;) String name, @Param(&quot;orderByColumn&quot;) String orderByColumn);

class UserSqlBuilder {

  // 如果不使用 @Param，就应该定义与 mapper 方法相同的参数
  public static String buildGetUsersByName(
      final String name, final String orderByColumn) {
    return new SQL(){{
      SELECT(&quot;*&quot;);
      FROM(&quot;users&quot;);
      WHERE(&quot;name like #{name} || '%'&quot;);
      ORDER_BY(orderByColumn);
    }}.toString();
  }

  // 如果使用 @Param，就可以只定义需要使用的参数
  public static String buildGetUsersByName(@Param(&quot;orderByColumn&quot;) final String orderByColumn) {
    return new SQL(){{
      SELECT(&quot;*&quot;);
      FROM(&quot;users&quot;);
      WHERE(&quot;name like #{name} || '%'&quot;);
      ORDER_BY(orderByColumn);
    }}.toString();
  }
}
</code></pre>
<p>以下例子展示了 <code>ProviderMethodResolver</code>（3.5.1 后可用）的默认实现使用方法：</p>
<pre><code class="language-java">@SelectProvider(UserSqlProvider.class)
List&lt;User&gt; getUsersByName(String name);

// 在你的 provider 类中实现 ProviderMethodResolver 接口
class UserSqlProvider implements ProviderMethodResolver {
  // 默认实现中，会将映射器方法的调用解析到实现的同名方法上
  public static String getUsersByName(final String name) {
    return new SQL(){{
      SELECT(&quot;*&quot;);
      FROM(&quot;users&quot;);
      if (name != null) {
        WHERE(&quot;name like #{value} || '%'&quot;);
      }
      ORDER_BY(&quot;id&quot;);
    }}.toString();
  }
}
</code></pre>
<pre><code class="language-java">@Select(value = &quot;SELECT SYS_GUID() FROM dual&quot;, databaseId = &quot;oracle&quot;) // Use this statement if DatabaseIdProvider provide &quot;oracle&quot;
@Select(value = &quot;SELECT uuid_generate_v4()&quot;, databaseId = &quot;postgres&quot;) // Use this statement if DatabaseIdProvider provide &quot;postgres&quot;
@Select(&quot;SELECT RANDOM_UUID()&quot;) // Use this statement if the DatabaseIdProvider not configured or not matches databaseId
String generateId();
</code></pre>
<h2 id="日志"><a class="header" href="#日志">日志</a></h2>
<h3 id="自动查找实现"><a class="header" href="#自动查找实现">自动查找实现</a></h3>
<p>Mybatis 通过使用内置的日志工厂提供日志功能,内置日志工厂将会把日志工作委托给下面的实现之一</p>
<ul>
<li>SLF4J</li>
<li>Apache Commons Logging</li>
<li>Log4j 2</li>
<li>Log4j</li>
<li>JDK logging</li>
</ul>
<p>MyBatis 内置日志工厂会基于运行时检测信息选择日志委托实现。它会（按上面罗列的顺序）使用第一个查找到的实现。当没有找到这些实现时，将会禁用日志功能</p>
<h3 id="手动配置"><a class="header" href="#手动配置">手动配置</a></h3>
<pre><code class="language-xml">&lt;configuration&gt;
  &lt;settings&gt;
    ...
    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;
    ...
  &lt;/settings&gt;
&lt;/configuration&gt;

</code></pre>
<p>可选的值有：SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING，或者是实现了 <code>org.apache.ibatis.logging.Log</code> 接口，且构造方法以字符串为参数的类完全限定名。</p>
<p>你也可以调用以下任一方法来选择日志实现：</p>
<pre><code class="language-properties">org.apache.ibatis.logging.LogFactory.useSlf4jLogging();
org.apache.ibatis.logging.LogFactory.useLog4JLogging();
org.apache.ibatis.logging.LogFactory.useJdkLogging();
org.apache.ibatis.logging.LogFactory.useCommonsLogging();
org.apache.ibatis.logging.LogFactory.useStdOutLogging();
</code></pre>
<h3 id="日志控制"><a class="header" href="#日志控制">日志控制</a></h3>
<p>只打印特定语句的日志。以下配置将只打印语句 <code>selectBlog</code> 的日志</p>
<pre><code class="language-properties">log4j.logger.org.mybatis.example.BlogMapper.selectBlog=TRACE
log4j.logger.org.mybatis.example=TRACE
log4j.logger.org.mybatis.example=DEBUG -- 只查看sql语句 不查看返回结果集
</code></pre>
<p>而要记录具体语句的日志，可以这样做：</p>
<pre><code>log4j.logger.org.mybatis.example.BlogMapper.selectBlog=TRACE
</code></pre>
<!-- endtoc -->
<p>{% endraw %}</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mybatis插件介绍"><a class="header" href="#mybatis插件介绍">mybatis插件介绍</a></h1>
<h2 id="什么是插件"><a class="header" href="#什么是插件">什么是插件</a></h2>
<p>与其称为Mybatis插件，不如叫Mybatis拦截器，更加符合其功能定位，实际上它就是一个拦截器，应用代理模式，在方法级别上进行拦截。</p>
<h2 id="支持拦截的方法"><a class="header" href="#支持拦截的方法">支持拦截的方法</a></h2>
<ul>
<li>执行器Executor（update、query、commit、rollback等方法）；</li>
<li>参数处理器ParameterHandler（getParameterObject、setParameters方法）；</li>
<li>结果集处理器ResultSetHandler（handleResultSets、handleOutputParameters等方法）；</li>
<li>SQL语法构建器StatementHandler（prepare、parameterize、batch、update、query等方法）；</li>
</ul>
<h2 id="拦截阶段"><a class="header" href="#拦截阶段">拦截阶段</a></h2>
<h1 id="mybatis插件场景"><a class="header" href="#mybatis插件场景">mybatis插件场景</a></h1>
<blockquote>
<p>Mybatis插件可以在DAO层进行拦截，如打印执行的SQL语句日志，做一些权限控制，分页等功能</p>
</blockquote>
<h2 id="分页功能"><a class="header" href="#分页功能">分页功能</a></h2>
<p>​	mybatis的分页默认是基于内存分页的（查出所有，再截取），数据量大的情况下效率较低，不过使用mybatis插件可以改变该行为，只需要拦截StatementHandler类的prepare方法，改变要执行的SQL语句为分页语句即可；</p>
<h2 id="公共字段统一赋值"><a class="header" href="#公共字段统一赋值">公共字段统一赋值</a></h2>
<p>​	一般业务系统都会有创建者，创建时间，修改者，修改时间四个字段，对于这四个字段的赋值，实际上可以在DAO层统一拦截处理，可以用mybatis插件拦截Executor类的update方法，对相关参数进行统一赋值即可；</p>
<h2 id="性能监控"><a class="header" href="#性能监控">性能监控</a></h2>
<p>​	对于SQL语句执行的性能监控，可以通过拦截Executor类的update, query等方法，用日志记录每个方法执行的时间；</p>
<h1 id="mybatis-sql抽象"><a class="header" href="#mybatis-sql抽象">mybatis SQL抽象</a></h1>
<h2 id="mappedstatement"><a class="header" href="#mappedstatement">MappedStatement</a></h2>
<pre><code class="language-csharp">&lt;select id=&quot;selectAuthorLinkedHashMap&quot; resultType=&quot;java.util.LinkedHashMap&quot;&gt;
        select id, username from author where id = #{value}
&lt;/select&gt;
</code></pre>
<p>一个sql标签 对应 一个  MappedStatement对象</p>
<h2 id="sqlsource"><a class="header" href="#sqlsource">SqlSource</a></h2>
<p>负责根据用户传递的parameterObject,动态地生成SQL语句,将信息封装到BoundSql对象中，并返回</p>
<h2 id="boundsql"><a class="header" href="#boundsql">BoundSql</a></h2>
<p>表示动态生成的SQL语句以及相应的参数信息</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreach"><a class="header" href="#foreach">foreach</a></h1>
<pre><code class="language-xml">     &lt;foreach collection=&quot;map&quot; index=&quot;key&quot; item=&quot;value&quot; open=&quot;&quot; separator=&quot;,&quot; close=&quot;&quot;&gt;
        (#{key,jdbcType=VARCHAR},#{value,jdbcType=VARCHAR})
      &lt;/foreach&gt;
</code></pre>
<h1 id="if"><a class="header" href="#if">if</a></h1>
<pre><code>&lt;if test=&quot;title != null&quot;&gt;
    AND title like #{title}
  &lt;/if&gt;
</code></pre>
<h1 id="choosewhenotherwise"><a class="header" href="#choosewhenotherwise">choose、when、otherwise</a></h1>
<pre><code> &lt;choose&gt;
    &lt;when test=&quot;title != null&quot;&gt;
      AND title like #{title}
    &lt;/when&gt;
    &lt;when test=&quot;author != null and author.name != null&quot;&gt;
      AND author_name like #{author.name}
    &lt;/when&gt;
    &lt;otherwise&gt;
      AND featured = 1
    &lt;/otherwise&gt;
  &lt;/choose&gt;
</code></pre>
<h1 id="trimwhereset"><a class="header" href="#trimwhereset">trim、where、set</a></h1>
<pre><code class="language-xml">  &lt;where&gt;
    &lt;if test=&quot;state != null&quot;&gt;
         state = #{state}
    &lt;/if&gt;
    &lt;if test=&quot;title != null&quot;&gt;
        AND title like #{title}
    &lt;/if&gt;
    &lt;if test=&quot;author != null and author.name != null&quot;&gt;
        AND author_name like #{author.name}
    &lt;/if&gt;
  &lt;/where&gt;
</code></pre>
<pre><code>&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;
  update Author
    &lt;set&gt;
      &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt;
      &lt;if test=&quot;password != null&quot;&gt;password=#{password},&lt;/if&gt;
      &lt;if test=&quot;email != null&quot;&gt;email=#{email},&lt;/if&gt;
      &lt;if test=&quot;bio != null&quot;&gt;bio=#{bio}&lt;/if&gt;
    &lt;/set&gt;
  where id=#{id}
&lt;/update&gt;
</code></pre>
<ul>
<li>where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句</li>
<li>而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除</li>
</ul>
<p>通过自定义 trim 元素来定制 <em>where</em>  或 set 元素的功能</p>
<pre><code>&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt;
  ...
&lt;/trim&gt;
</code></pre>
<pre><code>&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;
  ...
&lt;/trim&gt;
</code></pre>
<h1 id="foreach-1"><a class="header" href="#foreach-1">foreach</a></h1>
<pre><code>&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt;
  SELECT *
  FROM POST P
  WHERE ID in
  &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot;
      open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
        #{item}
  &lt;/foreach&gt;
&lt;/select&gt;
</code></pre>
<h1 id="script"><a class="header" href="#script">script</a></h1>
<p>在带注解的映射器接口类中使用动态 SQL，可以使用 <em>script</em> 元素。比如:</p>
<pre><code>    @Update({&quot;&lt;script&gt;&quot;,
      &quot;update Author&quot;,
      &quot;  &lt;set&gt;&quot;,
      &quot;    &lt;if test='username != null'&gt;username=#{username},&lt;/if&gt;&quot;,
      &quot;    &lt;if test='password != null'&gt;password=#{password},&lt;/if&gt;&quot;,
      &quot;    &lt;if test='email != null'&gt;email=#{email},&lt;/if&gt;&quot;,
      &quot;    &lt;if test='bio != null'&gt;bio=#{bio}&lt;/if&gt;&quot;,
      &quot;  &lt;/set&gt;&quot;,
      &quot;where id=#{id}&quot;,
      &quot;&lt;/script&gt;&quot;})
    void updateAuthorValues(Author author);
</code></pre>
<h1 id="bind"><a class="header" href="#bind">bind</a></h1>
<p><code>bind</code> 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：</p>
<pre><code>&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt;
  &lt;bind name=&quot;pattern&quot; value=&quot;'%' + _parameter.getTitle() + '%'&quot; /&gt;
  SELECT * FROM BLOG
  WHERE title LIKE #{pattern}
&lt;/select&gt;
</code></pre>
<h1 id="多数据库支持"><a class="header" href="#多数据库支持">多数据库支持</a></h1>
<p>如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句</p>
<pre><code>&lt;insert id=&quot;insert&quot;&gt;
  &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;
    &lt;if test=&quot;_databaseId == 'oracle'&quot;&gt;
      select seq_users.nextval from dual
    &lt;/if&gt;
    &lt;if test=&quot;_databaseId == 'db2'&quot;&gt;
      select nextval for seq_users from sysibm.sysdummy1&quot;
    &lt;/if&gt;
  &lt;/selectKey&gt;
  insert into users values (#{id}, #{name})
&lt;/insert&gt;
</code></pre>
<h1 id="动态-sql-中的插入脚本语言"><a class="header" href="#动态-sql-中的插入脚本语言">动态 SQL 中的插入脚本语言</a></h1>
<ul>
<li>MyBatis 从 3.2 版本开始支持插入脚本语言</li>
<li>这允许你插入一种语言驱动，并基于这种语言来编写动态 SQL 查询语句</li>
</ul>
<pre><code>public interface LanguageDriver {
  ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql);
  SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType);
  SqlSource createSqlSource(Configuration configuration, String script, Class&lt;?&gt; parameterType);
}
</code></pre>
<p>实现自定义语言驱动后，你就可以在 mybatis-config.xml 文件中将它设置为默认语言：</p>
<pre><code>&lt;typeAliases&gt;
  &lt;typeAlias type=&quot;org.sample.MyLanguageDriver&quot; alias=&quot;myLanguage&quot;/&gt;
&lt;/typeAliases&gt;
&lt;settings&gt;
  &lt;setting name=&quot;defaultScriptingLanguage&quot; value=&quot;myLanguage&quot;/&gt;
&lt;/settings&gt;

&lt;select id=&quot;selectBlog&quot; lang=&quot;myLanguage&quot;&gt;
  SELECT * FROM BLOG
&lt;/select&gt;

public interface Mapper {
  @Lang(MyLanguageDriver.class)
  @Select(&quot;SELECT * FROM BLOG&quot;)
  List&lt;Blog&gt; selectBlog();
}
</code></pre>
<p>可以使用 Apache Velocity 作为动态语言，更多细节请参考 MyBatis-Velocity 项目。</p>
<p>你前面看到的所有 xml 标签都由默认 MyBatis 语言提供，而它由语言驱动 <code>org.apache.ibatis.scripting.xmltags.XmlLanguageDriver</code>（别名为 <code>xml</code>）所提供。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resulthandler使用说明"><a class="header" href="#resulthandler使用说明">resultHandler使用说明</a></h1>
<ol>
<li>
<p>返回值为Null</p>
</li>
<li>
<p>实现ResultHandler接口</p>
</li>
<li>
<p>定义Mapper时传入ResultHandler</p>
<pre><code>  void selectByPrimaryKey(Integer id, ResultHandler&lt;User&gt; resultHandler);
</code></pre>
</li>
</ol>
<h1 id="defaultresulthandler"><a class="header" href="#defaultresulthandler">DefaultResultHandler</a></h1>
<pre><code class="language-java">public class DefaultResultHandler implements ResultHandler&lt;Object&gt; {

  /**
   * 集合
   */
  private final List&lt;Object&gt; list;

  public DefaultResultHandler() {
    list = new ArrayList&lt;&gt;();
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  public DefaultResultHandler(ObjectFactory objectFactory) {
    list = objectFactory.create(List.class);
  }

  @Override
  public void handleResult(ResultContext&lt;?&gt; context) {
    list.add(context.getResultObject());
  }

  public List&lt;Object&gt; getResultList() {
    return list;
  }

}

</code></pre>
<h1 id="defaultmapresulthandler"><a class="header" href="#defaultmapresulthandler">DefaultMapResultHandler</a></h1>
<pre><code class="language-java">/**
 *    Copyright 2009-2015 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.apache.ibatis.executor.result;

import java.util.Map;

import org.apache.ibatis.reflection.MetaObject;
import org.apache.ibatis.reflection.ReflectorFactory;
import org.apache.ibatis.reflection.factory.ObjectFactory;
import org.apache.ibatis.reflection.wrapper.ObjectWrapperFactory;
import org.apache.ibatis.session.ResultContext;
import org.apache.ibatis.session.ResultHandler;

/**
 * 默认Map的ResultHandler
 * @author Clinton Begin
 */
public class DefaultMapResultHandler&lt;K, V&gt; implements ResultHandler&lt;V&gt; {

  /**
   * 映射结果
   */
  private final Map&lt;K, V&gt; mappedResults;
  /**
   * 映射Key
   * &lt;p&gt;
   *   指定一个字段作为返回Map中的key，这里一般也就是使用唯一键来做key.
   * &lt;/p&gt;
   * &lt;p&gt;
   *     参考博客：https://blog.csdn.net/u012734441/article/details/85861337
   * &lt;/p&gt;
   */
  private final String mapKey;
  /**
   * 对象工厂
   */
  private final ObjectFactory objectFactory;
  /**
   * 对象包装工厂
   */
  private final ObjectWrapperFactory objectWrapperFactory;
  /**
   * 反射工厂
   */
  private final ReflectorFactory reflectorFactory;

  /**
   *
   * @param mapKey 指定一个字段作为返回Map中的key，这里一般也就是使用唯一键来做key.
   *               参考博客：https://blog.csdn.net/u012734441/article/details/85861337
   * @param objectFactory 对象工厂
   * @param objectWrapperFactory 对象包装工厂
   * @param reflectorFactory 反射工厂
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public DefaultMapResultHandler(String mapKey, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory) {
    this.objectFactory = objectFactory;
    this.objectWrapperFactory = objectWrapperFactory;
    this.reflectorFactory = reflectorFactory;
    this.mappedResults = objectFactory.create(Map.class);
    this.mapKey = mapKey;
  }

  @Override
  public void handleResult(ResultContext&lt;? extends V&gt; context) {
    //获取结果对象
    final V value = context.getResultObject();
    //value元对象
    final MetaObject mo = MetaObject.forObject(value, objectFactory, objectWrapperFactory, reflectorFactory);
    // TODO is that assignment always true?
    //获取mapKey的key
    final K key = (K) mo.getValue(mapKey);
    mappedResults.put(key, value);
  }

  public Map&lt;K, V&gt; getMappedResults() {
    return mappedResults;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="多结果集实现分页"><a class="header" href="#多结果集实现分页">多结果集实现分页</a></h3>
<ol>
<li>
<p>编写相应结果集 Map</p>
<pre><code class="language-xml">&lt;resultMap id=&quot;count&quot; type=&quot;_int&quot;&gt;
        &lt;result property=&quot;count&quot; column=&quot;count&quot; jdbcType=&quot;INTEGER&quot;&gt;&lt;/result&gt;
&lt;/resultMap&gt;
</code></pre>
</li>
<li>
<p>编写sql 指定<em>SQL_CALC_FOUND_ROWS</em> 关键字 </p>
<pre><code class="language-sql">select /* 指示获取实际查询条数*/ SQL_CALC_FOUND_ROWS,* from table_name; select found_rows() count
</code></pre>
</li>
<li>
<p>Mapper接口接收返回值</p>
<p>以<code>List&lt;Object&gt;</code> 返回 , 有几个结果集,List就有几个对象,对象的顺序按 sql的结果集编写孙旭</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jpa对象关系映射"><a class="header" href="#jpa对象关系映射">JPA对象关系映射</a></h1>
<p><strong>单向关系</strong></p>
<p>在这种关系中，只有一个实体可以将属性引用到另一个实体。它仅包含一个侧面，由于指定如何更新可以在数据库中进行。</p>
<p><strong>双向关系</strong></p>
<p>这种关系包含两边 - 既包含一个侧面，也包含另一个侧面。 所以这里每个实体都有一个关系字段或将该属性引用到其他实体。</p>
<h1 id="映射类型"><a class="header" href="#映射类型">映射类型</a></h1>
<p>**一对一 **</p>
<p><em>@OneToOne</em></p>
<p><strong>一对多</strong></p>
<p><em>@OneToMany</em></p>
<p><strong>多对一</strong></p>
<p><em>@ManyToOne</em></p>
<p><strong>多对多</strong></p>
<p><em>@ManyToMany</em></p>
<h1 id="jpa实体"><a class="header" href="#jpa实体">JPA实体</a></h1>
<p><strong>实体属性</strong></p>
<p>如果一个对象存储在数据库中并且可以随时访问，则该对象称为持久性</p>
<p><strong>持久性标识</strong></p>
<p>在Java中，每个实体都是唯一的，并表示为对象标识。 同样，当对象标识存储在数据库中时，它被表示为持久性标识。</p>
<p><strong>事务性</strong></p>
<p>实体可以执行各种操作，例如:创建，删除，更新。 每个操作都会对数据库进行一些更改。它确保无论数据库中的任何更改是原子级成功还是失败</p>
<p><strong>粒度</strong></p>
<p>实体不应该是基元，原始包装或具有单维状态的内置对象。</p>
<h1 id="实体元数据"><a class="header" href="#实体元数据">实体元数据</a></h1>
<p><strong>注解</strong> - 在Java中，注解是表示元数据的标签形式。 这个元数据保存在类中。</p>
<p><strong>XML</strong> - 在此形式中，元数据在XML文件的类外部保存。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-11"><a class="header" href="#前言-11">前言</a></h1>
<p>为了分布式session共享，通常的做法是将session存储在redis中，实现多个节点获取同一个session。此实现可以实现session共享，但session的特点是内存存储，就是为了高速频繁访问，每个请求都必须验证session是否存在是否过期，也从session中获取数据，这样导致一个页面刷新过程中的数十个请求会同时访问redis,在几毫秒内同时操作session的获取，修改，更新，保存，删除等操作，从而造成redis的并发量飙升，刷新一个页面操作redis几十到几百次。</p>
<p>为了解决由于session共享造成的redis高并发问题，很明显需要在redis之前做一次短暂的session缓存，如果该缓存存在就不用从redis中获取，从而减少同时访问redis的次数。如果做session缓存，主要有两种种方案，其实原理都相同：</p>
<p><strong>重写sessionManager的retrieveSession方法</strong></p>
<p>首先从request中获取session,如果request中不存在再走原来的从redis中获取。这样可以让一个请求的多次访问redis问题得到解决，因为request的生命周期为浏览器发送一个请求到接收服务器的一次响应完成</p>
<p>因此，在一次请求中，request中的session是一直存在的，并且不用担心session超时过期等的问题。这样就可以达到有多少次请求就几乎有多少次访问redis,大大减少单次请求，频繁访问redis的问题。大大减少redis的并发数量</p>
<pre><code class="language-java">
import java.io.Serializable;

import javax.servlet.ServletRequest;

import org.apache.shiro.session.Session;
import org.apache.shiro.session.UnknownSessionException;
import org.apache.shiro.session.mgt.SessionKey;
import org.apache.shiro.web.session.mgt.DefaultWebSessionManager;
import org.apache.shiro.web.session.mgt.WebSessionKey;

public class ShiroSessionManager extends DefaultWebSessionManager {
     /**
     * 获取session
     * 优化单次请求需要多次访问redis的问题
     * @param sessionKey
     * @return
     * @throws UnknownSessionException
     */
    @Override
    protected Session retrieveSession(SessionKey sessionKey) throws UnknownSessionException {
        Serializable sessionId = getSessionId(sessionKey);

        ServletRequest request = null;
        if (sessionKey instanceof WebSessionKey) {
            request = ((WebSessionKey) sessionKey).getServletRequest();
        }

        if (request != null &amp;&amp; null != sessionId) {
            Object sessionObj = request.getAttribute(sessionId.toString());
            if (sessionObj != null) {
                return (Session) sessionObj;
            }
        }

        Session session = super.retrieveSession(sessionKey);
        if (request != null &amp;&amp; null != sessionId) {
            request.setAttribute(sessionId.toString(), session);
        }
        return session;
    }
}
</code></pre>
<p><strong>session缓存于本地内存中</strong></p>
<p>自定义cacheRedisSessionDao,该sessionDao中一方面注入cacheManager用于session缓存，另一方面注入redisManager用于session存储</p>
<p>当readSession先用cacheManager从cache中读取，如果不存在再用redisManager从redis中读取</p>
<p><strong>注意：该方法最大的特点是session缓存的存活时间必须小于redis中session的存活时间，</strong></p>
<p><strong>就是当redus的session死亡，cahe中的session一定死亡,为了保证这一特点，cache中的session的存活时间应该设置为s级，设置为1s比较合适，并且存活时间固定不能刷新，不能随着访问而延长存活。</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-12"><a class="header" href="#前言-12">前言</a></h1>
<p>和前端进行数据交互时或者和第三方商家对接时，需要对隐私数据进行加密。单向加密，对称加密，非对称加密，其对应的算法也各式各样。java提供了统一的框架来规范（java.security）安全加密这类API。</p>
<h1 id="加密算法概念及分类"><a class="header" href="#加密算法概念及分类">加密算法概念及分类</a></h1>
<p>常用的加密算法类型有三种，如下:</p>
<ul>
<li>单向加密：也就是不可逆的加密，例如MD5，SHA，HMAC</li>
<li>对称加密：也就是加密方和解密方利用同一个秘钥对数据进行加密和解密，例如DES，PBE等等</li>
<li>非对称加密：非对称加密分为公钥和秘钥，二者是非对称的，例如用私钥加密的内容需要使用公钥来解密，使用公钥加密的内容需要用私钥来解密，DSA，RSA</li>
</ul>
<h1 id="秘钥生成"><a class="header" href="#秘钥生成">秘钥生成</a></h1>
<h2 id="对称加密密钥的生成"><a class="header" href="#对称加密密钥的生成">对称加密密钥的生成</a></h2>
<ul>
<li>KeyGenerator用于生成对称秘钥(可逆加密)，或者一个密码性秘钥</li>
<li>支持算法：AES、ARCFOUR、DES、DESede、HmacMD5、HmacSHA1、HmacSHA224、HmacSHA256、HmacSHA384、HmacSHA512、RC2</li>
</ul>
<pre><code class="language-java">public static final KeyGenerator getInstance(String algorithm, String provider)
public static final KeyGenerator getInstance(String algorithm)
public final void init(int keysize)
public final void init(int keysize, SecureRandom random)
public final void init(SecureRandom random)
public final void init(AlgorithmParameterSpec params, SecureRandom random)
public final SecretKey generateKey()
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-java">public static void main(String[] args) throws  Exception {
    SecretKey secretKey = generatorDesKey();
    System.out.println(secretKey);
}
public static SecretKey generatorDesKey() throws NoSuchAlgorithmException {
    KeyGenerator keyGen = KeyGenerator.getInstance(&quot;DES&quot;);
    SecureRandom random = new SecureRandom();
    random.nextBytes(new byte[128]);
    keyGen.init(56,random);
    SecretKey key = keyGen.generateKey();
    return key;
}
</code></pre>
<h2 id="非对称加密秘钥的生成"><a class="header" href="#非对称加密秘钥的生成">非对称加密秘钥的生成</a></h2>
<ul>
<li>KeyPairGenerator用于生成非对称加密算法的密钥对KeyPair，KeyPair会包括一个公钥和私钥</li>
<li>支持算法：DiffieHellman、DSA、RSA、RSASSA-PSS、EC</li>
</ul>
<pre><code class="language-java">//KeyPairGenerator.java
public static KeyPairGenerator getInstance(String algorithm)
public static KeyPairGenerator getInstance(String algorithm, String provider)
public void initialize(int keysize, SecureRandom random)
public void initialize(AlgorithmParameterSpec params, SecureRandom random)
public final KeyPair genKeyPair() 
//KeyPair.java
public PublicKey getPublic()
public PrivateKey getPrivate()
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    KeyPair keyPair = generatorRsaKey();
    System.out.println(keyPair);
}
public static KeyPair generatorRsaKey() throws Exception {
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);
    SecureRandom random = new SecureRandom();
    random.nextBytes(new byte[516]);
    keyGen.initialize(516,random);
    KeyPair keyPair = keyGen.genKeyPair();
    System.out.println(keyPair.getPrivate());
    System.out.println(keyPair.getPublic());
    return keyPair;
}
</code></pre>
<h2 id="密钥key和密钥规格keyspec的相互转化"><a class="header" href="#密钥key和密钥规格keyspec的相互转化">密钥Key和密钥规格KeySpec的相互转化</a></h2>
<blockquote>
<p>KeySpec是一个接口，用来组成加密密钥的密钥内容的（透明）规范。如果密钥存储在硬件设备上，则其规范可以包含有助于标识该设备上的密钥的信息</p>
</blockquote>
<blockquote>
<p>KeySpec具有规范性，所以一般会根据外部参数生成KeySpec，再根据KeySpec生成对应的Key</p>
</blockquote>
<h3 id="secretkeyfactory"><a class="header" href="#secretkeyfactory">SecretKeyFactory</a></h3>
<blockquote>
<p>用于对称加密的密钥和密钥规格之间的转换，配合KeyGenerator使用</p>
</blockquote>
<pre><code class="language-java">public static final SecretKeyFactory getInstance(String algorithm)
public static final SecretKeyFactory getInstance(String algorithm, String provider)
public final SecretKey translateKey(SecretKey key)
public final SecretKey generateSecret(KeySpec keySpec)
public final KeySpec getKeySpec(SecretKey key, Class&lt;?&gt; keySpec)
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);
    byte[] DESKey = &quot;helloWWW&quot;.getBytes(StandardCharsets.UTF_8);// 设置密钥
    DESKeySpec keySpec = new DESKeySpec(DESKey);// 设置密钥参数
    SecretKey key = keyFactory.generateSecret(keySpec);// 得到密钥对象
    System.out.println(key);
}
</code></pre>
<h2 id="keyfactory"><a class="header" href="#keyfactory">KeyFactory</a></h2>
<p>用于非对称加密的密钥和密钥规格之间的转换，配合KeyPairGenerator使用</p>
<ul>
<li>支持算法：DiffieHellman、DSA、RSA、RSASSA-PSS、EC</li>
</ul>
<pre><code class="language-java">//KeyFactory.java
public static KeyFactory getInstance(String algorithm)
public static KeyFactory getInstance(String algorithm, String provider)
public final PublicKey generatePublic(KeySpec keySpec)
public final PrivateKey generatePrivate(KeySpec keySpec)
public final &lt;T extends KeySpec&gt; T getKeySpec(Key key, Class&lt;T&gt; keySpec)
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    //生成RSA秘钥对；generatorRsaKey是上面示例提供的函数
    KeyPair keyPair = generatorRsaKey();
    System.out.println(keyPair);
    //PublicKey转KeySpec;KeySpec再转PublicKey
    X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(keyPair.getPublic().getEncoded());
    KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);
    PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);
    System.out.println(pubKey);
    //PrivateKey转KeySpec;KeySpec再转PrivateKey
    PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(keyPair.getPrivate().getEncoded());
    PrivateKey priKey = keyFactory.generatePrivate(priKeySpec);
    System.out.println(priKey);
}
</code></pre>
<h1 id="摘要算法"><a class="header" href="#摘要算法">摘要算法</a></h1>
<p>MessageDigest和javax.crypto.Mac(HMAC)</p>
<ul>
<li>
<p>单向加密是不可逆的，MD5、SHA、MAC都是属于单向加密算法的一种，也称之为摘要算法</p>
</li>
<li>
<p>MD5、SHA它们会根据明文用哈希算法计算一个固定长度的摘要（哈希值），然后把明文和摘要发送给接收者，接收者根据同样的算法计算出摘要，对比两个摘要是否一样即可验证明文的正确性，它的应用场景是：防止篡改和校验数据</p>
</li>
<li>
<p>MD5、SHA等算法是开源的，容易被试探出来。有没有更安全的摘要算法呢？HMAC-带密钥(密码)的hash函数，用一个密钥和一个明文消息作为输入，生成一个消息摘要。密钥一般使用KeyGenerator创建，相当于一个密码值，其被试探出的概率小</p>
</li>
<li>
<p>MessageDigest支持的算法：MD2、MD5、SHA-1、SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256</p>
</li>
<li>
<p>javax.crypto.Mac支持的算法：HmacMD5、HmacSHA1、HmacSHA224、HmacSHA256、HmacSHA384、HmacSHA512、PBEWithHmacSHA1</p>
</li>
</ul>
<p><strong>MD5的示例</strong></p>
<pre><code class="language-java">MessageDigest digest = MessageDigest.getInstance(&quot;MD5&quot;);
System.out.println(new String(digest.digest(&quot;hello world!&quot;.getBytes())));
System.out.println(new String(digest.digest(&quot;hello world!&quot;.getBytes())));
</code></pre>
<p><strong>MAC的示例</strong></p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    // 初始化HmacMD5摘要算法的密钥产生器
    KeyGenerator generator = KeyGenerator.getInstance(&quot;HmacMD5&quot;);
    // 产生密钥
    SecretKey secretKey = generator.generateKey();
    //SecretKeySpec继承于SecretKey和KeySpec，因此可直接用SecretKeySpec初始化Mac
    //SecretKey secretKey = new SecretKeySpec(&quot;password&quot;.getBytes(), &quot;HmacMD5&quot;);
    Mac mac = Mac.getInstance(&quot;HmacMD5&quot;);
    mac.init(secretKey);
    //计算摘要
    String data = &quot;hello world&quot;;
    byte[] result1 = mac.doFinal(data.getBytes());
    byte[] result2 = mac.doFinal(data.getBytes());
    System.out.println(new String(result1).equals(new String(result2)));
}
</code></pre>
<h1 id="签名算法工具-signature"><a class="header" href="#签名算法工具-signature">签名算法工具-Signature</a></h1>
<ul>
<li>签名算法其实也是加密算法，它加密后的数据具有唯一标识性，就像一个人的签名能代表一个人身份。签名一般是指用非对称加密算法的私钥来加密明文的过程，生成的密文可以被持有公钥的人识别解密，只要你的公钥是准确对应无误的，就能保证你解密的数据是来自持有私钥的一方</li>
<li>支持算法：NONEwithRSA、MD2withRSA、MD5withRSA、SHA512/224withRSA、SHA512/256withRSA、RSASSA-PSS、NONEwithDSA、SHA512withDSA、NONEwithECDSA、SHA512withECDSA、MD5withRSAandMGF1（太多了，选择列举几个）</li>
</ul>
<p><strong>示例</strong></p>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    KeyPair keyPair = generatorRsaKey();
    Signature signature = Signature.getInstance(&quot;MD5withRSA&quot;);
    signature.initSign(keyPair.getPrivate());
    //加解密数据
    byte[] data = &quot;hello world&quot;.getBytes();
    //数据签名
    signature.update(data);
    byte[] digest = signature.sign();
    //数据解密加验证
    signature.initVerify(keyPair.getPublic());
    signature.update(data);
    System.out.println(&quot;验证结果:&quot;+signature.verify(digest));
}
</code></pre>
<h1 id="常用加密工具类-cipher"><a class="header" href="#常用加密工具类-cipher">常用加密工具类-Cipher</a></h1>
<ul>
<li>用于加密/解密数据。支持各种类型的算法：对称加密（例如AES），非对称加密（例如RSA）</li>
<li>支持算法：AES、AESWrap、ARCFOUR、Blowfish、DES、DESede、DESedeWrap、ECIES、RSA（太多了，选择列举几个）</li>
</ul>
<pre><code class="language-java">public static void main(String[] args) throws Exception {
    KeyPair keyPair = generatorRsaKey();
    Cipher cipher = Cipher.getInstance(&quot;RSA&quot;);
    // 编码前设定编码方式及密钥
    cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPrivate());
    //加解密数据
    byte[] data = &quot;hello world&quot;.getBytes();
    //数据签名
    byte[] enData = cipher.doFinal(data);
    //数据解密
    cipher.init(Cipher.DECRYPT_MODE, keyPair.getPublic());
    byte[] newData = cipher.doFinal(enData);
    System.out.println(&quot;验证结果:&quot;+new String(newData));
}
------------输出结果------------------
验证结果:hello world
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java体系"><a class="header" href="#java体系">java体系</a></h1>
<p>Java分为三个体系，分别为 </p>
<ul>
<li><em>Java SE</em>（J2SE，Java to Platform Standard Edition，标准版），</li>
<li><em>JavaEE</em>（J2EE，Java to Platform, Enterprise Edition，企业版），</li>
<li>Java ME（J2ME，Java to Platform Micro Edition，微型版）。</li>
</ul>
<h1 id="概述-12"><a class="header" href="#概述-12">概述</a></h1>
<p><a href="https://www.jcp.org/en/home/index">JCP官网</a></p>
<ul>
<li>
<p>任何一门语言的问世和流传，以及取得这样大的影响力都离不开厂商、组织、开发者与用户们的共同参与，而Sun公司为了发展和更新这门语言组成了一个<strong>开放性国际组织JCP</strong>（Java Community Process），</p>
</li>
<li>
<p>任何想要提议加入Java功能或特性都必须以<strong>JSR正式文件</strong>（Java Specification Request）（Java 规范提案），进行提交然后经过JCP执行委员会投票，通过即成为最终标准文件</p>
</li>
<li>
<p>然后必须根据这个JSR做出免费且开发原始码的<strong>参考实现RI</strong>（Reference Implementation），并提供<strong>技术兼容性测试工具包TCK</strong>（Technology Compatibility Kit），厂商可以根据JSR实现产品。</p>
</li>
<li>
<p>JCP维护的规范包括J2ME、J2SE、J2EE，XML，OSS，JAIN等。组织成员可以提交JSR（Java Specification Requests），通过特定程序以后主要包括（Java技术规范、参考实现（RI）、技术兼容包（TCK）)，进入到下一版本的规范里面。</p>
</li>
<li>
<p>所有声称符合J2EE规范的J2EE类产品（应用服务器、应用软件、开发工具等），必须通过该组织提供的TCK兼容性测试（需要购买测试包），通过该测试后，需要缴纳J2EE商标使用费。两项完成，即是通过J2EE认证（Authorized Java Licensees of J2EE）。</p>
</li>
</ul>
<p>现在Java无疑已经成为了业界共同制定的一个标准，每一个标准也代表着业界面临的一些问题，而<strong>一个JSR规范标准可以有多种技术解决方案</strong>。</p>
<ul>
<li>下面列出了基于java三个平台的一系列标准JSR（标准）链接：
<ul>
<li>Java EE (54 JSRs) （https://www.jcp.org/en/jsr/platform?listBy=3&amp;listByType=platform）</li>
<li>Java SE (57 JSRs) （https://www.jcp.org/en/jsr/platform?listBy=2&amp;listByType=platform）</li>
<li>Java ME (85 JSRs) （https://www.jcp.org/en/jsr/platform?listBy=1&amp;listByType=platform）</li>
</ul>
</li>
</ul>
<h1 id="以jta为样例"><a class="header" href="#以jta为样例">以JTA为样例</a></h1>
<p>现在我们进入到一个（Java EE (54 JSRs)）标准的JSR下载页面（JSR-000907 JTA）的API标准：</p>
<p>其中有下载链接有两个文档</p>
<ul>
<li>从字面意思明白一个是 <strong>这些规则及标准的评估</strong>，</li>
<li>一个是这些<strong>规则的实施</strong>，打开实施规则的文档可以看出
<ul>
<li>这些标准提供了一些接口文档和协议。</li>
<li>里面提供了一些面对开发人员的接口以及面对具体实现接口的各个软件公司，也就是这些接口的具体的实现包，由各个软件厂商实现。</li>
</ul>
</li>
</ul>
<h1 id="jsr规范整理"><a class="header" href="#jsr规范整理">JSR规范整理</a></h1>
<table><thead><tr><th>JSR编号</th><th>模块与功能</th></tr></thead><tbody>
<tr><td>JSR 310</td><td>Java Date与Time API (时间与日期API)</td></tr>
<tr><td>JSR 315</td><td>Java Servlet 3.0（servlet规范）</td></tr>
<tr><td>JSR 303</td><td>Bean Validation1.0（bean检验）</td></tr>
<tr><td>JSR 380</td><td>Bean Validation 2.0</td></tr>
<tr><td>JSR 317</td><td>Java Persistence 2.0（持久化）</td></tr>
<tr><td>JSR 338</td><td>Java Persistence 2.2</td></tr>
<tr><td>JSR 907</td><td>Java Transaction API (JTA)（事务管理器）</td></tr>
<tr><td>JSR 250</td><td>Common Annotations for the Java Platform</td></tr>
<tr><td>JSR 107</td><td>JCache API（缓存）</td></tr>
</tbody></table>
<h1 id="java-ee-8技术对应的jsr标准"><a class="header" href="#java-ee-8技术对应的jsr标准">Java EE 8技术对应的JSR标准</a></h1>
<p>Java EE 8 基于Java EE 7. 下面是Java EE 8在java EE7之上的更新或者新增JSR:</p>
<ul>
<li>JSR 366 – Java EE 8 Platform</li>
<li>JSR 365 – Contexts and Dependency Injection (CDI) 2.0</li>
<li>JSR 367 – The Java API for JSON Binding (JSON-B) 1.0</li>
<li>JSR 369 – Java Servlet 4.0</li>
<li>JSR 370 – Java API for RESTful Web Services (JAX-RS) 2.1</li>
<li>JSR 372 – JavaServer Faces (JSF) 2.3</li>
<li>JSR 374 – Java API for JSON Processing (JSON-P)1.1</li>
<li>JSR 375 – Java EE Security API 1.0</li>
<li>JSR 380 – Bean Validation 2.0</li>
<li>JSR 250 – Common Annotations 1.3</li>
<li>JSR 338 – Java Persistence 2.2</li>
<li>JSR 356 – Java API for WebSocket 1.1</li>
<li>JSR 919 – JavaMail 1.6</li>
</ul>
<p><a href="https://www.oracle.com/java/technologies/java-ee-glance.html">参考链接</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jar-file-specification"><a class="header" href="#jar-file-specification">JAR File Specification</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<ul>
<li>JAR文件是一种基于流行的ZIP文件格式的文件格式，用于将许多文件聚合到一个文件中</li>
<li>JAR文件本质上是一个zip文件，其中包含一个可选的META-INF目录。</li>
<li>可以从 <em>jar</em> 命令行创建 或者 使用  <code>java.util.jar</code> API</li>
<li>jar包不仅用于存储jar文件，<em>META-INF</em> 如果存在，可以用于 存储包，扩展配置数据，例如：安全，版本控制，扩展和服务</li>
</ul>
<h2 id="the-meta-inf-directory"><a class="header" href="#the-meta-inf-directory">The META-INF directory</a></h2>
<p>The following files/directories in the META-INF directory are recognized and interpreted by the Java 2 Platform to configure applications, extensions, class loaders and services:</p>
<p><code>Java 2 Platform</code> 识别并解释了META-INF目录中的以下文件/目录，以配置应用程序，扩展，类加载器和服务</p>
<h3 id="manifestmf"><a class="header" href="#manifestmf"><strong><code>MANIFEST.MF</code></strong></a></h3>
<p>The manifest file that is used to define extension and package related data.</p>
<h3 id="indexlist"><a class="header" href="#indexlist"><code>INDEX.LIST</code></a></h3>
<blockquote>
<p>This file is generated by the new &quot;<code>-i&quot;</code> option of the jar tool</p>
</blockquote>
<p>which contains location information for packages defined in an application or extension. </p>
<p>It is part of the JarIndex implementation and used by class loaders to speed up their class loading process.</p>
<h3 id="xsf"><a class="header" href="#xsf"><code>x.SF</code></a></h3>
<p>The signature file for the JAR file. 'x' stands for the base file name.</p>
<h3 id="xdsa"><a class="header" href="#xdsa"><code>x.DSA</code></a></h3>
<p>The signature block file associated with the signature file with the same base file name. </p>
<p>This file stores the digital signature of the corresponding signature file.</p>
<h3 id="services"><a class="header" href="#services"><code>services/</code></a></h3>
<p>This directory stores all the service provider configuration files(SPI文件)</p>
<h2 id="name-value-pairs-and-sections"><a class="header" href="#name-value-pairs-and-sections">Name-Value pairs and Sections</a></h2>
<p>定义一些格式约定，在 <em>manifest</em> 清单、签名文件中的数据 以 <code>name: value</code> 键值对，受 <code>RFC822</code>启发</p>
<p>一组 键值对 叫 组，一个或多个空行 分隔组</p>
<p>二进制的数据以 base64表示，对于导致行长超过72个字节的二进制数据，需要连续进行。二进制数据的示例是摘要和签名。jar实现应支持最大65535字节的值。</p>
<p><strong>语法申明</strong></p>
<pre><code>Specification:
  section:                       *header +newline
  nonempty-section:      +header +newline
  newline:                      CR LF | LF | CR (not followed by LF)
  header:                       name : value
  name:                         alphanum *headerchar
  value:                          SPACE *otherchar newline *continuation
  continuation:              SPACE *otherchar newline
  alphanum:                  {A-Z} | {a-z} | {0-9}
  headerchar:                alphanum | - | _
  otherchar:                  any UTF-8 character except NUL, CR and LF
; Also: To prevent mangling of files sent via straight e-mail, no
; header will start with the four letters &quot;From&quot;.
</code></pre>
<h2 id="jar-manifest"><a class="header" href="#jar-manifest">JAR Manifest</a></h2>
<h3 id="overview-3"><a class="header" href="#overview-3">Overview</a></h3>
<p>jar文件 <em>manifest</em> 包含一个  主分区，以及跟随一系列 单独的 jar文件条目</p>
<p><em>manifest</em> 清单的 主分区是指文件最先开始到 第一个空行</p>
<p>包括 安全和 jar本身的配置信息，还有组成jar所依赖的应用或扩展</p>
<p>主分区还定义了适用于每个单独清单条目的主要属性</p>
<p>此部分中的任何属性名称都不能等于“<code>Name</code>”。</p>
<p>其他 单独分区定义了各种各样的属性</p>
<p>并非JAR文件中的所有文件都需要在清单中作为条目列出，但必须列出所有要签名的文件。清单文件本身不能列出</p>
<p>每个分区 都必须以名称为“<code>Name</code>”的属性开头，该值必须是文件的相对路径，或者是引用外部数据的绝对URL。</p>
<p>申明多个单独分区且 文件entry是一样的，属性会合并，相同属性的最后一个会胜选</p>
<p>未知属性被忽略，可以由应用程序去实现</p>
<pre><code>Manifest Specification:
  manifest-file:                    main-section newline *individual-section
  main-section:                    version-info newline *main-attribute
  version-info:                      Manifest-Version : version-number
  version-number :               digit+{.digit+}*
  main-attribute:                 (any legitimate main attribute) newline
  individual-section:             Name : value newline *perentry-attribute
  perentry-attribute:            (any legitimate perentry attribute) newline
  newline :                            CR LF | LF | CR (not followed by LF)
   digit:                                {0-9} 
</code></pre>
<p><em>main-attribute</em> 指的是出现在 主分区中的 属性</p>
<p><em>per-entry attribute</em> 指的是 出现在 独立分区中的属性</p>
<p>如果同时出现在main分区，和独立分区，则独立分区优先</p>
<h3 id="main-attributes"><a class="header" href="#main-attributes">Main Attributes</a></h3>
<p><strong>general main attributes</strong> </p>
<blockquote>
<p>通用主属性</p>
</blockquote>
<ul>
<li>Manifest-Version: 定义manifest的版本.</li>
<li>Created-By: 定义这个jar文件是被哪一个<em>vendor</em> 实现的</li>
<li>Signature-Version:  jar文件的签名版本</li>
<li>Class-Path:此属性的值指定此应用程序或扩展程序需要的扩展程序或库的相对URL。URLs 由一个或多个空格分隔. 应用程序或扩展类加载器使用此属性的值来构造其内部搜索路径。</li>
</ul>
<p><strong>attribute defined for stand-alone applications</strong></p>
<blockquote>
<p>独立应用程序,捆绑到可执行jar文件中的独立应用程序使用此属性组，java -jar x.jar</p>
</blockquote>
<ul>
<li>Main-Class: Java启动类文件相对路径,必须有 .class 后缀</li>
</ul>
<p><strong>attributes defined for applets</strong> </p>
<p><strong>attribute defined for extension identification</strong></p>
<p><strong>attributes defined for extension and package</strong></p>
<ul>
<li>Implementation-Title: The value is a string that defines the title of the extension implementation.</li>
<li>Implementation-Version: The value is a string that defines the version of the extension implementation.</li>
<li>Implementation-Vendor: The value is a string that defines the organization that maintains the extension implementation.</li>
<li>Implementation-Vendor-Id: The value is a string id that uniquely defines the organization that maintains the extension implementation.</li>
<li>Implementation-URL: This attribute defines the URL from which the extension implementation can be downloaded from.</li>
<li>Specification-Title: The value is a string that defines the title of the extension specification.</li>
<li>Specification-Version: The value is a string that defines the version of the extension specification.</li>
<li>Specification-Vendor: The value is a string that defines the organization that maintains the extension specification.</li>
<li>Sealed: This attribute defines whether this JAR file is sealed or not. The value can be either &quot;true&quot; or &quot;false&quot;, case is ignored. If it is set to &quot;true&quot;, then all the packages in the JAR file are defaulted to be sealed, unless they are defined otherwise individually.</li>
</ul>
<h3 id="per-entry-attributes"><a class="header" href="#per-entry-attributes">Per-Entry Attributes</a></h3>
<p><strong>例如</strong></p>
<pre><code>Manifest-Version: 1.0
Created-By: 1.2 (Sun Microsystems Inc.)
Sealed: true
Name: foo/bar/
Sealed: false
</code></pre>
<p>所有在a.jar中存档的软件包都是密封的 foo.bar除外</p>
<p><em>per-entry attribute</em> 有以下配置组</p>
<p><strong>attributes defined for file contents:</strong></p>
<blockquote>
<p>文件内容相关的属性</p>
</blockquote>
<ul>
<li>Content-Type: 指定 文件的 MIME类型 值必须是 <em>type/subtype</em>. RFC <a href="ftp://www.ietf.org/rfc/rfc1521.txt">1521</a> and <a href="ftp://www.ietf.org/rfc/rfc1522.txt">1522</a> 对MIME类型进行了定义</li>
</ul>
<p><strong>attributes defined for package versioning and sealing information</strong></p>
<blockquote>
<p>包的版本控制与 封装信息</p>
</blockquote>
<p>与 主分区 的属性一致，会覆盖主分区的同名属性</p>
<p><strong>attribute defined for beans objects</strong></p>
<blockquote>
<p>bean对象</p>
</blockquote>
<ul>
<li>Java-Bean: 指定的jar文件条目是否为Java Beans对象. <em>true</em> 或 <em>false</em></li>
</ul>
<p><strong>attributes defined for signing</strong></p>
<blockquote>
<p>签名与校验</p>
</blockquote>
<ul>
<li>x-Digest-y: 此属性的值存储实际的摘要值. 前缀“ x”指定算法名称，可选的后缀“ y”表示摘要值应针对哪种语言进行验证。</li>
<li>Magic: 这是一个可选属性，应用程序可以使用该属性来指示验证者应如何计算清单条目中包含的摘要值。
此属性的值是一组用逗号分隔的上下文特定的字符串。</li>
</ul>
<h2 id="signed-jar-file"><a class="header" href="#signed-jar-file">Signed JAR File</a></h2>
<p>A JAR file can be signed by using the command line <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/security/SecurityToolsSummary.html">jarsigner</a> tool or directly through the <code>java.security</code> API. Every file entry, including non-signature related files in the <code>META-INF</code> directory, will be signed if the JAR file is signed by the jarsigner tool. The signature related files are:</p>
<p>可以使用命令行， jarsigner 工具或直接通过<code>java.security</code> <em>API</em> 来对JAR文件进行签名。 
如果JAR文件由jarsigner工具签名，则每个文件条目（包括META-INF目录中与签名无关的文件）都将被签名。
与签名相关的文件是：</p>
<ul>
<li><code>META-INF/MANIFEST.MF</code></li>
<li><code>META-INF/*.SF</code></li>
<li><code>META-INF/*.DSA</code></li>
<li><code>META-INF/*.RSA</code></li>
<li><code>META-INF/SIG-*</code></li>
</ul>
<p>如果此类文件位于“ META-INF”子目录中，则它们不被视为与签名相关。</p>
<p>这些文件名的不区分大小写的版本将被保留，也不会被签名。</p>
<p>可以使用java.security API对JAR文件的子集进行签名。</p>
<p>已签名的JAR文件与原始JAR文件完全相同，不同之处在于已更新其清单，并将两个附加文件添加到“ META-INF”目录中：签名文件和 <em>signature block file</em>。
当不使用jarsigner时，签名程序必须构造签名文件和签名块文件。</p>
<p>对于在签名的jar文件中签名的每个文件条目，只要清单中不存在该清单条目，就会为其创建一个单独的清单条目</p>
<p>每个清单条目 列出一个或多个 摘要属性</p>
<h3 id="signature-file"><a class="header" href="#signature-file">Signature File</a></h3>
<h3 id="signature-validation"><a class="header" href="#signature-validation">Signature Validation</a></h3>
<h3 id="the-magic-attribute"><a class="header" href="#the-magic-attribute">The Magic Attribute</a></h3>
<h3 id="digital-signatures"><a class="header" href="#digital-signatures">Digital Signatures</a></h3>
<h3 id="notes-on-manifest-and-signature-files"><a class="header" href="#notes-on-manifest-and-signature-files">Notes on Manifest and Signature Files</a></h3>
<h2 id="jar-index"><a class="header" href="#jar-index">JAR Index</a></h2>
<h3 id="overview-4"><a class="header" href="#overview-4">Overview</a></h3>
<p><strong>优化网络应用程序</strong></p>
<p>从1.3开始，引入JarIndex来优化网络应用程序（尤其是小应用程序）的类加载器的类搜索过程。
最初，小程序类加载器使用简单的线性搜索算法来搜索其内部搜索路径中的每个元素，该内部搜索路径是由“ ARCHIVE”标签或“ Class-Path”主属性构造的。
类加载器将下载并打开其搜索路径中的每个元素，直到找到该类或资源为止。
如果类加载器尝试查找不存在的资源，则必须下载应用程序或applet中的所有jar文件。
对于大型网络应用程序和小程序，这可能导致启动缓慢，响应缓慢以及网络带宽浪费。 
JarIndex机制收集小程序中定义的所有jar文件的内容，并将信息存储在小程序类路径上第一个jar文件的索引文件中。
在下载第一个jar文件之后，小应用程序类加载器将使用收集的内容信息来高效下载jar文件。</p>
<p><strong>Index.list</strong></p>
<p>现有的jar工具已得到增强，能够检查jar文件列表并生成有关哪些类和资源驻留在哪个jar文件中的目录信息。
该目录信息存储在根jar文件的META-INF目录中名为INDEX.LIST的简单文本文件中。
当类加载器加载根jar文件时，它将读取“ INDEX.LIST”文件，并使用它来构建从文件名和程序包名到jar文件名列表的映射的哈希表。
为了找到类或资源，类加载器查询哈希表以找到正确的jar文件，然后在必要时下载它。</p>
<p><strong><em>Index.list</em> 过时</strong></p>
<p>一旦类加载器在一个特定的jar文件中找到一个“ INDEX.LIST”文件，它就总是信任其中列出的信息。
如果找到特定类的映射，但类加载器无法通过跟踪链接找到它，则抛出<em>InvalidJarIndexException</em>
发生这种情况时，应用程序开发人员应在扩展名上重新运行“ jar”工具，以将正确的信息添加到索引文件中。</p>
<p><strong>文件尽量小</strong></p>
<p>为了防止给应用程序增加过多的空间开销并加快内存中哈希表的构建速度，INDEX.LIST文件应保持尽可能小。</p>
<ul>
<li>对于具有非空程序包名称的类，映射记录在程序包级别。
通常，一个程序包名称映射到一个jar文件，</li>
<li>但是如果一个特定的程序包跨越一个以上的jar文件，则此程序包的映射值将是jar文件列表。</li>
<li>对于具有非空目录前缀的资源文件，映射也记录在目录级别。</li>
<li>仅对于包名称为空的类以及位于根目录中的资源文件，映射将在单个文件级别记录。</li>
</ul>
<h3 id="index-file-specification"><a class="header" href="#index-file-specification">Index File Specification</a></h3>
<p>INDEX.LIST文件包含一个或多个节，每个节由单个空白行分隔。
每个部分定义了一个特定jar文件的内容，其中的头定义了jar文件的路径名，后跟一个包或文件名的列表，每行一个。
所有的jar文件路径都相对于根jar文件的代码库。
这些路径名的解析方式与当前扩展机制对捆绑扩展名的解析方式相同。 
UTF-8编码用于支持索引文件中文件名或包名中的非ASCII字符。</p>
<h2 id="service-provider"><a class="header" href="#service-provider">Service Provider</a></h2>
<p><em>META-INF/services</em> SPI 机制 详见 <a href="29.%E5%85%B6%E4%BB%96_JSR/../java%E5%9F%BA%E7%A1%80/JavaSPI.html">SPI</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-13"><a class="header" href="#概述-13">概述</a></h1>
<p><strong>JMH只适合细粒度的方法测试，并不适用于系统之间的链路测试！</strong></p>
<h1 id="使用-5"><a class="header" href="#使用-5">使用</a></h1>
<h2 id="引包-1"><a class="header" href="#引包-1"><strong>引包</strong></a></h2>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;
            &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;
            &lt;version&gt;1.20&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;
            &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;
            &lt;version&gt;1.20&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
<h2 id="helloworldtest"><a class="header" href="#helloworldtest">HelloWorldTest</a></h2>
<pre><code class="language-java">package com.weisanju.logger;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS) //每次都进行 五次预热执行，每隔1秒进行一次预热操作
@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS) //预热结束后，进行五次实际 执行，每隔一秒执行
public class JMHSample_01_HelloWorld {
    static class Demo {
        int id;
        String name;

        public Demo(int id, String name) {
            this.id = id;
            this.name = name;
        }
    }

    static List&lt;Demo&gt; demoList;

    static {
        demoList = new ArrayList();
        for (int i = 0; i &lt; 10000; i++) {
            demoList.add(new Demo(i, &quot;test&quot;));
        }
    }

    @Benchmark //定义基准测试方法单元
    @BenchmarkMode(Mode.AverageTime) //取方法平均值
    @OutputTimeUnit(TimeUnit.MICROSECONDS) //输出单元 us
    public void testHashMapWithoutSize() {
        Map map = new HashMap();
        for (Demo demo : demoList) {
            map.put(demo.id, demo.name);
        }
    }

    @Benchmark //定义基准测试方法单元
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.MICROSECONDS)
    public void testHashMap() {
        Map map = new HashMap((int) (demoList.size() / 0.75f) + 1);
        for (Demo demo : demoList) {
            map.put(demo.id, demo.name);
        }
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(JMHSample_01_HelloWorld.class.getSimpleName())
                .forks(1)
                .build();
        new Runner(opt).run();
    }
}
</code></pre>
<p>上面的代码翻译一下：分别定义两个基准测试的方法testHashMapWithoutSize和 testHashMap，这两个基准测试方法执行流程是：每个方法执行前都进行5次预热执行，每隔1秒进行一次预热操作，预热执行结束之后进行5次实际测量执行，每隔1秒进行一次实际执行，我们此次基准测试测量的是平均响应时长，单位是us。</p>
<p>预热？为什么要预热？因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译成为机器码从而提高执行速度。为了让 benchmark 的结果更加接近真实情况就需要进行预热。</p>
<p>从上面的执行结果我们看出，针对一个Map的初始化参数的给定其实有很大影响，当我们给定了初始化参数执行执行的速度是没给定参数的2/3，这个优化速度还是比较明显的，所以以后大家在初始化Map的时候能给定参数最好都给定了，代码是处处优化的，积少成多。</p>
<h2 id="示例2-1"><a class="header" href="#示例2-1">示例2</a></h2>
<pre><code class="language-java">package benchmark;

import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.infra.Blackhole;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

@State(Scope.Benchmark)
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@Fork(value = 1, jvmArgsPrepend = &quot;-XX:+PrintStringTableStatistics&quot;)
@Warmup(iterations = 5)
@Measurement(iterations = 5)
public class StringInternBenchMark {

    @Param({&quot;1&quot;, &quot;100&quot;, &quot;10000&quot;, &quot;1000000&quot;})
    private int size;

    private StringInterner str;
    private ConcurrentHashMapInterner chm;
    private HashMapInterner hm;

    @Setup
    public void setup() {
        str = new StringInterner();
        chm = new ConcurrentHashMapInterner();
        hm = new HashMapInterner();
    }

    public static class StringInterner {
        public String intern(String s) {
            return s.intern();
        }
    }

    @Benchmark
    public void useIntern(Blackhole bh) {
        for (int c = 0; c &lt; size; c++) {
            bh.consume(str.intern(&quot;doit&quot; + c));
        }
    }

    public static class ConcurrentHashMapInterner {
        private final Map&lt;String, String&gt; map;

        public ConcurrentHashMapInterner() {
            map = new ConcurrentHashMap&lt;&gt;();
        }

        public String intern(String s) {
            String exist = map.putIfAbsent(s, s);
            return (exist == null) ? s : exist;
        }
    }

    @Benchmark
    public void useCurrentHashMap(Blackhole bh) {
        for (int c = 0; c &lt; size; c++) {
            bh.consume(chm.intern(&quot;doit&quot; + c));
        }
    }

    public static class HashMapInterner {
        private final Map&lt;String, String&gt; map;

        public HashMapInterner() {
            map = new HashMap&lt;&gt;();
        }

        public String intern(String s) {
            String exist = map.putIfAbsent(s, s);
            return (exist == null) ? s : exist;
        }
    }

    @Benchmark
    public void useHashMap(Blackhole bh) {
        for (int c = 0; c &lt; size; c++) {
            bh.consume(hm.intern(&quot;doit&quot; + c));
        }
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(StringInternBenchMark.class.getSimpleName())
                .build();
        new Runner(opt).run();
    }
}
</code></pre>
<h1 id="benchmark"><a class="header" href="#benchmark"><strong>@Benchmark</strong></a></h1>
<ul>
<li>@Benchmark标签是用来标记测试方法的，只有被这个注解标记的话，该方法才会参与基准测试，但是有一个基本的原则就是被</li>
<li>@Benchmark标记的方法必须是public的。</li>
</ul>
<h1 id="warmup"><a class="header" href="#warmup"><strong>@Warmup</strong></a></h1>
<p>@Warmup用来配置预热的内容，可用于类或者方法上，越靠近执行方法的地方越准确。一般配置warmup的参数有这些：</p>
<ul>
<li>iterations：预热的次数。</li>
<li>time：每次预热的时间。</li>
<li>timeUnit：时间单位，默认是s。</li>
<li><strong>batchSize：批处理大小，每次操作调用几次方法。（后面用到）</strong></li>
</ul>
<h1 id="measurement"><a class="header" href="#measurement"><strong>@Measurement</strong></a></h1>
<p>用来控制实际执行的内容，配置的选项本warmup一样。</p>
<h1 id="benchmarkmode"><a class="header" href="#benchmarkmode">@BenchmarkMode</a></h1>
<p>主要是表示测量的纬度，有以下这些纬度可供选择：</p>
<ul>
<li>Mode.Throughput 吞吐量纬度</li>
<li>Mode.AverageTime 平均时间</li>
<li>Mode.SampleTime 抽样检测</li>
<li>Mode.SingleShotTime 检测一次调用</li>
</ul>
<p><strong>Mode.All 运用所有的检测模式 在方法级别指定@BenchmarkMode的时候可以一定指定多个纬度，例如： @BenchmarkMode({Mode.Throughput, Mode.AverageTime, Mode.SampleTime, Mode.SingleShotTime})，代表同时在多个纬度对目标方法进行测量。</strong></p>
<table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody>
<tr><td>Mode.Throughput</td><td>计算吞吐量</td></tr>
<tr><td>Mode.AverageTime</td><td>计算平均运行时间</td></tr>
<tr><td>Mode.SampleTime</td><td>在测试中，随机进行采样执行的时间</td></tr>
<tr><td>Mode.SingleShotTime</td><td>测量单次操作的时间</td></tr>
<tr><td>Mode.All</td><td>所有模式依次运行</td></tr>
</tbody></table>
<p><strong>每个维度 默认运行 十轮</strong></p>
<h1 id="outputtimeunit"><a class="header" href="#outputtimeunit"><strong>@OutputTimeUnit</strong></a></h1>
<p>@OutputTimeUnit代表测量的单位，比如秒级别，毫秒级别，微妙级别等等。一般都使用微妙和毫秒级别的稍微多一点。该注解可以用在方法级别和类级别，当用在类级别的时候会被更加精确的方法级别的注解覆盖，原则就是离目标更近的注解更容易生效。</p>
<h1 id="state"><a class="header" href="#state"><strong>@State</strong></a></h1>
<p>在很多时候我们需要维护一些状态内容，比如在多线程的时候我们会维护一个共享的状态，这个状态值可能会在每隔线程中都一样，也有可能是每个线程都有自己的状态，JMH为我们提供了状态的支持。该注解只能用来标注在类上，因为类作为一个属性的载体。 @State的状态值主要有以下几种：</p>
<ul>
<li>
<p>Scope.Benchmark 该状态的意思是会在所有的Benchmark的工作线程中共享变量内容。</p>
</li>
<li>
<p>Scope.Group 同一个Group的线程可以享有同样的变量</p>
</li>
<li>
<p>Scope.Thread 每隔线程都享有一份变量的副本，线程之间对于变量的修改不会相互影响。 下面看两个常见的@State的写法：</p>
</li>
</ul>
<h2 id="要求"><a class="header" href="#要求">要求</a></h2>
<p>这个类必须遵循以下四条规则：</p>
<ul>
<li>有无参构造函数(默认构造函数)</li>
<li>必须公共类</li>
<li>如果是内部类，需要是静态内部类</li>
<li>必须使用 @State 注解</li>
</ul>
<h2 id="配置方式-1"><a class="header" href="#配置方式-1"><strong>配置方式</strong></a></h2>
<p>第一种是 Benchmark 不在 State 的类里。这时需要在测试方法的入参列表里显式注入该 State。</p>
<pre><code class="language-java">public class JMHSample_03_States {

    @State(Scope.Benchmark)
    public static class BenchmarkState {
        volatile double x = Math.PI;
    }

    @State(Scope.Thread)
    public static class ThreadState {
        volatile double x = Math.PI;
    }

    @Benchmark
    public void measureUnshared(ThreadState state) {
        state.x++;
    }

    @Benchmark
    public void measureShared(BenchmarkState state) {
        state.x++;
    }
}
</code></pre>
<p>第二种是 Benchmark 在 State 的类里。这时不需要在测试方法的入参列表里显式注入该 State。</p>
<pre><code class="language-java">@State(Scope.Thread)
public class JMHSample_04_DefaultState {

    double x = Math.PI;

    @Benchmark
    public void measure() {
        x++;
    }

}
</code></pre>
<h2 id="scope-1"><a class="header" href="#scope-1">Scope</a></h2>
<table><thead><tr><th>scope</th><th>描述</th></tr></thead><tbody>
<tr><td>Benchmark</td><td>Benchmark 中所有线程都使用同一个 State</td></tr>
<tr><td>Group</td><td>Benchmark 中同一 Benchmark 组（使用@Group标识，后面再讲）使用一个 State</td></tr>
<tr><td>Thread</td><td>Benchmark 中每个线程使用同一个 State</td></tr>
</tbody></table>
<h1 id="setup-和-teardown"><a class="header" href="#setup-和-teardown">@Setup 和 @TearDown</a></h1>
<p>这两个注解只能定义在注解了 State 里，其中，<code>@Setup</code>类似于 junit 的<code>@Before</code>，而<code>@TearDown</code>类似于 junit 的<code>@After</code>。</p>
<pre><code class="language-java">@State(Scope.Thread)
public class JMHSample_05_StateFixtures {

    double x;

    @Setup(Level.Iteration)
    public void prepare() {
        System.err.println(&quot;init............&quot;);
        x = Math.PI;
    }

    @TearDown(Level.Iteration)
    public void check() {
        System.err.println(&quot;destroy............&quot;);
        assert x &gt; Math.PI : &quot;Nothing changed?&quot;;
    }


    @Benchmark
    public void measureRight() {
        x++;
    }

}
</code></pre>
<p>这两个注解注释的方法的调用时机，主要受 Level 的控制，JMH 提供了三种 Level，如下：</p>
<ol>
<li>
<p>Trial</p>
<p>Benchmark 开始前或结束后执行，如下。Level 为 Benchmark 的 Setup 和 TearDown 方法的开销不会计入到最终结果。</p>
<pre><code class="language-java">//Benchmark
public void Benchmark01(){
    // call Setup method
    // 每个循环为一个iteration
    for(iterations){
        // 每个循环为一个invocation，这里会统计每次invocation的开销
        while(!timeout){
            // 调用我们的测试方法
        }
    }
    // call TearDown method
}
</code></pre>
</li>
<li>
<p>Iteration</p>
<p>Benchmark 里每个 Iteration 开始前或结束后执行，如下。Level 为 Iteration 的 Setup 和 TearDown 方法的开销不会计入到最终结果。</p>
<pre><code class="language-java">//Benchmark
public void Benchmark01(){
    // 每个循环为一个iteration
    for(iterations){
        // call Setup method
        // 每个循环为一个invocation，这里会统计每次invocation的开销
        while(!timeout){
            // 调用我们的测试方法
        }
        // call TearDown method
    }
}
</code></pre>
</li>
<li>
<p>Invocation</p>
<p>Iteration 里每次方法调用开始前或结束后执行，如下。<strong>Level 为 Invocation 的 Setup 和 TearDown 方法的开销将计入到最终结果</strong>。</p>
</li>
</ol>
<h1 id="jmh-maven"><a class="header" href="#jmh-maven">JMH Maven</a></h1>
<h2 id="引入插件"><a class="header" href="#引入插件">引入插件</a></h2>
<pre><code class="language-xml">&lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.2&lt;/version&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;shade&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;finalName&gt;${uberjar.name}&lt;/finalName&gt;
                            &lt;transformers&gt;
                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;
                                    &lt;mainClass&gt;org.openjdk.jmh.Main&lt;/mainClass&gt;
                                &lt;/transformer&gt;
                            &lt;/transformers&gt;
                            &lt;filters&gt;
                                &lt;filter&gt;
                                    &lt;artifact&gt;*:*&lt;/artifact&gt;
                                    &lt;excludes&gt;
                                        &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;
                                        &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;
                                        &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;
                                    &lt;/excludes&gt;
                                &lt;/filter&gt;
                            &lt;/filters&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
</code></pre>
<ul>
<li>
<p>用 JMH 生成骨架</p>
</li>
<li>
<pre><code class="language-powershell">  mvn archetype:generate ^
  -DinteractiveMode=false ^
  -DarchetypeGroupId=org.openjdk.jmh ^
  -DarchetypeArtifactId=jmh-java-benchmark-archetype ^
  -DarchetypeVersion=1.25 ^
  -DgroupId=cn.zzs.jmh ^
  -DartifactId=jmh-test01 ^
  -Dversion=1.0.0
</code></pre>
</li>
</ul>
<h1 id="jmh-sample"><a class="header" href="#jmh-sample">JMH Sample</a></h1>
<p><a href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/">JMH样例代码</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="反编译-javap"><a class="header" href="#反编译-javap">反编译-javap</a></h1>
<pre><code> -help  --help  -?        输出此用法消息
  -version                 版本信息
  -v  -verbose             输出附加信息
  -l                       输出行号和本地变量表
  -public                  仅显示公共类和成员
  -protected               显示受保护的/公共类和成员
  -package                 显示程序包/受保护的/公共类
                           和成员 (默认)
  -p  -private             显示所有类和成员
  -c                       对代码进行反汇编
  -s                       输出内部类型签名
  -sysinfo                 显示正在处理的类的
                           系统信息 (路径, 大小, 日期, MD5 散列)
  -constants               显示最终常量
  -classpath &lt;path&gt;        指定查找用户类文件的位置
  -cp &lt;path&gt;               指定查找用户类文件的位置
  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="传统的session认证"><a class="header" href="#传统的session认证">传统的session认证</a></h1>
<p>​	Http协议本身是一种无状态的协议,这就意味者,如果用户向我们的应用提供了用户和密码进行认证,那么下一次请求,用户还要再进行一次认证才行</p>
<p>​	所以为了让我们的应用能识别是哪个用户发出的请求,我们只能在服务存储一份用户登录信息,这份登录信息会在响应时传递给浏览器,告诉其保存为cookie,以便下次请求时发送给我们的应用,这个cookie也就是sessionId,这就是传统的基于session认证</p>
<h1 id="基于session认证所显露的问题"><a class="header" href="#基于session认证所显露的问题">基于session认证所显露的问题</a></h1>
<ul>
<li>用户过多服务端内存开销变大</li>
<li>在分布式的应用中,需要第三方组件同步session(例如 Redis)</li>
<li>CSRF:如果cookie被截获,用户就会容易遭受跨站请求伪造</li>
</ul>
<h1 id="基于token的鉴权机制"><a class="header" href="#基于token的鉴权机制">基于token的鉴权机制</a></h1>
<h2 id="什么是jwt"><a class="header" href="#什么是jwt">什么是JWT</a></h2>
<ul>
<li>
<p>JWT是 存有用户及其登陆信息的 json字符串</p>
</li>
<li>
<p>jwt将 以前 基于服务端的session认证  改成 基于jwt自身的认证( 即服务端接收到一个)</p>
</li>
<li>
<p>jwt 使用摘要算法,保证 header,跟payload 没有被篡改,也就保证了该token的合法性</p>
</li>
<li>
<p>但jwt没有保证 传输的 加密性, 在通信过程中可能被窃取</p>
</li>
</ul>
<h2 id="token认证流程"><a class="header" href="#token认证流程">token认证流程</a></h2>
<ul>
<li>用户使用用户名密码来请求服务器</li>
<li>服务器进行验证用户的信息</li>
<li>服务器通过验证发送给用户一个token</li>
<li>客户端存储token，并在每次请求时附送上这个token值</li>
<li>服务端验证token值，并返回数据</li>
</ul>
<p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持<code>CORS(跨来源资源共享)</code>策略，一般我们在服务端这么做就可以了<code>Access-Control-Allow-Origin: *</code>。</p>
<h2 id="token解析流程"><a class="header" href="#token解析流程">Token解析流程</a></h2>
<ol>
<li>服务收到token之后 首先判断该token有没有被人篡改
<ol>
<li>取 header跟 payload 跟服务端保存的 secret ,使用header中的签名算法做一次签名</li>
<li>然后与token中的  signature部分 对比,一致则认为没有被篡改</li>
<li>取 payload 中的 到期日期,判断token是否过期</li>
</ol>
</li>
</ol>
<h2 id="jwt的构成"><a class="header" href="#jwt的构成">JWT的构成</a></h2>
<h3 id="header"><a class="header" href="#header">header</a></h3>
<p>jwt的头部承载两部分信息：</p>
<ul>
<li>声明类型，这里是jwt</li>
<li>声明签名算法 通常直接使用 HMAC SHA256</li>
<li>示例</li>
</ul>
<pre><code>{
  'typ': 'JWT',
  'alg': 'HS256'
}
</code></pre>
<p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分.</p>
<h3 id="playload"><a class="header" href="#playload">playload</a></h3>
<p>存放有效信息的地方</p>
<ul>
<li>标准中注册的声明</li>
<li>公共的声明</li>
<li>私有的声明</li>
</ul>
<p><strong>标准中注册的声明</strong> (建议但不强制使用) ：</p>
<ul>
<li><strong>iss</strong>: jwt签发者</li>
<li><strong>sub</strong>: jwt所面向的用户</li>
<li><strong>aud</strong>: 接收jwt的一方</li>
<li><strong>exp</strong>: jwt的过期时间，这个过期时间必须要大于签发时间</li>
<li><strong>nbf</strong>: 定义在什么时间之前，该jwt都是不可用的.</li>
<li><strong>iat</strong>: jwt的签发时间</li>
</ul>
<p><strong>公共的声明</strong> ：
公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p>
<p><strong>私有的声明</strong> ：
私有声明是提供者和消费者所共同定义的声明，不要存放敏感信息,因为token。</p>
<pre><code class="language-json">{
  &quot;sub&quot;: &quot;1234567890&quot;,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;admin&quot;: true
}
</code></pre>
<p>然后将其进行base64加密，得到Jwt的第二部分。</p>
<h3 id="signature"><a class="header" href="#signature">signature</a></h3>
<p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<ul>
<li>header (base64后的)</li>
<li>payload (base64后的)</li>
<li>secret</li>
</ul>
<p>这个部分需要base64编码的header和base64编码的payload使用<code>.</code>连接组成的字符串，然后通过header中声明的签名方式进行加盐<code>secret</code>，然后就构成了jwt的第三部分。</p>
<pre><code class="language-csharp">// javascript
var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);

var signature = HMACSHA256(encodedString, 'secret'); // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</code></pre>
<p>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p>
<p>JWT的应用</p>
<pre><code class="language-bash">fetch('api/user/1', {
  headers: {
    'Authorization': 'Bearer ' + token
  }
})
</code></pre>
<h2 id="base64url算法"><a class="header" href="#base64url算法">Base64URL算法</a></h2>
<p>如前所述，JWT头和有效载荷序列化的算法都用到了Base64URL。该算法和常见Base64算法类似，稍有差别。</p>
<p>作为令牌的JWT可以放在URL中（例如api.example/?token=xxx）。 Base64中用的三个字符是&quot;+&quot;，&quot;/&quot;和&quot;=&quot;，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：&quot;=&quot;去掉，&quot;+&quot;用&quot;-&quot;替换，&quot;/&quot;用&quot;_&quot;替换，这就是Base64URL算法，很简单把。</p>
<h1 id="jwt的使用场景"><a class="header" href="#jwt的使用场景">JWT的使用场景</a></h1>
<h2 id="一次性验证"><a class="header" href="#一次性验证">一次性验证</a></h2>
<p>比如用户注册后需要发一封邮件让其激活账户，通常邮件中需要有一个链接，这个链接需要具备以下的特性：能够标识用户，该链接具有时效性（通常只允许几小时之内激活），不能被篡改以激活其他可能的账户…这种场景就和 jwt 的特性非常贴近，jwt 的 payload 中固定的参数：iss 签发者和 exp 过期时间正是为其做准备的。</p>
<h2 id="restful-api-的无状态认证"><a class="header" href="#restful-api-的无状态认证">restful api 的无状态认证</a></h2>
<p>​	使用 jwt 来做 restful api 的身份认证也是值得推崇的一种使用方案。客户端和服务端共享 secret；过期时间由服务端校验，客户端定时刷新；签名信息不可被修改…spring security oauth jwt 提供了一套完整的 jwt 认证体系，以笔者的经验来看：使用 oauth2 或 jwt 来做 restful api 的认证都没有大问题，oauth2 功能更多，支持的场景更丰富，后者实现简单。</p>
<h1 id="jwt的局限"><a class="header" href="#jwt的局限">JWT的局限</a></h1>
<h2 id="注销"><a class="header" href="#注销">注销</a></h2>
<p>传统的 session+cookie 方案用户点击注销，服务端清空 session 即可，因为状态保存在服务端。但 jwt 的方案就比较难办了，因为 jwt 是无状态的，服务端通过计算来校验有效性。没有存储起来，所以即使客户端删除了 jwt，但是该 jwt 还是在有效期内，只不过处于一个游离状态。分析下痛点：注销变得复杂的原因在于 jwt 的无状态。我提供几个方案，视具体的业务来决定能不能接受。</p>
<ul>
<li>仅仅清空客户端的 cookie，这样用户访问时就不会携带 jwt，服务端就认为用户需要重新登录。这是一个典型的假注销，对于用户表现出退出的行为，实际上这个时候携带对应的 jwt 依旧可以访问系统。</li>
<li>清空或修改服务端的用户对应的 secret，这样在用户注销后，jwt 本身不变，但是由于 secret 不存在或改变，则无法完成校验。这也是为什么将 secret 设计成和用户相关的原因。</li>
<li>借助第三方存储自己管理 jwt 的状态，可以以 jwt 为 key，实现去 redis 一类的缓存中间件中去校验存在性。方案设计并不难，但是引入 redis 之后，就把无状态的 jwt 硬生生变成了有状态了，违背了 jwt 的初衷。实际上这个方案和 session 都差不多了。</li>
</ul>
<h3 id="修改密码"><a class="header" href="#修改密码">修改密码</a></h3>
<p>修改密码则略微有些不同，假设号被到了，修改密码（是用户密码，不是 jwt 的 secret）之后，盗号者在原 jwt 有效期之内依旧可以继续访问系统，所以仅仅清空 cookie 自然是不够的，这时，需要强制性的修改 secret。在我的实践中就是这样做的。</p>
<h3 id="续签问题"><a class="header" href="#续签问题">续签问题</a></h3>
<p>续签问题可以说是我抵制使用 jwt 来代替传统 session 的最大原因，因为 jwt 的设计中我就没有发现它将续签认为是自身的一个特性。传统的 cookie 续签方案一般都是框架自带的，session 有效期 30 分钟，30 分钟内如果有访问，session 有效期被刷新至 30 分钟。而 jwt 本身的 payload 之中也有一个 exp 过期时间参数，来代表一个 jwt 的时效性，而 jwt 想延期这个 exp 就有点身不由己了，因为 payload 是参与签名的，一旦过期时间被修改，整个 jwt 串就变了，jwt 的特性天然不支持续签！ 如果你一定要使用 jwt 做会话管理（payload 中存储会话信息），也不是没有解决方案，但个人认为都不是很令人满意</p>
<h4 id="1每次请求刷新-jwt"><a class="header" href="#1每次请求刷新-jwt">1.每次请求刷新 jwt</a></h4>
<p>jwt 修改 payload 中的 exp 后整个 jwt 串就会发生改变，那…就让它变好了，每次请求都返回一个新的 jwt 给客户端。太暴力了，不用我赘述这样做是多么的不优雅，以及带来的性能问题。但，至少这是最简单的解决方案。</p>
<h4 id="2只要快要过期的时候刷新-jwt"><a class="header" href="#2只要快要过期的时候刷新-jwt">2.只要快要过期的时候刷新 jwt</a></h4>
<p>一个上述方案的改造点是，只在最后的几分钟返回给客户端一个新的 jwt。这样做，触发刷新 jwt 基本就要看运气了，如果用户恰巧在最后几分钟访问了服务器，触发了刷新，万事大吉；如果用户连续操作了 27 分钟，只有最后的 3 分钟没有操作，导致未刷新 jwt，无疑会令用户抓狂。</p>
<h4 id="3完善-refreshtoken"><a class="header" href="#3完善-refreshtoken">3.完善 refreshToken</a></h4>
<p>借鉴 oauth2 的设计，返回给客户端一个 refreshToken，允许客户端主动刷新 jwt。一般而言，jwt 的过期时间可以设置为数小时，而 refreshToken 的过期时间设置为数天。我认为该方案并可行性是存在的，但是为了解决 jwt 的续签把整个流程改变了，为什么不考虑下 oauth2 的 password 模式和 client 模式呢？</p>
<h4 id="4使用-redis-记录独立的过期时间"><a class="header" href="#4使用-redis-记录独立的过期时间">4.使用 redis 记录独立的过期时间</a></h4>
<p>实际上我的项目中由于历史遗留问题，就是使用 jwt 来做登录和会话管理的，为了解决续签问题，我们在 redis 中单独会每个 jwt 设置了过期时间，每次访问时刷新 jwt 的过期时间，若 jwt 不存在与 redis 中则认为过期。 同样改变了 jwt 的流程，不过嘛，世间安得两全法。我只能奉劝各位还未使用 jwt 做会话管理的朋友，尽量还是选用传统的 session+cookie 方案，有很多成熟的分布式 session 框架和安全框架供你开箱即用。</p>
<h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<p>https://www.liqingbo.cn/docs/jwt/content/application.html</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="一致性hash算法背景"><a class="header" href="#一致性hash算法背景">一致性Hash算法背景</a></h2>
<p>一致性哈希算法在1997年由麻省理工学院的Karger等人在<strong>解决分布式Cache</strong>中提出的，设计目标是为了解决因特网中的热点(Hot spot)问题，</p>
<p>但现在一致性hash算法在分布式系统中也得到了广泛应用，研究过memcached缓存数据库的人都知道，memcached服务器端本身不提供分布式cache的一致性，而是由客户端来提供，具体在计算一致性hash时采用如下步骤：</p>
<ol>
<li>首先求出memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。</li>
<li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</li>
<li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过2^32仍然找不到服务器，就会保存到第一台memcached服务器上。</li>
</ol>
<p><img src="32.%E5%85%B6%E4%BB%96_%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1//Users/weisanju/personnalNotes/note/src/images/consistency-hash-example1.png" alt="" /></p>
<p>余数分布式算法由于保存键的服务器会发生巨大变化而影响缓存的命中率</p>
<p>但Consistent Hashing中，只有在园（continuum）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响</p>
<h2 id="一致性hash性质"><a class="header" href="#一致性hash性质"><strong>一致性Hash性质</strong></a></h2>
<p>考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来，如何保证当系统的节点数目发生变化时仍然能够对外提供良好的服务，这是值得考虑的</p>
<p>尤其实在设计分布式缓存系统时，如果某台服务器失效，对于整个系统来说如果不采用合适的算法来保证一致性，那么缓存于系统中的所有数据都可能会失效（即由于系统节点数目变少，客户端在请求某一对象时需要重新计算其hash值（通常与系统中的节点数目有关），由于hash值已经改变，所以很可能找不到保存该对象的服务器节点），因此一致性hash就显得至关重要，良好的分布式cahce系统中的一致性hash算法应该满足以下几个方面：</p>
<ul>
<li>
<p><strong>平衡性(Balance)</strong></p>
<p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p>
</li>
<li>
<p><strong>单调性(Monotonicity)</strong></p>
<p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。简单的哈希算法往往不能满足单调性的要求，如最简单的线性哈希：x = (ax + b) mod (P)，在上式中，P表示全部缓冲的大小。不难看出，当缓冲大小发生变化时(从P1到P2)，原来所有的哈希结果均会发生变化，从而不满足单调性的要求。哈希结果的变化意味着当缓冲空间发生变化时，所有的映射关系需要在系统内全部更新。而在P2P系统内，缓冲的变化等价于Peer加入或退出系统，这一情况在P2P系统中会频繁发生，因此会带来极大计算和传输负荷。单调性就是要求哈希算法能够应对这种情况。</p>
</li>
<li>
<p><strong>分散性(Spread)</strong></p>
<p>在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</p>
</li>
</ul>
<ul>
<li><strong>负载(Load)</strong></li>
</ul>
<p>​	负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p>
<ul>
<li><strong>平滑性(Smoothness)</strong></li>
</ul>
<p>平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</p>
<h2 id="原理"><a class="header" href="#原理">原理</a></h2>
<ol>
<li>确定环：整个空间按顺时针方向组织。0和232-1在零点中方向重合。</li>
<li>确定服务器位置：下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的ip或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用ip地址哈希后在环空间的位置如下：</li>
<li>使用hash算法定位数据到 环中的服务器位置
<ol>
<li>将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</li>
</ol>
</li>
</ol>
<p>一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p>
<p>另外，一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。</p>
<h2 id="虚拟节点机制"><a class="header" href="#虚拟节点机制">虚拟节点机制</a></h2>
<p>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点</p>
<p>具体做法可以在服务器ip或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p>
<p><img src="32.%E5%85%B6%E4%BB%96_%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1//Users/weisanju/personnalNotes/note/src/images/consistency-hash-virtual-node.png" alt="" /></p>
<p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据库自增长序列或字段"><a class="header" href="#数据库自增长序列或字段"><strong>数据库自增长序列或字段</strong></a></h1>
<p>最常见的方式。利用数据库，全数据库唯一。</p>
<p>优点：</p>
<p>1）简单，代码方便，性能可以接受。</p>
<p>2）数字ID天然排序，对分页或者需要排序的结果很有帮助。</p>
<p>缺点：</p>
<p>1）不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理。</p>
<p>2）在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。</p>
<p>3）在性能达不到要求的情况下，比较难于扩展。</p>
<p>4）如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦。</p>
<p>5）分表分库的时候会有麻烦。</p>
<p><strong>优化方案：</strong></p>
<p>1）针对主库单点，如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个数。比如：Master1 生成的是 1，4，7，10，Master2生成的是2,5,8,11 Master3生成的是 3,6,9,12。这样就可以有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。</p>
<h1 id="uuid"><a class="header" href="#uuid"><strong>UUID</strong></a></h1>
<p>1）简单，代码方便。</p>
<p>2）生成ID性能非常好，基本不会有性能问题。</p>
<p>3）全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对。</p>
<p>缺点：</p>
<p>1）没有排序，无法保证趋势递增。</p>
<p>2）UUID往往是使用字符串存储，查询的效率比较低。</p>
<p>3）存储空间比较大，如果是海量数据库，就需要考虑存储量的问题。</p>
<p>4）传输数据量大</p>
<p>5）不可读。</p>
<h1 id="uuid的变种"><a class="header" href="#uuid的变种"><strong>UUID的变种</strong></a></h1>
<p>UUID不可读，可以使用UUID to Int64的方法</p>
<pre><code class="language-java">/// &lt;summary&gt;
/// 根据GUID获取唯一数字序列
/// &lt;/summary&gt;
public static long GuidToInt64()
{
    byte[] bytes = Guid.NewGuid().ToByteArray();
    return BitConverter.ToInt64(bytes, 0);
}
</code></pre>
<p>为了解决UUID无序的问题，NHibernate在其主键生成方式中提供了Comb算法（combined guid/timestamp）。保留GUID的10个字节，用另6个字节表示GUID生成的时间（DateTime）。</p>
<pre><code class="language-java">/// &lt;summary&gt; 
/// Generate a new &lt;see cref=&quot;Guid&quot;/&gt; using the comb algorithm. 
/// &lt;/summary&gt; 
private Guid GenerateComb()
{
    byte[] guidArray = Guid.NewGuid().ToByteArray();
 
    DateTime baseDate = new DateTime(1900, 1, 1);
    DateTime now = DateTime.Now;
 
    // Get the days and milliseconds which will be used to build    
    //the byte string    
    TimeSpan days = new TimeSpan(now.Ticks - baseDate.Ticks);
    TimeSpan msecs = now.TimeOfDay;
 
    // Convert to a byte array        
    // Note that SQL Server is accurate to 1/300th of a    
    // millisecond so we divide by 3.333333    
    byte[] daysArray = BitConverter.GetBytes(days.Days);
    byte[] msecsArray = BitConverter.GetBytes((long)
      (msecs.TotalMilliseconds / 3.333333));
 
    // Reverse the bytes to match SQL Servers ordering    
    Array.Reverse(daysArray);
    Array.Reverse(msecsArray);
 
    // Copy the bytes into the guid    
    Array.Copy(daysArray, daysArray.Length - 2, guidArray,
      guidArray.Length - 6, 2);
    Array.Copy(msecsArray, msecsArray.Length - 4, guidArray,
      guidArray.Length - 4, 4);
 
    return new Guid(guidArray);
}
</code></pre>
<h1 id="redis生成id"><a class="header" href="#redis生成id"><strong>Redis生成ID</strong></a></h1>
<p>当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。</p>
<p>可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。各个Redis生成的ID为：</p>
<blockquote>
<p>比较适合使用Redis来生成每天从0开始的流水号。比如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。</p>
</blockquote>
<p>优点：</p>
<p>1）不依赖于数据库，灵活方便，且性能优于数据库。</p>
<p>2）数字ID天然排序，对分页或者需要排序的结果很有帮助。</p>
<h1 id="twitter的snowflake算法"><a class="header" href="#twitter的snowflake算法"><strong>Twitter的snowflake算法</strong></a></h1>
<p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看https://github.com/twitter/snowflake。</p>
<p>snowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。</p>
<p>优点：</p>
<p>1）不依赖于数据库，灵活方便，且性能优于数据库。</p>
<p>2）ID按照时间在单机上是递增的。</p>
<p>缺点：</p>
<p>1）在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全局递增的情况。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分布式-session"><a class="header" href="#分布式-session">分布式 Session</a></h1>
<h2 id="粘性-session"><a class="header" href="#粘性-session">粘性 Session</a></h2>
<ul>
<li>
<p>场景</p>
<p>将用户锁定到某一个服务器上，用户第一次请求时，负载均衡器将用户的请求转发到了 A 服务器上，如果负载均衡器设置了粘性 Session 的话，那么用户以后的每次请求都会转发到 A 服务器上，相当于把用户和 A 服务器粘到了一块，这就是粘性 Session 机制。</p>
</li>
<li>
<p>优点</p>
<p>简单，不需要对 Session 做任何处理。</p>
</li>
<li>
<p>缺点</p>
<p>缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的 Session 信息都将失效。</p>
</li>
<li>
<p>适用场景</p>
<ul>
<li>发生故障对客户产生的影响较小；</li>
<li>服务器发生故障是低概率事件。</li>
</ul>
</li>
</ul>
<h2 id="服务器-session-复制"><a class="header" href="#服务器-session-复制">服务器 Session 复制</a></h2>
<ul>
<li>
<p>任何一个服务器上的 Session 发生改变，该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要 Session，以此来保证 Session 同步</p>
</li>
<li>
<p>优点</p>
<ul>
<li>可容错，各个服务器间 Session 能够实时响应。</li>
</ul>
</li>
<li>
<p>缺点</p>
<p>会对网络负荷造成一定压力，如果 Session 量大的话可能会造成网络堵塞，拖慢服务器性能</p>
</li>
<li>
<p>实现方式</p>
</li>
</ul>
<ol>
<li>设置 Tomcat 的 server.xml 开启 tomcat 集群功能。</li>
<li>在应用里增加信息：通知应用当前处于集群环境中，支持分布式，即在 web.xml 中添加<code>&lt;distributable/&gt;</code> 选项。</li>
</ol>
<h2 id="session-共享机制"><a class="header" href="#session-共享机制">Session 共享机制</a></h2>
<p>使用分布式缓存方案比如 Memcached、Redis，但是要求 Memcached 或 Redis 必须是集群。</p>
<ul>
<li>
<p>粘性 Session 共享机制</p>
<p>一个用户的 Session 会绑定到一个 Tomcat 上。Memcached 只是起到备份作用。</p>
</li>
<li>
<p>非粘性 Session 共享机制</p>
<p>Tomcat 本身不存储 Session，而是存入 Memcached 中。Memcached 集群构建主从复制架构。</p>
</li>
<li>
<p>实现方式</p>
<p>用开源的 msm 插件解决 Tomcat 之间的 Session 共享：Memcached_Session_Manager（MSM）</p>
</li>
</ul>
<h2 id="session-持久化到数据库"><a class="header" href="#session-持久化到数据库">Session 持久化到数据库</a></h2>
<p>拿出一个数据库，专门用来存储 Session 信息。保证 Session 的持久化。</p>
<ul>
<li>
<p>优点</p>
<p>服务器出现问题，Session 不会丢失</p>
</li>
<li>
<p>缺点</p>
<p>如果网站的访问量很大，把 Session 存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</p>
</li>
</ul>
<h2 id="terracotta-实现-session-复制"><a class="header" href="#terracotta-实现-session-复制">Terracotta 实现 Session 复制</a></h2>
<p>Terracotta 的基本原理是对于集群间共享的数据，当在一个节点发生变化的时候，Terracotta 只把变化的部分发送给 Terracotta 服务器，然后由服务器把它转发给真正需要这个数据的节点。它是服务器 Session 复制的优化。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分布式事务"><a class="header" href="#分布式事务">分布式事务</a></h1>
<h2 id="分布式事务产生原因"><a class="header" href="#分布式事务产生原因">分布式事务产生原因</a></h2>
<ul>
<li>数据库分库分表</li>
<li>SOA 架构</li>
</ul>
<h2 id="应用场景与解决方案"><a class="header" href="#应用场景与解决方案">应用场景与解决方案</a></h2>
<p>银行开户场景:手动实现的二阶段提交的协议，统计权值</p>
<p>消息中间件：</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="描述"><a class="header" href="#描述">描述</a></h1>
<ul>
<li>
<p>是一个开源的分布式的,为分布式应用提供协调服务的Apache项目</p>
</li>
<li>
<p>基于观察者模式设计的分布式服务管理框架</p>
</li>
<li>
<p>储存和管理大家关心的数据</p>
</li>
<li>
<p>一个领导者,多个跟随者组成的集群</p>
</li>
</ul>
<h1 id="特性-2"><a class="header" href="#特性-2">特性</a></h1>
<ul>
<li>集群中只要有半数以上节点存活,zookeeper 集群就能正常服务</li>
<li>全局数据一致,每个节点 数据相同</li>
<li>原子更新</li>
<li>实时性</li>
</ul>
<h1 id="数据模型结构"><a class="header" href="#数据模型结构">数据模型结构</a></h1>
<ul>
<li>与文件系统类似,整体上可以看作是一颗树</li>
<li>每个节点称作 znode,每个znode能存储1MB的数据</li>
<li>每个znode可以通过路径唯一标识</li>
</ul>
<h1 id="应用场景"><a class="header" href="#应用场景">应用场景</a></h1>
<ul>
<li>统一命名服务</li>
<li>统一配置管理</li>
<li>统一集群管理</li>
<li>服务节点动态上下线</li>
<li>负载均衡</li>
</ul>
<h1 id="基本操作-1"><a class="header" href="#基本操作-1">基本操作</a></h1>
<p><em>./zkServer.sh start|status|stop</em></p>
<p><em>./zkCli.sh</em></p>
<h1 id="配置解读"><a class="header" href="#配置解读">配置解读</a></h1>
<table><thead><tr><th>配置名</th><th>解释</th></tr></thead><tbody>
<tr><td><em>tickTime</em></td><td>心跳帧发送的时长</td></tr>
<tr><td><em>initLimit</em></td><td>启动时,最大延迟的 心跳帧的 个数</td></tr>
<tr><td><em>syncLimit</em></td><td>启动后,最大延迟的心跳帧的个数</td></tr>
<tr><td><em>dataDir</em></td><td>数据保存目录</td></tr>
<tr><td><em>clientPort</em></td><td>监听客户端连接的  端口</td></tr>
</tbody></table>
<h1 id="内部原理"><a class="header" href="#内部原理">内部原理</a></h1>
<p>选举机制</p>
<ul>
<li>
<p>半数机制</p>
<p>集群中半数以上机器存活,集群可用,所以zookeeper适合安装奇数台服务器</p>
</li>
<li>
<p>选举机制</p>
<ul>
<li>zookeeper的master 和 slave 是通过选举产生的</li>
<li>根据启动顺序 投最大的id的 服务,达到半数以上则选举成功</li>
</ul>
</li>
</ul>
<p>节点类型</p>
<ul>
<li>
<p>持久 </p>
<p>客户端和服务器断开的连接后,节点不删除</p>
<p>分两类持久化节点</p>
<ul>
<li>持久化目录节点</li>
<li>持久化顺序编号目录节点
<ul>
<li>按顺序编号</li>
<li>可以用于所有事件进行全局排序</li>
</ul>
</li>
</ul>
</li>
<li>
<p>短暂 </p>
<p>客户端和服务器断开的连接后,节点自己删除</p>
</li>
</ul>
<h1 id="zookeeper集群搭建"><a class="header" href="#zookeeper集群搭建">Zookeeper集群搭建</a></h1>
<ol>
<li>
<p>同步文件</p>
</li>
<li>
<p>在<em>zkData</em> 创建 <em>myid</em>文件</p>
</li>
<li>
<p>增加 服务器配置</p>
<pre><code>server.2=hadoop1:2888:3888
server.3=hadoop2:2888:3888
server.4=hadoop3:2888:3888
2888:leader与follower 的交换信息的端口
3888:选举端口
</code></pre>
</li>
<li>
<pre><code>systemctl stop firewalld &amp;&amp; ./zookeeper/bin/zkServer.sh start &amp;&amp; ./zookeeper/bin/zkServer.sh status
</code></pre>
</li>
</ol>
<h1 id="客户端命令行操作"><a class="header" href="#客户端命令行操作">客户端命令行操作</a></h1>
<table><thead><tr><th>操作</th><th>解析</th></tr></thead><tbody>
<tr><td><em>ziCli.sh</em></td><td>启动客户端</td></tr>
<tr><td><em>help</em></td><td>帮助</td></tr>
<tr><td><em>ls /</em></td><td>查看当前节点</td></tr>
<tr><td><em>create /path  data_string</em></td><td>创建普通节点</td></tr>
<tr><td><em>get /path</em></td><td>获取节点的值</td></tr>
<tr><td><em>create -e /path data_string</em></td><td>短暂结点</td></tr>
<tr><td><em>create -s /path data_string</em></td><td>序号节点</td></tr>
<tr><td><em>set /path data_value</em></td><td>修改节点的值</td></tr>
<tr><td><em>get /path watch</em></td><td>监听节点的值变化</td></tr>
<tr><td><em>ls /path watch</em></td><td>监听目录节点</td></tr>
<tr><td><em>delete /path</em></td><td>删除空节点或者非目录节点</td></tr>
<tr><td><em>rmr</em></td><td>递归删除节点</td></tr>
<tr><td><em>stat</em></td><td>查看节点状态</td></tr>
</tbody></table>
<h1 id="stat结构体解析"><a class="header" href="#stat结构体解析"><em>stat</em>结构体解析</a></h1>
<table><thead><tr><th>名称</th><th>解析</th></tr></thead><tbody>
<tr><td><em>czxid</em></td><td>事务id,每次修改zookeeper都会收到<em>zxid</em>的时间戳</td></tr>
<tr><td><em>ctime</em></td><td>znode被创建的毫秒数</td></tr>
<tr><td><em>mzxid</em></td><td>最后更新的事务<em>zxid</em></td></tr>
<tr><td><em>mtime</em></td><td>最后被修改的毫秒数</td></tr>
<tr><td><em>pzxid</em></td><td>最后更新的子节点的<em>zxid</em></td></tr>
<tr><td><em>cversion</em></td><td>子节点变化号,<em>znode</em>子节点修改次数</td></tr>
<tr><td><em>dataversion</em></td><td>数据变化号</td></tr>
<tr><td><em>aclVersion</em></td><td>访问控制列表变化号</td></tr>
<tr><td><em>ephemeralOwner</em></td><td>临时节点的拥有者的 sessionID,不是临时节点为0</td></tr>
<tr><td><em>dataLength</em></td><td>数据长度</td></tr>
<tr><td><em>numChildren</em></td><td>子节点数量</td></tr>
</tbody></table>
<h1 id="cs跨进程间监听器原理"><a class="header" href="#cs跨进程间监听器原理">C/S跨进程间监听器原理</a></h1>
<ol>
<li>客户端在main线程中创建两个线程,一个<em>connect</em>负责 与<em>zookeeper</em>服务器网络通信,另一个<em>listener</em>负责监听</li>
<li>通过<em>connect</em>将被监听的对象 发送到 服务器</li>
<li>服务器检测到 监听事件发生,将消息发送给 <em>listener</em>线程</li>
<li><em>listener</em>线程调用 <em>process</em>方法</li>
</ol>
<h1 id="写数据流程"><a class="header" href="#写数据流程">写数据流程</a></h1>
<ul>
<li>如果<em>server1</em>不是<em>leader</em> ,将请求转发给<em>leader</em></li>
<li><em>leader</em>会将写的数据广播给<em>follower</em></li>
<li><em>follower</em>数据写成功了之后会通知<em>leader</em></li>
<li>当大多数写成功了,<em>leader</em>即可认为写成功,然后通知客户端</li>
</ul>
<h1 id="acl访问权限与节点模式"><a class="header" href="#acl访问权限与节点模式">ACL访问权限与节点模式</a></h1>
<h1 id="服务器动态上下线功能"><a class="header" href="#服务器动态上下线功能">服务器动态上下线功能</a></h1>
<ul>
<li>往服务器注册监听,临时节点</li>
<li>客户端监听<em>getChildren</em>,一旦有服务器下线,就会自动重新注册</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分布式锁"><a class="header" href="#分布式锁">分布式锁</a></h1>
<p>Java 提供了两种内置的锁的实现，一种是由 JVM 实现的 synchronized 和 JDK 提供的 Lock</p>
<p>当你的应用是单机或者说单进程应用时，可以使用 synchronized 或 Lock 来实现锁</p>
<h2 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h2>
<p>应用端 、web端同时进行操作</p>
<h2 id="数据库分布式锁"><a class="header" href="#数据库分布式锁">数据库分布式锁</a></h2>
<ul>
<li>
<p>基于mysql锁表</p>
<ul>
<li>依靠数据库唯一索引来实现</li>
<li>没有失效时间，会导致死锁</li>
<li>只能是非阻塞</li>
<li>不可重入</li>
</ul>
</li>
<li>
<p>乐观锁增加版本号</p>
<p>根据版本号来判断更新之前有没有其他线程更新过，如果被更新过，则获取锁失败。</p>
</li>
</ul>
<h2 id="redis-分布式锁"><a class="header" href="#redis-分布式锁">Redis 分布式锁</a></h2>
<ul>
<li>
<p>基于 SETNX、EXPIRE</p>
<ul>
<li>使用 SETNX（set if not exist）命令插入一个键值对时，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True</li>
<li>EXPIRE 可以为一个键值对设置一个过期时间，从而避免了死锁的发生。</li>
</ul>
</li>
<li>
<p>RedLock 算法</p>
<ul>
<li>ReadLock 算法使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时还可用。</li>
<li>尝试从 N 个相互独立 Redis 实例获取锁，如果一个实例不可用，应该尽快尝试下一个。</li>
<li>计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数（N/2+1）实例上获取了锁，那么就认为锁获取成功了。</li>
<li>如果锁获取失败，会到每个实例上释放锁。</li>
</ul>
</li>
<li>
<p>Zookeeper 分布式锁</p>
<ul>
<li>
<p>Zookeeper 提供了一种树形结构级的命名空间</p>
</li>
<li>
<p>节点类型</p>
<ul>
<li>永久节点：不会因为会话结束或者超时而消失；</li>
<li>临时节点：如果会话结束或者超时就会消失；</li>
<li>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，依次类推。</li>
</ul>
</li>
<li>
<p>监听器</p>
<p>为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。</p>
</li>
<li>
<p>分布式锁实现</p>
<ul>
<li>创建一个锁目录 /lock。</li>
<li>在 /lock 下创建临时的且有序的子节点，第一个客户端对应的子节点为 /lock/lock-0000000000，第二个为 /lock/lock-0000000001，以此类推。</li>
<li>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；</li>
<li>执行业务代码，完成后，删除对应的子节点。</li>
</ul>
</li>
<li>
<p>会话超时</p>
<ul>
<li>如果一个已经获得锁的会话超时了，因为创建的是临时节点，因此该会话对应的临时节点会被删除，其它会话就可以获得锁了</li>
</ul>
</li>
<li>
<p>羊群效应</p>
<ul>
<li>只需要监听前一个子节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="分布式锁应该具备哪些条件"><a class="header" href="#分布式锁应该具备哪些条件"><strong>分布式锁应该具备哪些条件</strong></a></h1>
<ol>
<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； </li>
<li>高可用的获取锁与释放锁； </li>
<li>高性能的获取锁与释放锁； </li>
<li>具备可重入特性； </li>
<li>具备锁失效机制，防止死锁； </li>
<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</li>
</ol>
<h1 id="常见分布式锁方案对比"><a class="header" href="#常见分布式锁方案对比">常见分布式锁方案对比</a></h1>
<h3 id="常见分布式锁方案对比-1"><a class="header" href="#常见分布式锁方案对比-1">常见分布式锁方案对比</a></h3>
<table><thead><tr><th>分类</th><th>方案</th><th>实现原理</th><th>优点</th><th>缺点</th></tr></thead><tbody>
<tr><td>基于数据库</td><td>基于mysql 表唯一索引</td><td>1.表增加唯一索引 2.加锁：执行insert语句，若报错，则表明加锁失败 3.解锁：执行delete语句</td><td>完全利用DB现有能力，实现简单</td><td>1.锁无超时自动失效机制，有死锁风险 2.不支持锁重入，不支持阻塞等待 3.操作数据库开销大，性能不高</td></tr>
<tr><td>基于MongoDB findAndModify原子操作</td><td>1.加锁：执行findAndModify原子命令查找document，若不存在则新增 2.解锁：删除document</td><td>实现也很容易，较基于MySQL唯一索引的方案，性能要好很多</td><td>1.大部分公司数据库用MySQL，可能缺乏相应的MongoDB运维、开发人员 2.锁无超时自动失效机制</td><td></td></tr>
<tr><td>基于分布式协调系统</td><td>基于ZooKeeper</td><td>1.加锁：在/lock目录下创建临时有序节点，判断创建的节点序号是否最小。若是，则表示获取到锁；否，则则watch /lock目录下序号比自身小的前一个节点 2.解锁：删除节点</td><td>1.由zk保障系统高可用 2.Curator框架已原生支持系列分布式锁命令，使用简单</td><td>需单独维护一套zk集群，维保成本高</td></tr>
<tr><td>基于缓存</td><td>基于redis命令</td><td>1. 加锁：执行setnx，若成功再执行expire添加过期时间 2. 解锁：执行delete命令</td><td>实现简单，相比数据库和分布式系统的实现，该方案最轻，性能最好</td><td>1.setnx和expire分2步执行，非原子操作；若setnx执行成功，但expire执行失败，就可能出现死锁 2.delete命令存在误删除非当前线程持有的锁的可能 3.不支持阻塞等待、不可重入</td></tr>
<tr><td>基于redis Lua脚本能力</td><td>1. 加锁：执行SET lock_name random_value EX seconds NX 命令  2. 解锁：执行Lua脚本，释放锁时验证random_value  -- ARGV[1]为random_value, KEYS[1]为lock_nameif redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then  return redis.call(&quot;del&quot;,KEYS[1])else  return 0end</td><td>同上；实现逻辑上也更严谨，除了单点问题，生产环境采用用这种方案，问题也不大。</td><td>不支持锁重入，不支持阻塞等待</td><td></td></tr>
</tbody></table>
<h1 id="redisson分布式锁的实现"><a class="header" href="#redisson分布式锁的实现">Redisson分布式锁的实现</a></h1>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<pre><code class="language-java">// 1.构造redisson实现分布式锁必要的Config
Config config = new Config();
config.useSingleServer().setAddress(&quot;redis://127.0.0.1:5379&quot;).setPassword(&quot;123456&quot;).setDatabase(0);
// 2.构造RedissonClient
RedissonClient redissonClient = Redisson.create(config);
// 3.获取锁对象实例（无法保证是按线程的顺序获取到）
RLock rLock = redissonClient.getLock(lockKey);
try {
    /**
     * 4.尝试获取锁
     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败
     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）
     */
    boolean res = rLock.tryLock((long)waitTimeout, (long)leaseTime, TimeUnit.SECONDS);
    if (res) {
        //成功获得锁，在这里处理业务
    }
} catch (Exception e) {
    throw new RuntimeException(&quot;aquire lock fail&quot;);
}finally{
    //无论如何, 最后都要解锁
    rLock.unlock();
}
</code></pre>
<h2 id="基于lua脚本的加锁解锁"><a class="header" href="#基于lua脚本的加锁解锁">基于LUA脚本的加锁解锁</a></h2>
<p><strong>介绍</strong></p>
<p>如果要手写一个分布式锁组件，肯定要定义2个接口：加锁、解锁；redisson 的作者就是在加锁和解锁的执行层面采用Lua脚本，有原子性保证。</p>
<ul>
<li>加锁和解锁过程中还巧妙地利用了redis的发布订阅功能</li>
</ul>
<h3 id="加锁lua脚本"><a class="header" href="#加锁lua脚本"><strong>加锁Lua脚本</strong></a></h3>
<p><strong>脚本入参</strong></p>
<table><thead><tr><th>参数</th><th>示例值</th><th>含义</th></tr></thead><tbody>
<tr><td>KEY个数</td><td>1</td><td>KEY个数</td></tr>
<tr><td>KEYS[1]</td><td>my_first_lock_name</td><td>锁名</td></tr>
<tr><td>ARGV[1]</td><td>60000</td><td>持有锁的有效时间：<strong>毫秒</strong></td></tr>
<tr><td>ARGV[2]</td><td>58c62432-bb74-4d14-8a00-9908cc8b828f:1</td><td><strong>唯一标识</strong>：获取锁时set的唯一值，实现上为redisson客户端<strong>ID(UUID)+线程ID</strong></td></tr>
</tbody></table>
<pre><code class="language-lua">-- 若锁不存在：则新增锁，并设置锁重入计数为1、设置锁过期时间
if (redis.call('exists', KEYS[1]) == 0) then
    redis.call('hset', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end;
 
-- 若锁存在，且唯一标识也匹配：则表明当前加锁请求为锁重入请求，故锁重入计数+1，并再次设置锁过期时间
if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end;
 
-- 若锁存在，但唯一标识不匹配：表明锁是被其他线程占用，当前线程无权解他人的锁，直接返回锁剩余过期时间
return redis.call('pttl', KEYS[1]);
</code></pre>
<p><strong>当且仅当返回nil，才表示加锁成功</strong>，否则返回锁的超时时间</p>
<p><strong>流程图</strong></p>
<p><img src="32.%E5%85%B6%E4%BB%96_%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/../images/distribute-lock-lua-lock.png" alt="" /></p>
<h3 id="解锁lua脚本"><a class="header" href="#解锁lua脚本"><strong>解锁Lua脚本</strong></a></h3>
<p><strong>脚本入参</strong></p>
<table><thead><tr><th>参数</th><th>示例值</th><th>含义</th></tr></thead><tbody>
<tr><td>KEY个数</td><td>2</td><td>KEY个数</td></tr>
<tr><td>KEYS[1]</td><td>my_first_lock_name</td><td>锁名</td></tr>
<tr><td>KEYS[2]</td><td>redisson_lock__channel:{my_first_lock_name}</td><td><strong>解锁消息PubSub频道</strong></td></tr>
<tr><td>ARGV[1]</td><td>0</td><td><strong>redisson定义0表示解锁消息</strong></td></tr>
<tr><td>ARGV[2]</td><td>30000</td><td>设置锁的过期时间；默认值30秒</td></tr>
<tr><td>ARGV[3]</td><td>58c62432-bb74-4d14-8a00-9908cc8b828f:1</td><td>唯一标识；同加锁流程</td></tr>
</tbody></table>
<p><strong>脚本内容</strong></p>
<pre><code class="language-lua">-- 若锁不存在：则直接广播解锁消息，并返回1
if (redis.call('exists', KEYS[1]) == 0) then
    redis.call('publish', KEYS[2], ARGV[1]);
    return 1; 
end;
 
-- 若锁存在，但唯一标识不匹配：则表明锁被其他线程占用，当前线程不允许解锁其他线程持有的锁
if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then
    return nil;
end; 
 
-- 若锁存在，且唯一标识匹配：则先将锁重入计数减1
local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); 
if (counter &gt; 0) then 
    -- 锁重入计数减1后还大于0：表明当前线程持有的锁还有重入，不能进行锁删除操作，但可以友好地帮忙设置下过期时期
    redis.call('pexpire', KEYS[1], ARGV[2]); 
    return 0; 
else 
    -- 锁重入计数已为0：间接表明锁已释放了。直接删除掉锁，并广播解锁消息，去唤醒那些争抢过锁但还处于阻塞中的线程
    redis.call('del', KEYS[1]); 
    redis.call('publish', KEYS[2], ARGV[1]); 
    return 1;
end;
 
return nil;
</code></pre>
<p><strong>流程</strong></p>
<p><img src="32.%E5%85%B6%E4%BB%96_%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1//images/distribute-lock-lua-unlock.png" alt="" /></p>
<p><strong>广播解锁消息有什么用？</strong> </p>
<ul>
<li>是为了通知其他争抢锁阻塞住的线程，从阻塞中解除，并再次去争抢锁。</li>
</ul>
<p><strong>返回值0、1、nil有什么不一样？</strong> </p>
<ul>
<li>当且仅当返回1，才表示当前请求真正触发了解锁Lua脚本；但客户端又并不关心解锁请求的返回值，好像没什么用</li>
</ul>
<h2 id="流程"><a class="header" href="#流程">流程</a></h2>
<h2 id="用户操作时序图"><a class="header" href="#用户操作时序图">用户操作时序图</a></h2>
<pre><code class="language-mermaid">sequenceDiagram
	participant a as 客户端
    participant c as 服务端
	participant b as 分布式锁中心
	a-&gt;&gt; c:带着资源id尝试操作资源
	c-&gt;&gt; b:判断资源是否被锁定
alt 未锁定，则锁定
	b-&gt;&gt;c:获取锁成功
	c-&gt;&gt;c:操作资源
	c-&gt;&gt;a:返回操作结果
else 已被其他占用
	b-&gt;&gt;c:获取锁失败
	c-&gt;&gt;a:返回其他人已经在操作，请稍后重试
end
</code></pre>
<h1 id="代码实现"><a class="header" href="#代码实现">代码实现</a></h1>
<ul>
<li><input disabled="" type="checkbox"/>
<p><strong>实现 <em>JDK</em> 锁接口</strong></p>
<blockquote>
<p>lock锁接口详见 <a href="32.%E5%85%B6%E4%BB%96_%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/../java/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/%E5%9F%BA%E4%BA%8EAQS%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/Lock%E9%94%81%E6%8E%A5%E5%8F%A3.html">Lock</a></p>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
无阻塞方式</li>
<li><input disabled="" type="checkbox"/>
阻塞方式</li>
<li><input disabled="" type="checkbox"/>
超时方式</li>
<li><input disabled="" type="checkbox"/>
支持可配置锁定时长，超时自动续期</li>
<li><input disabled="" type="checkbox"/>
锁资源管理界面 手动释放锁</li>
<li><input disabled="" type="checkbox"/>
支持多底层切换
<ul>
<li><input disabled="" type="checkbox"/>
单机环境，支持使用 JDK各个锁实现</li>
<li><input disabled="" type="checkbox"/>
集群环境，支持 redis，<em>zookeeper</em></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<p>设计 <em>JMH</em> 基准比对测试</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>设计<em>Jmeter</em> 测试场景</p>
</li>
<li><input disabled="" type="checkbox"/>
<p><strong>基于注解的分布式锁支持</strong></p>
</li>
<li><input disabled="" type="checkbox"/>
<p><strong>支持基于Spring注解的动态代理支持</strong></p>
</li>
<li><input disabled="" type="checkbox"/>
<p><strong>支持 <em>SpringEL</em> 表达式</strong></p>
</li>
<li><input disabled="" type="checkbox"/>
<p><em>SpringBootStarter</em> 支持</p>
</li>
</ul>
<h1 id="类设计"><a class="header" href="#类设计">类设计</a></h1>
<h2 id="锁信息"><a class="header" href="#锁信息">锁信息</a></h2>
<ul>
<li>锁定 唯一资源 ID</li>
<li>锁定人</li>
<li>锁定过期时间</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计方案"><a class="header" href="#设计方案">设计方案</a></h1>
<h2 id="通用存储"><a class="header" href="#通用存储">通用存储</a></h2>
<p>锁资源存放 可以是 本地内存，可以是 <em>redis</em>，可以是数据库，可以是 <em>zookeeper</em></p>
<h2 id="使用简单"><a class="header" href="#使用简单">使用简单</a></h2>
<p>用户只应关注 key的生成策略，屏蔽加锁，记录判断等逻辑由 框架实现</p>
<h2 id="支持注解"><a class="header" href="#支持注解">支持注解</a></h2>
<p>注解，能够做到对代码 少侵入</p>
<h2 id="多级存储"><a class="header" href="#多级存储">多级存储</a></h2>
<p>比如一级存储可以用内存来实现 例如，本地内存或者 Redis 来实现，优点是性能高，适用于 90%的场景。</p>
<p>二级存储可以支持 Mysql, Mongo 等数据库，适用于时间长或者永久存储的场景。</p>
<p>二级存储可以做持久化</p>
<h1 id="概述-14"><a class="header" href="#概述-14">概述</a></h1>
<p>对同一个系统，使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的</p>
<p>幂等有两个维度：一是空间维度上的幂等，即幂等对象的范围，是个人还是机构，是某一次交易还是某种类型的交易...</p>
<h1 id="幂等性适用领域"><a class="header" href="#幂等性适用领域">幂等性适用领域</a></h1>
<p>电商支付，银行金融</p>
<h1 id="解决办法"><a class="header" href="#解决办法">解决办法</a></h1>
<h2 id="mvcc"><a class="header" href="#mvcc">MVCC</a></h2>
<h2 id="多版本并发控制"><a class="header" href="#多版本并发控制">多版本并发控制</a></h2>
<p>multiversion  concurent control</p>
<p>启用版本号</p>
<h2 id="去重表"><a class="header" href="#去重表">去重表</a></h2>
<p>建立唯一性索引</p>
<h2 id="token机制"><a class="header" href="#token机制">TOKEN机制</a></h2>
<p>为每一次操作生成一个唯一性凭证，</p>
<p>一个token在操作的每一个阶段只有一次执行权，一旦执行成功则保存执行结果。对重复的请求，返回同一个结果</p>
<p>服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的</p>
<ol>
<li>
<p>就必须在执行业务前，先去获取token，服务器会把token保存到redis中。</p>
</li>
<li>
<p>然后调用业务接口请求时，把token携带过去，一般放在请求头部。</p>
</li>
<li>
<p>服务器判断token是否存在redis中，存在表示第一次请求，可以继续执行业务，执行业务完成后，最后需要把redis中的token删除。</p>
</li>
<li>
<p>如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="负载均衡的算法与实现"><a class="header" href="#负载均衡的算法与实现">负载均衡的算法与实现</a></h1>
<h2 id="算法"><a class="header" href="#算法">算法</a></h2>
<p>顺序、加权轮询</p>
<p>最少连接算法（least Connections）：将请求发送给当前最少连接数的服务器</p>
<p>加权最小连接：在最小连接的基础上，根据服务器的性能为每台服务器分配权重，根据权重计算出每台服务器能处理的连接数。</p>
<p>随机算法（Random）：该算法比较适合服务器性能差不多的场景</p>
<h2 id="实现"><a class="header" href="#实现">实现</a></h2>
<p>DNS负载均衡</p>
<p>链路层负载均衡器</p>
<p>修改IP负载均衡</p>
<p>HTTP 重定向</p>
<p>反向代理</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="上手"><a class="header" href="#上手">上手</a></h1>
<h2 id="依赖-2"><a class="header" href="#依赖-2"><strong>依赖</strong></a></h2>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.jeasy&lt;/groupId&gt;
    &lt;artifactId&gt;easy-rules-core&lt;/artifactId&gt;
    &lt;version&gt;4.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="定义规则"><a class="header" href="#定义规则"><strong>定义规则</strong></a></h2>
<h3 id="注解定义"><a class="header" href="#注解定义">注解定义</a></h3>
<pre><code class="language-java">@Rule(name = &quot;weather rule&quot;, description = &quot;if it rains then take an umbrella&quot;)
public class WeatherRule {

    @Condition
    public boolean itRains(@Fact(&quot;rain&quot;) boolean rain) {
        return rain;
    }
    
    @Action
    public void takeAnUmbrella() {
        System.out.println(&quot;It rains, take an umbrella!&quot;);
    }
}
</code></pre>
<h3 id="fluent-api定义"><a class="header" href="#fluent-api定义">Fluent API定义</a></h3>
<pre><code class="language-java">Rule weatherRule = new RuleBuilder()
        .name(&quot;weather rule&quot;)
        .description(&quot;if it rains then take an umbrella&quot;)
        .when(facts -&gt; facts.get(&quot;rain&quot;).equals(true))
        .then(facts -&gt; System.out.println(&quot;It rains, take an umbrella!&quot;))
        .build();
</code></pre>
<h3 id="表达式语言"><a class="header" href="#表达式语言">表达式语言</a></h3>
<pre><code class="language-java">Rule weatherRule = new MVELRule()
        .name(&quot;weather rule&quot;)
        .description(&quot;if it rains then take an umbrella&quot;)
        .when(&quot;rain == true&quot;)
        .then(&quot;System.out.println(\&quot;It rains, take an umbrella!\&quot;);&quot;);
</code></pre>
<h3 id="yaml的规则描述器"><a class="header" href="#yaml的规则描述器">YAML的规则描述器</a></h3>
<pre><code class="language-yml">name: &quot;weather rule&quot;
description: &quot;if it rains then take an umbrella&quot;
condition: &quot;rain == true&quot;
actions:
  - &quot;System.out.println(\&quot;It rains, take an umbrella!\&quot;);&quot;
</code></pre>
<pre><code class="language-java">MVELRuleFactory ruleFactory = new MVELRuleFactory(new YamlRuleDefinitionReader());
Rule weatherRule = ruleFactory.createRule(new FileReader(&quot;weather-rule.yml&quot;));
</code></pre>
<h2 id="使用-6"><a class="header" href="#使用-6">使用</a></h2>
<pre><code class="language-java">  // 定义事实
        Facts facts = new Facts();
        facts.put(&quot;rain&quot;, true);

        // 定义规则
        Rule weatherRule = ...
        Rules rules = new Rules();
        rules.register(weatherRule);

        // 使用规则引擎执行
        RulesEngine rulesEngine = new DefaultRulesEngine();
        rulesEngine.fire(rules, facts);
</code></pre>
<h1 id="对规则的抽象"><a class="header" href="#对规则的抽象">对规则的抽象</a></h1>
<h2 id="规则的定义"><a class="header" href="#规则的定义">规则的定义</a></h2>
<p>包括：名字、描述、优先级、事实集合、条件集合和行动集合</p>
<h2 id="规则的比较"><a class="header" href="#规则的比较">规则的比较</a></h2>
<p><em>UnitRuleGroup</em></p>
<p>要么应用所有规则,要么都不应用, 规则组里的规则 是一个整体</p>
<p><em>ActivationRuleGroup</em></p>
<p>第一个满足条件的会被触发,其他的会被忽略 ,规则首先会被以优先级排序</p>
<p>ConditionalRuleGroup</p>
<p>以优先级排序,当前规则返回true 则触发余下规则</p>
<h2 id="规则引擎"><a class="header" href="#规则引擎">规则引擎</a></h2>
<p><strong>DefaultRulesEngine</strong></p>
<p>（以规则的自然顺序执行）和</p>
<p><strong>InferenceRulesEngine</strong></p>
<p>（一直执行直到没有可用的规则），且接受包括优先级阈值等的参数。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chrono"><a class="header" href="#chrono">chrono</a></h1>
<p>chrono包提供历法相关的接口与实现。Java中默认使用的历法是ISO 8601日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天，闰年是366天。闰年的定义是：非世纪年，能被4整除；世纪年能被400整除。为了计算的一致性，公元1年的前一年被当做公元0年，以此类推。此外chrono包提供了四种其他历法，每种历法有自己的纪元（Era）类、日历类和日期类，分别是：</p>
<ul>
<li>泰国佛教历：ThaiBuddhistEra、ThaiBuddhistChronology和ThaiBuddhistDate；</li>
<li>民国历：MinguoEra、MinguoChronology和MinguoDate；</li>
<li>日本历：JapaneseEra、JapaneseChronology和JapaneseDate</li>
<li>伊斯兰历：HijrahEra、HijrahChronology和HijrahDate：</li>
</ul>
<h1 id="format"><a class="header" href="#format">format</a></h1>
<p>format包提供了日期格式化的方法。format包中定义了时区名称、日期解析和格式化的各种枚举，以及最为重要的格式化类DateTimeFormatter。需要注意的是，format包类中的类都是final的，都提供了线程安全的访问。在DateTimeFormatter类中提供了ofPattern的静态方法来获得一个DateTimeFormatter，但细看其实现，其实还是调用的DateTimeFormatterBuilder的静态方法：<code>DateTimeFormatterBuilder.appendPattern(pattern).toFormatter();</code>所以我们在实际格式化日期和时间的时候，是两种方式都可以使用的。</p>
<h1 id="temporal"><a class="header" href="#temporal">temporal</a></h1>
<p>temporal包中定义了整个日期时间框架的基础：各种时间单位、时间调节器，以及在年月日时分秒中用到的各种属性。Java8中的日期时间类都是实现了temporal包中的时间单位（Temporal）、时间调节器（TemporalAdjuster）和各种属性的接口，所以在后面的日期的操作方法中都是以最基本的时间单位和各种属性为参数的。</p>
<h1 id="zone"><a class="header" href="#zone">zone</a></h1>
<p>定义了时区转换的各种方法。</p>
<h1 id="java-8日期时间类"><a class="header" href="#java-8日期时间类">Java 8日期/时间类</a></h1>
<h2 id="instant"><a class="header" href="#instant">Instant</a></h2>
<ul>
<li>
<p>时间戳</p>
</li>
<li>
<p>Instant可以精确到纳秒,这超过了long的最大表示范围,实现中是分成了两部分来表示，一部分是<code>seconds</code>，表示从1970-01-01 00:00:00开始到现在的秒数，另一个部分是<code>nanos</code>，表示纳秒部分</p>
</li>
<li>
<p>创建方式</p>
<pre><code class="language-java">Instant now = Instant.now(); 
Instant instant = Instant.ofEpochSecond(60, 100000);
</code></pre>
</li>
</ul>
<h2 id="duration"><a class="header" href="#duration">Duration</a></h2>
<ul>
<li>
<p>Duration是两个时间戳的差值</p>
</li>
<li>
<p>包含两部分：<code>seconds</code>表示秒，<code>nanos</code>表示纳秒</p>
</li>
</ul>
<pre><code class="language-java">LocalDateTime from = LocalDateTime.of(2020, Month.JANUARY, 22, 16, 6, 0);    // 2020-01-22 16:06:00
LocalDateTime to = LocalDateTime.of(2020, Month.FEBRUARY, 22, 16, 6, 0);     // 2020-02-22 16:06:00
Duration duration = Duration.between(from, to);     // 表示从 2020-01-22 16:06:00到 2020-02-22 16:06:00 这段时间
</code></pre>
<pre><code class="language-java">Duration duration1 = Duration.of(5, ChronoUnit.DAYS);       // 5天
Duration duration2 = Duration.of(1000, ChronoUnit.MILLIS);  // 1000毫秒
</code></pre>
<h2 id="period"><a class="header" href="#period">Period</a></h2>
<ul>
<li>
<p>以年月日来衡量一个时间段 (比如1年2个月3天：<code>Period period = Period.of(1, 2, 3);</code> )</p>
<pre><code class="language-java">Period period = Period.between(
                LocalDate.of(2020, 1, 22),
                LocalDate.of(2020, 2, 22));
</code></pre>
</li>
</ul>
<h4 id="localdatelocaltimelocaldatetime"><a class="header" href="#localdatelocaltimelocaldatetime">LocalDate/LocalTime/LocalDateTime</a></h4>
<p><strong>简单的日期操作</strong></p>
<blockquote>
<p>简单的日期操作，比如增加、减少一天、修改年月日等</p>
</blockquote>
<pre><code class="language-java">LocalDate date = LocalDate.of(2020, 2, 22);          // 2020-02-22
LocalDate date1 = date.withYear(2021);              // 修改为 2021-02-22
LocalDate date2 = date.withMonth(3);                // 修改为 2020-03-22
LocalDate date3 = date.withDayOfMonth(1);           // 修改为 2020-02-01
LocalDate date4 = date.plusYears(1);                // 增加一年 2021-02-22
LocalDate date5 = date.minusMonths(2);              // 减少两个月，到2019年的12月  2019-12-22
LocalDate date6 = date.plus(5, ChronoUnit.DAYS);    // 增加5天 2020-02-27
</code></pre>
<p><strong>复杂的日期操作</strong></p>
<blockquote>
<p>比较复杂的日期操作，比如将时间调到下一个工作日，或者是下个月的最后一天，这时候我们可以使用with()方法的另一个重载方法，它接收一个TemporalAdjuster参数，可以使我们更加灵活的调整日期</p>
</blockquote>
<pre><code class="language-java">LocalDate date7 = date.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));      // 返回下一个距离当前时间最近的星期日 2020-02-23
LocalDate date9 = date.with(TemporalAdjusters.lastInMonth(DayOfWeek.SATURDAY));  // 返回本月最后一个周六 2020-02-29
</code></pre>
<p><code>TemporalAdjuster</code>API</p>
<table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody>
<tr><td>dayOfWeekInMonth</td><td>返回同一个月中每周的第几天</td></tr>
<tr><td>firstDayOfMonth</td><td>返回当月的第一天</td></tr>
<tr><td>firstDayOfNextMonth</td><td>返回下月的第一天</td></tr>
<tr><td>firstDayOfNextYear</td><td>返回下一年的第一天</td></tr>
<tr><td>firstDayOfYear</td><td>返回本年的第一天</td></tr>
<tr><td>firstInMonth</td><td>返回同一个月中第一个星期几</td></tr>
<tr><td>lastDayOfMonth</td><td>返回当月的最后一天</td></tr>
<tr><td>lastDayOfNextMonth</td><td>返回下月的最后一天</td></tr>
<tr><td>lastDayOfNextYear</td><td>返回下一年的最后一天</td></tr>
<tr><td>lastDayOfYear</td><td>返回本年的最后一天</td></tr>
<tr><td>lastInMonth</td><td>返回同一个月中最后一个星期几</td></tr>
<tr><td>next / previous</td><td>返回后一个/前一个给定的星期几</td></tr>
<tr><td>nextOrSame / previousOrSame</td><td>返回后一个/前一个给定的星期几，如果这个值满足条件，直接返回</td></tr>
</tbody></table>
<h2 id="时区"><a class="header" href="#时区">时区</a></h2>
<pre><code class="language-java">//根据字符串获取时区
ZoneId shanghaiZoneId = ZoneId.of(&quot;Asia/Shanghai&quot;);
//获取系统默认时区
ZoneId systemZoneId = ZoneId.systemDefault();
//获取时区字符串
Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();
//新旧时区转换
ZoneId oldToNewZoneId = TimeZone.getDefault().toZoneId();

//转换ZonedDateTime 对象
LocalDateTime localDateTime = LocalDateTime.now();
ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, shanghaiZoneId);
</code></pre>
<p>ZonedDateTime对象由两部分构成，LocalDateTime和ZoneId，其中2020-02-22T16:50:54.658部分为LocalDateTime，+08:00[Asia/Shanghai]部分为ZoneId。另一种表示时区的方式是使用ZoneOffset，它是以当前时间和世界标准时间（UTC）/格林威治时间（GMT）的偏差来计算，例如：</p>
<pre><code class="language-java">ZoneOffset zoneOffset = ZoneOffset.of(&quot;+09:00&quot;); 
LocalDateTime localDateTime = LocalDateTime.now(); 
OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spi是什么"><a class="header" href="#spi是什么">SPI是什么</a></h1>
<p>SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。</p>
<p><img src="50.%E5%85%B6%E4%BB%96_%E6%9C%AA%E5%88%86%E7%B1%BB//images/spi.png" alt="" /></p>
<h1 id="使用场景-1"><a class="header" href="#使用场景-1">使用场景</a></h1>
<ul>
<li>数据库驱动加载接口实现类的加载  JDBC加载不同类型数据库的驱动</li>
<li>日志门面接口实现类加载  SLF4J加载不同提供商的日志实现类</li>
<li>Spring ，Spring中大量使用了SPI,比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等</li>
</ul>
<h1 id="使用规范"><a class="header" href="#使用规范">使用规范</a></h1>
<p>实现SPI，就需要按照SPI本身定义 的规范来进行配置，SPI规范如下：</p>
<ul>
<li>需要在classpath下创建一个目录，该目录命名必须是：META-INF/services</li>
<li>在该目录下创建一个文件，该文件需要满足以下几个条件
<ul>
<li>文件名必须是扩展的接口的全路径名称</li>
<li>文件内部描述的是该扩展接口的所有实现类</li>
<li>文件的编码格式是UTF-8</li>
</ul>
</li>
<li>SPI的实现类<strong>必须携带一个不带参数的构造方法</strong></li>
</ul>
<h1 id="示例-11"><a class="header" href="#示例-11">示例</a></h1>
<p><img src="50.%E5%85%B6%E4%BB%96_%E6%9C%AA%E5%88%86%E7%B1%BB//images/spi_sqldriver.png" alt="" /></p>
<h1 id="总结-19"><a class="header" href="#总结-19">总结</a></h1>
<h2 id="spi是如何进行类加载的"><a class="header" href="#spi是如何进行类加载的">SPI是如何进行类加载的</a></h2>
<ul>
<li>通过规定 类的定义与 类的注册 方式来动态加载类</li>
</ul>
<pre><code class="language-java">public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) {
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}
</code></pre>
<h2 id="spi为什么会破坏双亲委派机制"><a class="header" href="#spi为什么会破坏双亲委派机制">SPI为什么会破坏双亲委派机制</a></h2>
<p>因为 Java核心库定义了一系列 核心SPI接口，这些接口类是由 系统类加载器加载的，而系统类加载器 无法加载 实现类，所以需要使用 线程上下文的类加载器</p>
<h2 id="spi的优缺点"><a class="header" href="#spi的优缺点">SPI的优缺点</a></h2>
<p><strong>优点</strong></p>
<p>相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式使得源框架，不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类：</p>
<ul>
<li>代码硬编码import 导入实现类</li>
<li>指定类全路径反射获取：例如在JDBC4.0之前，JDBC中获取数据库驱动类需要通过<strong>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</strong>，类似语句先动态加载数据库相关的驱动，然后再进行获取连接等的操作</li>
<li>第三方服务模块把接口实现类实例注册到指定地方，源框架从该处访问实例</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。</li>
<li>并发多线程使用ServiceLoader类的实例是不安全的。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javaunsafe类与cas操作-1"><a class="header" href="#javaunsafe类与cas操作-1">JavaUnsafe类与CAS操作</a></h1>
<h2 id="前言-13"><a class="header" href="#前言-13">前言</a></h2>
<p>最近看java源码发现有多处地方都使用到了Unsafe类,于是在网上查阅资料教程.以下是个人总结</p>
<h2 id="unsafe简介-1"><a class="header" href="#unsafe简介-1">Unsafe简介</a></h2>
<p>Unsafe两大功能:</p>
<ol>
<li>直接通过内存地址 修改对象,获取对象引用</li>
<li>使用硬件指令 实现 原子操作 (CAS compare and swap)</li>
</ol>
<p>Unsafe的使用:</p>
<ol>
<li>
<p>Unsafe是典型的单例模式,通过  <code>public static Unsafe getUnsafe()</code>获取实例</p>
</li>
<li>
<p>且 该方法被 <code>@CallerSensitive</code>所注解, 表明只能由系统类加载器加载的类所调用</p>
</li>
<li>
<p>为了在测试代码中使用Unsafe,可以通过反射获取该类的静态字段的实例</p>
<pre><code class="language-java">Field f= Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
f.setAccessible(true);
Unsafe u = (Unsafe) f.get(null);
</code></pre>
</li>
</ol>
<h2 id="unsafe-api-1"><a class="header" href="#unsafe-api-1">Unsafe API</a></h2>
<h3 id="获取偏移-1"><a class="header" href="#获取偏移-1">获取偏移</a></h3>
<ol>
<li>
<p>获取成员变量在 对象中的偏移</p>
<p><code>public native long objectFieldOffset(Field f);</code></p>
</li>
<li>
<p>获取静态成员所在 的类,返回<code>Class</code>对象</p>
<p><code>public native Object staticFieldBase(Field f);</code></p>
</li>
<li>
<p>获取静态成员在 类中的偏移</p>
<p><code>public native long staticFieldOffset(Field f);</code></p>
</li>
<li>
<p>获取数组首个元素 在数组对象中的偏移</p>
<p><code>public native int arrayBaseOffset(Class arrayClass);</code></p>
</li>
<li>
<p>获取每个数组元素所占空间</p>
<p><code>public native int arrayIndexScale(Class arrayClass);</code></p>
</li>
</ol>
<h3 id="根据-对象偏移--获取或设置-对象中字段的引用或值-1"><a class="header" href="#根据-对象偏移--获取或设置-对象中字段的引用或值-1">根据 对象+偏移  获取或设置 对象中字段的引用或值</a></h3>
<ol>
<li>
<p>获取 对象var1内部中偏移为var2的 XXX类型字段的 值或引用</p>
<pre><code class="language-java">public native byte getXxxx(Object var1, long var2);
例如
   public native byte getByte(Object var1, long var2);
   public native int getInt(Object var1, long var2);
   public native double getDouble(long var1);
   public native boolean getBoolean(Object var1, long var2);
   public native Object getObject(Object var1, long var2);
......
</code></pre>
</li>
<li>
<p>设置对象var1内部中偏移为var2的 XXX类型字段的值 为var4</p>
<pre><code class="language-java"> public native void putBoolean(Object var1, long var2, boolean var4);
 public native void putByte(Object var1, long var2, byte var4);
 public native void putInt(Object var1, long var2, int var4);
 public native void putObject(Object var1, long var2, Object var4);
......
</code></pre>
</li>
<li>
<p>带<code>volatile</code>语义的<code>get,put</code>:表示多线程之间的变量可见,一个线程修改一个变量之后,另一个线程立刻能看到</p>
<pre><code class="language-JAVA">public native void putBooleanVolatile(Object var1, long var2, boolean var4);
public native int getIntVolatile(Object var1, long var2);
public native long getLongVolatile(Object var1, long var2);
......
</code></pre>
</li>
</ol>
<h3 id="本地内存操作-1"><a class="header" href="#本地内存操作-1">本地内存操作</a></h3>
<ol>
<li>
<p>分配指定大小的一块本地内存 (同C语言中的 malloc)</p>
<p><code>public native long allocateMemory(long bytes);</code></p>
</li>
<li>
<p>重新分配内存(同C语言中的 realloc)</p>
<p><code>public native long reallocateMemory(long address, long bytes);</code></p>
</li>
<li>
<p>将给定的内存块  的所有字节 <code>bytes</code> 设置成固定的值 <code>value</code> (通过 <code>object + offset</code> 确定内存的基址)(同C语言中的 memset)</p>
<p><code>public native void setMemory(Object o, long offset, long bytes, byte value);</code></p>
</li>
<li>
<p>复制内存块,<code>内存块 srcBasc+srcOffset + bytes - &gt; destBase+destOffset + bytes</code>  (同C语言中的 memcpy)</p>
<p><code>public native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset,long bytes);</code></p>
</li>
<li>
<p>释放通过Allocate分配的本地内存(同C语言中的 free)</p>
<p><code> public native void freeMemory(long address);</code></p>
</li>
<li>
<p>获取和设置本地内存中的值,va1表示本地内存绝对地址,var3表示要设置的值</p>
<pre><code class="language-java">public native short getShort(long var1);
public native int getInt(long var1);
public native void putShort(long var1, short var3);
public native void putInt(long var1, int var3);
</code></pre>
</li>
</ol>
<h3 id="cas操作-1"><a class="header" href="#cas操作-1">CAS操作</a></h3>
<p><code>java.util.concurrent 包中无锁化的实现就是调用了CAS以下原子操作</code></p>
<ol start="0">
<li>
<p>CAS语义</p>
<ol>
<li>将 由var1+var2确定的地址的值  从var4 修改成 var5 </li>
<li>如果旧值不为 var4,则直接退出</li>
<li>多个线程修改同一个变量时, 只会有一个线程修改成功,其他线程不会被挂起,而是告知失败</li>
<li>这是一种 乐观锁的语义, 每个线程都假设自己的操作能成功,与之相对应的synchronized的悲观锁语义,每次修改操作必须 只能有一个线程独占资源</li>
</ol>
</li>
<li>
<p>设置 通过 var1+var2确定的内存基址的int类型变量,将值原子的从 var4 变成 var5,成功true,失败false</p>
<pre><code class="language-java">替换int值:public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
替换引用:public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);
</code></pre>
</li>
<li>
<p>基于上面操作的包装方法: 得到对象 中某个int字段的值 通过(var1+var2), 并给该值加上 var4,返回相加前的值</p>
<pre><code class="language-Java">典型实现
public final int getAndAddInt(Object var1, long var2, int var4) {
        int var5;
        do {
            var5 = this.getIntVolatile(var1, var2);
        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
        return var5;
    }
</code></pre>
</li>
</ol>
<h3 id="packunpack-1"><a class="header" href="#packunpack-1">Pack/Unpack</a></h3>
<ol>
<li>
<p>阻塞和释放任一线程对象</p>
</li>
<li>
<p>内部实现通过 信号量的方式,信号量值为1,pack 消耗值, unpack增加值</p>
</li>
<li>
<p>在 <code>LockSupport </code>类包装使用</p>
</li>
</ol>
<h2 id="example-9"><a class="header" href="#example-9">Example</a></h2>
<pre><code>//测试对象
public class UnsafeEntity {
    private  int a;
    private  int c;
    private  int d;
    private  static  int b = 1;
    getter......
    setter......
}
</code></pre>
<pre><code class="language-java">
//测试代码
package com.weisanju;
import sun.misc.Unsafe;
import java.lang.reflect.Field;

public class UnsafeTest {
    public static void main(String[] args) throws Exception {
        Field f= Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
        f.setAccessible(true);
        Unsafe u = (Unsafe) f.get(null);
        //获取成员变量 的偏移
        long a = u.objectFieldOffset(UnsafeEntity.class.getDeclaredField(&quot;a&quot;));
        long c = u.objectFieldOffset(UnsafeEntity.class.getDeclaredField(&quot;c&quot;));
        long d = u.objectFieldOffset(UnsafeEntity.class.getDeclaredField(&quot;d&quot;));
        System.out.println(&quot;成员字段a:&quot;+a);
        System.out.println(&quot;成员字段c:&quot;+c);
        System.out.println(&quot;成员字段d:&quot;+d);

        //设置对象字段的值
        UnsafeEntity testa = new UnsafeEntity();
        testa.setA(666);
        System.out.println(&quot;设置前:&quot;+u.getInt(testa, a));
        u.putInt(testa,a,777);
        System.out.println(&quot;设置后:&quot;+u.getInt(testa, a));

        //获取静态字段所在的类的对象
        System.out.println(u.staticFieldBase(UnsafeEntity.class.getDeclaredField(&quot;b&quot;)));
        //获取静态字段的偏移
        long b = u.staticFieldOffset(UnsafeEntity.class.getDeclaredField(&quot;b&quot;));
        System.out.println(&quot;静态字段b:&quot;+b);

        //静态字段的设置, 注意由于静态字段,存储于方法区,所以起始对象为类的字节码
        System.out.println(&quot;设置前:&quot;+u.getInt(UnsafeEntity.class, b));
        u.putInt(UnsafeEntity.class,b,11);
        System.out.println(&quot;设置后:&quot;+u.getInt(UnsafeEntity.class, b));


        //普通 数组的使用
        int arr[] = {1,2,3,4,5,6,7,8};
        //head为头地址偏移
        long head = u.arrayBaseOffset(int[].class);
        //step为数组元素所占空间
        long step = u.arrayIndexScale(int[].class);
        // 获取 与设置 arr[7] 的值
        int index = 7;
        System.out.println(u.getInt(arr, head + step * index));
        u.putInt(arr,head+step*index,666);
        System.out.println(arr[index]);

        //对象数组的使用
        UnsafeEntity arrObj[] = new UnsafeEntity[10];
        //head为头地址偏移
        head = u.arrayBaseOffset(UnsafeEntity[].class);
        //step为数组元素所占空间
        step = u.arrayIndexScale(UnsafeEntity[].class);
        // 获取 与设置 arr[7] 的值
        index = 7;
        arrObj[index] = new UnsafeEntity();
        System.out.println(u.getObject(arrObj, head + step * index));
        u.putObject(arrObj,head+step*index,new UnsafeEntity());
        System.out.println(arrObj[index]);
    }
}
</code></pre>
<pre><code>输出结果
成员字段a:12
成员字段c:16
成员字段d:20
设置前:666
设置后:777
class com.weisanju.UnsafeEntity
静态字段b:104
设置前:1
设置后:11
8
666
com.weisanju.UnsafeEntity@1540e19d
com.weisanju.UnsafeEntity@677327b6
</code></pre>
<h2 id="总结-20"><a class="header" href="#总结-20">总结</a></h2>
<ol>
<li>Unsafe为从cpu底层指令 层面 为多线程提供了无锁化设计,以及直接操作内存地址的能力,Java中 Atomic原子类,netty,concurrent包等底层都封装了 该对象</li>
<li>当然 极大的效率,也必然意外着 极大的不安全, 如果错误给一块内存区赋值,程序不会有任何反应,这就给程序带来极大的安全隐患</li>
<li>当然了解Unsafe类 能够便于我们更好的阅读 Java底层源码</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java异常类结构图"><a class="header" href="#java异常类结构图">Java异常类结构图</a></h1>
<p><img src="50.%E5%85%B6%E4%BB%96_%E6%9C%AA%E5%88%86%E7%B1%BB/../../images/RuntimeException.png" alt="" /></p>
<p>**错误：**Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p>
<p>**异常：**Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。</p>
<p><strong>综上针对这些异常，可以分为两类：非检查异常、检查异常.</strong></p>
<p><strong>非检查异常</strong>：上图中的Error 和 RuntimeException 以及他们的子类都属于非检查异常。这类异常在javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try...catch...finally）这样的异常，也可以不处理。</p>
<p><strong>检查异常</strong>：除了Error 和 RuntimeException的其它异常都属于检查异常。这类异常是javac强制要求程序员为这样的异常做预备处理工作（使用try...catch...finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的</p>
<p><strong>finally块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：System.exit()。</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型变换"><a class="header" href="#类型变换">类型变换</a></h1>
<p><strong>类型变换指的是在一种类型的基础上构造 / 映射 / 变换出另一种新类型，是质的转变，即原类型与新类型不在一个抽象层面上。</strong></p>
<h3 id="具体公式"><a class="header" href="#具体公式">具体公式</a></h3>
<p>有<code>X</code>、<code>Y</code>2种类型，而符号<code>≤</code>表示子类型关系（比如：<code>X ≤ Y</code>即类型<code>X</code>是类型<code>Y</code>的子类型），<code>f</code>表示类型变换，
假设<code>X ≤ Y</code>，并且<code>X</code>和<code>Y</code>经过同一类型变换<code>f</code>后构造出对应更复杂的类型<code>f(X)</code>和<code>f(Y)</code>，那么就可以得出如下这些结论：</p>
<ul>
<li><strong>如果<code>f(X) ≤ f(Y)</code>，即保持<code>X</code>和<code>Y</code>的关系，那么类型变换<code>f</code>是协变的（covariant），或具有协变性；</strong></li>
<li><strong>如果<code>f(Y) ≤ f(X)</code>，即逆转<code>X</code>和<code>Y</code>的关系，那么类型变换<code>f</code>是逆变的（contravariant），或具有逆变性；</strong></li>
<li><strong>如果即是<code>f(X) ≤ f(Y)</code>也是<code>f(Y) ≤ f(X)</code>，那么类型变换<code>f</code>是双变的（bivariant），或具有双变性；</strong></li>
<li><strong>如果既不是<code>f(X) ≤ f(Y)</code>也不是<code>f(Y) ≤ f(X)</code>，那么类型变换<code>f</code>是不可变的（invariant），或具有不可变</strong></li>
</ul>
<h1 id="数组的协变"><a class="header" href="#数组的协变">数组的协变</a></h1>
<p>如果一只猫是一只动物，那一群猫是一群动物吗？一群狗是一群动物吗？Java数组认为是的。于是你可以这样写：</p>
<pre><code class="language-java">Animal[] animals = new Cat[2];

Animal[] animals = new Cat[2];
animals[0] = new Cat();
// 下面这行代码会抛运行时异常
animals[1] = new Dog();
Animal animal = animal[0];
</code></pre>
<p>这种情况，编译器100%过，而运行时100%抛异常</p>
<p>如果Cat是Animal的子类型，那么Cat[]也是Animal[]的子类型，我们称这种性质为<strong>协变</strong>（covariance）。<strong>Java中，数组是协变的</strong>。</p>
<h1 id="泛型的不变性"><a class="header" href="#泛型的不变性">泛型的不变性</a></h1>
<p><strong>Java中的泛型是不变（invariance）</strong></p>
<p>也就是说，<code>List&lt;Cat&gt;</code>并不是<code>List&lt;Animal&gt;</code>的子类型</p>
<h1 id="消费场景的协变"><a class="header" href="#消费场景的协变">消费场景的协变</a></h1>
<p>比如，我希望有一个Animal的集合，我不用去管它里面存的具体类型是什么，但我每次从这个集合取出来的，一定是<strong>一个Animal或其子类</strong>。这是一种典型的消费场景，从集合中取出元素来消费。</p>
<p>在消费场景，Java提供了通配符和extends关键字来支持泛型的协变。</p>
<pre><code class="language-java">List&lt;? extends Animal&gt; animals = new LinkedList&lt;Cat&gt;();
// 以下四行代码都不能编译通过
// animals.add(new Dog());
// animals.add(new Cat());
// animals.add(new Animal());
// animals.add(new Object());
// 可以添加null，但没意义
animals.add(null);
// 可以安全地取出来
Animal animal = animals.get(0);
</code></pre>
<p>为什么协变下不能写入呢？因为<strong>协变下写入是不安全的</strong>，</p>
<h1 id="生产场景的逆变"><a class="header" href="#生产场景的逆变">生产场景的逆变</a></h1>
<p>我们希望有一个集合，可以往里面写入Animal及其子类。那可以通过super关键字来定义泛型集合：</p>
<pre><code class="language-java">// 下面这行代码编译不通过
// List&lt;? super Animal&gt; animals = new LinkedList&lt;Cat&gt;();
// 下面都是OK的写法
// List&lt;? super Animal&gt; animals = new LinkedList&lt;Object&gt;();
// List&lt;? super Animal&gt; animals = new LinkedList&lt;Animal&gt;();
// 等价于上面一行的写法
List&lt;? super Animal&gt; animals = new LinkedList&lt;&gt;();
animals.add(new Cat());
animals.add(new Dog());
// 取出来一定是Object
Object object = animals.get(0);

// 这样写是OK的
List&lt;? super Cat&gt; cats = new LinkedList&lt;Animal&gt;();

</code></pre>
<p>逆变（contravariance），也称逆协变，从名字可以看出来，它与协变的性质是相反的。也就是说，<code>List&lt;Animal&gt;</code> 是<code>List&lt;? super Cat&gt;</code>的子类型。</p>
<h1 id="任意类型通配符"><a class="header" href="#任意类型通配符">任意类型通配符</a></h1>
<p>也就是说，它是“无界”的，对于任意类型X，<code>List&lt;X&gt;</code>都是<code>List&lt;?&gt;</code>的子类型。但<code>List&lt;?&gt;</code>不能<code>add</code>，get出来也是Object类型。它同时具有协变和逆变的两种性质，上界是Object，但不能调用add方法。</p>
<p>那它与List<Object>有什么区别呢？根据前面的推断，有两个比较明显的区别：</p>
<ul>
<li>List<Object>可以调用add方法，但List&lt;?&gt;不能。</li>
<li><code>List&lt;?&gt;</code>可以协变，上界是Object，但List<Object>不能协变。</li>
</ul>
<h3 id="何时限制通配符的上界或下界"><a class="header" href="#何时限制通配符的上界或下界">何时限制通配符的上界或下界？</a></h3>
<p><strong>PECS表示producer-extends，consumer-super。</strong></p>
<p><strong>更加通俗具体地理解就是参数化类型是只读的，那就用<code>extends</code>限制通配符的上界；参数化类型是只写的，那就用<code>super</code>限制通配符的下界。</strong></p>
<h1 id="java泛型中的协变"><a class="header" href="#java泛型中的协变">Java泛型中的协变</a></h1>
<pre><code>(? extend Animal) 是 Animal的子类类型，但是不确定是哪种
//泛型协变原则：子类类型				父类类型
Collection&lt;? extend Animal&gt;  &lt;= Collection&lt;Animal&gt;
//面向对象：子类类型可以转换成父类类型


? super Animal 是 Animal的 父类类型：
//逆变原则：如何匹配具体的类型

? super Animal &lt;= Animal

//面向对象：子类类型可以转换成父类类型
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="见图"><a class="header" href="#见图">见图</a></h1>
<p><img src="50.%E5%85%B6%E4%BB%96_%E6%9C%AA%E5%88%86%E7%B1%BB//images/po_vo_bo.jfif" alt="" /></p>
<p><strong>PO（Persistant Object）-持久对象</strong></p>
<p>一个PO对应数据库表中的一条记录，等同于entity，一般PO仅用于表示数据，除了拥有get、set方法，没有操作数据的方法。</p>
<p><strong>BO（business object）-业务对象</strong></p>
<p>BO可以看成是PO的组合，例如：一个订单会有商品PO、购买人PO等，可以建立一个BO处理订单信息。这样处理业务逻辑时就可以针对BO来处理，对外就不会暴露数据表结构了。可以根据实际需要把业务处理方法放在BO里面。</p>
<p><strong>VO（value object /view object）-值对象/表现层对象</strong></p>
<p>主要对应前台页面显示的数据对象，例如常见的json。</p>
<p><strong>DTO（Data Transfer Object）-数据传输对象</strong></p>
<p>跨层级或者跨进程传输时用到的对象，例如微服务中服务于服务之间的调用传输的对象就是DTO。DTO和VO的比较相似但是还是有些差异，这些主要体现在设计上或对业务的解释上，例如：同一个gender属性，DTO中的值可能是“1”，VO为了更好理解则会转化为“男”。</p>
<p><strong>DAO（data access object）-数据访问对象</strong></p>
<p>用来访问数据库，封装对数据库的增删改查操作，PO一起使用。</p>
<p><strong>POJO（plain ordinary java object）-简单Java对象</strong></p>
<p>可以理解为最常用到的Java Bean，PO、VO、DTO都是典型的POJO，它是一个中间对象可以转化为PO、DTO、VO。</p>
<p>不同类型的“O”在不同的架构层级中扮演不同的角色，每种“O”都有不同的用途，目的就是为了更好的封装自己的服务及有效的控制数据的传播。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-14"><a class="header" href="#前言-14">前言</a></h1>
<p>WeakCache&lt;K,P,V&gt;中，K代表key值，P代表参数，V代表存储的值。</p>
<p>此类用于缓存{（key，sub-key）--&gt;value}键值对</p>
<p>Keys and values are 弱引用 sub-keys are 强引用. 键直接传递给 get 方法，该方法也接受一个参数</p>
<p>sub-keys 是使用 <em>subKeyFactory</em>  从键计算出来的，使用传递给构造函数的 valueFactory 函数从 keys and parameter 中计算 values，键可以为空并通过标识进行比较，而 subKeyFactory 返回的子键或 valueFactory 返回的值不能为空</p>
<p>sub-keys使用它们的 equals 方法比较</p>
<p>当 keys的 WeakReferences 被清除时,每次get、containsValue 、 size methods   调用时都会从缓存中懒惰地删除条目</p>
<p>清除对单个值的 WeakReferences 不会导致删除，但这些条目在逻辑上被视为不存在，并根据请求对其键/子键触发重新评估 valueFactory。</p>
<h1 id="实现-1"><a class="header" href="#实现-1">实现</a></h1>
<pre><code class="language-java">//缓存Map
private final ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map = new ConcurrentHashMap&lt;&gt;();
// 用于 size、containsValue，快速查找
private final ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap = new ConcurrentHashMap&lt;&gt;();
</code></pre>
<h1 id="构造方法"><a class="header" href="#构造方法">构造方法</a></h1>
<pre><code class="language-java">public WeakCache(BiFunction&lt;K, P, ?&gt; subKeyFactory, BiFunction&lt;K, P, V&gt; valueFactory) {
	this.subKeyFactory = Objects.requireNonNull(subKeyFactory);
	this.valueFactory = Objects.requireNonNull(valueFactory);
}
</code></pre>
<p>这样我们就可以通过subKeyFactory ，valueFactory 获取对应的子键与值。</p>
<h1 id="静态内部类"><a class="header" href="#静态内部类">静态内部类</a></h1>
<h2 id="cachevalue"><a class="header" href="#cachevalue">CacheValue</a></h2>
<p>静态内部类，实际上就是用于存储一个值的对象</p>
<pre><code class="language-java">private interface Value&lt;V&gt; extends Supplier&lt;V&gt; {}

@FunctionalInterface
public interface Supplier&lt;T&gt; {
    T get();
}

</code></pre>
<h2 id="hashcode与identityhashcode-1"><a class="header" href="#hashcode与identityhashcode-1">hashCode与identityHashCode</a></h2>
<p>在Object类中的hashCode可以获取相应对象的hashCode，而这个identityHashCode也是可以获取对象的hashCode，那么两这有什么不同吗？从源码看两者都是本地方法（native），实际上获取时的结果是与hashCode无异的，但是这里的hashCode指的是原有的Object中的hashCode的方法，如果进行了重写就可能会有不同了，所以为了得到原有的Object中的hashCode的值，identityHashCode会比较方便。</p>
<h2 id="lookupvalue"><a class="header" href="#lookupvalue">LookupValue</a></h2>
<p>静态内部类，为了便于对CacheValue中的值进行判断，建立了LookupValue，也实现了Value接口，是CacheValue运算时的替代，实现方式也很相似。</p>
<pre><code class="language-java">    private static final class LookupValue&lt;V&gt; implements Value&lt;V&gt; {
        private final V value;

        LookupValue(V value) {
            this.value = value;
        }

        @Override
        public V get() {
            return value;
        }

        @Override
        public int hashCode() {
            return System.identityHashCode(value); // compare by identity
        }

        @Override
        public boolean equals(Object obj) {
            return obj == this ||
                   obj instanceof Value &amp;&amp;
                   this.value == ((Value&lt;?&gt;) obj).get();  // compare by identity
        }
    }					
</code></pre>
<h2 id="cachekey"><a class="header" href="#cachekey">CacheKey</a></h2>
<pre><code class="language-java">private static final class CacheKey&lt;K&gt; extends WeakReference&lt;K&gt; {

    // a replacement for null keys
    private static final Object NULL_KEY = new Object();

    static &lt;K&gt; Object valueOf(K key, ReferenceQueue&lt;K&gt; refQueue) {
        return key == null
               // null key means we can't weakly reference it,
               // so we use a NULL_KEY singleton as cache key
               ? NULL_KEY
               // non-null key requires wrapping with a WeakReference
               : new CacheKey&lt;&gt;(key, refQueue);
    }

    private final int hash;

    private CacheKey(K key, ReferenceQueue&lt;K&gt; refQueue) {
        super(key, refQueue);
        this.hash = System.identityHashCode(key);  // compare by identity
    }

    @Override
    public int hashCode() {
        return hash;
    }

    @Override
    public boolean equals(Object obj) {
        K key;
        return obj == this ||
               obj != null &amp;&amp;
               obj.getClass() == this.getClass() &amp;&amp;
               // cleared CacheKey is only equal to itself
               (key = this.get()) != null &amp;&amp;
               // compare key by identity
               key == ((CacheKey&lt;K&gt;) obj).get();
    }

    void expungeFrom(ConcurrentMap&lt;?, ? extends ConcurrentMap&lt;?, ?&gt;&gt; map,
                     ConcurrentMap&lt;?, Boolean&gt; reverseMap) {
        // removing just by key is always safe here because after a CacheKey
        // is cleared and enqueue-ed it is only equal to itself
        // (see equals method)...
        ConcurrentMap&lt;?, ?&gt; valuesMap = map.remove(this);
        // remove also from reverseMap if needed
        if (valuesMap != null) {
            for (Object cacheValue : valuesMap.values()) {
                reverseMap.remove(cacheValue);
            }
        }
    }
}
</code></pre>
<h1 id="get方法"><a class="header" href="#get方法">GET方法</a></h1>
<pre><code class="language-java">public V get(K key, P parameter) {
    Objects.requireNonNull(parameter);
// 清除 引用队列 过期的 key
    expungeStaleEntries();


    Object cacheKey = CacheKey.valueOf(key, refQueue);

    //来加载设置并获取一级缓存
    // lazily install the 2nd level valuesMap for the particular cacheKey
    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);
    if (valuesMap == null) {
        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap
            = map.putIfAbsent(cacheKey,
                              valuesMap = new ConcurrentHashMap&lt;&gt;());
        if (oldValuesMap != null) {
            valuesMap = oldValuesMap;
        }
    }

    // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that
    // subKey from valuesMap
    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));
    //计算二级key,获取二级缓存
    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);
    Factory factory = null;

    while (true) {
        //二级缓存在
        if (supplier != null) {
            // supplier might be a Factory or a CacheValue&lt;V&gt; instance
            //获取实际值
            V value = supplier.get();
            //二级缓存不为空，直接返回
            if (value != null) {
                return value;
            }
        }
        //没有supplier、
        //或者 value被回收了
        // else no supplier in cache
        // or a supplier that returned null (could be a cleared CacheValue
        // or a Factory that wasn't successful in installing the CacheValue)

        //没有factory新建一个 FactorySupplier
        // lazily construct a Factory
        if (factory == null) {
            factory = new Factory(key, parameter, subKey, valuesMap);
        }
        
        //没有supplier
        if (supplier == null) {
            //放入supplier
            supplier = valuesMap.putIfAbsent(subKey, factory);
            //返回空 则证明成功按爪那个
            if (supplier == null) {
                // successfully installed Factory
                supplier = factory;
            }
            //不反回空，则说明同一时刻  有其他线程放入了 supplier,则继续下一轮循环
            // else retry with winning supplier
        } else {
            //存在supplier，但是值没了：放入新值
            if (valuesMap.replace(subKey, supplier, factory)) {
                // successfully replaced
                // cleared CacheEntry / unsuccessful Factory
                // with our Factory
                supplier = factory;
            } else {
                //放入失败:同一时刻有人在尝试操作此键：获取它并操作
                // retry with current supplier
                supplier = valuesMap.get(subKey);
            }
        }
    }
}
</code></pre>
<h1 id="清除key的无效引用"><a class="header" href="#清除key的无效引用">清除Key的无效引用</a></h1>
<p>将无效弱引用队列的值拿出来，一一从一级缓存中移除</p>
<pre><code class="language-java">private void expungeStaleEntries() {
    CacheKey&lt;K&gt; cacheKey;
    while ((cacheKey = (CacheKey&lt;K&gt;)refQueue.poll()) != null) {
        cacheKey.expungeFrom(map, reverseMap);
    }
}


void expungeFrom(ConcurrentMap&lt;?, ? extends ConcurrentMap&lt;?, ?&gt;&gt; map,
                 ConcurrentMap&lt;?, Boolean&gt; reverseMap) {
    // removing just by key is always safe here because after a CacheKey
    // is cleared and enqueue-ed it is only equal to itself
    // (see equals method)...
    ConcurrentMap&lt;?, ?&gt; valuesMap = map.remove(this);
    // remove also from reverseMap if needed
    if (valuesMap != null) {
        for (Object cacheValue : valuesMap.values()) {
            reverseMap.remove(cacheValue);
        }
    }
}
</code></pre>
<h1 id="计算value"><a class="header" href="#计算value">计算Value</a></h1>
<p>java.lang.reflect.WeakCache.Factory#get</p>
<pre><code class="language-java">public synchronized V get() { // serialize access
    // re-check
    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);
    if (supplier != this) {
        //返回null表明：1.被CacheValue替代了  2. 值 被GC可能将其回收了,其他线程新了一个Supplier
        // something changed while we were waiting:
        // might be that we were replaced by a CacheValue
        // or were removed because of failure -&gt;
        // return null to signal WeakCache.get() to retry
        // the loop
        return null;
    }
    // else still us (supplier == this)

    // create new value
    V value = null;
    try {
        //计算值
        value = Objects.requireNonNull(valueFactory.apply(key, parameter));
    } finally {
        if (value == null) { // remove us on failure
            valuesMap.remove(subKey, this);
        }
    }
    // the only path to reach here is with non-null value
    assert value != null;

    // wrap value with CacheValue (WeakReference)
    CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value);

    // put into reverseMap：放入索引Map
    reverseMap.put(cacheValue, Boolean.TRUE);

    //替换 当前factory为 CacheValue
    // try replacing us with CacheValue (this should always succeed)
    if (!valuesMap.replace(subKey, this, cacheValue)) {
        throw new AssertionError(&quot;Should not reach here&quot;);
    }

    // successfully replaced us with new CacheValue -&gt; return the value
    // wrapped by it
    return value;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ioutils"><a class="header" href="#ioutils">IOUtils</a></h1>
<p><em>org.apache.commons.io.IOUtils</em></p>
<p>closeQuietly：关闭一个IO流、socket、或者selector且不抛出异常，通常放在finally块</p>
<p>toString：转换IO流、 Uri、 byte[]为String</p>
<p>copy：IO流数据复制，从输入流写到输出流中，最大支持2GB</p>
<p>toByteArray：从输入流、URI获取byte[]</p>
<p>write：把字节. 字符等写入输出流</p>
<p>toInputStream：把字符转换为输入流</p>
<p>readLines：从输入流中读取多行数据，返回List<String></p>
<p>copyLarge：同copy，支持2GB以上数据的复制</p>
<p>lineIterator：从输入流返回一个迭代器，根据参数要求读取的数据量，全部读取，如果数据不够，则失败</p>
<h1 id="fileutils"><a class="header" href="#fileutils">FileUtils</a></h1>
<p><em>org.apache.commons.io.FileUtils</em></p>
<p>deleteDirectory：删除文件夹</p>
<p>readFileToString：以字符形式读取文件内容</p>
<p>deleteQueitly：删除文件或文件夹且不会抛出异常</p>
<p>copyFile：复制文件</p>
<p>writeStringToFile：把字符写到目标文件，如果文件不存在，则创建</p>
<p>forceMkdir：强制创建文件夹，如果该文件夹父级目录不存在，则创建父级</p>
<p>write：把字符写到指定文件中</p>
<p>listFiles：列举某个目录下的文件(根据过滤器)</p>
<p>copyDirectory：复制文件夹</p>
<p>forceDelete：强制删除文件</p>
<h1 id="entityutils"><a class="header" href="#entityutils">EntityUtils</a></h1>
<p><em>org.apache.http.util.EntityUtils</em></p>
<p>toString：把Entity转换为字符串</p>
<p>consume：确保Entity中的内容全部被消费。可以看到源码里又一次消费了Entity的内容，假如用户没有消费，那调用Entity时候将会把它消费掉</p>
<p>toByteArray：把Entity转换为字节流</p>
<p>consumeQuietly：和consume一样，但不抛异常</p>
<p>getContentCharset：获取内容的编码</p>
<h1 id="stringutils"><a class="header" href="#stringutils">StringUtils</a></h1>
<p><em>org.apache.commons.lang3.StringUtils</em></p>
<p>isBlank：字符串是否为空 (trim后判断)</p>
<p>isEmpty：字符串是否为空 (不trim并判断)</p>
<p>equals：字符串是否相等</p>
<p>join：合并数组为单一字符串，可传分隔符</p>
<p>split：分割字符串</p>
<p>EMPTY：返回空字符串</p>
<p>replace：替换字符串</p>
<p>capitalize：首字符大写</p>
<h1 id="filenameutils"><a class="header" href="#filenameutils">FilenameUtils</a></h1>
<p><em>org.apache.commons.io.FilenameUtils</em></p>
<p>getExtension：返回文件后缀名</p>
<p>getBaseName：返回文件名，不包含后缀名</p>
<p>getName：返回文件全名</p>
<p>concat：按命令行风格组合文件路径(详见方法注释)</p>
<p>removeExtension：删除后缀名</p>
<p>normalize：使路径正常化</p>
<p>wildcardMatch：匹配通配符</p>
<p>seperatorToUnix：路径分隔符改成unix系统格式的，即/</p>
<p>getFullPath：获取文件路径，不包括文件名</p>
<p>isExtension：检查文件后缀名是不是传入参数(List<String>)中的一个</p>
<h1 id="stringutils-1"><a class="header" href="#stringutils-1">StringUtils</a></h1>
<p><em>org.springframework.util.StringUtils</em></p>
<p>hasText：检查字符串中是否包含文本</p>
<p>hasLength：检测字符串是否长度大于0</p>
<p>isEmpty：检测字符串是否为空（若传入为对象，则判断对象是否为null）</p>
<p>commaDelimitedStringToArray：逗号分隔的String转换为数组</p>
<p>collectionToDelimitedString：把集合转为CSV格式字符串</p>
<p>replace 替换字符串</p>
<p>delimitedListToStringArray：相当于split</p>
<p>uncapitalize：首字母小写</p>
<p>collectionToDelimitedCommaString：把集合转为CSV格式字符串</p>
<p>tokenizeToStringArray：和split基本一样，但能自动去掉空白的单词</p>
<h1 id="arrayutils"><a class="header" href="#arrayutils">ArrayUtils</a></h1>
<p><em>org.apache.commons.lang.ArrayUtils</em></p>
<p>contains：是否包含某字符串</p>
<p>addAll：添加整个数组</p>
<p>clone：克隆一个数组</p>
<p>isEmpty：是否空数组</p>
<p>add：向数组添加元素</p>
<p>subarray：截取数组</p>
<p>indexOf：查找某个元素的下标</p>
<p>isEquals：比较数组是否相等</p>
<p>toObject：基础类型数据数组转换为对应的Object数组</p>
<h1 id="stringescapeutils"><a class="header" href="#stringescapeutils">StringEscapeUtils</a></h1>
<p><em>org.apache.commons.lang3.StringEscapeUtils</em></p>
<h1 id="urlencodedutils"><a class="header" href="#urlencodedutils">URLEncodedUtils</a></h1>
<p><em>org.apache.http.client.utils.URLEncodedUtils</em></p>
<p>format：格式化参数，返回一个HTTP POST或者HTTP PUT可用
application/x-www-form-urlencoded字符串</p>
<p>parse：把String或者URI等转换为List<NameValuePair></p>
<h1 id="digestutils"><a class="header" href="#digestutils">DigestUtils</a></h1>
<p><em>org.apache.commons.codec.digest.DigestUtils</em></p>
<p>md5Hex：MD5加密，返回32位字符串</p>
<p>sha1Hex：SHA-1加密</p>
<p>sha256Hex：SHA-256加密</p>
<p>sha512Hex：SHA-512加密</p>
<p>md5：MD5加密，返回16位字符串</p>
<h1 id="collectionutils"><a class="header" href="#collectionutils">CollectionUtils</a></h1>
<p><em>org.apache.commons.collections.CollectionUtils</em></p>
<p>isEmpty：是否为空</p>
<p>select：根据条件筛选集合元素</p>
<p>transform：根据指定方法处理集合元素，类似List的map()</p>
<p>filter：过滤元素，雷瑟List的filter()</p>
<p>find：基本和select一样</p>
<p>collect：和transform 差不多一样，但是返回新数组</p>
<p>forAllDo：调用每个元素的指定方法</p>
<p>isEqualCollection：判断两个集合是否一致</p>
<h1 id="arrayutils-1"><a class="header" href="#arrayutils-1">ArrayUtils</a></h1>
<p><em>org.apache.commons.lang3.ArrayUtils</em></p>
<p>contains：是否包含某个字符串</p>
<p>addAll：添加整个数组</p>
<p>clone：克隆一个数组</p>
<p>isEmpty：是否空数组</p>
<p>add：向数组添加元素</p>
<p>subarray：截取数组</p>
<p>indexOf：查找某个元素的下标</p>
<p>isEquals：比较数组是否相等</p>
<p>toObject：基础类型数据数组转换为对应的Object数组</p>
<h1 id="propertyutils"><a class="header" href="#propertyutils">PropertyUtils</a></h1>
<p><em>org.apache.commons.beanutils.PropertyUtils</em></p>
<p>getProperty：获取对象属性值</p>
<p>setProperty：设置对象属性值</p>
<p>getPropertyDiscriptor：获取属性描述器</p>
<p>isReadable：检查属性是否可访问</p>
<p>copyProperties：复制属性值，从一个对象到另一个对象</p>
<p>getPropertyDiscriptors：获取所有属性描述器</p>
<p>isWriteable：检查属性是否可写</p>
<p>getPropertyType：获取对象属性类型</p>
<h1 id="stringescapeutils-1"><a class="header" href="#stringescapeutils-1">StringEscapeUtils</a></h1>
<p><em>org.apache.commons.lang3.StringEscapeUtils</em></p>
<p>unescapeHtml4：转义html</p>
<p>escapeHtml4：反转义html</p>
<p>escapeXml：转义xml</p>
<p>unescapeXml：反转义xml</p>
<p>escapeJava：转义unicode编码</p>
<p>escapeEcmaScript：转义EcmaScript字符</p>
<p>unescapeJava：反转义unicode编码</p>
<p>escapeJson：转义json字符</p>
<p>escapeXml10：转义Xml10</p>
<p>这个现在已经废弃了，建议使用commons-text包里面的方法。</p>
<h1 id="beanutils"><a class="header" href="#beanutils">BeanUtils</a></h1>
<p><em>org.apache.commons.beanutils.BeanUtils</em></p>
<p>copyPeoperties：复制属性值，从一个对象到另一个对象</p>
<p>getProperty：获取对象属性值</p>
<p>setProperty：设置对象属性值</p>
<p>populate：根据Map给属性复制</p>
<p>copyPeoperty：复制单个值，从一个对象到另一个对象</p>
<p>cloneBean：克隆bean实例</p>
<div style="break-before: page; page-break-before: always;"></div><p>foreach是 Java中的 语法糖</p>
<h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p>如果遇到数组，则将 其 编译成普通 for循环</p>
<p><strong>编译前</strong></p>
<pre><code class="language-java">        String[] a = new String[]{&quot;1&quot;,&quot;2&quot;};

        for (String s : a) {
            System.out.println(s);
        }
</code></pre>
<p><strong>编译后</strong></p>
<pre><code class="language-java">        String[] a = new String[]{&quot;1&quot;, &quot;2&quot;};
        String[] var8 = a;
        int var4 = a.length;

        for(int var5 = 0; var5 &lt; var4; ++var5) {
            String s = var8[var5];
            System.out.println(s);
        }
</code></pre>
<h1 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h1>
<p>如果遇到集合等其他实现了迭代器的接口，则编译成 迭代器 迭代</p>
<pre><code class="language-java">        List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);
        for (Integer integer : integers) {
            System.out.println(integer);
        }
</code></pre>
<pre><code class="language-java">        List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);
        Iterator var2 = integers.iterator();

        while(var2.hasNext()) {
            Integer integer = (Integer)var2.next();
            System.out.println(integer);
   s     }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatter-1"><a class="header" href="#formatter-1">formatter</a></h1>
<h2 id="简介-13"><a class="header" href="#简介-13">简介</a></h2>
<p>formatter是一个抽象的基类用于格式化 对 区域 敏感的 地区,主要包括三类</p>
<ol>
<li>日期</li>
<li>数值</li>
<li>消息(语言)</li>
</ol>
<h2 id="子类必须实现以下三个方法"><a class="header" href="#子类必须实现以下三个方法">子类必须实现以下三个方法</a></h2>
<ul>
<li><em>format(Object obj, StringBuffer toAppendTo, FieldPosition pos)</em></li>
<li><em>formatToCharacterIterator(Object obj)</em></li>
<li><em>parseObject(String source, ParsePosition pos)</em></li>
</ul>
<h2 id="子类一般要实现的-工厂方法"><a class="header" href="#子类一般要实现的-工厂方法">子类一般要实现的 工厂方法</a></h2>
<p><em>getInstance</em> //使用currentLocale</p>
<p><em>getInstance(Locale)</em></p>
<p>或者更具体的工厂方法</p>
<p><em>getIntegerInstance, getCurrencyInstance</em></p>
<h2 id="还应能获取-所有支持的locale"><a class="header" href="#还应能获取-所有支持的locale">还应能获取 所有支持的Locale</a></h2>
<p><em>public static Locale[] getAvailableLocales()</em></p>
<p>子类应该以如下形式的定义 <em>FieldPosition</em>的字段</p>
<p>item_FIELD 的形式</p>
<h1 id="messageformat"><a class="header" href="#messageformat">MessageFormat</a></h1>
<p>MessageFormat提供了以自然语言的形式,产生一系列组合的字符串</p>
<h2 id="messageformat的语法定义"><a class="header" href="#messageformat的语法定义">messageFormat的语法定义</a></h2>
<pre><code>定义: | 二者选一, [] 可选, 

pattern = string | pattern formatElement string

formatElemnt = {argumentindex\[,FormatType]\[,FormatType ]}

formatType = number | date |time |choice

style = short | medium | long | full| integer|currency|precent|SubformatPattern
</code></pre>
<h2 id="一些规定"><a class="header" href="#一些规定">一些规定</a></h2>
<ul>
<li>
<p>pattern用 Java中的 &quot;&quot; 包裹</p>
</li>
<li>
<p>单引号 包裹的不会解析</p>
</li>
<li>
<p>两个连续的单引号可以表示 一个单引号字符</p>
</li>
<li>
<p>花括号必须成对</p>
</li>
<li>
<p>没有结束的 单引号 默认在 pattern末尾加上单引号</p>
</li>
<li>
<p>argumentIndex表示的是 非负的整数 0~9,之后解析传递进来的参数,按照这个顺序去解析</p>
</li>
<li>
<p>formatType,formatStyle 是用来创建Format实例</p>
</li>
</ul>
<h2 id="type与style对应的-java类"><a class="header" href="#type与style对应的-java类">type与style对应的 Java类</a></h2>
<table><thead><tr><th>FormatType</th><th>FormatStyle</th><th>Subformat Created</th></tr></thead><tbody>
<tr><td><em>(none)</em></td><td><em>(none)</em></td><td><code>null</code></td></tr>
<tr><td><code>number</code></td><td><em>(none)</em></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/NumberFormat.html#getInstance(java.util.Locale)"><code>NumberFormat.getInstance</code></a><code>(getLocale())</code></td></tr>
<tr><td></td><td><code>integer</code></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/NumberFormat.html#getIntegerInstance(java.util.Locale)"><code>NumberFormat.getIntegerInstance</code></a><code>(getLocale())</code></td></tr>
<tr><td></td><td><code>currency</code></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/NumberFormat.html#getCurrencyInstance(java.util.Locale)"><code>NumberFormat.getCurrencyInstance</code></a><code>(getLocale())</code></td></tr>
<tr><td></td><td><code>percent</code></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/text/NumberFormat.html#getPercentInstance(java.util.Locale)"><code>NumberFormat.getPercentInstance</code></a><code>(getLocale())</code></td></tr>
<tr><td></td><td><em>SubformatPattern</em></td><td><code>new</code> [<code>DecimalFormat</code>](https://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormat.html#DecimalFormat(java.lang.String, java.text.DecimalFormatSymbols))<code>(subformatPattern,</code> <a href="https://docs.oracle.com/javase/7/docs/api/java/text/DecimalFormatSymbols.html#getInstance(java.util.Locale)"><code>DecimalFormatSymbols.getInstance</code></a><code>(getLocale()))</code></td></tr>
<tr><td><code>date</code></td><td><em>(none)</em></td><td>[<code>DateFormat.getDateInstance</code>](https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#getDateInstance(int, java.util.Locale))<code>(</code><a href="https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#DEFAULT"><code>DateFormat.DEFAULT</code></a><code>, getLocale())</code></td></tr>
<tr><td></td><td><code>short</code></td><td>[<code>DateFormat.getDateInstance</code>](https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#getDateInstance(int, java.util.Locale))<code>(</code><a href="https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#SHORT"><code>DateFormat.SHORT</code></a><code>, getLocale())</code></td></tr>
<tr><td></td><td><code>medium</code></td><td>[<code>DateFormat.getDateInstance</code>](https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#getDateInstance(int, java.util.Locale))<code>(</code><a href="https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#DEFAULT"><code>DateFormat.DEFAULT</code></a><code>, getLocale())</code></td></tr>
<tr><td></td><td><code>long</code></td><td>[<code>DateFormat.getDateInstance</code>](https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#getDateInstance(int, java.util.Locale))<code>(</code><a href="https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#LONG"><code>DateFormat.LONG</code></a><code>, getLocale())</code></td></tr>
<tr><td></td><td><code>full</code></td><td>[<code>DateFormat.getDateInstance</code>](https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#getDateInstance(int, java.util.Locale))<code>(</code><a href="https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#FULL"><code>DateFormat.FULL</code></a><code>, getLocale())</code></td></tr>
<tr><td></td><td><em>SubformatPattern</em></td><td><code>new</code> [<code>SimpleDateFormat</code>](https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#SimpleDateFormat(java.lang.String, java.util.Locale))<code>(subformatPattern, getLocale())</code></td></tr>
<tr><td><code>time</code></td><td><em>(none)</em></td><td>[<code>DateFormat.getTimeInstance</code>](https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#getTimeInstance(int, java.util.Locale))<code>(</code><a href="https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#DEFAULT"><code>DateFormat.DEFAULT</code></a><code>, getLocale())</code></td></tr>
<tr><td></td><td><code>short</code></td><td>[<code>DateFormat.getTimeInstance</code>](https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#getTimeInstance(int, java.util.Locale))<code>(</code><a href="https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#SHORT"><code>DateFormat.SHORT</code></a><code>, getLocale())</code></td></tr>
<tr><td></td><td><code>medium</code></td><td>[<code>DateFormat.getTimeInstance</code>](https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#getTimeInstance(int, java.util.Locale))<code>(</code><a href="https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#DEFAULT"><code>DateFormat.DEFAULT</code></a><code>, getLocale())</code></td></tr>
<tr><td></td><td><code>long</code></td><td>[<code>DateFormat.getTimeInstance</code>](https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#getTimeInstance(int, java.util.Locale))<code>(</code><a href="https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#LONG"><code>DateFormat.LONG</code></a><code>, getLocale())</code></td></tr>
<tr><td></td><td><code>full</code></td><td>[<code>DateFormat.getTimeInstance</code>](https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#getTimeInstance(int, java.util.Locale))<code>(</code><a href="https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html#FULL"><code>DateFormat.FULL</code></a><code>, getLocale())</code></td></tr>
<tr><td></td><td><em>SubformatPattern</em></td><td><code>new</code> [<code>SimpleDateFormat</code>](https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#SimpleDateFormat(java.lang.String, java.util.Locale))<code>(subformatPattern, getLocale())</code></td></tr>
<tr><td><code>choice</code></td><td><em>SubformatPattern</em></td><td><code>new</code> <a href="https://docs.oracle.com/javase/7/docs/api/java/text/ChoiceFormat.html#ChoiceFormat(java.lang.String)"><code>ChoiceFormat</code></a><code>(subformatPattern)</code></td></tr>
</tbody></table>
<h2 id="example-10"><a class="header" href="#example-10">example</a></h2>
<pre><code class="language-java">   String result = MessageFormat.format(
       &quot;At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.&quot;,
       planet, new Date(), event);
</code></pre>
<p>可重用的</p>
<pre><code class="language-java">   int fileCount = 1273;
   String diskName = &quot;MyDisk&quot;;
   Object[] testArgs = {new Long(fileCount), diskName};
  
   MessageFormat form = new MessageFormat(
       &quot;The disk \&quot;{1}\&quot; contains {0} file(s).&quot;);
  
   System.out.println(form.format(testArgs));
</code></pre>
<p>ChoiceFormat</p>
<pre><code class="language-java">  MessageFormat form = new MessageFormat(&quot;The disk \&quot;{1}\&quot; contains {0}.&quot;);
   double[] filelimits = {0,1,2};
   String[] filepart = {&quot;no files&quot;,&quot;one file&quot;,&quot;{0,number} files&quot;};
   ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
   form.setFormatByArgumentIndex(0, fileform);
  
   int fileCount = 1273;
   String diskName = &quot;MyDisk&quot;;
   Object[] testArgs = {new Long(fileCount), diskName};
  
   System.out.println(form.format(testArgs));
</code></pre>
<p>语义化的创建 choice</p>
<pre><code class="language-java"> form.applyPattern(
    &quot;There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}.&quot;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试题"><a class="header" href="#测试题"><strong>测试题</strong></a></h1>
<pre><code class="language-java">@Test
public void test2() {
	Integer i1 = 64;
	int i2 = 64;

	Integer i3 = Integer.valueOf(64);
	Integer i4 = new Integer(64);

	Integer i5 = 256;
	Integer i6 = Integer.valueOf(256);

	System.out.println(&quot;A：&quot; + (i1 == i2));
	System.out.println(&quot;B：&quot; + (i1 == i3));
	System.out.println(&quot;C：&quot; + (i3 == i4));
	System.out.println(&quot;D：&quot; + (i2 == i4));
	System.out.println(&quot;E：&quot; + (i3.equals(i4)));
	System.out.println(&quot;F：&quot; + (i5 == i6));
}
</code></pre>
<h1 id="答案"><a class="header" href="#答案"><strong>答案</strong></a></h1>
<pre><code class="language-j">A：true
B：true
C：false
D：true
E：true
F：false
</code></pre>
<h1 id="现象-1"><a class="header" href="#现象-1"><strong>现象</strong></a></h1>
<ul>
<li>如果==两端有一个是基础类型(int)，则会发生自动拆箱操作，这时比较的是值。</li>
<li>如果==两端都是包装类型(Integer)，则不会自动拆箱，首先会面临缓存问题
<ul>
<li>自动装箱与 Integer.valueOf(64) 会面临缓存问题, 缓存范围 在 -128~127</li>
<li>new Integer 会生成一个新对象</li>
</ul>
</li>
</ul>
<h1 id="总结-21"><a class="header" href="#总结-21"><strong>总结</strong></a></h1>
<p>引用数据类型 使用 <strong>equals</strong> 比较</p>
<h1 id="扩展"><a class="header" href="#扩展">扩展</a></h1>
<p>不同数值类型比较</p>
<pre><code class="language-java">public class MainTesat {
    public static void main(String[] args) {
       Long a = 2L;
       Integer b = 2;

       System.out.println(b.equals(a));
    }
}

//false
</code></pre>
<p><strong>总结</strong></p>
<p>不同 数值类型 的equals 比较 会返回false</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>
<p>改变变量的值</p>
</li>
<li>
<p>条件断点</p>
</li>
<li>
<p>实时表达式计算(Evaluate)</p>
</li>
<li>
<p>丢弃栈帧(drop frame)</p>
<pre><code>丢弃调用该方法的栈帧
</code></pre>
</li>
<li>
<p>变量断点</p>
<pre><code>变量断点在变量初始化或者变量值改变的时候可以是程序停在变量值改变的那行代码上。
</code></pre>
</li>
<li>
<p>方法断点</p>
<pre><code>方法上也是可以打断点的，比如有时候我们想进入到jdk内部的方法里，因为jdk的class在编译的时候为了节省空间，去掉了调试信息，用普通的step into可能进入不了方法内部，这个时候可以在相应的方法上打个断点，或者使用Force step into进入到方法体内部。
</code></pre>
</li>
<li>
<p>多线程调试</p>
</li>
<li>
<p>日志断点</p>
<pre><code>添加执行语句
</code></pre>
</li>
<li>
<p>强制返回</p>
<pre><code>Force Return,默认给一个返回值
</code></pre>
</li>
</ul>
<p><a href="https://www.toutiao.com/i6818070719855854088/">参考</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="问题"><a class="header" href="#问题">问题</a></h1>
<p>Properties提供的应用程序解决方案主要存在两个问题：</p>
<ul>
<li>
<p>配置文件不能放在主目录中，因为某些OS（如Win9X）没有主目录的概念；</p>
</li>
<li>
<p>没有标准的文件命名规则，存在文件名冲突的可能性。</p>
</li>
<li>
<p>Java中的Preferences类可以解决这些问题。Preferences提供一个存储配置信息的中心知识库，与平台无关。在Windows系统中，它存储在注册表中，在Linux中存储在本地文件系统中。它的实现是透明的，程序员无需深究它的底层是如何实现的。</p>
</li>
<li>
<p>Preferences的中心知识库是树状结构，因此可以避免文件名冲突。每个用户都有一棵树，存放与本用户有关的配置；还有一个系统树，存放全体用户的公共信息。内部的配置信息仍然以key-value的结构进行存储。</p>
</li>
</ul>
<h1 id="preferences的使用步骤"><a class="header" href="#preferences的使用步骤">Preferences的使用步骤</a></h1>
<h2 id="获得根节点"><a class="header" href="#获得根节点">获得根节点</a></h2>
<pre><code class="language-java">//如果配置信息位于用户树，则获取用户树的根节点，否则获取系统树根节点；
Preferences root = Preferences.userRoot();
Preferences root = Preferences.systemRoot();
</code></pre>
<h2 id="获取配置节点"><a class="header" href="#获取配置节点">获取配置节点</a></h2>
<pre><code class="language-java">preferences = root.node(&quot;path&quot;);
</code></pre>
<ol>
<li>
<p>path是配置节点相对于根节点的路径；</p>
</li>
<li>
<p>如果节点的路径名与类的包名相同，则可通过类的对象直接获得配置节点：</p>
</li>
</ol>
<pre><code>Preferences node = Preferences.userNodeForPackage(this.getClass());
Preferences node = Preferences.systemNodeForPackage(this.getClass());
</code></pre>
<h2 id="读取配置项"><a class="header" href="#读取配置项">读取配置项</a></h2>
<pre><code class="language-java">String title =  preferences.get(&quot;title&quot;, &quot;default title&quot;);
</code></pre>
<p>Preferences要求读取配置项时必须指定默认值。因为在实际环境中总会有各种不如意，比如系统中还没有中心知识库，或者网络暂时不可用等等。</p>
<h2 id="设置配置项"><a class="header" href="#设置配置项">设置配置项</a></h2>
<pre><code class="language-java">preferences.put(key, value);
</code></pre>
<h2 id="同步配置项"><a class="header" href="#同步配置项">同步配置项</a></h2>
<pre><code class="language-java">preferences.flush();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语法糖"><a class="header" href="#语法糖">语法糖</a></h1>
<p>语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。</p>
<blockquote>
<p>有意思的是，在编程领域，除了语法糖，还有语法盐和语法糖精的说法</p>
</blockquote>
<p>我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。很多人说Java是一个“低糖语言”，其实从Java 7开始Java语言层面上一直在添加各种糖，主要是在“Project Coin”项目下研发。尽管现在Java有人还是认为现在的Java是低糖，未来还会持续向着“高糖”的方向发展。</p>
<h1 id="解语法糖"><a class="header" href="#解语法糖">解语法糖</a></h1>
<p>前面提到过，语法糖的存在主要是方便开发人员使用。但其实，Java虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。</p>
<p>说到编译，大家肯定都知道，Java语言中，<code>javac</code>命令可以将后缀名为<code>.java</code>的源文件编译为后缀名为<code>.class</code>的可以运行于Java虚拟机的字节码。如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p>
<p>Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。</p>
<h1 id="switch-支持-string-与枚举"><a class="header" href="#switch-支持-string-与枚举">switch 支持 String 与枚举</a></h1>
<pre><code class="language-java">//前
public class switchDemoString {
    public static void main(String[] args) {
        String str = &quot;world&quot;;
        switch (str) {
        case &quot;hello&quot;:
            System.out.println(&quot;hello&quot;);
            break;
        case &quot;world&quot;:
            System.out.println(&quot;world&quot;);
            break;
        default:
            break;
        }
    }
}

//后，进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。
public class switchDemoString
{
    public switchDemoString()
    {
    }
    public static void main(String args[])
    {
        String str = &quot;world&quot;;
        String s;
        switch((s = str).hashCode())
        {
        default:
            break;
        case 99162322:
            if(s.equals(&quot;hello&quot;))
                System.out.println(&quot;hello&quot;);
            break;
        case 113318802:
            if(s.equals(&quot;world&quot;))
                System.out.println(&quot;world&quot;);
            break;
        }
    }
}
</code></pre>
<h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<p>通常情况下，一个编译器处理泛型有两种方式：<code>Code specialization</code>和<code>Code sharing</code>。C++和C#是使用<code>Code specialization</code>的处理机制，而Java使用的是<code>Code sharing</code>的机制。</p>
<blockquote>
<p>Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（<code>type erasue</code>）实现的。</p>
</blockquote>
<p><strong>对于Java虚拟机来说，他根本不认识<code>Map&lt;String, String&gt; map</code>这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。</strong></p>
<pre><code class="language-java">Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();  
map.put(&quot;name&quot;, &quot;hollis&quot;);  
map.put(&quot;wechat&quot;, &quot;Hollis&quot;);  
map.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;);


Map map = new HashMap();  
map.put(&quot;name&quot;, &quot;hollis&quot;);  
map.put(&quot;wechat&quot;, &quot;Hollis&quot;);  
map.put(&quot;blog&quot;, &quot;www.hollischuang.com&quot;);  
</code></pre>
<pre><code class="language-java">//擦除前
public static &lt;A extends Comparable&lt;A&gt;&gt; A max(Collection&lt;A&gt; xs) {
    Iterator&lt;A&gt; xi = xs.iterator();
    A w = xi.next();
    while (xi.hasNext()) {
        A x = xi.next();
        if (w.compareTo(x) &lt; 0)
            w = x;
    }
    return w;
}
//擦除后
public static Comparable max(Collection xs){
    Iterator xi = xs.iterator();
    Comparable w = (Comparable)xi.next();
    while(xi.hasNext())
    {
        Comparable x = (Comparable)xi.next();
        if(w.compareTo(x) &lt; 0)
            w = x;
    }
    return w;
}
</code></pre>
<p><strong>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的<code>Class</code>类对象。比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</strong></p>
<h1 id="自动装箱与拆箱"><a class="header" href="#自动装箱与拆箱">自动装箱与拆箱</a></h1>
<p><strong>自动装箱</strong></p>
<pre><code class="language-java">public static void main(String[] args) {
    int i = 10;
    Integer n = i;
}


public static void main(String args[])
{
    int i = 10;
    Integer n = Integer.valueOf(i);
}
</code></pre>
<p><strong>自动拆箱</strong></p>
<pre><code class="language-java">public static void main(String[] args) {
 
    Integer i = 10;
    int n = i;
}

public static void main(String args[])
{
    Integer i = Integer.valueOf(10);
    int n = i.intValue();
}
</code></pre>
<h1 id="方法变长参数"><a class="header" href="#方法变长参数">方法变长参数</a></h1>
<pre><code class="language-java">//前
public static void main(String[] args)
    {
        print(&quot;Holis&quot;, &quot;公众号:Hollis&quot;, &quot;博客：www.hollischuang.com&quot;, &quot;QQ：907607222&quot;);
    }
 
public static void print(String... strs)
{
    for (int i = 0; i &lt; strs.length; i++)
    {
        System.out.println(strs[i]);
    }
}

//后
public static void main(String args[])
{
    print(new String[] {
        &quot;Holis&quot;, &quot;\u516C\u4F17\u53F7:Hollis&quot;, &quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;, &quot;QQ\uFF1A907607222&quot;
    });
}
 
public static transient void print(String strs[])
{
    for(int i = 0; i &lt; strs.length; i++)
        System.out.println(strs[i]);
 
}
</code></pre>
<h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<p><strong>枚举类既不能继承其他类 也不能被其他类继承</strong></p>
<pre><code class="language-java">//前
public enum t {
    SPRING,SUMMER;
}

//后
public final class T extends Enum
{
    private T(String s, int i)
    {
        super(s, i);
    }
    public static T[] values()
    {
        T at[];
        int i;
        T at1[];
        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);
        return at1;
    }
 
    public static T valueOf(String s)
    {
        return (T)Enum.valueOf(demo/T, s);
    }
 
    public static final T SPRING;
    public static final T SUMMER;
    private static final T ENUM$VALUES[];
    static
    {
        SPRING = new T(&quot;SPRING&quot;, 0);
        SUMMER = new T(&quot;SUMMER&quot;, 1);
        ENUM$VALUES = (new T[] {
            SPRING, SUMMER
        });
    }
}

</code></pre>
<h1 id="内部类"><a class="header" href="#内部类">内部类</a></h1>
<p><strong>内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，<code>outer.java</code>里面定义了一个内部类<code>inner</code>，一旦编译成功，就会生成两个完全不同的<code>.class</code>文件了，分别是<code>outer.class</code>和<code>outer$inner.class</code>。</strong></p>
<h1 id="条件编译"><a class="header" href="#条件编译">条件编译</a></h1>
<pre><code class="language-java">
public class ConditionalCompilation {
    public static void main(String[] args) {
        final boolean DEBUG = true;
        if(DEBUG) {
            System.out.println(&quot;Hello, DEBUG!&quot;);
        }
 
        final boolean ONLINE = false;
 
        if(ONLINE){
            System.out.println(&quot;Hello, ONLINE!&quot;);
        }
    }
}
</code></pre>
<p><strong>Java语法的条件编译，是通过判断条件为常量的if语句实现的。其原理也是Java语言的语法糖。根据if判断条件的真假，编译器直接把分支为false的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，</strong></p>
<h1 id="断言"><a class="header" href="#断言">断言</a></h1>
<pre><code class="language-java">
public class AssertTest {
    public static void main(String args[]) {
        int a = 1;
        int b = 1;
        assert a == b;
        System.out.println(&quot;公众号：Hollis&quot;);
        assert a != b : &quot;Hollis&quot;;
        System.out.println(&quot;博客：www.hollischuang.com&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class AssertTest {
   public AssertTest()
    {
    }
public static void main(String args[])
{
    int a = 1;
    int b = 1;
    if(!$assertionsDisabled &amp;&amp; a != b)
        throw new AssertionError();
    System.out.println(&quot;\u516C\u4F17\u53F7\uFF1AHollis&quot;);
    if(!$assertionsDisabled &amp;&amp; a == b)
    {
        throw new AssertionError(&quot;Hollis&quot;);
    } else
    {
        System.out.println(&quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;);
        return;
    }
}
 
static final boolean $assertionsDisabled = !com/hollis/suguar/AssertTest.desiredAssertionStatus();
 
}
</code></pre>
<p>很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了assert这个语法糖我们节省了很多代码。<strong>其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行。</strong><code>-enableassertions</code>会设置$assertionsDisabled字段的值。</p>
<h1 id="数值字面量"><a class="header" href="#数值字面量">数值字面量</a></h1>
<p>在java 7中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。</p>
<pre><code class="language-java">
public class Test {
    public static void main(String... args) {
        int i = 10_000;
        System.out.println(i);
    }
}


public class Test
{
  public static void main(String[] args)
  {
    int i = 10000;
    System.out.println(i);
  }
}
</code></pre>
<h1 id="for-each"><a class="header" href="#for-each">for-each</a></h1>
<pre><code class="language-java">
public static void main(String... args) {
    String[] strs = {&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;};
    for (String s : strs) {
        System.out.println(s);
    }
    List&lt;String&gt; strList = ImmutableList.of(&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;);
    for (String s : strList) {
        System.out.println(s);
    }
}


public static transient void main(String args[])
{
    String strs[] = {
        &quot;Hollis&quot;, &quot;\u516C\u4F17\u53F7\uFF1AHollis&quot;, &quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;
    };
    String args1[] = strs;
    int i = args1.length;
    for(int j = 0; j &lt; i; j++)
    {
        String s = args1[j];
        System.out.println(s);
    }
 
    List strList = ImmutableList.of(&quot;Hollis&quot;, &quot;\u516C\u4F17\u53F7\uFF1AHollis&quot;, &quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;);
    String s;
    for(Iterator iterator = strList.iterator(); iterator.hasNext(); System.out.println(s))
        s = (String)iterator.next();
 
}
</code></pre>
<h1 id="try-with-resource"><a class="header" href="#try-with-resource">try-with-resource</a></h1>
<pre><code class="language-java">
public static void main(String[] args) {
    BufferedReader br = null;
    try {
        String line;
        br = new BufferedReader(new FileReader(&quot;d:\\hollischuang.xml&quot;));
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
    } catch (IOException e) {
        // handle exception
    } finally {
        try {
            if (br != null) {
                br.close();
            }
        } catch (IOException ex) {
            // handle exception
        }
    }
}

//前
public static void main(String... args) {
    try (BufferedReader br = new BufferedReader(new FileReader(&quot;d:\\ hollischuang.xml&quot;))) {
        String line;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
    } catch (IOException e) {
        // handle exception
    }
}
//后
public static transient void main(String args[])
    {
        BufferedReader br;
        Throwable throwable;
        br = new BufferedReader(new FileReader(&quot;d:\\ hollischuang.xml&quot;));
        throwable = null;
        String line;
        try
        {
            while((line = br.readLine()) != null)
                System.out.println(line);
        }
        catch(Throwable throwable2)
        {
            throwable = throwable2;
            throw throwable2;
        }
        if(br != null)
            if(throwable != null)
                try
                {
                    br.close();
                }
                catch(Throwable throwable1)
                {
                    throwable.addSuppressed(throwable1);
                }
            else
                br.close();
            break MISSING_BLOCK_LABEL_113;
            Exception exception;
            exception;
            if(br != null)
                if(throwable != null)
                    try
                    {
                        br.close();
                    }
                    catch(Throwable throwable3)
                      {
                        throwable.addSuppressed(throwable3);
                    }
                else
                    br.close();
        throw exception;
        IOException ioexception;
        ioexception;
    }
}

</code></pre>
<h1 id="lambda表达式"><a class="header" href="#lambda表达式">Lambda表达式</a></h1>
<p><strong>Labmda表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个JVM底层提供的lambda相关api。</strong></p>
<pre><code>
public static void main(String... args) {
    List&lt;String&gt; strList = ImmutableList.of(&quot;Hollis&quot;, &quot;公众号：Hollis&quot;, &quot;博客：www.hollischuang.com&quot;);
 
    strList.forEach( s -&gt; { System.out.println(s); } );
}



public static /* varargs */ void main(String ... args) {
    ImmutableList strList = ImmutableList.of((Object)&quot;Hollis&quot;, (Object)&quot;\u516c\u4f17\u53f7\uff1aHollis&quot;, (Object)&quot;\u535a\u5ba2\uff1awww.hollischuang.com&quot;);
    strList.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)());
}
 
private static /* synthetic */ void lambda$main$0(String s) {
    System.out.println(s);
}
</code></pre>
<p>在<code>forEach</code>方法中，其实是调用了<code>java.lang.invoke.LambdaMetafactory#metafactory</code>方法，该方法的第四个参数implMethod指定了方法实现。可以看到这里其实是调用了一个<code>lambda$main$0</code>方法进行了输出。</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>1、尽量指定类、方法的final修饰符</strong></p>
<p>Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50% 。</p>
<p><strong>2、尽量重用对象</strong></p>
<p><strong>3、尽可能使用局部变量</strong></p>
<p><strong>4、及时关闭流</strong></p>
<p><strong>5、尽量减少对变量的重复计算</strong></p>
<p>**6、**尽量采用懒加载的策略，即在需要的时候才创建</p>
<p><strong>7、慎用异常</strong></p>
<p><strong>8、不要在循环中使用try…catch…，应该把其放在最外层</strong></p>
<p><strong>9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度</strong></p>
<p><strong>10、当复制大量数据时，使用System.arraycopy命令</strong></p>
<p><strong>11、乘法和除法使用移位操作</strong></p>
<p><strong>12、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</strong></p>
<p><strong>13、</strong> 尽量在合适的场合使用单例</p>
<p>14、<strong>使用同步代码块替代同步方法</strong></p>
<p>15、<strong>程序运行过程中避免使用反射</strong></p>
<p>16、<strong>使用带缓冲的输入输出流进行IO操作</strong></p>
<p>17、<strong>字符串变量和字符串常量equals的时候将字符串常量写在前面，避免空指针</strong></p>
<p>18、使用 <em>try-with-resources</em> 关闭流</p>
<p>19、<em>尽量避免使用split</em>，</p>
<p>除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。</p>
<p>rebase测试</p>
<p>12</p>
<div style="break-before: page; page-break-before: always;"></div><p>[TOC]</p>
<h1 id="java5"><a class="header" href="#java5">java5</a></h1>
<h2 id="泛型-generics"><a class="header" href="#泛型-generics">泛型 (Generics)</a></h2>
<pre><code> List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();
</code></pre>
<h2 id="增强循环enhanced-for-loop"><a class="header" href="#增强循环enhanced-for-loop">增强循环（Enhanced for Loop）</a></h2>
<pre><code> int[] array = {1, 2, 3, 4, 5};
 for (int i : array) {
    System.out.println(i);
 } 
</code></pre>
<h2 id="自动封箱拆箱autoboxingunboxing-"><a class="header" href="#自动封箱拆箱autoboxingunboxing-">自动封箱拆箱(Autoboxing/Unboxing )。</a></h2>
<p><strong>八大基本类型和它们的包装类能够自动的相互转换。</strong></p>
<h2 id="枚举typesafe-enums"><a class="header" href="#枚举typesafe-enums">枚举(Typesafe Enums)。</a></h2>
<pre><code>ps:枚举是一种实现线程安全的单例模式的好方式。

 enum TestEnum{
        one,
        two;
        TestEnum() {
        }
    }
</code></pre>
<h2 id="可变参数-varargs"><a class="header" href="#可变参数-varargs">可变参数 (Varargs)</a></h2>
<p><strong>语法：(type... arguments)</strong></p>
<p><strong>可变参数本质仍然是用一个数组存储参数，只是java隐藏了这一过程。需要注意的是如果一个方法声明中含有可变参数，那必须放在最后一个位置。</strong></p>
<pre><code> /**
 * 可变参数测试
 *
 * @param args
 */
public static void testVarargs(String... args) {
    //本质就是个数组
    System.out.println(args[1]);
    for (String arg : args) {
        System.out.println(arg);
    }
}
</code></pre>
<h2 id="静态导入static-import"><a class="header" href="#静态导入static-import">静态导入（Static Import）。</a></h2>
<p><strong>通过import类来使用类里的静态变量或方法（直接通过名字，不需要加上类名.）,简化了代码的书写。</strong></p>
<pre><code>//单个导入
import static java.lang.Math.PI;
//批量导入
import static java.lang.Math.*;11
ps:过去的版本中只能通过继承类或实现接口才能使用。
</code></pre>
<h2 id="注解annotations"><a class="header" href="#注解annotations">注解（Annotations）。</a></h2>
<p><strong>关键字@interface。</strong></p>
<pre><code>//注释注解的注解又叫做元注解
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyAnnotations {
    //注解内可以添加方法，也可以不添加
    //注解方法的返回值只能是基本类型，String，Class类,枚举,注解,可以有默认值。
    int id();
    String name() default &quot;whh&quot;;
    Class classType();
    TestEnum enumType();
}
</code></pre>
<h2 id="新的线程模型和并发库"><a class="header" href="#新的线程模型和并发库">新的线程模型和并发库</a></h2>
<p><strong>（java.util.concurrent)。</strong></p>
<h1 id="java6"><a class="header" href="#java6">java6</a></h1>
<h2 id="集合框架增强"><a class="header" href="#集合框架增强">集合框架增强。</a></h2>
<p>为了更好的支持双向访问集合。添加了许多新的类和接口。
新的数组拷贝方法。Arrays.copyOf和Arrays.copyOfRange</p>
<pre><code>//以下为添加的新接口和类
Deque,BlockingDeque,NavigableSet,NavigableMap,ConcurrentNavigableMap，ArrayDeque， ConcurrentSkipListSet ,ConcurrentSkipListMap,ConcurrentSkipListMap ,AbstractMap.SimpleEntry ,AbstractMap.SimpleImmutableEntry
</code></pre>
<h2 id="scripting-可以让其他语言在java平台上运行"><a class="header" href="#scripting-可以让其他语言在java平台上运行">Scripting. 可以让其他语言在java平台上运行。</a></h2>
<p>java6包含了一个基于Mozilla Rhino实现的javascript脚本引擎。</p>
<h2 id="支持jdbc40规范"><a class="header" href="#支持jdbc40规范">支持JDBC4.0规范。</a></h2>
<h1 id="java7"><a class="header" href="#java7">java7</a></h1>
<h2 id="二进制前缀0b或者0b"><a class="header" href="#二进制前缀0b或者0b">二进制前缀0b或者0B。</a></h2>
<p>整型（byte, short, int, long）可以直接用二进制表示。</p>
<p>//二进制字面值前缀0b 或0B
int i = 0b010;//10进制值为2
int j = 0B010;</p>
<h2 id="字面常量数字的下划线"><a class="header" href="#字面常量数字的下划线">字面常量数字的下划线。</a></h2>
<p>用下划线连接整数提升其可读性，自身无含义，不可用在数字的起始和末尾。</p>
<pre><code>//数字间的下划线不影响实际值
 int k = 1_1;//值为11
</code></pre>
<h2 id="switch-支持string类型"><a class="header" href="#switch-支持string类型">switch 支持String类型。</a></h2>
<h2 id="泛型实例化类型自动推断"><a class="header" href="#泛型实例化类型自动推断">泛型实例化类型自动推断。</a></h2>
<pre><code>Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;String, List&lt;String&gt;&gt;();    // 之前
Map&lt;String, List&lt;String&gt;&gt; myMap = new HashMap&lt;&gt;();        // 现在
</code></pre>
<h2 id="try-with-resources语句"><a class="header" href="#try-with-resources语句">try-with-resources语句。</a></h2>
<pre><code class="language-java">   /*
     * 声明在try括号中的对象称为资源，在方法执行完毕后会被自动关闭,相对与之前必须在finally关闭资源，这一特性大大提高了代码的简洁性。
     * 所有实现java.lang.AutoCloseable接口的类都作为资源被自动关闭。
    */
   try (BufferedReader reader=new BufferedReader(new FileReader(&quot;d:1.txt&quot;))){
      return reader.readLine();
  }
</code></pre>
<h2 id="单个catch中捕获多个异常类型"><a class="header" href="#单个catch中捕获多个异常类型">单个catch中捕获多个异常类型</a></h2>
<p><strong>（用| 分割）并通过改进的类型检查重新抛出异常。</strong></p>
<h1 id="java8"><a class="header" href="#java8">java8</a></h1>
<h2 id="lambada表达式lambda-expressions"><a class="header" href="#lambada表达式lambda-expressions">lambada表达式(Lambda Expressions)。</a></h2>
<p><strong>Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中)。</strong></p>
<h2 id="方法引用method-references"><a class="header" href="#方法引用method-references">方法引用（Method references）。</a></h2>
<p>方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，可以使语言的构造更紧凑简洁，减少冗余代码。</p>
<h2 id="默认方法default-methods"><a class="header" href="#默认方法default-methods">默认方法（Default methods）。</a></h2>
<p>默认方法允许将新功能添加到库的接口中，并确保兼容实现老版本接口的旧有代码。</p>
<h2 id="重复注解repeating-annotations"><a class="header" href="#重复注解repeating-annotations">重复注解（Repeating Annotations）。</a></h2>
<p>重复注解提供了在同一声明或类型中多次应用相同注解类型的能力。</p>
<h2 id="类型注解type-annotation"><a class="header" href="#类型注解type-annotation">类型注解（Type Annotation）。</a></h2>
<p>在任何地方都能使用注解，而不是在声明的地方。</p>
<h2 id="类型推断增强"><a class="header" href="#类型推断增强">类型推断增强。</a></h2>
<p>方法参数反射（Method Parameter Reflection）。</p>
<h2 id="stream-api-"><a class="header" href="#stream-api-">Stream API 。</a></h2>
<p>新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。Stream API集成到了Collections API里。</p>
<h2 id="hashmap改进"><a class="header" href="#hashmap改进">HashMap改进，</a></h2>
<p>在键值哈希冲突时能有更好表现。</p>
<h2 id="date-time-api"><a class="header" href="#date-time-api">Date Time API。</a></h2>
<p>加强对日期和时间的处理。</p>
<h2 id="javautil-包下的改进"><a class="header" href="#javautil-包下的改进">java.util 包下的改进，</a></h2>
<p>提供了几个实用的工具类。</p>
<ul>
<li>并行数组排序。</li>
<li>标准的Base64编解码。</li>
<li>支持无符号运算。</li>
</ul>
<h2 id="javautilconcurrent-包下增加了新的类和方法"><a class="header" href="#javautilconcurrent-包下增加了新的类和方法">java.util.concurrent 包下增加了新的类和方法。</a></h2>
<ul>
<li>java.util.concurrent.ConcurrentHashMap 类添加了新的方法以支持新的StreamApi和lambada表达式。</li>
<li>java.util.concurrent.atomic 包下新增了类以支持可伸缩可更新的变量。</li>
<li>java.util.concurrent.ForkJoinPool类新增了方法以支持 common pool。</li>
<li>新增了java.util.concurrent.locks.StampedLock类，为控制读/写访问提供了一个基于性能的锁，且有三种模式可供选择。</li>
</ul>
<h2 id="hotspot"><a class="header" href="#hotspot">HotSpot</a></h2>
<ul>
<li>删除了 永久代（PermGen）.</li>
<li>方法调用的字节码指令支持默认方法。</li>
</ul>
<h1 id="java9"><a class="header" href="#java9">java9</a></h1>
<h2 id="java模块系统"><a class="header" href="#java模块系统">java模块系统</a></h2>
<p>（Java Platform Module System）。</p>
<h2 id="新的版本号格式"><a class="header" href="#新的版本号格式">新的版本号格式</a></h2>
<pre><code>$MAJOR.$MINOR.$SECURITY.$PATCH
</code></pre>
<h2 id="java-shell"><a class="header" href="#java-shell">java shell</a></h2>
<p>交互式命令行控制台。</p>
<h2 id="在private-instance-methods方法上可以使用safevarargs注解"><a class="header" href="#在private-instance-methods方法上可以使用safevarargs注解">在private instance methods方法上可以使用@SafeVarargs注解。</a></h2>
<h2 id="diamond语法与匿名内部类结合使用"><a class="header" href="#diamond语法与匿名内部类结合使用">diamond语法与匿名内部类结合使用。</a></h2>
<h2 id="下划线_不能单独作为变量名使用"><a class="header" href="#下划线_不能单独作为变量名使用">下划线_不能单独作为变量名使用。</a></h2>
<h2 id="支持私有接口方法您可以使用diamond语法与匿名内部类结合使用"><a class="header" href="#支持私有接口方法您可以使用diamond语法与匿名内部类结合使用">支持私有接口方法(您可以使用diamond语法与匿名内部类结合使用)。</a></h2>
<h2 id="javadoc"><a class="header" href="#javadoc">Javadoc</a></h2>
<ul>
<li>简化Doclet API。</li>
<li>支持生成HTML5格式。</li>
<li>加入了搜索框,使用这个搜索框可以查询程序元素、标记的单词和文档中的短语。</li>
<li>支持新的模块系统。</li>
</ul>
<h2 id="jvm"><a class="header" href="#jvm">JVM</a></h2>
<ul>
<li>增强了Garbage-First(G1)并用它替代Parallel GC成为默认的垃圾收集器。</li>
<li>统一了JVM 日志，为所有组件引入了同一个日志系统。</li>
<li>删除了JDK 8中弃用的GC组合。（DefNew + CMS，ParNew + SerialOld，Incremental CMS）。</li>
</ul>
<h2 id="properties文件支持utf-8编码"><a class="header" href="#properties文件支持utf-8编码">properties文件支持UTF-8编码</a></h2>
<p>之前只支持ISO-8859-1。支持Unicode 8.0，在JDK8中是Unicode 6.2。</p>
<h2 id="stream加强"><a class="header" href="#stream加强">Stream加强</a></h2>
<h2 id="集合加强"><a class="header" href="#集合加强">集合加强</a></h2>
<p>list.of()，map.of()，copyof等只读集合的快速创建</p>
<h1 id="java10"><a class="header" href="#java10">java10</a></h1>
<h2 id="局部变量类型推断"><a class="header" href="#局部变量类型推断">局部变量类型推断</a></h2>
<p>（Local-Variable Type Inference）</p>
<pre><code class="language-java">//之前的代码格式
URL url = new URL(&quot;http://www.oracle.com/&quot;); 
URLConnection conn = url.openConnection(); 
Reader reader = new BufferedReader(
    new InputStreamReader(conn.getInputStream()))
//java10中用var来声明变量
var url = new URL(&quot;http://www.oracle.com/&quot;); 
var conn = url.openConnection(); 
var reader = new BufferedReader(
    new InputStreamReader(conn.getInputStream()));
</code></pre>
<p>var是一个保留类型名称，而不是关键字。所以之前使用var作为变量、方法名、包名的都没问题，但是如果作为类或接口名，那么这个类和接口就必须重命名了。</p>
<p>var的使用场景主要有以下四种：</p>
<ul>
<li>本地变量初始化。</li>
<li>增强for循环中。</li>
<li>传统for循环中声明的索引变量。</li>
<li>Try-with-resources 变量。​</li>
</ul>
<h2 id="optional类添加了新的方法"><a class="header" href="#optional类添加了新的方法">Optional类添加了新的方法</a></h2>
<p>orElseThrow(无参数版)</p>
<p>相比于已经存在的get方法，这个方法更推荐使用。</p>
<h1 id="java11"><a class="header" href="#java11">java11</a></h1>
<h2 id="直接运行"><a class="header" href="#直接运行">直接运行</a></h2>
<pre><code class="language-text">java HelloWorld.java
</code></pre>
<h2 id="string新增方法"><a class="header" href="#string新增方法">String新增方法</a></h2>
<p>trip方法，可以去除首尾空格，与之前的trim的区别是还可以去除unicode编码的空白字符，例如：</p>
<pre><code class="language-java">char c = '\u2000';//Unicdoe空白字符
String str = c + &quot;abc&quot; + c;
System.out.println(str.strip());
System.out.println(str.trim());

System.out.println(str.stripLeading());//去除前面的空格
System.out.println(str.stripTrailing());//去除后面的空格
</code></pre>
<p>isBlank方法，判断字符串长度是否为0，或者是否是空格，制表符等其他空白字符</p>
<pre><code class="language-java">String str = &quot; &quot;;
System.out.println(str.isBlank());
</code></pre>
<p>repeat方法，字符串重复的次数</p>
<pre><code class="language-java">String str = &quot;monkey&quot;;
System.out.println(str.repeat(4));
</code></pre>
<h2 id="lambda表达式中的变量类型推断"><a class="header" href="#lambda表达式中的变量类型推断">lambda表达式中的变量类型推断</a></h2>
<p>jdk11中允许在lambda表达式的参数中使用var修饰</p>
<pre><code class="language-java">//支持lambda表达式参数中使用var
   MyInterface mi = (var a,var b)-&gt;{
       System.out.println(a);
       System.out.println(b);
   };

   mi.m1(&quot;monkey&quot;,1024);
</code></pre>
<h2 id="支持unicode-100在jdk10中是80"><a class="header" href="#支持unicode-100在jdk10中是80">支持Unicode 10.0,在jdk10中是8.0</a></h2>
<h2 id="标准化http-client"><a class="header" href="#标准化http-client">标准化HTTP Client</a></h2>
<h2 id="编译器线程的延迟分配"><a class="header" href="#编译器线程的延迟分配">编译器线程的延迟分配</a></h2>
<p>添加了新的命令-XX:+UseDynamicNumberOfCompilerThreads动态控制编译器线程的数量。</p>
<h2 id="新的垃圾收集器zgc"><a class="header" href="#新的垃圾收集器zgc">新的垃圾收集器—ZGC</a></h2>
<p>一种可伸缩的低延迟垃圾收集器(实验性)。</p>
<h2 id="epsilon"><a class="header" href="#epsilon">Epsilon</a></h2>
<p>一款新的实验性无操作垃圾收集器。Epsilon GC 只负责内存分配，不实现任何内存回收机制。这对于性能测试非常有用，可用于与其他GC对比成本和收益。</p>
<h2 id="lambda参数的局部变量语法"><a class="header" href="#lambda参数的局部变量语法">Lambda参数的局部变量语法</a></h2>
<p>java10中引入的var字段得到了增强，现在可以用在lambda表达式的声明中。如果lambda表达式的其中一个形式参数使用了var，那所有的参数都必须使用var。</p>
<p><strong>当然这个var的使用是有限制的，仅适用于局部变量，增强for循环的索引，以及普通for循环的本地变量；它不能使用于方法形参，构造方法形参，方法返回类型等。</strong></p>
<h2 id="optional加强"><a class="header" href="#optional加强">Optional加强</a></h2>
<h2 id="inputstreamtransferto"><a class="header" href="#inputstreamtransferto">InputStream.transferTo</a></h2>
<h1 id="java12"><a class="header" href="#java12">Java12</a></h1>
<h2 id="升级的switch语句"><a class="header" href="#升级的switch语句">升级的switch语句</a></h2>
<p>在jdk12之前的switch语句中，如果没有写break，则会出现case穿透现象，下面是对case穿透的一个应用，根据输入的月份打印相应的季节。</p>
<p>在jdk12之后我们可以省略全部的break和部分case，这样使用</p>
<pre><code class="language-java">int month = 3;
    switch (month) {
        case 3,4,5 -&gt; System.out.println(&quot;spring&quot;);
        case 6,7,8 -&gt; System.out.println(&quot;summer&quot;);
        case 9,10,11 -&gt; System.out.println(&quot;autumn&quot;);
        case 12, 1,2 -&gt; System.out.println(&quot;winter&quot;);
        default -&gt; System.out.println(&quot;wrong&quot;);
    }
</code></pre>
<p>这个是预览功能，如果需要编译和运行的话需要使用下面命令，预览功能在2个版本之后会成为正式版，</p>
<pre><code class="language-text">编译:
    javac --enable-preview -source 12 Test.java

运行：
    java --enable-preview Test
</code></pre>
<h1 id="java13"><a class="header" href="#java13">Java13</a></h1>
<h2 id="升级的switch语句-1"><a class="header" href="#升级的switch语句-1">升级的switch语句</a></h2>
<p>jdk13中对switch语句又进行了升级，可以switch的获取返回值</p>
<pre><code class="language-java">int month = 3;
   String result = switch (month) {
        case 3,4,5 -&gt; &quot;spring&quot;;
        case 6,7,8 -&gt; &quot;summer&quot;;
        case 9,10,11 -&gt; &quot;autumn&quot;;
        case 12, 1,2 -&gt; &quot;winter&quot;;
        default -&gt; &quot;wrong&quot;;
    };

    System.out.println(result);
</code></pre>
<p>对于jdk15之后的版本可以直接编译和运行，否则需要使用下面命令执行该预览功能</p>
<pre><code class="language-text">编译:
    javac --enable-preview -source 13 Test.java

运行：
    java --enable-preview Test
</code></pre>
<h2 id="文本块的变化"><a class="header" href="#文本块的变化">文本块的变化</a></h2>
<p>在jdk13之前的版本中如果输入的字符串中有换行的话，需要添加换行符</p>
<pre><code class="language-java">String s = &quot;Hello\nWorld\nLearn\nJava&quot;;
    System.out.println(s);
</code></pre>
<p>jdk13之后可以直接这样写：</p>
<pre><code class="language-java">String s = &quot;&quot;&quot;
            Hello
            World
            Learn
            Java
           &quot;&quot;&quot;;
  System.out.println(s);
</code></pre>
<h1 id="java14"><a class="header" href="#java14">Java14</a></h1>
<h2 id="instanceof模式匹配"><a class="header" href="#instanceof模式匹配">instanceof模式匹配</a></h2>
<p>该特性可以减少强制类型转换的操作，简化了代码，代码示例：</p>
<pre><code class="language-java">public class TestInstanceof{
    public static void main(String[] args){

        //jdk14之前的写法
        Object obj = new Integer(1);
        if(obj instanceof Integer){
            Integer i = (Integer)obj;
            int result = i + 10;
            System.out.println(i);
        }

        //jdk14新特性  不用再强制转换了
        //这里相当于是将obj强制为Integer之后赋值给i了
        if(obj instanceof Integer i){
            int result = i + 10;
            System.out.println(i);
        }else{
            //作用域问题，这里是无法访问i的
        }
    }
}
</code></pre>
<pre><code class="language-java">编译:
    javac --enable-preview -source 14 TestInstanceof.java

运行：
    java --enable-preview TestInstanceof
</code></pre>
<h2 id="友好的空指针"><a class="header" href="#友好的空指针">友好的空指针</a></h2>
<p>（NullPointerException）提示</p>
<p>jdk14中添加了对于空指针异常友好的提示，便于开发者快速定位空指针的对象。示例代码：</p>
<pre><code class="language-java">class Machine{
    public void start(){
        System.out.println(&quot;启动&quot;);
    }
}

class Engine{
    public Machine machine;
}

class Car{
    public Engine engine;

}

public class TestNull{
    public static void main(String[] args){
        //这里会报出空指针，但是哪个对象是null呢？
        new Car().engine.machine.start();
    }
}
</code></pre>
<p>我们在运行上面代码的时候，错误信息就可以明确的指出那个对象为null了。此外，还可以使用下面参数来查看:</p>
<pre><code class="language-text">java -XX:+ShowCodeDetailsInExceptionMessages TestNull
</code></pre>
<p>这样编译器会明确的告诉开发者哪个对象是null。</p>
<h2 id="record类型"><a class="header" href="#record类型">record类型</a></h2>
<p>之前在编写javabean类的时候，需要编写成员变量，get方法，构造方法，toString方法，hashcode方法，equals方法。</p>
<p>jdk14编写User</p>
<pre><code class="language-java">public record User(String name,Integer age){}
</code></pre>
<p>通过反编译命令可以看到该字节码文件中的内容，User类是继承了Record类型：</p>
<pre><code class="language-text">javap -p -private user
</code></pre>
<pre><code class="language-java">public class TestUser{
    public static void main(String[] args){
        User u = new User(&quot;jack&quot;,15);
        System.out.println(u);
        System.out.println(u.name());
    }
}
</code></pre>
<pre><code class="language-text">编译:
    javac --enable-preview -source 14 TestUser.java

运行：
    java --enable-preview TestUser
</code></pre>
<h2 id="sealed-classes"><a class="header" href="#sealed-classes">Sealed Classes</a></h2>
<p>密封类和接口，作用是限制一个类可以由哪些子类继承或者实现。</p>
<ol>
<li>如果指定模块的话，sealed class和其子类必须在同一个模块下。如果没有指定模块，则需要在同一个包下。</li>
<li>sealed class指定的子类必须直接继承该sealed class。</li>
<li>sealed class的子类要用final修饰。</li>
<li>sealed class的子类如果不想用final修饰的话，可以将子类声明为sealed class。</li>
</ol>
<p>Animal类，在指定允许继承的子类时可以使用全限定名</p>
<pre><code class="language-java">public sealed class Animal 
    permits Cat, Dog{//多个子类之间用,隔开

        public void eat(){}
}
</code></pre>
<p>Cat类</p>
<pre><code class="language-java">public final class Cat extends Animal{
    public void eat(){
        System.out.println(&quot;123&quot;);
    }
}
</code></pre>
<p>Dog类</p>
<pre><code class="language-java">public sealed class Dog extends Animal
    permits Husky {}
</code></pre>
<p>Husky类</p>
<pre><code class="language-java">public final class Husky extends Dog{
}
</code></pre>
<p>Test类</p>
<pre><code class="language-java">public class Test{
    public static void main(String[] args){
        Cat c = new Cat();
        c.eat();
        Dog d = new Dog();
    }
}
</code></pre>
<h2 id="charsequence新增的方法"><a class="header" href="#charsequence新增的方法">CharSequence新增的方法</a></h2>
<p>该接口中新增了default方法isEmpty()，作用是判断CharSequence是否为空。</p>
<h2 id="treemap新增方法"><a class="header" href="#treemap新增方法">TreeMap新增方法</a></h2>
<ul>
<li>putIfAbsent</li>
<li>computeIfAbsent</li>
<li>computeIfPresent</li>
<li>compute</li>
<li>merge</li>
</ul>
<h2 id="文本块"><a class="header" href="#文本块">文本块</a></h2>
<p>文本块由预览版变为正式版</p>
<h2 id="无需配置环境变量"><a class="header" href="#无需配置环境变量">无需配置环境变量</a></h2>
<p>win系统中安装完成之后会自动将java.exe, javaw.exe, javac.exe, jshell.exe这几个命令添加到环境变量中。这部分可以打开环境变量看下。不过还是建议配置环境变量，因为这几个命令不够用</p>
<h1 id="java16"><a class="header" href="#java16">java16</a></h1>
<p>这里只介绍一些跟开发关联度较大的特性，除此之外JDK16还更新了许多其他新特性，感兴趣的同学可以去Oracle官网查看</p>
<h2 id="包装类构造方法的警告"><a class="header" href="#包装类构造方法的警告">包装类构造方法的警告</a></h2>
<p>使用包装类的构造方法在编译的时候会出现警告，不建议再使用包装类的构造方法。下面代码在javac编译之后会出现警告。</p>
<h2 id="新增日时段"><a class="header" href="#新增日时段">新增日时段</a></h2>
<p>在DateTimeFormatter.ofPattern传入B可以获取现在时间对应的日时段，上午，下午等</p>
<pre><code class="language-java">System.out.println(DateTimeFormatter.ofPattern(&quot;B&quot;).format(LocalDateTime.now()));
</code></pre>
<h2 id="invocationhandler新增方法"><a class="header" href="#invocationhandler新增方法">InvocationHandler新增方法</a></h2>
<pre><code class="language-java">public static Object invokeDefault(Object proxy, Method method, Object... args)
</code></pre>
<p>该方法可以调用父接口中defalut方法，比如有下面接口</p>
<pre><code class="language-java">interface Girl{
    default void eat(){
        System.out.println(&quot;cucumber&quot;);
    }

}
</code></pre>
<pre><code class="language-java">interface Girl{
    default void eat(){
        System.out.println(&quot;cucumber&quot;);
    }

}
</code></pre>
<p>实现类</p>
<pre><code class="language-java">public class Lucy implements Girl{
    public void eat(){
        System.out.println(&quot;banana&quot;);
    }
}
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class Test{
    public static void main(String[] args) {
        Girl girl = new Lucy();


        //不使用invokeDefault会调用重写的eat方法
        Girl proxy1 = (Girl)Proxy.newProxyInstance(girl.getClass().getClassLoader(),girl.getClass().getInterfaces(),
            (obj,method,params)-&gt;{
            Object invoke = method.invoke(girl);
            return invoke;
        });
        proxy1.eat();

        //使用invokeDefault会调用父接口中的default方法
        Girl proxy2 = (Girl)Proxy.newProxyInstance(Girl.class.getClassLoader(),new Class&lt;?&gt;[]{Girl.class},
            (obj,method,params)-&gt;{
            if (method.isDefault()) {
                return InvocationHandler.invokeDefault(obj, method, params);
            }
            return null;
        });
        proxy2.eat();

    }

}
</code></pre>
<h2 id="streamtolist"><a class="header" href="#streamtolist">Stream().toList()</a></h2>
<h2 id="其他-1"><a class="header" href="#其他-1">其他</a></h2>
<p>在之前jdk版本中作为预览功能的Record类，模式匹配的instanceof，打包工具jpackage，已成为正式版。jdk16对GC，jvm运行时内存等内容有一些变化，例如：<strong>ZGC并发栈处理</strong>，<strong>弹性meta space</strong>。</p>
<h1 id="java17"><a class="header" href="#java17">Java17</a></h1>
<p>java17是一个LTS（long term support）长期支持的版本，根据计划来看java17会支持到2029年（java8会支持到2030年，OMG），同时Oracle提议下一个LTS版本是java21，在2023年9月发布，这样讲LST版本的发布周期由之前的3年变为了2年。这里只介绍一些跟开发关联度较大的特性，除此之外JDK17还更新了一些其他新特性，感兴趣的同学可以从<a href="https://link.zhihu.com/?target=https%3A//www.oracle.com/news/announcement/oracle-releases-java-17-2021-09-14/">这里查看</a>：</p>
<p><img src="50.%E5%85%B6%E4%BB%96_%E6%9C%AA%E5%88%86%E7%B1%BB/../images/v2-c2a307eed725229b1b2df8e511600b4b_r.png" alt="preview" /></p>
<h2 id="switch语法的变化预览"><a class="header" href="#switch语法的变化预览">switch语法的变化(预览)</a></h2>
<p>在之前版本中新增的instanceof模式匹配的特性在switch中也支持了，即我们可以在switch中减少强转的操作。比如下面的代码：</p>
<pre><code class="language-java">interface Animal{}

class Rabbit implements Animal{
    //特有的方法
    public void run(){
        System.out.println(&quot;run&quot;);
    }
}

class Bird implements Animal{
    //特有的方法
    public void fly(){
        System.out.println(&quot;fly&quot;);
    }
}
</code></pre>
<p>新特性可以减少Animal强转操作代码的编写：</p>
<pre><code class="language-java">public class Switch01{
    public static void main(String[] args) {
        Animal a = new Rabbit();
        animalEat(a);
    }

    public static void animalEat(Animal a){
        switch(a){
            //如果a是Rabbit类型，则在强转之后赋值给r，然后再调用其特有的run方法
            case Rabbit r -&gt; r.run();
            //如果a是Bird类型，则在强转之后赋值给b，然后调用其特有的fly方法
            case Bird b -&gt; b.fly();
            //支持null的判断
            case null -&gt; System.out.println(&quot;null&quot;);
            default -&gt; System.out.println(&quot;no animal&quot;);
        }
    }

}
</code></pre>
<p>该功能在java17中是预览的，编译和运行需要加上额外的参数:</p>
<pre><code class="language-text">javac --enable-preview -source 17 Switch01.java
java  --enable-preview Switch01
</code></pre>
<h2 id="sealed-classes-1"><a class="header" href="#sealed-classes-1">Sealed Classes</a></h2>
<p>在jdk15中已经添加了Sealed Classes，只不过当时是作为预览版，经历了2个版本之后，在jdk17中Sealed Classes已经成为正式版了。Sealed Classes的作用是可以限制一个类或者接口可以由哪些子类继承或者实现。</p>
<h2 id="伪随机数的变化"><a class="header" href="#伪随机数的变化">伪随机数的变化</a></h2>
<p>增加了伪随机数相关的类和接口来让开发者使用stream流进行操作</p>
<ul>
<li>RandomGenerator</li>
<li>RandomGeneratorFactory</li>
</ul>
<p>之前的java.util.Random和java.util.concurrent.ThreadLocalRandom都是RandomGenerator接口的实现类。</p>
<h2 id="去除了aot和jit"><a class="header" href="#去除了aot和jit">去除了AOT和JIT</a></h2>
<p>AOT（Ahead-of-Time）是java9中新增的功能，可以先将应用中中的字节码编译成机器码。</p>
<p>Graal编译器作为使用java开发的JIT（just-in-time ）即时编译器在java10中加入（注意这里的JIT不是之前java中的JIT，在JEP 317中有说明<a href="https://link.zhihu.com/?target=https%3A//openjdk.java.net/jeps/317">https://openjdk.java.net/jeps/317</a>）。</p>
<p>以上两项功能由于使用量较少，且需要花费很多精力来维护，因此在java17中被移除了。当然你可以通过Graal VM来继续使用这些功能。</p>
<h1 id="参考链接-3"><a class="header" href="#参考链接-3">参考链接：</a></h1>
<ul>
<li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjavase%2Fjdk-relnotes-index-2162236.html">JDK Release Notes</a></li>
<li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjavase%2F8-whats-new-2157071.html">What's New in JDK 8</a></li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2F9%2Fwhatsnew%2Ftoc.htm%23JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6">What’s New in JDK 9</a></li>
<li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjavase%2F10-relnote-issues-4108729.html%23NewFeature">JDK 10 Release Notes</a></li>
<li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjavase%2F11-relnote-issues-5012449.html%23NewFeature">JDK 11 Release Notes</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-15"><a class="header" href="#概述-15">概述</a></h1>
<p>Java 序列化是 JDK 1.1 时引入的一组开创性的特性，用于将 Java 对象转换为字节数组，便于存储或传输。此后，仍然可以将字节数组转换回 Java 对象原有的状态。</p>
<p>序列化的思想是“冻结”对象状态，然后写到磁盘或者在网络中传输；反序列化的思想是“解冻”对象状态，重新获得可用的 Java 对象。</p>
<p>再来看看序列化 Serializbale 接口的定义：</p>
<pre><code class="language-java">public interface Serializable {
}
</code></pre>
<p>序列化接口本身没有任何作用，起作用的是 <em>ObjectOutputStream</em>，ObjectInputStream</p>
<h1 id="oos与ois的序列化与反序列化"><a class="header" href="#oos与ois的序列化与反序列化">OOS与OIS的序列化与反序列化</a></h1>
<p>以 ObjectOutputStream 为例，它在序列化的时候会依次调用 writeObject()→writeObject0()→writeOrdinaryObject()→writeSerialData()→invokeWriteObject()→defaultWriteFields()。</p>
<p><strong>核心代码</strong></p>
<pre><code>if (obj instanceof String) {
    writeString((String) obj, unshared);
} else if (cl.isArray()) {
    writeArray(obj, desc, unshared);
} else if (obj instanceof Enum) {
    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);
} else if (obj instanceof Serializable) {
    writeOrdinaryObject(obj, desc, unshared);
} else {
    if (extendedDebugInfo) {
        throw new NotSerializableException(
            cl.getName() + &quot;\n&quot; + debugInfoStack.toString());
    } else {
        throw new NotSerializableException(cl.getName());
    }
}
</code></pre>
<p>也就是说，ObjectOutputStream 在序列化的时候，会判断被序列化的对象是哪一种类型，字符串？数组？枚举？还是 Serializable，如果全都不是的话，抛出 NotSerializableException。</p>
<h1 id="字段选择"><a class="header" href="#字段选择">字段选择</a></h1>
<ul>
<li>过滤 STATIC，TRANSIENT</li>
</ul>
<pre><code class="language-java">private static ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) {
    Field[] clFields = cl.getDeclaredFields();
    ArrayList&lt;ObjectStreamField&gt; list = new ArrayList&lt;&gt;();
    int mask = Modifier.STATIC | Modifier.TRANSIENT;

    int size = list.size();
    return (size == 0) ? NO_FIELDS :
        list.toArray(new ObjectStreamField[size]);
}
</code></pre>
<h1 id="externalizable"><a class="header" href="#externalizable">Externalizable</a></h1>
<p>除了 Serializable 之外，Java 还提供了一个序列化接口 Externalizable</p>
<pre><code class="language-java">class Wanger implements Externalizable {
    private String name;
    private int age;

    public Wanger() {

    }

    public String getName() {
        return name;
    }


    @Override
    public String toString() {
        return &quot;Wanger{&quot; + &quot;name=&quot; + name + &quot;,age=&quot; + age + &quot;}&quot;;
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {

    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {

    }

}
</code></pre>
<p><strong>新增了一个无参的构造方法。</strong></p>
<ul>
<li>使用 Externalizable 进行反序列化的时候，会调用被序列化类的无参构造方法去创建一个新的对象，然后再将被保存对象的字段值复制过去</li>
</ul>
<p><strong>新增了两个方法 writeExternal() 和 readExternal()</strong></p>
<p>1）调用 ObjectOutput 的 writeObject() 方法将字符串类型的 name 写入到输出流中；</p>
<p>2）调用 ObjectOutput 的 writeInt() 方法将整型的 age 写入到输出流中；</p>
<p>3）调用 ObjectInput 的 readObject() 方法将字符串类型的 name 读入到输入流中；</p>
<p>4）调用 ObjectInput 的 readInt() 方法将字符串类型的 age 读入到输入流中；</p>
<h1 id="serialversionuid"><a class="header" href="#serialversionuid">serialVersionUID</a></h1>
<p>serialVersionUID 被称为序列化 ID，它是决定 Java 对象能否反序列化成功的重要因子。在反序列化时，Java 虚拟机会把字节流中的 serialVersionUID 与被序列化类中的 serialVersionUID 进行比较，如果相同则可以进行反序列化，否则就会抛出序列化版本不一致的异常。</p>
<p>1）添加一个默认版本的序列化 ID：</p>
<pre><code>private static final long serialVersionUID = 1L。
</code></pre>
<p>2）添加一个随机生成的不重复的序列化 ID。</p>
<pre><code>private static final long serialVersionUID = -2095916884810199532L;
</code></pre>
<p>3）添加 @SuppressWarnings 注解。</p>
<pre><code>@SuppressWarnings(&quot;serial&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-3"><a class="header" href="#-3"></a></h1>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><strong>Lambda 表达式</strong>：Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）</li>
<li><strong>函数式接口</strong>：指的是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口，这样的接口可以隐式转换为 Lambda 表达式</li>
<li><strong>方法引用</strong>：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码</li>
<li><strong>默认方法</strong>：默认方法就是一个在接口里面有了一个实现的方法</li>
<li><strong>Stream API</strong>：新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li>
<li><strong>Optional 类</strong>：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li><strong>Date Time API</strong>：加强对日期与时间的处理。</li>
<li><strong>Nashorn, JavaScript 引擎</strong>：Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="jdk中rtjartoolsjar和dtjar作用"><a class="header" href="#jdk中rtjartoolsjar和dtjar作用">JDK中rt.jar、tools.jar和dt.jar作用</a></h3>
<ol>
<li>dt.jar和tools.jar位于：{Java_Home}/lib/下，而rt.jar位于：{Java_Home}/jre/lib/下,其中：</li>
<li>rt.jar是JAVA基础类库，也就是你在java doc里面看到的所有的类的class文件</li>
<li>dt.jar是关于运行环境的类库</li>
<li>tools.jar是工具类库,编译和运行需要的都是toos.jar里面的类分别是sun.tools.java.<em>; sun.tols.javac.</em>;</li>
<li>在Classpath设置这几个变量，是为了方便在程序中 import；Web系统都用到tool.jar。</li>
</ol>
<h3 id="rtjar"><a class="header" href="#rtjar">rt.jar</a></h3>
<p>rt.jar 默认就在Root Classloader的加载路径里面的，而在Claspath配置该变量是不需要的；</p>
<p>同时jre/lib目录下的 其他jar:jce.jar、jsse.jar、charsets.jar、resources.jar都在Root Classloader中</p>
<h3 id="toolsjar"><a class="header" href="#toolsjar">tools.jar</a></h3>
<ol>
<li>tools.jar 是系统用来编译一个类的时候用到的，即执行javac的时候用到</li>
<li>javac XXX.java  实际上就是运行  java -Calsspath=%JAVA_HOME%\lib\tools.jar xx.xxx.Main XXX.java</li>
<li>javac就是对上面命令的封装 所以tools.jar 也不用加到classpath里面</li>
</ol>
<h3 id="dtjar"><a class="header" href="#dtjar">dt.jar</a></h3>
<p>dt.jar是关于运行环境的类库,主要是swing的包  在用到swing时最好加上。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常量池"><a class="header" href="#常量池">常量池</a></h1>
<p>通常来说，我们提到的常量池分为三种</p>
<ul>
<li>class文件中的常量池</li>
<li>运行时常量池</li>
<li>字符串常量池</li>
</ul>
<h1 id="class文件中的常量池"><a class="header" href="#class文件中的常量池">class文件中的常量池</a></h1>
<blockquote>
<p>class文件中的常量池当然是位于class文件中，而<strong>class文件又是位于磁盘上</strong>。</p>
</blockquote>
<p><img src="50.%E5%85%B6%E4%BB%96_%E6%9C%AA%E5%88%86%E7%B1%BB/../../images/string_class_structure.png" alt="" /></p>
<p>常量池可以理解为class文件中资源仓库，它是class文件结构中与其它项目关联最多的数据类型，主要用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。</p>
<p>字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。</p>
<p>符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        String name = &quot;dmz&quot;;
    }
}

//编译成以下字节码
public class com.dmz.jvm.Main
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
// 这里就是常量池了
Constant pool:
   #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = String             #21            // dmz
   #3 = Class              #22            // com/dmz/jvm/Main
   #4 = Class              #23            // java/lang/Object
   #5 = Utf8               &lt;init&gt;
   #6 = Utf8               ()V
   #7 = Utf8               Code
   #8 = Utf8               LineNumberTable
   #9 = Utf8               LocalVariableTable
  #10 = Utf8               this
  #11 = Utf8               Lcom/dmz/jvm/Main;
  #12 = Utf8               main
  #13 = Utf8               ([Ljava/lang/String;)V
  #14 = Utf8               args
  #15 = Utf8               [Ljava/lang/String;
  #16 = Utf8               name
  #17 = Utf8               Ljava/lang/String;
  #18 = Utf8               SourceFile
  #19 = Utf8               Main.java
  #20 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V
  #21 = Utf8               dmz
  #22 = Utf8               com/dmz/jvm/Main
  #23 = Utf8               java/lang/Object
 // 下面是方法表                           
{
  public com.dmz.jvm.Main();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 7: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/dmz/jvm/Main;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=2, args_size=1
         // 可以看到方法表中的指令引用了常量池中的常量，这也是为什么说常量池是资源仓库的原因
         // 因为它会被class文件中的其它结构引用         
         0: ldc           #2                  // String dmz
         2: astore_1
         3: return
      LineNumberTable:
        line 9: 0
        line 10: 3
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       4     0  args   [Ljava/lang/String;
            3       1     1  name   Ljava/lang/String;
}
SourceFile: &quot;Main.java&quot;
</code></pre>
<h1 id="字符串常量池"><a class="header" href="#字符串常量池"><strong>字符串常量池</strong></a></h1>
<p>字符串常量池比较特殊，在JDK1.7之前，其存在于永久代中，到JDK1.7及之后，已经中永久代移到了堆中。</p>
<h2 id="方法区元空间永久代区别"><a class="header" href="#方法区元空间永久代区别"><strong>方法区，元空间，永久代区别</strong></a></h2>
<ul>
<li>方法区是JVM在内存分配时需要遵守的<strong>规范</strong>，是一个理论，具体的实现可以因人而异</li>
<li>永久代是hotspot的jdk1.8以前对方法区的<strong>实现</strong>，使用jdk1.7的老司机肯定以前经常遇到过java.lang.OutOfMemoryError: PremGen space异常。这里的PermGen space其实指的就是方法区。</li>
<li>元空间是jdk1.8对方法区的实现，jdk1.8彻底移除了永久代，其实，移除永久代的工作从JDK 1.7就开始了。JDK 1.7中，存储在永久代的部分数据就已经转移到Java Heap或者Native Heap。但永久代仍存在于JDK 1.7中，并没有完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了Java heap；类的静态变量(class statics)转移到了Java heap。到jdk1.8彻底移除了永久代，将JDK7中还剩余的永久代信息全部移到元空间，元空间相比对永久代最大的差别是，元空间使用的是本地内存（Native Memory）。</li>
</ul>
<h2 id="存储引用"><a class="header" href="#存储引用"><strong>存储引用</strong></a></h2>
<p><strong>字符串常量池存储的是字符串实例对象的引用！</strong></p>
<pre><code>简单来说，HotSpot VM里StringTable是个哈希表，里面存的是主流字符串的引用（而不是驻留字符串实例自身）。也就是说某些普通的字符串实例被这个StringTable引用之后就等同被赋予了“驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例里只有一份，被所有的类共享。类的运行时常量池里的CONSTANT_String类型的常量，经过解析（resolve）之后，同样存的是字符串的引用；解析的过程会去查询StringTable，以保证运行时常量池所引用的字符串与StringTable所引用的是一致的。 
​ ------R大博客
</code></pre>
<ul>
<li>字符串常量池本质就是一个哈希表</li>
<li>字符串常量池中存储的是字符串实例的引用</li>
<li>字符串常量池在被整个JVM共享</li>
<li>在解析运行时常量池中的符号引用时，会去查询字符串常量池，确保运行时常量池中解析后的直接引用跟字符串常量池中的引用是一致的</li>
</ul>
<h2 id="intern方法分析"><a class="header" href="#intern方法分析">intern方法分析</a></h2>
<pre><code>/** 
 * Returns a canonical representation for the string object. 
 * &lt;p&gt; 
 * A pool of strings, initially empty, is maintained privately by the 
 * class &lt;code&gt;String&lt;/code&gt;. 
 * &lt;p&gt; 
 * When the intern method is invoked, if the pool already contains a 
 * string equal to this &lt;code&gt;String&lt;/code&gt; object as determined by 
 * the {@link #equals(Object)} method, then the string from the pool is 
 * returned. Otherwise, this &lt;code&gt;String&lt;/code&gt; object is added to the 
 * pool and a reference to this &lt;code&gt;String&lt;/code&gt; object is returned. 
 * &lt;p&gt; 
 * It follows that for any two strings &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, 
 * &lt;code&gt;s.intern() == t.intern()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; 
 * if and only if &lt;code&gt;s.equals(t)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. 
 * &lt;p&gt; 
 * All literal strings and string-valued constant expressions are 
 * interned. String literals are defined in section 3.10.5 of the 
 * &lt;cite&gt;The Java™ Language Specification&lt;/cite&gt;. 
 * 
 * @return  a string that has the same contents as this string, but is 
 *          guaranteed to be from a pool of unique strings. 
 */  
public native String intern();  
</code></pre>
<p>这是一个 native 方法，</p>
<p>如果常量池中<strong>存在当前字符串</strong>（使用 hashCode判断）, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回”。</p>
<pre><code class="language-java">public static void main(String[] args) {
    String s = new String(&quot;1&quot;);
    s.intern();
    String s2 = &quot;1&quot;;
    System.out.println(s == s2);

    String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);
    s3.intern();
    String s4 = &quot;11&quot;;
    System.out.println(s3 == s4);
}
</code></pre>
<p>打印结果是</p>
<ul>
<li>jdk6 下false false</li>
<li>jdk7 下false true</li>
</ul>
<h2 id="jdk6与jdk7区别"><a class="header" href="#jdk6与jdk7区别"><strong>jdk6与Jdk7区别</strong></a></h2>
<ul>
<li>jdk6 遇到字面量时，会 判断字面量 是否存在常量池中，是的话，就直接返回 常量池引用，否的话 从 方法区也就是永久代中 生成一份 字符串实例，并将引用指向 常量池</li>
<li>jdk7 遇到字面量时，会 判断字面量 是否存在常量池中，是的话，就直接返回 常量池引用，否的话 直接再堆中成一份 字符串实例，并将引用指向 常量池</li>
</ul>
<p><img src="50.%E5%85%B6%E4%BB%96_%E6%9C%AA%E5%88%86%E7%B1%BB//images/string_jdk6.png" alt="" /></p>
<p><img src="50.%E5%85%B6%E4%BB%96_%E6%9C%AA%E5%88%86%E7%B1%BB/%5Cimages%5Cstring_jdk7.png" alt="" /></p>
<h1 id="运行时常量池"><a class="header" href="#运行时常量池">运行时常量池</a></h1>
<h2 id="位置在哪"><a class="header" href="#位置在哪">位置在哪？</a></h2>
<p><strong>位于方法区中</strong>，1.6在永久代，1.7在元空间中，永久代跟元空间都是对方法区的实现</p>
<h2 id="用来干什么"><a class="header" href="#用来干什么">用来干什么？</a></h2>
<p>jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</p>
<p>所以简单来说，<strong>运行时常量池就是用来存放class常量池中的内容的。</strong></p>
<p><img src="50.%E5%85%B6%E4%BB%96_%E6%9C%AA%E5%88%86%E7%B1%BB//images/string_constant_structure.png" alt="" /></p>
<h1 id="测试"><a class="header" href="#测试">测试</a></h1>
<pre><code class="language-java">// 环境1.7及以上
public class Clazz {
    public static void main(String[] args) {
        String s1 = new StringBuilder().append(&quot;ja&quot;).append(&quot;va1&quot;).toString();
        String s2 = s1.intern();
        System.out.println(s1==s2);
        
        String s5 = &quot;dmz&quot;;
        String s3 = new StringBuilder().append(&quot;d&quot;).append(&quot;mz&quot;).toString();
        String s4 = s3.intern();
        System.out.println(s3 == s4);

        String s7 = new StringBuilder().append(&quot;s&quot;).append(&quot;pring&quot;).toString();
        String s8 = s7.intern();
        String s6 = &quot;spring&quot;;
        System.out.println(s7 == s8);
    }
}
</code></pre>
<p><a href="https://blog.csdn.net/qq_41907991/article/details/106799400">链接</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jdk-中-threadlocal-的实现"><a class="header" href="#jdk-中-threadlocal-的实现">JDK 中 ThreadLocal 的实现</a></h1>
<h2 id="threadlocal-是如何存储变量的"><a class="header" href="#threadlocal-是如何存储变量的">ThreadLocal 是如何存储变量的</a></h2>
<ul>
<li>
<p>绑定在本地线程变量 中 <strong>Thread.ThreadLocal.ThreadLocalMap</strong></p>
</li>
<li>
<p>每个线程可能有多个 <strong>ThreadLocal</strong>
<img src="https://i.loli.net/2020/10/25/DnTV85QOvkdjR1X.png" alt="20201025071133" /></p>
</li>
</ul>
<h2 id="threadlocalmap为什么要继承-weakreference"><a class="header" href="#threadlocalmap为什么要继承-weakreference">ThreadLocalMap为什么要继承 <strong>WeakReference</strong></a></h2>
<ul>
<li>
<p>ThreadLocalMap是与线程绑定在一起的, 而ThreadLocal 又与 ThreadLocalMap存在引用 ,但两者生命周期 可能会不一致,会导致内存泄漏的风险</p>
</li>
<li>
<p>设置为 弱引用 可以在GC时 被回收</p>
</li>
</ul>
<h2 id="threadlocalmap是如何避免内存泄漏的"><a class="header" href="#threadlocalmap是如何避免内存泄漏的">ThreadLocalMap是如何避免内存泄漏的</a></h2>
<ul>
<li>
<p>Entry是一个弱引用对象, 持有对ThreadLocal 的 弱引用</p>
</li>
<li>
<p>在 调用</p>
<pre><code>get,set,remove 的方法时 ,都会清空 key为null 相应的 value
</code></pre>
</li>
<li>
<p>只能保证 key 的弱引用,  value无法保证, 所以在不需要 <strong>LocalThread</strong> 之后  应调用一次清理</p>
</li>
</ul>
<h1 id="threadlocalmap源码分析"><a class="header" href="#threadlocalmap源码分析">ThreadLocalMap源码分析</a></h1>
<blockquote>
<p>每个线程都会有一个 ThreadLocalMap，用来存放当前线程 所有的 本地线程变量，key为 ThreadLocal对象，value为存放的值</p>
</blockquote>
<ul>
<li><em>ThreadLocalMap</em> 内部是由 数组 hash实现</li>
<li>hash冲突解决 使用 开放地址法中的 线性查找，往前寻找第一个空闲区域</li>
</ul>
<h2 id="初始化-7"><a class="header" href="#初始化-7">初始化</a></h2>
<p><strong>使用ThreadLocal初始化</strong></p>
<ul>
<li>初始化容量为16</li>
<li>使用 ThreadLocal的 hashCode作为 目标散列对象</li>
<li>默认扩容阈值是 2/3</li>
</ul>
<pre><code class="language-java">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {
    table = new Entry[INITIAL_CAPACITY];
    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);
    table[i] = new Entry(firstKey, firstValue);
    size = 1;
    setThreshold(INITIAL_CAPACITY);
}
</code></pre>
<p><strong>使用ThreadLocalMap初始化</strong></p>
<ul>
<li>循环取数据 放入到新的Map中</li>
<li>如果产生冲突，则 索引下放到下一个</li>
</ul>
<pre><code class="language-java">private ThreadLocalMap(ThreadLocalMap parentMap) {
    Entry[] parentTable = parentMap.table;
    int len = parentTable.length;
    setThreshold(len);
    table = new Entry[len];

    for (int j = 0; j &lt; len; j++) {
        Entry e = parentTable[j];
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();
            if (key != null) {
                Object value = key.childValue(e.value);
                Entry c = new Entry(key, value);
                int h = key.threadLocalHashCode &amp; (len - 1);
                while (table[h] != null)
                    h = nextIndex(h, len);
                table[h] = c;
                size++;
            }
        }
    }
}
</code></pre>
<h2 id="放入元素-2"><a class="header" href="#放入元素-2">放入元素</a></h2>
<ul>
<li>
<p>根据 hashCode计算 数组中的索引</p>
</li>
<li>
<p>如果 entry是空闲的，则直接放入空闲地区</p>
</li>
<li>
<p>如果 entry不是空闲的，则说明发生hash冲突</p>
<ul>
<li>如果在冲突过程中 遇到 失效的 key，则调用 <em>replaceStaleEntry</em></li>
<li>如果在冲突过程中 遇到 key本身，则直接替换value</li>
</ul>
</li>
<li>
<p>如果在冲突过程中 既没遇到 失效得key，也没遇到 key本身，且遇到 空闲 <em>slot</em>，</p>
<p>则先调用一遍 启发式清理，如果没有清理出数据，且超过了阈值则扩容</p>
</li>
</ul>
<pre><code class="language-java">private void set(ThreadLocal&lt;?&gt; key, Object value) {

    // We don't use a fast path as with get() because it is at
    // least as common to use set() to create new entries as
    // it is to replace existing ones, in which case, a fast
    // path would fail more often than not.

    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp; (len-1);

    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        ThreadLocal&lt;?&gt; k = e.get();

        if (k == key) {
            e.value = value;
            return;
        }

        if (k == null) {
            replaceStaleEntry(key, value, i); //替换 当前无效引用
            return;
        }
    }

    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
        rehash();
}
</code></pre>
<h2 id="获取元素-2"><a class="header" href="#获取元素-2">获取元素</a></h2>
<p><strong>快慢路径</strong></p>
<ul>
<li>如果第一个命中了则 直接返回</li>
<li>如果没有命中，则线性探测</li>
</ul>
<pre><code class="language-java">private Entry getEntry(ThreadLocal&lt;?&gt; key) {
    int i = key.threadLocalHashCode &amp; (table.length - 1);
    Entry e = table[i];
    if (e != null &amp;&amp; e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}

private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {
    Entry[] tab = table;
    int len = tab.length;
    while (e != null) {
        ThreadLocal&lt;?&gt; k = e.get();
        if (k == key)
        return e;
        if (k == null)
        expungeStaleEntry(i);
        else
            i = nextIndex(i, len);
        e = tab[i];
        }
    return null;
}
</code></pre>
<h2 id="在哈希冲突过程中遇到-无效引用"><a class="header" href="#在哈希冲突过程中遇到-无效引用">在哈希冲突过程中遇到 无效引用</a></h2>
<ul>
<li>记录 当前无效引用的 连续非<em>NULL</em> 区间 上一个无效引用
<ul>
<li>如果 后向区间 存在 key本身，则交换 key 与 staleSlot的 位置，并调用一次 线性探测清理，与 启发式清理</li>
<li>如果 后向区间 不存在 key本身，则直接取代staleSlot的位置，如果在当前区间内还探测到其他 无效Key则 进行 线性探测清理，与 启发式清理</li>
</ul>
</li>
</ul>
<pre><code class="language-java">private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,
                               int staleSlot) {
    Entry[] tab = table;
    int len = tab.length;
    Entry e;

    // Back up to check for prior stale entry in current run.
    // We clean out whole runs at a time to avoid continual
    // incremental rehashing due to garbage collector freeing
    // up refs in 
    
    (i.e., whenever the collector runs).
    int slotToExpunge = staleSlot;
    for (int i = prevIndex(staleSlot, len);
         (e = tab[i]) != null;
         i = prevIndex(i, len))
        if (e.get() == null)
            slotToExpunge = i;

    // Find either the key or trailing null slot of run, whichever
    // occurs first
    for (int i = nextIndex(staleSlot, len);
         (e = tab[i]) != null;
         i = nextIndex(i, len)) {
        ThreadLocal&lt;?&gt; k = e.get();

        // If we find key, then we need to swap it
        // with the stale entry to maintain hash table order.
        // The newly stale slot, or any other stale slot
        // encountered above it, can then be sent to expungeStaleEntry
        // to remove or rehash all of the other entries in run.
        if (k == key) {
            e.value = value;

            tab[i] = tab[staleSlot];
            tab[staleSlot] = e;

            // Start expunge at preceding stale entry if it exists
            if (slotToExpunge == staleSlot)
                slotToExpunge = i;
            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
            return;
        }

        // If we didn't find stale entry on backward scan, the
        // first stale entry seen while scanning for key is the
        // first still present in the run.
        if (k == null &amp;&amp; slotToExpunge == staleSlot)
            slotToExpunge = i;
    }

    // If key not found, put new entry in stale slot
    tab[staleSlot].value = null;
    tab[staleSlot] = new Entry(key, value);

    // If there are any other stale entries in run, expunge them
    if (slotToExpunge != staleSlot)
        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);
}
</code></pre>
<h2 id="线性清理"><a class="header" href="#线性清理">线性清理</a></h2>
<p><strong>输入与输出</strong></p>
<p>传入失效的key的索引，返回邻近的下一个 空闲 <em>slot</em></p>
<p><strong>步骤</strong></p>
<ul>
<li>清空当前 失效 <em>slot</em></li>
<li>清空 非NULL 区间的 失效 <em>slot</em></li>
<li>将冲突的 <em>slot</em> 尽量 往正确的索引移动</li>
</ul>
<pre><code class="language-java">private int expungeStaleEntry(int staleSlot) {
    Entry[] tab = table;
    int len = tab.length;

    // expunge entry at staleSlot
    tab[staleSlot].value = null;
    tab[staleSlot] = null;
    size--;

    // Rehash until we encounter null
    Entry e;
    int i;
    for (i = nextIndex(staleSlot, len);
         (e = tab[i]) != null;
         i = nextIndex(i, len)) {
        ThreadLocal&lt;?&gt; k = e.get();
        if (k == null) {
            e.value = null;
            tab[i] = null;
            size--;
        } else {
            int h = k.threadLocalHashCode &amp; (len - 1);
            if (h != i) {
                tab[i] = null;

                // Unlike Knuth 6.4 Algorithm R, we must scan until
                // null because multiple entries could have been stale.
                while (tab[h] != null)
                    h = nextIndex(h, len);
                tab[h] = e;
            }
        }
    }
    return i;
}
</code></pre>
<h2 id="启发式清理"><a class="header" href="#启发式清理">启发式清理</a></h2>
<p><strong>输入输出</strong></p>
<p>i不是 失效的key的索引即可</p>
<p>n为扫描的 轮数，<code>log2(n)</code></p>
<p><strong>逻辑</strong></p>
<ul>
<li>按 连续的 非NULL段清理，故 n的元素 最多有 n/2段</li>
</ul>
<pre><code class="language-java">private boolean cleanSomeSlots(int i, int n) {
    boolean removed = false;
    Entry[] tab = table;
    int len = tab.length;
    do {
        i = nextIndex(i, len);
        Entry e = tab[i];
        if (e != null &amp;&amp; e.get() == null) {
            n = len;
            removed = true;
            i = expungeStaleEntry(i);
        }
    } while ( (n &gt;&gt;&gt;= 1) != 0);
    return removed;
}
</code></pre>
<h2 id="全量清理"><a class="header" href="#全量清理">全量清理</a></h2>
<blockquote>
<p>循环调用线性清理</p>
</blockquote>
<pre><code class="language-java">private void expungeStaleEntries() {
    Entry[] tab = table;
    int len = tab.length;
    for (int j = 0; j &lt; len; j++) {
        Entry e = tab[j];
        if (e != null &amp;&amp; e.get() == null)
            expungeStaleEntry(j);
    }
}
</code></pre>
<h2 id="扩容逻辑"><a class="header" href="#扩容逻辑">扩容逻辑</a></h2>
<ul>
<li>3/4的阈值 扩容</li>
<li>扩容是 2倍率</li>
</ul>
<pre><code class="language-java">private void rehash() {
    expungeStaleEntries();

    // Use lower threshold for doubling to avoid hysteresis
    if (size &gt;= threshold - threshold / 4)
        resize();
}

private void resize() {
    Entry[] oldTab = table;
    int oldLen = oldTab.length;
    int newLen = oldLen * 2;
    Entry[] newTab = new Entry[newLen];
    int count = 0;

    for (int j = 0; j &lt; oldLen; ++j) {
        Entry e = oldTab[j];
        if (e != null) {
            ThreadLocal&lt;?&gt; k = e.get();
            if (k == null) {
                e.value = null; // Help the GC
            } else {
                int h = k.threadLocalHashCode &amp; (newLen - 1);
                while (newTab[h] != null)
                    h = nextIndex(h, newLen);
                newTab[h] = e;
                count++;
            }
        }
    }

    setThreshold(newLen);
    size = count;
    table = newTab;
}
</code></pre>
<h1 id="threadlocal扩展"><a class="header" href="#threadlocal扩展">ThreadLocal扩展</a></h1>
<h2 id="可继承的threadlocal"><a class="header" href="#可继承的threadlocal">可继承的<strong>ThreadLocal</strong></a></h2>
<pre><code class="language-java">ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
</code></pre>
<p>在本线程 创建子线程 会把 inheritableThreadLocals 传递 给子线程</p>
<pre><code>InheritableThreadLocal
</code></pre>
<p><strong>源码</strong></p>
<pre><code class="language-java">if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)
    this.inheritableThreadLocals =
        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
/* Stash the specified stack size in case the VM cares */
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-java">public static void main(String[] args) {
    ThreadLocal&lt;String&gt; a = new ThreadLocal&lt;&gt;();
    a.set(&quot;xjq&quot;);

    InheritableThreadLocal&lt;String&gt; b = new InheritableThreadLocal&lt;&gt;();
    b.set(&quot;xjq&quot;);
    new Thread(()-&gt;{
        String s = b.get();
        System.out.println(s);
    }).start();

}
</code></pre>
<h2 id="transmittablethreadlocal"><a class="header" href="#transmittablethreadlocal"><em>TransmittableThreadLocal</em></a></h2>
<p>用于在异步调用间，线程池的 ThreadLocal传递</p>
<h1 id="threadlocal-应用"><a class="header" href="#threadlocal-应用">ThreadLocal 应用</a></h1>
<h2 id="spring-获取被代理的对象"><a class="header" href="#spring-获取被代理的对象"><strong>spring 获取被代理的对象</strong></a></h2>
<p><strong>spring aop</strong></p>
<p>Spring 的事务是基于 AOP 实现的，AOP 是基于动态代理实现的。</p>
<p>所以 @Transactional 注解如果想要生效，那么其调用方，需要是被 Spring 动态代理后的类。</p>
<p>因此如果在同一个类里面，使用 this 调用被 @Transactional 注解修饰的方法时，是不会生效的。</p>
<p><strong>为什么？</strong></p>
<p>因为 this 对象是未经动态代理后的对象。</p>
<p><strong>那么我们怎么获取动态代理后的对象呢？</strong></p>
<p>其中的一个方法就是通过 AopContext 来获取。</p>
<p><strong>对应代码位置</strong></p>
<pre><code class="language-java">org.springframework.aop.framework.CglibAopProxy.DynamicAdvisedInterceptor#intercept

				if (this.advised.exposeProxy) {
					// Make invocation available if necessary.
					oldProxy = AopContext.setCurrentProxy(proxy);
					setProxyContext = true;
				}
</code></pre>
<p><strong>对应开关</strong></p>
<pre><code>@EnableAspectJAutpProxy(exposeProxy=true)
或者
&lt;aop:aspectj-autoproxy expose-proxy='true'/&gt;
</code></pre>
<h2 id="mybatis-的分页插件pagehelper"><a class="header" href="#mybatis-的分页插件pagehelper"><strong>mybatis 的分页插件，PageHelper</strong></a></h2>
<p><strong>使用</strong></p>
<pre><code class="language-java">PageHelper.startPage(1,10);
List&lt;User&gt; list = userMapper.selectInfo()
</code></pre>
<p><strong>为什么紧跟着的第一个 select 方法会被分页?</strong></p>
<p>PageHelper 方法使用了静态的 ThreadLocal 参数，分页参数和线程是绑定的：</p>
<h1 id="总结-22"><a class="header" href="#总结-22">总结</a></h1>
<h2 id="threadlocal的实现原理是什么"><a class="header" href="#threadlocal的实现原理是什么">ThreadLocal的实现原理是什么？</a></h2>
<ul>
<li>每一个线程绑定一个 <em>ThreadLocalMap</em> ，这个<em>Map</em> 以 ThreadLocal作为Key，存入的值作为 value，这样 每个线程都有作用于全局的 独立的内存空间</li>
</ul>
<h2 id="threadlocalmap的实现原理"><a class="header" href="#threadlocalmap的实现原理">ThreadLocalMap的实现原理？</a></h2>
<ul>
<li>
<p>ThreadLocalMap维护了Entry环形数组，数组中元素Entry的逻辑上的key为某个ThreadLocal对象（实际上是指向该ThreadLocal对象的弱引用），value为代码中该线程往该ThreadLoacl变量实际塞入的值。</p>
</li>
<li>
<p>是一个Map，底层使用 数组实现，通过hash散列 到 数组对应的索引</p>
</li>
<li>
<p>通过线性 探测解决 hash冲突</p>
</li>
</ul>
<h2 id="threadlocalmap-的key有什么特殊之处"><a class="header" href="#threadlocalmap-的key有什么特殊之处"><em>ThreadLocalMap</em> 的key有什么特殊之处？</a></h2>
<ul>
<li>继承了弱引用，当 内存不足时，会回收此处引用的空间</li>
</ul>
<p><strong>为何要这样做</strong></p>
<ul>
<li>因为 线程的生命周期 可能明显要大于 ThreadLocal的存活周期</li>
<li>如果<em>ThreadLocal</em> 的外部引用消失了，但线程还在，就会出现 内存泄漏</li>
<li>所以使用 弱引用，如果 <em>ThreadLocal</em> 不存在外部引用了，这个<em>Key</em> 就可能会被垃圾回收掉</li>
<li>然后再下一次 对 这个 Map的 访问或修改中 <em>entry</em> 可能会就被移除</li>
</ul>
<p>但是重要的一点：<em>value</em> 还是会产生内存泄漏</p>
<p>所以 <em>key</em> 的弱引用只是为了提醒 <em>Map</em> 尽快对 清理<em>entry</em> </p>
<h2 id="threadlocalmap扩容机制"><a class="header" href="#threadlocalmap扩容机制">ThreadLocalMap扩容机制？</a></h2>
<p>启发式清理 无效引用，如果没有清理任何数据，当前大小超过了阈值，则开始 扩容</p>
<p>而开始扩容前，会进行一次全量的 无效引用的清理，如果此时超过了  3\4阈值，则真正开始扩容</p>
<h2 id="应用-1"><a class="header" href="#应用-1">应用</a></h2>
<ul>
<li>spring获取当前代理对象</li>
<li>mybatis分页</li>
<li>自己项目：租户Code</li>
<li>org.slf4j.MDC ，链路追踪ID</li>
</ul>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/multi-thread/%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3ThreadLocal%E5%85%B3%E9%94%AE%E5%AD%97.md">参考链接</a></p>
<p><a href="https://www.toutiao.com/i6885197882979254796/">InternalThreadLocalMap</a></p>
<p><a href="https://github.com/alibaba/transmittable-thread-local">transmittable-thread-local</a></p>
<div style="break-before: page; page-break-before: always;"></div><p><a href="https://sourcemaking.com/refactoring"><strong>参考链接</strong></a></p>
<table><thead><tr><th>名称项</th><th>英文</th><th>表现场景</th><th>解决办法</th></tr></thead><tbody>
<tr><td>重复代码</td><td>Duplicated Code</td><td>同一个 class 内的两个函数含有相同的表达式<br />两个互为兄弟的 subclass 内含相同的表达式<br />两个毫不相干的 classes 内出现 Duplicate Code</td><td>提出公共代码</td></tr>
<tr><td>过长方法</td><td>Long Method</td><td>方法过长</td><td>提出模块</td></tr>
<tr><td>大类</td><td>Large Class</td><td>把太多的责任交给了一个类</td><td>一个方法一个职责</td></tr>
<tr><td>过长参数列表</td><td>Long Parameter List</td><td></td><td>抽象成类</td></tr>
<tr><td>发散式变动</td><td>Divergent Change</td><td>不同的变化作用于单个类</td><td>重构，保持类功能单一,把相对不变的和相对变化相隔离</td></tr>
<tr><td>霰弹式变动</td><td>Shotgun Surgery</td><td>对系统一个地方的改变涉及到其他许多地方的相关改变</td><td>提取变化部分为公共的类</td></tr>
<tr><td>依恋情结</td><td>Feature Envy</td><td>一个类的方法频繁用 get 方法存取其他类的状态进行计算</td><td>将总是一起变化的东西放在一块儿。［数据］和[引用这些数据]的行为总是一起变化的</td></tr>
<tr><td>数据泥团</td><td>Data Clumps</td><td>可以在很多地方看到相同的三或四笔数据项</td><td>[总是绑在一起出现的数据]真应该放进属于它们自己的对象中</td></tr>
<tr><td>基本型别偏执</td><td>Primitive Obsession</td><td>基本数据类型 对象化</td><td>反复出现的一组参数，抽象成类 <br />有关联的多个数组，抽象成类</td></tr>
<tr><td>switch 语句</td><td>Switch Statements</td><td></td><td><code>state</code>/<code>strategy</code>/<code>多态</code></td></tr>
<tr><td>平等继承体系</td><td>Parallel Inheritance Hierarchies</td><td>每当你为某个<code>class</code>增加一个<code>subclass</code>，必须也为另一个<code>class</code>相应增加一个<code>subclass</code></td><td>将这 两个继承体系合并优化,有一个类是可以去掉继承关系</td></tr>
<tr><td>冗赘类</td><td>Lazy Class</td><td></td><td>删除</td></tr>
<tr><td>夸夸其谈未来性</td><td>Speculative Generality</td><td>多余的未来的设计</td><td>不要过多设计</td></tr>
<tr><td>临时字段</td><td>Temporary Field</td><td>临时变量命名</td><td>抽象成类</td></tr>
<tr><td>过度耦合的消息链</td><td>MessageChains</td><td>用户向一个对象索求另一个对象，然后再向后者索求另一个对象</td><td>获取对象一步到位</td></tr>
<tr><td>中间转手人</td><td>Middle Man</td><td>某个类接口有一半的方法都委托给其它类,委托的过度使用</td><td>继承代替委托</td></tr>
<tr><td>太亲密</td><td>Inappropriate Intimacy</td><td>两个类彼此使用对方私有的成员或方法</td><td>划清界限拆散／合并／单向联系</td></tr>
<tr><td>不同接口的相似类</td><td>Alternative Classes with Different Interfaces</td><td></td><td>合并</td></tr>
<tr><td>不完善的类库</td><td>Incomplete Library Class</td><td></td><td>包一层函数或包装成新的类</td></tr>
<tr><td>纯稚的数据类</td><td>Data Class</td><td></td><td>将相关操作封装进去，减少 public 成员变量</td></tr>
<tr><td>被拒绝的遗赠</td><td></td><td>父类里面方法很多，子类只用有限几个,继承体系设计错误</td><td>用代理替代继承关系</td></tr>
<tr><td>过多注释</td><td>Comments</td><td></td><td>避免用注释解释代码，而是说明代码的目的，背景等，好代码自己会说话</td></tr>
</tbody></table>
<p><strong>Bloaters</strong>(膨胀)</p>
<blockquote>
<p>代码,方法,类 随着时间 增长到了难以使用的巨大比例</p>
</blockquote>
<h1 id="重构技巧"><a class="header" href="#重构技巧">重构技巧</a></h1>
<h2 id="重构条件表达式"><a class="header" href="#重构条件表达式">重构条件表达式</a></h2>
<p><strong>简化条件表达式</strong></p>
<pre><code class="language-java">//重构前
if (date.before(SUMMER_START) || date.after(SUMMER_END)) {
  charge = quantity * winterRate + winterServiceCharge;
}
else {
  charge = quantity * summerRate;
}

//重构后
if (isSummer(date)) {
  charge = summerCharge(quantity);
}
else {
  charge = winterCharge(quantity);
}
</code></pre>
<p><strong>合并条件表达式</strong></p>
<pre><code class="language-java">//重构前
double disabilityAmount() {
  if (seniority &lt; 2) {
    return 0;
  }
  if (monthsDisabled &gt; 12) {
    return 0;
  }
  if (isPartTime) {
    return 0;
  }
  // Compute the disability amount.
  // ...
}
//重构后
double disabilityAmount() {
  if (isNotEligibleForDisability()) {
    return 0;
  }
  // Compute the disability amount.
  // ...
}
</code></pre>
<p><strong>重复代码提取</strong></p>
<pre><code class="language-java">//重构前
if (isSpecialDeal()) {
  total = price * 0.95;
  send();
}
else {
  total = price * 0.98;
  send();
}
//重构后
if (isSpecialDeal()) {
  total = price * 0.95;
}
else {
  total = price * 0.98;
}
send();
</code></pre>
<p><strong>嵌套条件判断完毕后,立即返回</strong></p>
<pre><code class="language-java">//重构前
public double getPayAmount() {
  double result;
  if (isDead){
    result = deadAmount();
  }
  else {
    if (isSeparated){
      result = separatedAmount();
    }
    else {
      if (isRetired){
        result = retiredAmount();
      }
      else{
        result = normalPayAmount();
      }
    }
  }
  return result;
}
//重构后
public double getPayAmount() {
  if (isDead){
    return deadAmount();
  }
  if (isSeparated){
    return separatedAmount();
  }
  if (isRetired){
    return retiredAmount();
  }
  return normalPayAmount();
}
</code></pre>
<p><strong>条件处理逻辑过多时使用多态</strong></p>
<pre><code class="language-java">//重构前
class Bird {
  // ...
  double getSpeed() {
    switch (type) {
      case EUROPEAN:
        return getBaseSpeed();
      case AFRICAN:
        return getBaseSpeed() - getLoadFactor() * numberOfCoconuts;
      case NORWEGIAN_BLUE:
        return (isNailed) ? 0 : getBaseSpeed(voltage);
    }
    throw new RuntimeException(&quot;Should be unreachable&quot;);
  }
}

//重构后
abstract class Bird {
  // ...
  abstract double getSpeed();
}

class European extends Bird {
  double getSpeed() {
    return getBaseSpeed();
  }
}
class African extends Bird {
  double getSpeed() {
    return getBaseSpeed() - getLoadFactor() * numberOfCoconuts;
  }
}
class NorwegianBlue extends Bird {
  double getSpeed() {
    return (isNailed) ? 0 : getBaseSpeed(voltage);
  }
}

// Somewhere in client code
speed = bird.getSpeed();
</code></pre>
<p><strong>给空值以默认值,默认行为</strong></p>
<pre><code class="language-java">//重构前
if (customer == null) {
  plan = BillingPlan.basic();
}
else {
  plan = customer.getPlan();
}
class NullCustomer extends Customer {
  boolean isNull() {
    return true;
  }
  Plan getPlan() {
    return new NullPlan();
  }
  // Some other NULL functionality.
}
//重构后
// Replace null values with Null-object.
customer = (order.customer != null) ?
  order.customer : new NullCustomer();

// Use Null-object as if it's normal subclass.
plan = customer.getPlan();
</code></pre>
<p><strong>前置 assert 检查</strong>
士大夫</p>
<pre><code>double getExpenseLimit() {
  Assert.isTrue(expenseLimit != NULL_EXPENSE || primaryProject != null);

  return (expenseLimit != NULL_EXPENSE) ?
    expenseLimit:
    primaryProject.getMemberExpenseLimit();
}
</code></pre>
<h2 id="方法组合"><a class="header" href="#方法组合">方法组合</a></h2>
<p><strong>抽取方法</strong></p>
<pre><code class="language-java">//重构前
void printOwing() {
  printBanner();

  // Print details.
  System.out.println(&quot;name: &quot; + name);
  System.out.println(&quot;amount: &quot; + getOutstanding());
}
void printOwing() {
  printBanner();
  printDetails(getOutstanding());
}
//重构后
void printDetails(double outstanding) {
  System.out.println(&quot;name: &quot; + name);
  System.out.println(&quot;amount: &quot; + outstanding);
}
</code></pre>
<p><strong>合并方法</strong></p>
<pre><code class="language-java">//重构前
class PizzaDelivery {
  // ...
  int getRating() {
    return moreThanFiveLateDeliveries() ? 2 : 1;
  }
  boolean moreThanFiveLateDeliveries() {
    return numberOfLateDeliveries &gt; 5;
  }
}
//重构后
class PizzaDelivery {
  // ...
  int getRating() {
    return numberOfLateDeliveries &gt; 5 ? 2 : 1;
  }
}
</code></pre>
<p><strong>抽取变量</strong></p>
<p>变量名尽量保持 自注释</p>
<pre><code class="language-java">//重构前
void renderBanner() {
  if ((platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1) &amp;&amp;
       (browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1) &amp;&amp;
        wasInitialized() &amp;&amp; resize &gt; 0 )
  {
    // do something
  }
}
//重构后
void renderBanner() {
  final boolean isMacOs = platform.toUpperCase().indexOf(&quot;MAC&quot;) &gt; -1;
  final boolean isIE = browser.toUpperCase().indexOf(&quot;IE&quot;) &gt; -1;
  final boolean wasResized = resize &gt; 0;

  if (isMacOs &amp;&amp; isIE &amp;&amp; wasInitialized() &amp;&amp; wasResized) {
    // do something
  }
}
</code></pre>
<p><strong>合并简单临时变量</strong></p>
<pre><code class="language-java">//重构前
boolean hasDiscount(Order order) {
  double basePrice = order.basePrice();
  return basePrice &gt; 1000;
}
//重构后
boolean hasDiscount(Order order) {
  return order.basePrice() &gt; 1000;
}
</code></pre>
<p><strong>使用查询替换临时变量</strong></p>
<pre><code class="language-java">//重构前
double calculateTotal() {
  double basePrice = quantity * itemPrice;
  if (basePrice &gt; 1000) {
    return basePrice * 0.95;
  }
  else {
    return basePrice * 0.98;
  }
}
//重构后
double calculateTotal() {
  if (basePrice() &gt; 1000) {
    return basePrice() * 0.95;
  }
  else {
    return basePrice() * 0.98;
  }
}
double basePrice() {
  return quantity * itemPrice;
}
</code></pre>
<p><strong>分离临时变量</strong></p>
<pre><code class="language-java">double temp = 2 * (height + width);
System.out.println(temp);
temp = height * width;
System.out.println(temp);
final double perimeter = 2 * (height + width);
System.out.println(perimeter);
final double area = height * width;
System.out.println(area);
</code></pre>
<p><strong>不要对入参进行修改</strong></p>
<pre><code class="language-java">//重构前
int discount(int inputVal, int quantity) {
  if (inputVal &gt; 50) {
    inputVal -= 2;
  }
  // ...
}
//重构后
int discount(int inputVal, int quantity) {
  int result = inputVal;
  if (inputVal &gt; 50) {
    result -= 2;
  }
  // ...
}
</code></pre>
<p><strong>多条件计算使用对象</strong></p>
<pre><code class="language-java">//重构前
class Order {
  // ...
  public double price() {
    double primaryBasePrice;
    double secondaryBasePrice;
    double tertiaryBasePrice;
    // Perform long computation.
  }
}
class Order {
  // ...
  public double price() {
    return new PriceCalculator(this).compute();
  }
}
//重构后
class PriceCalculator {
  private double primaryBasePrice;
  private double secondaryBasePrice;
  private double tertiaryBasePrice;

  public PriceCalculator(Order order) {
    // Copy relevant information from the
    // order object.
  }

  public double compute() {
    // Perform long computation.
  }
}
</code></pre>
<p><strong>使用算法替换代码段</strong></p>
<pre><code class="language-java">//重构前
String foundPerson(String[] people){
  for (int i = 0; i &lt; people.length; i++) {
    if (people[i].equals(&quot;Don&quot;)){
      return &quot;Don&quot;;
    }
    if (people[i].equals(&quot;John&quot;)){
      return &quot;John&quot;;
    }
    if (people[i].equals(&quot;Kent&quot;)){
      return &quot;Kent&quot;;
    }
  }
  return &quot;&quot;;
}
//重构后
String foundPerson(String[] people){
  List candidates =
    Arrays.asList(new String[] {&quot;Don&quot;, &quot;John&quot;, &quot;Kent&quot;});
  for (int i=0; i &lt; people.length; i++) {
    if (candidates.contains(people[i])) {
      return people[i];
    }
  }
  return &quot;&quot;;
}
</code></pre>
<h2 id="组织数据"><a class="header" href="#组织数据">组织数据</a></h2>
<p><strong>使用对象替换数据类型</strong></p>
<pre><code>Order
	Customer String

Order
	Customer Object
		name String
</code></pre>
<h2 id="在对象之间移动功能"><a class="header" href="#在对象之间移动功能">在对象之间移动功能</a></h2>
<p><strong>代理隐藏</strong></p>
<pre><code>a获取b的对象 调用b的方法,

//重构
在 a中建一个方法 去调用b的方法
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言-15"><a class="header" href="#前言-15">前言</a></h1>
<ul>
<li>本文基于 java1.8_251 版本的 Arrays.sort方法，关于整数数组排序的方法</li>
<li>方法签名为 <em>java.util.Arrays#sort(int[])</em></li>
<li>其内部调用的 是 <strong>DualPivotQuicksort.sort</strong> 方法</li>
<li><em>Arrays.sort</em> 内部基于 多种排序算法
<ul>
<li>当数组中的元素 基本有序时， 采用 <strong>改进的归并排序</strong></li>
<li>当数组的个数 较少，且基本有序，采用 传统的<strong>插入排序</strong> 否则 采用 <strong>双元素插入排序</strong></li>
<li>当数组中的元素 无序时 采用 <strong>双枢纽 快速排序</strong></li>
</ul>
</li>
</ul>
<h1 id="dualpivotquicksortsort"><a class="header" href="#dualpivotquicksortsort">DualPivotQuicksort.sort</a></h1>
<h2 id="流程图-2"><a class="header" href="#流程图-2">流程图</a></h2>
<p><img src="50.%E5%85%B6%E4%BB%96_%E6%9C%AA%E5%88%86%E7%B1%BB/....%5Cimages%5CdualPivotQuicksort_sort.png" alt="image-20210213195936815" /></p>
<h2 id="code-1"><a class="header" href="#code-1">code</a></h2>
<pre><code class="language-java">{
        // Use Quicksort on small arrays
        if (right - left &lt; QUICKSORT_THRESHOLD) {
            sort(a, left, right, true); //小数组 采用 插入排序
            return;
        }

        /*
         * Index run[i] is the start of i-th run
         * (ascending or descending sequence).
         */
        int[] run = new int[MAX_RUN_COUNT + 1];
        int count = 0; run[0] = left;

        // Check if the array is nearly sorted
		......//判断数组是否是 基本有序的,如果基本有序 则直接 采用归并排序

        // Check special cases
        // Implementation note: variable &quot;right&quot; is increased by 1.
        if (run[count] == right++) { // The last run contains one element
            run[++count] = right;
        } else if (count == 1) { // The array is already sorted，已经有序
            return;
        }

...... //采用改进的归并排序
</code></pre>
<h1 id="判断数组是否基本有序"><a class="header" href="#判断数组是否基本有序">判断数组是否基本有序</a></h1>
<h2 id="如何判断"><a class="header" href="#如何判断">如何判断</a></h2>
<ul>
<li>任意数组都可以看作 由  正序数列+逆序数列的 组合，故使用 <code>run[count]=k</code>，记录 第 count个数列的 结束索引的位置为K</li>
<li>当第 run数组的大小超过了 <em>MAX_RUN_LENGTH</em> 则认为 无序</li>
<li>当 <em>count</em> 为1则认为数组 已经排序好</li>
</ul>
<h2 id="code-2"><a class="header" href="#code-2">code</a></h2>
<pre><code class="language-java">        for (int k = left; k &lt; right; run[count] = k) {
            if (a[k] &lt; a[k + 1]) { // ascending
                while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);
            } else if (a[k] &gt; a[k + 1]) { // descending
                while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);
                for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {
                    int t = a[lo]; a[lo] = a[hi]; a[hi] = t;
                }
            } else { // equal
                for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) {
                    if (--m == 0) {
                        sort(a, left, right, true);
                        return;
                    }
                }
            }

            /*
             * The array is not highly structured,
             * use Quicksort instead of merge sort.
             */
            if (++count == MAX_RUN_COUNT) {
                sort(a, left, right, true);
                return;
            }
        }


        // Check special cases
        // Implementation note: variable &quot;right&quot; is increased by 1.
        if (run[count] == right++) { // The last run contains one element
            run[++count] = right;
        } else if (count == 1) { // The array is already sorted，已经有序
            return;
        }
</code></pre>
<h1 id="二路归并排序"><a class="header" href="#二路归并排序">二路归并排序</a></h1>
<h2 id="原理-1"><a class="header" href="#原理-1">原理</a></h2>
<ul>
<li>循环的每一轮迭代都将数组a中的两个相邻的单调子序列“归并”为一个新的单调子序列，并存储在数组b中。</li>
<li>循环中的每轮迭代将两个相邻的单调子序列进行归并，第一个子序列的范围是run[k-2] - run[k-1], 第二个子序列的范围是run[k-1] - run[k]，内层循环每次迭代都将k增加2。同时last变量记录了归并得到的新的子序列的个数，同时合并run 数组的内容。</li>
</ul>
<p>**PS：**这里需要注意，如果a数组中的子序列个数是奇数，那么最后一个子序列就无法进行配对、归并操作，此时，直接将这个子序列复制到b中。 </p>
<ul>
<li>每轮迭代以后，子序列的数目都会减少，因此，反复地进行迭代归并后，最终会使得整个数组只包含1个单调递增的子序列，此时整个数组排序完成。</li>
<li>因此，每轮迭代后，交换a、b指针，继续执行下一轮迭代时，同样对a数组进行归并，存储在b数组中。就这样，利用a和b代表的存储空间反复的进行归并，就可以完成数组的排序。107-108行的代码完成了交换a和b指针的工作</li>
</ul>
<h2 id="code-3"><a class="header" href="#code-3">code</a></h2>
<pre><code class="language-java">        // Determine alternation base for merge
        byte odd = 0;
        for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);

        // Use or create temporary array b for merging
        int[] b;                 // temp array; alternates with a
        int ao, bo;              // array offsets from 'left'
        int blen = right - left; // space needed for b
        if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {
            work = new int[blen];
            workBase = 0;
        }
        if (odd == 0) {
            System.arraycopy(a, left, work, workBase, blen);
            b = a;
            bo = 0;
            a = work;
            ao = workBase - left;
        } else {
            b = work;
            ao = 0;
            bo = workBase - left;
        }
		//以上是初始化的操作

        // Merging
        for (int last; count &gt; 1; count = last) {
            for (int k = (last = 0) + 2; k &lt;= count; k += 2) {
                int hi = run[k], mi = run[k - 1];
                for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {
                    if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {
                        b[i + bo] = a[p++ + ao];
                    } else {
                        b[i + bo] = a[q++ + ao];
                    }
                }
                run[++last] = hi;
            }
            if ((count &amp; 1) != 0) {
                for (int i = right, lo = run[count - 1]; --i &gt;= lo;
                    b[i + bo] = a[i + ao]
                );
                run[++last] = right;
            }
            int[] t = a; a = b; b = t;
            int o = ao; ao = bo; bo = o;
        }
    }
</code></pre>
<h1 id="改进的快速排序"><a class="header" href="#改进的快速排序">改进的快速排序</a></h1>
<h2 id="改进的快速排序整体流程图"><a class="header" href="#改进的快速排序整体流程图"><strong>改进的快速排序整体流程图</strong></a></h2>
<p><img src="50.%E5%85%B6%E4%BB%96_%E6%9C%AA%E5%88%86%E7%B1%BB/....%5Cimages%5CdualPivotQuicksort_quick_sort.png" alt="image-20210213201130603" /></p>
<h3 id="代码-1"><a class="header" href="#代码-1">代码</a></h3>
<pre><code class="language-java">{
        int length = right - left + 1;

        // Use insertion sort on tiny arrays
        if (length &lt; INSERTION_SORT_THRESHOLD) {
            if (leftmost) {
                ......//传统插入排序
            } else {
         		......//双元素插入排序
            }
            return;
        }

        ...... //计算双枢纽位置
            
		//五个点各不相等则 采用 双枢纽
        if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {
			......//双枢纽划分
            // Sort left and right parts recursively, excluding known pivots
            sort(a, left, less - 2, leftmost);
            sort(a, great + 2, right, false);

            /*
             * If center part is too large (comprises &gt; 4/7 of the array),
             * swap internal pivot values to ends.
             */
            if (less &lt; e1 &amp;&amp; e5 &lt; great) {
                ......//处理中间区间过长的问题
            }

            // Sort center part recursively
            sort(a, less, great, false);

        } else { // Partitioning with one pivot
            ......//单枢纽划分
            sort(a, left, less - 1, leftmost);
            sort(a, great + 1, right, false);
        }
    }
</code></pre>
<h2 id="双枢纽排序"><a class="header" href="#双枢纽排序"><strong>双枢纽排序</strong></a></h2>
<h3 id="流程图-3"><a class="header" href="#流程图-3">流程图</a></h3>
<p><img src="50.%E5%85%B6%E4%BB%96_%E6%9C%AA%E5%88%86%E7%B1%BB/....%5Cimages%5CdualPivotQuicksort_quick_dual_pivot_sort.png" alt="image-20210213202642614" /></p>
<h3 id="寻找双枢纽位置"><a class="header" href="#寻找双枢纽位置">寻找双枢纽位置</a></h3>
<blockquote>
<p>java 279~312</p>
</blockquote>
<pre><code class="language-java">        // Inexpensive approximation of length / 7 取差不多数组长度的1/7
        int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;
        /*
         * Sort five evenly spaced elements around (and including) the
         * center element in the range. These elements will be used for
         * pivot selection as described below. The choice for spacing
         * these elements was empirically determined to work well on
         * a wide variety of inputs.
         * 从中间点 分别向 左右扩展 两个点，间距取大约数组长度的1/7，并将这五个点排序
         */
        int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint
        int e2 = e3 - seventh;
        int e1 = e2 - seventh;
        int e4 = e3 + seventh;
        int e5 = e4 + seventh;

        // Sort these elements using insertion sort
        if (a[e2] &lt; a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }

        if (a[e3] &lt; a[e2]) { int t = a[e3]; a[e3] = a[e2]; a[e2] = t;
            if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }
        }
        if (a[e4] &lt; a[e3]) { int t = a[e4]; a[e4] = a[e3]; a[e3] = t;
            if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;
                if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }
            }
        }
        if (a[e5] &lt; a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t;
            if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;
                if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;
                    if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }
                }
            }
        }
</code></pre>
<h3 id="双枢纽划分"><a class="header" href="#双枢纽划分">双枢纽划分</a></h3>
<pre><code class="language-java">// 判断五个点是否都 各不相同
if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {
    /*
     * Use the second and fourth of the five sorted elements as pivots.
     * These values are inexpensive approximations of the first and
     * second terciles of the array. Note that pivot1 &lt;= pivot2.
     */
    int pivot1 = a[e2];
    int pivot2 = a[e4];

    /*
     * The first and the last elements to be sorted are moved to the
     * locations formerly occupied by the pivots. When partitioning
     * is complete, the pivots are swapped back into their final
     * positions, and excluded from subsequent sorting.
     */
    a[e2] = a[left];
    a[e4] = a[right];

    /*
     * Skip elements, which are less or greater than pivot values.
     */
    while (a[++less] &lt; pivot1);
    while (a[--great] &gt; pivot2);

    /*
     * Partitioning:
     *
     *   left part           center part                   right part
     * +--------------------------------------------------------------+
     * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |
     * +--------------------------------------------------------------+
     *               ^                          ^       ^
     *               |                          |       |
     *              less                        k     great
     *
     * Invariants:
     *
     *              all in (left, less)   &lt; pivot1
     *    pivot1 &lt;= all in [less, k)     &lt;= pivot2
     *              all in (great, right) &gt; pivot2
     *
     * Pointer k is the first index of ?-part.
     */
    outer:
    for (int k = less - 1; ++k &lt;= great; ) {
        int ak = a[k];
        if (ak &lt; pivot1) { // Move a[k] to left part
            a[k] = a[less];
            /*
             * Here and below we use &quot;a[i] = b; i++;&quot; instead
             * of &quot;a[i++] = b;&quot; due to performance issue.
             */
            a[less] = ak;
            ++less;
        } else if (ak &gt; pivot2) { // Move a[k] to right part
            while (a[great] &gt; pivot2) {
                if (great-- == k) {
                    break outer;
                }
            }
            if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2
                a[k] = a[less];
                a[less] = a[great];
                ++less;
            } else { // pivot1 &lt;= a[great] &lt;= pivot2
                a[k] = a[great];
            }
            /*
             * Here and below we use &quot;a[i] = b; i--;&quot; instead
             * of &quot;a[i--] = b;&quot; due to performance issue.
             */
            a[great] = ak;
            --great;
        }
    }

    // Swap pivots into their final positions
    a[left]  = a[less  - 1]; a[less  - 1] = pivot1;
    a[right] = a[great + 1]; a[great + 1] = pivot2;

    // Sort left and right parts recursively, excluding known pivots
    sort(a, left, less - 2, leftmost);
    sort(a, great + 2, right, false);

    /*
     * If center part is too large (comprises &gt; 4/7 of the array),
     * swap internal pivot values to ends.
     */
    if (less &lt; e1 &amp;&amp; e5 &lt; great) {
       ...... //处理 中间区间过大的问题
    }

    // Sort center part recursively
    sort(a, less, great, false);
</code></pre>
<h3 id="单枢纽划分"><a class="header" href="#单枢纽划分">单枢纽划分</a></h3>
<pre><code class="language-java">{ // Partitioning with one pivot
            /*
             * Use the third of the five sorted elements as pivot.
             * This value is inexpensive approximation of the median.
             */
            int pivot = a[e3];

            /*
             * Partitioning degenerates to the traditional 3-way
             * (or &quot;Dutch National Flag&quot;) schema:
             *
             *   left part    center part              right part
             * +-------------------------------------------------+
             * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |
             * +-------------------------------------------------+
             *              ^              ^        ^
             *              |              |        |
             *             less            k      great
             *
             * Invariants:
             *
             *   all in (left, less)   &lt; pivot
             *   all in [less, k)     == pivot
             *   all in (great, right) &gt; pivot
             *
             * Pointer k is the first index of ?-part.
             */
            for (int k = less; k &lt;= great; ++k) {
                if (a[k] == pivot) {
                    continue;
                }
                int ak = a[k];
                if (ak &lt; pivot) { // Move a[k] to left part
                    a[k] = a[less];
                    a[less] = ak;
                    ++less;
                } else { // a[k] &gt; pivot - Move a[k] to right part
                    while (a[great] &gt; pivot) {
                        --great;
                    }
                    if (a[great] &lt; pivot) { // a[great] &lt;= pivot
                        a[k] = a[less];
                        a[less] = a[great];
                        ++less;
                    } else { // a[great] == pivot
                        /*
                         * Even though a[great] equals to pivot, the
                         * assignment a[k] = pivot may be incorrect,
                         * if a[great] and pivot are floating-point
                         * zeros of different signs. Therefore in float
                         * and double sorting methods we have to use
                         * more accurate assignment a[k] = a[great].
                         */
                        a[k] = pivot;
                    }
                    a[great] = ak;
                    --great;
                }
            }

            /*
             * Sort left and right parts recursively.
             * All elements from center part are equal
             * and, therefore, already sorted.
             */
            sort(a, left, less - 1, leftmost);
            sort(a, great + 1, right, false);
        }
</code></pre>
<h3 id="中间区间过大的问题"><a class="header" href="#中间区间过大的问题">中间区间过大的问题</a></h3>
<ul>
<li>大于数组的 4/7 就认为 中间区间过大</li>
<li>将其中 等于 pivot1 pivot2的数据放到 privot1的最右边 或者 privot2的最左边</li>
</ul>
<pre><code class="language-java">            /*
             * If center part is too large (comprises &gt; 4/7 of the array),
             * swap internal pivot values to ends.
             */
            if (less &lt; e1 &amp;&amp; e5 &lt; great) {
                /*
                 * Skip elements, which are equal to pivot values.
                 */
                while (a[less] == pivot1) {
                    ++less;
                }

                while (a[great] == pivot2) {
                    --great;
                }

                /*
                 * Partitioning:
                 *
                 *   left part         center part                  right part
                 * +----------------------------------------------------------+
                 * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |
                 * +----------------------------------------------------------+
                 *              ^                        ^       ^
                 *              |                        |       |
                 *             less                      k     great
                 *
                 * Invariants:
                 *
                 *              all in (*,  less) == pivot1
                 *     pivot1 &lt; all in [less,  k)  &lt; pivot2
                 *              all in (great, *) == pivot2
                 *
                 * Pointer k is the first index of ?-part.
                 */
                outer:
                for (int k = less - 1; ++k &lt;= great; ) {
                    int ak = a[k];
                    if (ak == pivot1) { // Move a[k] to left part
                        a[k] = a[less];
                        a[less] = ak;
                        ++less;
                    } else if (ak == pivot2) { // Move a[k] to right part
                        while (a[great] == pivot2) {
                            if (great-- == k) {
                                break outer;
                            }
                        }
                        if (a[great] == pivot1) { // a[great] &lt; pivot2
                            a[k] = a[less];
                            /*
                             * Even though a[great] equals to pivot1, the
                             * assignment a[less] = pivot1 may be incorrect,
                             * if a[great] and pivot1 are floating-point zeros
                             * of different signs. Therefore in float and
                             * double sorting methods we have to use more
                             * accurate assignment a[less] = a[great].
                             */
                            a[less] = pivot1;
                            ++less;
                        } else { // pivot1 &lt; a[great] &lt; pivot2
                            a[k] = a[great];
                        }
                        a[great] = ak;
                        --great;
                    }
                }
            }
</code></pre>
<h2 id="传统插入排序"><a class="header" href="#传统插入排序">传统插入排序</a></h2>
<pre><code class="language-java">                /*
                 * Traditional (without sentinel) insertion sort,
                 * optimized for server VM, is used in case of
                 * the leftmost part.
                 */
                for (int i = left, j = i; i &lt; right; j = ++i) {
                    int ai = a[i + 1];
                    while (ai &lt; a[j]) {
                        a[j + 1] = a[j];
                        if (j-- == left) {
                            break;
                        }
                    }
                    a[j + 1] = ai;
                }
</code></pre>
<h2 id="双元素插入排序"><a class="header" href="#双元素插入排序">双元素插入排序</a></h2>
<pre><code class="language-java">       /*
                 * Skip the longest ascending sequence.
                 */
                do {
                    if (left &gt;= right) {
                        return;
                    }
                } while (a[++left] &gt;= a[left - 1]);

                /*
                 * Every element from adjoining part plays the role
                 * of sentinel, therefore this allows us to avoid the
                 * left range check on each iteration. Moreover, we use
                 * the more optimized algorithm, so called pair insertion
                 * sort, which is faster (in the context of Quicksort)
                 * than traditional implementation of insertion sort.
                 */
                for (int k = left; ++left &lt;= right; k = ++left) {
                    int a1 = a[k], a2 = a[left];

                    if (a1 &lt; a2) {
                        a2 = a1; a1 = a[left];
                    }
                    while (a1 &lt; a[--k]) {
                        a[k + 2] = a[k];
                    }
                    a[++k + 1] = a1;

                    while (a2 &lt; a[--k]) {
                        a[k + 1] = a[k];
                    }
                    a[k + 1] = a2;
                }
                int last = a[right];

                while (last &lt; a[--right]) {
                    a[right + 1] = a[right];
                }
                a[right + 1] = last;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概览"><a class="header" href="#概览">概览</a></h1>
<ul>
<li>enum关键字在 java5 中引入，表示一种特殊类型的类</li>
<li>枚举类是一种“语法糖”，<strong>只有编译器知道“enum”关键字，jvm是不知道的，字节码文件中没有枚举这一概念</strong></li>
<li>其总是继承java.lang.Enum类，所以不能枚举不能继承其他类，但是可以实现接口</li>
<li>枚举构造函数默认是私有的</li>
</ul>
<h1 id="自定义枚举方法"><a class="header" href="#自定义枚举方法">自定义枚举方法</a></h1>
<p><strong>可以在枚举的外面定义一个 类，用来实现关于枚举的各个API</strong></p>
<pre><code class="language-java">public class Pizza {
    private PizzaStatus status;
    public enum PizzaStatus {
        ORDERED,
        READY,
        DELIVERED;
    }
 
    public boolean isDeliverable() {
        if (getStatus() == PizzaStatus.READY) {
            returntrue;
        }
        returnfalse;
    }
     
    // Methods that set and get the status variable.
}	
</code></pre>
<h1 id="在switch语句中使用枚举类型"><a class="header" href="#在switch语句中使用枚举类型">在switch语句中使用枚举类型</a></h1>
<pre><code class="language-java">public int getDeliveryTimeInDays() {
    switch (status) {
        case ORDERED: return5;
        case READY: return2;
        case DELIVERED: return0;
    }
    return0;
}
</code></pre>
<h1 id="在枚举中定义方法"><a class="header" href="#在枚举中定义方法">在枚举中定义方法</a></h1>
<pre><code class="language-java">publicclass Pizza {
 
    private PizzaStatus status;
    public enum PizzaStatus {
        ORDERED (5){
            @Override
            public boolean isOrdered() {
                returntrue;
            }
        },
        READY (2){
            @Override
            public boolean isReady() {
                returntrue;
            }
        },
        DELIVERED (0){
            @Override
            public boolean isDelivered() {
                returntrue;
            }
        };
 
        private int timeToDelivery;
 
        public boolean isOrdered() {returnfalse;}
 
        public boolean isReady() {returnfalse;}
 
        public boolean isDelivered(){returnfalse;}
 
        public int getTimeToDelivery() {
            return timeToDelivery;
        }
 
        PizzaStatus (int timeToDelivery) {
            this.timeToDelivery = timeToDelivery;
        }
    }
 
    public boolean isDeliverable() {
        returnthis.status.isReady();
    }
 
    public void printTimeToDeliver() {
        System.out.println(&quot;Time to delivery is &quot; +
          this.getStatus().getTimeToDelivery());
    }
     
    // Methods that set and get the status variable.
}
</code></pre>
<h1 id="枚举反编译"><a class="header" href="#枚举反编译">枚举反编译</a></h1>
<h2 id="原始代码"><a class="header" href="#原始代码">原始代码</a></h2>
<pre><code class="language-java">public enum Fruit {
    APPLE, BANANA, WATERMELON;
    private int value;

    private Fruit() {
        //默认构造器
        this.value = 0;
    }

    private Fruit(int value) {
        //带参数的构造器
        this.value = value;
    }
}
</code></pre>
<h2 id="jvm字节码"><a class="header" href="#jvm字节码">JVM字节码</a></h2>
<blockquote>
<p>简单反编译：javap -p DateTypeEnum.class</p>
<p>复杂编译：javap -c DateTypeEnum</p>
</blockquote>
<pre><code class="language-java">public final class Fruit extends java.lang.Enum&lt;Fruit&gt; {
  public static final Fruit APPLE;

  public static final Fruit BANANA;

  public static final Fruit WATERMELON;

  public static Fruit[] values();
    Code:
       0: getstatic     #1                  // Field $VALUES:[LFruit;
       3: invokevirtual #2                  // Method &quot;[LFruit;&quot;.clone:()Ljava/lang/Object;
       6: checkcast     #3                  // class &quot;[LFruit;&quot;
       9: areturn

  public static Fruit valueOf(java.lang.String);
    Code:
       0: ldc           #4                  // class Fruit
       2: aload_0
       3: invokestatic  #5                  // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;
       6: checkcast     #4                  // class Fruit
       9: areturn

  static {};
    Code:
       0: new           #4                  // class Fruit
       3: dup
       4: ldc           #8                  // String APPLE
       6: iconst_0
       7: invokespecial #9                  // Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V
      10: putstatic     #10                 // Field APPLE:LFruit;
      13: new           #4                  // class Fruit
      16: dup
      17: ldc           #11                 // String BANANA
      19: iconst_1
      20: invokespecial #9                  // Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V
      23: putstatic     #12                 // Field BANANA:LFruit;
      26: new           #4                  // class Fruit
      29: dup
      30: ldc           #13                 // String WATERMELON
      32: iconst_2
      33: invokespecial #9                  // Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V
      36: putstatic     #14                 // Field WATERMELON:LFruit;
      39: iconst_3
      40: anewarray     #4                  // class Fruit
      43: dup
      44: iconst_0
      45: getstatic     #10                 // Field APPLE:LFruit;
      48: aastore
      49: dup
      50: iconst_1
      51: getstatic     #12                 // Field BANANA:LFruit;
      54: aastore
      55: dup
      56: iconst_2
      57: getstatic     #14                 // Field WATERMELON:LFruit;
      60: aastore
      61: putstatic     #1                  // Field $VALUES:[LFruit;
      64: return
}
</code></pre>
<h2 id="最终源码"><a class="header" href="#最终源码">最终源码</a></h2>
<pre><code class="language-java">public final class Fruit extends Enum {   
//3个枚举成员实例    
    public static final Fruit APPLE;    
    public static final Fruit BANANA;    
    public static final Fruit WATERMELON;    
    private int value;//普通变量    
    private static final Fruit ENUM$VALUES[];//存储枚举常量的枚举数组    
    static {
    //静态域，初始化枚举常量，枚举数组        
        APPLE = new Fruit(&quot;APPLE&quot;, 0);        
        BANANA = new Fruit(&quot;BANANA&quot;, 1);        
        WATERMELON = new Fruit(&quot;WATERMELON&quot;, 2);        
        ENUM$VALUES = (new Fruit[]{APPLE, BANANA, WATERMELON});    
    }
    private Fruit(String s, int i) {
        //编译器改造了默认构造器        
        super(s, i);        
        value = 0;    
    }    
    private Fruit(String s, int i, int value) {
        //编译器改造了带参数的构造器        
        super(s, i);        
        this.value = value;    
    }    
    public static Fruit[] values() {
        //编译器添加了静态方法values()        
        Fruit afruit[];        
        int i;        
        Fruit afruit1[];        
        System.arraycopy(afruit = ENUM$VALUES, 0, afruit1 = new Fruit[i = afruit.length], 0, i);        
        return afruit1;    
    }    
    public static Fruit valueOf(String s) {
        //编译器添加了静态方法valueOf()        
        return (Fruit) Enum.valueOf(Test_2018_1_16 / Fruit, s);    
    }
}
</code></pre>
<h2 id="手动继承枚举"><a class="header" href="#手动继承枚举">手动继承枚举</a></h2>
<pre><code class="language-java">public class MyEnum extends Enum { // 这样写肯定是通不过编译的，因为编译器不允许我们的类显示的继承Enum类

    private MyEnum() {}

    public static final MyEnum e1 = new MyEnum(&quot;WHITE&quot;, 0);
    public static final MyEnum e2 = new MyEnum(&quot;BLACK&quot;, 1);

    public MyEnum[] values() {
        return new MyEnum[]{e1, e2}; // 这个地方有问题，等下指出
    }
}
</code></pre>
<h1 id="枚举可以定义抽象方法"><a class="header" href="#枚举可以定义抽象方法">枚举可以定义抽象方法</a></h1>
<p><strong>但是一定要在各自的示例中实现</strong></p>
<pre><code>“不含抽象方法”的class反编译文件：public **final** class Weather extends Enum

“含有抽象方法”的class反编译文件：public **abstract**class Weather extends Enum
</code></pre>
<pre><code class="language-java">public  enum Fruit {
    APPLE{
        @Override
        void doSomeThing() {
            
        }
    }, BANANA {
        @Override
        void doSomeThing() {
            
        }
    }, WATERMELON {
        @Override
        void doSomeThing() {
            
        }
    };
    private int value;

    Fruit() {
        //默认构造器
        this.value = 0;
    }

    Fruit(int value) {
        //带参数的构造器
        this.value = value;
    }

    abstract void doSomeThing();
}
</code></pre>
<h1 id="进阶"><a class="header" href="#进阶">进阶</a></h1>
<h2 id="enumset"><a class="header" href="#enumset">EnumSet</a></h2>
<h3 id="构造-1"><a class="header" href="#构造-1">构造</a></h3>
<p><strong>根据枚举类构造</strong></p>
<pre><code class="language-java">EnumSet&lt;Fruit&gt; fruits = EnumSet.allOf(Fruit.class);
</code></pre>
<p><strong>根据枚举实例构造</strong></p>
<pre><code class="language-java">EnumSet&lt;Fruit&gt; one = EnumSet.of(Fruit.APPLE);
EnumSet&lt;Fruit&gt; two = EnumSet.of(Fruit.APPLE,Fruit.BANANA);
EnumSet&lt;Fruit&gt; three = EnumSet.of(Fruit.APPLE,Fruit.BANANA,Fruit.WATERMELON);
</code></pre>
<p><strong>根据枚举集合的补集构造</strong></p>
<pre><code class="language-java">EnumSet&lt;Fruit&gt; oneComp = EnumSet.complementOf(one);
</code></pre>
<p><strong>构造空枚举集合</strong></p>
<pre><code class="language-java">EnumSet&lt;Fruit&gt; fruits1 = EnumSet.noneOf(Fruit.class);
EnumSet&lt;Fruit&gt; fruits2 = EnumSet.complementOf(fruits1);
</code></pre>
<p><strong>根据ordinary范围构造</strong></p>
<pre><code class="language-java">EnumSet&lt;Fruit&gt; range = EnumSet.range(Fruit.APPLE, Fruit.WATERMELON);
</code></pre>
<h3 id="使用-7"><a class="header" href="#使用-7"><strong>使用</strong></a></h3>
<p><strong>与一般的 Set集合 使用无异</strong></p>
<h2 id="enummap"><a class="header" href="#enummap">EnumMap</a></h2>
<ul>
<li>会事先在内部初始化 一些key的集合，因此大小是固定的，性能比 <em>HashMap</em> 要好很多</li>
<li>会将 null值 映射成  为 <em>null object</em></li>
</ul>
<h3 id="构造-2"><a class="header" href="#构造-2">构造</a></h3>
<pre><code>EnumMap&lt;Fruit,String&gt; enumMap = new EnumMap&lt;&gt;(Fruit.class);
//此时出初始化了 指定枚举类型的key

enumMap.put(Fruit.APPLE,&quot;xjq&quot;);
enumMap.put(Fruit.WATERMELON,null);
enumMap.put(Fruit.BANANA,&quot;xjq&quot;);
</code></pre>
<p><strong>使用</strong></p>
<p>与普通<em>map</em> 使用无异</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是注解"><a class="header" href="#什么是注解">什么是注解?</a></h1>
<p>​	Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。,和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中,Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 </p>
<h1 id="内置注解"><a class="header" href="#内置注解">内置注解</a></h1>
<h2 id="作用在代码上的注解"><a class="header" href="#作用在代码上的注解">作用在代码上的注解</a></h2>
<p><em>@Override</em></p>
<p>​	检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</p>
<p><em>@Deprecated</em></p>
<p>​	标记过时方法。如果使用该方法，会报编译警告。</p>
<p>@SuppressWarnings</p>
<p>​	指示编译器去忽略注解中声明的警告。</p>
<pre><code>deprecation：使用了不赞成使用的类或方法时的警告；
unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 
fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;
path：在类路径、源文件路径等中有不存在的路径时的警告; 
serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告; 
finally：任何 finally 子句不能正常完成时的警告; 
all：关于以上所有情况的警告。
</code></pre>
<h2 id="元注解"><a class="header" href="#元注解">元注解</a></h2>
<ul>
<li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li>
<li>@Documented - 类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的,标记这些注解是否包含在用户文档中。</li>
<li>@Target - 标记这个注解应该是哪种 Java 成员。</li>
<li>@Inherited - 可以让注解被继承，但这并不是真的继承，只是通过使用@Inherited，可以让子类Class对象使用getAnnotations()获取父类被@Inherited修饰的注解</li>
</ul>
<pre><code class="language-java">@Inherited
@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface DocumentA {
}

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface DocumentB {
}

@DocumentA
class A{ }

class B extends A{ }

@DocumentB
class C{ }

class D extends C{ }

//测试
public class DocumentDemo {

    public static void main(String... args){
        A instanceA=new B();
        System.out.println(&quot;已使用的@Inherited注解:&quot;+Arrays.toString(instanceA.getClass().getAnnotations()));

        C instanceC = new D();

        System.out.println(&quot;没有使用的@Inherited注解:&quot;+Arrays.toString(instanceC.getClass().getAnnotations()));
    }

    /**
     * 运行结果:
     已使用的@Inherited注解:[@com.zejian.annotationdemo.DocumentA()]
     没有使用的@Inherited注解:[]
     */
}
</code></pre>
<h3 id="从-java-7-开始额外添加了-3-个注解"><a class="header" href="#从-java-7-开始额外添加了-3-个注解">从 Java 7 开始，额外添加了 3 个注解</a></h3>
<ul>
<li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>
<li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li>
<li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li>
</ul>
<h1 id="annotation的组成部分"><a class="header" href="#annotation的组成部分">Annotation的组成部分</a></h1>
<blockquote>
<p>java Annotation 的组成中，有 3 个非常重要的主干类。它们分别是：</p>
</blockquote>
<pre><code class="language-java">package java.lang.annotation;
public interface Annotation {

    boolean equals(Object obj);

    int hashCode();

    String toString();

    Class&lt;? extends Annotation&gt; annotationType();
}
</code></pre>
<pre><code class="language-java">public enum ElementType {
    /**标明该注解可以用于类、接口（包括注解类型）或enum声明*/
    TYPE,

    /** 标明该注解可以用于字段(域)声明，包括enum实例 */
    FIELD,

    /** 标明该注解可以用于方法声明 */
    METHOD,

    /** 标明该注解可以用于参数声明 */
    PARAMETER,

    /** 标明注解可以用于构造函数声明 */
    CONSTRUCTOR,

    /** 标明注解可以用于局部变量声明 */
    LOCAL_VARIABLE,

    /** 标明注解可以用于注解声明(应用于另一个注解上)*/
    ANNOTATION_TYPE,

    /** 标明注解可以用于包声明 */
    PACKAGE,

    /**
     * 标明注解可以用于类型参数声明（1.8新加入）
     * @since 1.8
     */
    TYPE_PARAMETER,

    /**
     * 类型使用声明（1.8新加入)
     * @since 1.8
     */
    TYPE_USE
}
</code></pre>
<pre><code class="language-java">package java.lang.annotation;
public enum RetentionPolicy {
    SOURCE,            /* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */

    CLASS,             /* 编译器将Annotation存储于类对应的.class文件中。默认行为  */

    RUNTIME            /* 编译器将Annotation存储于class文件中，并且可由JVM读入 */
}
</code></pre>
<h2 id="annotation本身"><a class="header" href="#annotation本身"><strong>Annotation</strong>本身</a></h2>
<ul>
<li><strong>Annotation 就是个接口。</strong></li>
<li>每 1 个 Annotation对象都与1个RetentionPolicy,关联并且与 1～n 个 ElementType关联</li>
</ul>
<h2 id="elementtype"><a class="header" href="#elementtype">ElementType</a></h2>
<p>当注解未指定Target值时，则此注解可以用于任何元素之上，多个值使用{}包含并用逗号隔开，如下</p>
<pre><code class="language-java">@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
</code></pre>
<h2 id="retentionpolicy"><a class="header" href="#retentionpolicy">RetentionPolicy</a></h2>
<ul>
<li><em>SOURCE</em> </li>
</ul>
<blockquote>
<p>Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了</p>
</blockquote>
<ul>
<li>CLASS</li>
</ul>
<blockquote>
<p>编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。</p>
</blockquote>
<ul>
<li>RUNTIME</li>
</ul>
<blockquote>
<p>编译器将 Annotation 存储于 class 文件中，并且可由JVM读入</p>
</blockquote>
<h1 id="自定义注解-1"><a class="header" href="#自定义注解-1">自定义注解</a></h1>
<h2 id="注解元素及其数据类型"><a class="header" href="#注解元素及其数据类型">注解元素及其数据类型</a></h2>
<h3 id="标记注解"><a class="header" href="#标记注解">标记注解</a></h3>
<p>(marker annotation) 没有定义元素的注解</p>
<h3 id="注解支持的数据类型"><a class="header" href="#注解支持的数据类型">注解支持的数据类型</a></h3>
<ul>
<li>所有基本类型（int,float,boolean,byte,double,char,long,short）</li>
<li>String</li>
<li>Class</li>
<li>enum</li>
<li>Annotation</li>
<li>上述类型的数组</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>若使用了其他数据类型，编译器将会丢出一个编译错误</li>
<li>声明注解元素时可以使用基本类型但不允许使用任何包装类型</li>
<li>注解也可以作为元素的类型，也就是嵌套注解</li>
</ul>
<p><strong>示例</strong></p>
<pre><code class="language-java">
/**
 * Created by wuzejian on 2017/5/19.
 * 数据类型使用Demo
 */

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface Reference{
    boolean next() default false;
}

public @interface AnnotationElementDemo {
    //枚举类型
    enum Status {FIXED,NORMAL};

    //声明枚举
    Status status() default Status.FIXED;

    //布尔类型
    boolean showSupport() default false;

    //String类型
    String name()default &quot;&quot;;

    //class类型
    Class&lt;?&gt; testCase() default Void.class;

    //注解嵌套
    Reference reference() default @Reference(next=true);

    //数组类型
    long[] value();
}
</code></pre>
<p><strong>编译器对默认值的限制</strong></p>
<p>编译器对元素的默认值有些过分挑剔,</p>
<ol>
<li>首先，元素不能有不确定的值,元素必须要么具有默认值，要么在使用注解时提供元素的值</li>
<li>对于非基本类型的元素，无论是在源代码中声明，还是在注解接口中定义默认值，都不能以null作为值</li>
</ol>
<h2 id="注解不支持继承"><a class="header" href="#注解不支持继承">注解不支持继承</a></h2>
<p>​	注解是不支持继承的,因为编译器会自动继承java.lang.annotation.Annotation接口，Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。</p>
<pre><code>//定义注解
@Target(ElementType.TYPE)//只能应用于类上
@Retention(RetentionPolicy.RUNTIME)//保存到运行时
public @interface DBTable {
    String name() default &quot;&quot;;
}
//反编译
public interface DBTable extends Annotation
{
    public abstract String name();
}
</code></pre>
<h2 id="快捷方式"><a class="header" href="#快捷方式">快捷方式</a></h2>
<p>​	所谓的快捷方式就是注解中定义了名为value的元素，并且在使用该注解时，如果该元素是唯一需要赋值的一个元素，那么此时无需使用key=value的语法，而只需在括号内给出value元素所需的值即可。这可以应用于任何合法类型的元素</p>
<h1 id="java-8中注解增强"><a class="header" href="#java-8中注解增强">Java 8中注解增强</a></h1>
<h2 id="repeatable"><a class="header" href="#repeatable">@Repeatable</a></h2>
<blockquote>
<p>元注解@Repeatable是JDK1.8新加入的，它表示在同一个位置重复相同的注解。在没有该注解前，一般是无法在同一个类型上使用相同的注解的</p>
</blockquote>
<pre><code class="language-java">@FilterPath(&quot;/web/update&quot;)
@FilterPath(&quot;/web/add&quot;)
public class A {}
</code></pre>
<p><strong>注解处理API</strong></p>
<p><em>getDeclaredAnnotationsByType()</em></p>
<p><em>getAnnotationsByType()</em></p>
<p>用于获取 repeatable的注解</p>
<p>如果没有@Inherited 则不会往父类寻找</p>
<p><strong>使用方式</strong></p>
<pre><code>@Target({ElementType.TYPE,ElementType.FIELD,ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(FilterPaths.class)
public @interface FilterPath {
    String  value();
}


@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface FilterPaths {
    FilterPath[] value();
}

@FilterPath(&quot;/web/list&quot;)
class CC { }

//使用案例
@FilterPath(&quot;/web/update&quot;)
@FilterPath(&quot;/web/add&quot;)
@FilterPath(&quot;/web/delete&quot;)
class AA extends CC{
    public static void main(String[] args) {

        Class&lt;?&gt; clazz = AA.class;
        //通过getAnnotationsByType方法获取所有重复注解
        FilterPath[] annotationsByType = clazz.getAnnotationsByType(FilterPath.class);
        FilterPath[] annotationsByType2 = clazz.getDeclaredAnnotationsByType(FilterPath.class);
        if (annotationsByType != null) {
            for (FilterPath filter : annotationsByType) {
                System.out.println(&quot;1:&quot;+filter.value());
            }
        }

        System.out.println(&quot;-----------------&quot;);

        if (annotationsByType2 != null) {
            for (FilterPath filter : annotationsByType2) {
                System.out.println(&quot;2:&quot;+filter.value());
            }
        }


        System.out.println(&quot;使用getAnnotation的结果:&quot;+clazz.getAnnotation(FilterPath.class));


        /**
         * 执行结果(当前类拥有该注解FilterPath,则不会从CC父类寻找)
         1:/web/update
         1:/web/add
         1:/web/delete
         -----------------
         2:/web/update
         2:/web/add
         2:/web/delete
         使用getAnnotation的结果:null
         */
    }
}
</code></pre>
<h2 id="新增的两种elementtype"><a class="header" href="#新增的两种elementtype">新增的两种ElementType</a></h2>
<p>以前注解只能标注在一个声明(如字段、类、方法)上</p>
<p>新增的TYPE_PARAMETER可以用于标注类型参数，而TYPE_USE则可以用于标注任意类型(不包括class)</p>
<pre><code>//TYPE_PARAMETER 标注在类型参数上
class D&lt;@Parameter T&gt; { }

//TYPE_USE则可以用于标注任意类型(不包括class)
//用于父类或者接口
class Image implements @Rectangular Shape { }

//用于构造函数
new @Path String(&quot;/usr/bin&quot;)

//用于强制转换和instanceof检查,注意这些注解中用于外部工具，它们不会对类型转换或者instanceof的检查行为带来任何影响。
String path=(@Path String)input;
if(input instanceof @Path String)

//用于指定异常
public Person read() throws @Localized IOException.

//用于通配符绑定
List&lt;@ReadOnly ? extends Person&gt;
List&lt;? extends @ReadOnly Person&gt;

@NotNull String.class //非法，不能标注class
import java.lang.@NotNull String //非法，不能标注import
</code></pre>
<blockquote>
<p>这里主要说明一下TYPE_USE，类型注解用来支持在Java的程序中做强类型检查，配合第三方插件工具（如Checker Framework），可以在编译期检测出runtime error（如UnsupportedOperationException、NullPointerException异常），避免异常延续到运行期才发现，从而提高代码质量，这就是类型注解的主要作用。总之Java 8 新增加了两个注解的元素类型ElementType.TYPE_USE 和ElementType.TYPE_PARAMETER ，通过它们，我们可以把注解应用到各种新场合中。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类的关系"><a class="header" href="#类的关系">类的关系</a></h1>
<p>在UML类图中，常见的有以下几种关系: <strong>泛化</strong>（Generalization）, <strong>实现</strong>（Realization），<strong>关联</strong>（Association)<strong>，聚合</strong>（Aggregation），<strong>组合</strong>(Composition)，<strong>依赖</strong>(Dependency)</p>
<h2 id="泛化generalization"><a class="header" href="#泛化generalization">泛化（Generalization）</a></h2>
<p><strong>泛化关系</strong></p>
<p>是一种<strong>继承</strong>关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。</p>
<p><strong>箭头指向</strong></p>
<p>带三角箭头的实线，箭头指向父类</p>
<h2 id="实现realization"><a class="header" href="#实现realization">实现（Realization）</a></h2>
<p><strong>实现关系</strong></p>
<p>是一种类与接口的关系，表示类是接口所有特征和行为的实现.</p>
<p><strong>箭头指向</strong></p>
<p>带三角箭头的虚线，箭头指向接口，指向接口</p>
<h2 id="关联association"><a class="header" href="#关联association">关联（Association)</a></h2>
<p><strong>关联关系</strong></p>
<p>是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</p>
<p><strong>箭头指向</strong></p>
<p>带普通箭头的实心线，指向<strong>被拥有者</strong>，指向成员变量</p>
<h2 id="聚合aggregation"><a class="header" href="#聚合aggregation">聚合（Aggregation）</a></h2>
<p><strong>聚合关系</strong></p>
<p>是整体与部分的关系，且<strong>部分可以离开整体而单独存在</strong>。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。</p>
<p>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</p>
<p><strong>箭头指向</strong></p>
<p>带空心菱形的实心线，菱形指向 整体，成员变量 指向拥有者</p>
<h2 id="组合composition"><a class="header" href="#组合composition">组合(Composition)</a></h2>
<p><strong>组合关系</strong></p>
<p>是整体与部分的关系，但<strong>部分不能离开整体而单独存在</strong>。如公司和部门是整体和部分的关系，没有公司就不存在部门。</p>
<p>组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。</p>
<p><strong>箭头指向</strong></p>
<p>带实心菱形的实线，菱形指向整体</p>
<h2 id="依赖dependency"><a class="header" href="#依赖dependency">依赖(Dependency)</a></h2>
<p><strong>依赖关系</strong></p>
<p>是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.</p>
<p><strong>箭头指向</strong></p>
<p>带箭头的虚线，指向被使用者，一般指 局部变量、方法的参数或者对静态方法的调用</p>
<p>各种关系的强弱顺序：</p>
<p>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
